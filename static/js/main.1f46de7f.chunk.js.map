{"version":3,"sources":["constants.ts","data/encryption.ts","analytics.ts","data/encode.ts","css/variables.module.scss","locales lazy /^/.//.*/.json$/ groupOptions: {} namespace object","i18n.ts","colors.ts","keys.ts","utils.ts","appState.ts","hooks/useCallbackRefState.ts","element/typeChecks.ts","math.ts","points.ts","element/bounds.ts","renderer/renderElement.ts","scene/Scene.ts","random.ts","element/mutateElement.ts","element/sizeHelpers.ts","groups.ts","element/newElement.ts","element/transformHandles.ts","ga.ts","galines.ts","gapoints.ts","gadirections.ts","gatransforms.ts","element/collision.ts","element/resizeTest.ts","element/linearElementEditor.ts","element/binding.ts","element/resizeElements.ts","element/dragElements.ts","element/textWysiwyg.tsx","element/textElement.ts","element/showSelectedShapeActions.ts","element/index.ts","scene/scrollbars.ts","scene/selection.ts","scene/scroll.ts","scene/comparisons.ts","scene/zoom.ts","errors.ts","components/Spinner.tsx","components/ToolButton.tsx","components/icons.tsx","actions/register.ts","actions/actionDeleteSelected.tsx","zindex.ts","actions/actionZindex.tsx","actions/actionSelectAll.ts","actions/actionDuplicateSelection.tsx","components/ButtonIconSelect.tsx","components/Popover.tsx","components/ColorPicker.tsx","components/IconPicker.tsx","actions/actionProperties.tsx","components/DarkModeToggle.tsx","components/Tooltip.tsx","components/ClearCanvas.tsx","actions/actionCanvas.tsx","actions/actionFinalize.tsx","components/ProjectName.tsx","renderer/roundRect.ts","clients.ts","types.ts","renderer/renderScene.ts","data/filesystem.ts","data/restore.ts","data/blob.ts","data/json.ts","element/image.ts","scene/export.ts","charts.ts","clipboard.ts","data/index.ts","components/CheckboxItem.tsx","components/Stack.tsx","components/ActiveFile.tsx","actions/actionExport.tsx","data/resave.ts","actions/actionStyles.ts","components/HelpIcon.tsx","actions/actionGroup.tsx","actions/actionMenu.tsx","components/Avatar.tsx","actions/actionAddToLibrary.ts","actions/actionNavigate.tsx","align.ts","actions/actionAlign.tsx","disitrubte.ts","actions/actionDistribute.tsx","actions/actionFlip.ts","actions/actionClipboard.tsx","actions/actionToggleGridMode.tsx","actions/actionToggleZenMode.tsx","actions/actionToggleStats.tsx","actions/actionHistory.tsx","actions/manager.tsx","data/library.ts","gesture.ts","history.ts","shapes.tsx","actions/shortcuts.ts","components/ContextMenu.tsx","components/Actions.tsx","components/BackgroundPickerAndDarkModeToggle.tsx","components/CollabButton.tsx","components/ImageExportDialog.tsx","components/FixedSideContainer.tsx","components/HintViewer.tsx","components/Island.tsx","components/LibraryUnit.tsx","components/LoadingMessage.tsx","components/LockButton.tsx","components/Section.tsx","components/UserList.tsx","components/LibraryButton.tsx","components/MobileMenu.tsx","components/PasteChartDialog.tsx","components/HelpDialog.tsx","components/Card.tsx","components/JSONExportDialog.tsx","components/LayerUI.tsx","components/Stats.tsx","components/Toast.tsx","actions/actionToggleViewMode.tsx","components/App.tsx","components/Modal.tsx","components/Dialog.tsx","components/ErrorDialog.tsx","components/TopErrorBoundary.tsx","packages/excalidraw/publicPath.js","components/InitializeApp.tsx","packages/utils.ts","packages/excalidraw/index.tsx","excalidraw-app/app_constants.ts","excalidraw-app/data/FileManager.ts","excalidraw-app/data/firebase.ts","excalidraw-app/data/index.ts","excalidraw-app/data/localStorage.ts","excalidraw-app/collab/Portal.tsx","excalidraw-app/collab/RoomDialog.tsx","createInverseContext.tsx","excalidraw-app/collab/reconciliation.ts","excalidraw-app/collab/CollabWrapper.tsx","excalidraw-app/components/LanguageList.tsx","excalidraw-app/CustomStats.tsx","excalidraw-app/components/icons.tsx","excalidraw-app/components/ExportToExcalidrawPlus.tsx","excalidraw-app/index.tsx","serviceWorker.tsx","excalidraw-app/pwa.ts","excalidraw-app/sentry.ts","index.tsx"],"names":["APP_NAME","DRAGGING_THRESHOLD","LINE_CONFIRM_THRESHOLD","ELEMENT_SHIFT_TRANSLATE_AMOUNT","ELEMENT_TRANSLATE_AMOUNT","TEXT_TO_CENTER_SNAP_THRESHOLD","SHIFT_LOCKING_ANGLE","Math","PI","CURSOR_TYPE","TEXT","CROSSHAIR","GRABBING","GRAB","POINTER","MOVE","AUTO","POINTER_BUTTON","MAIN","WHEEL","SECONDARY","TOUCH","EVENT","ENV","TEST","DEVELOPMENT","CLASSES","SHAPE_ACTIONS_MENU","FONT_FAMILY","Virgil","Helvetica","Cascadia","THEME","LIGHT","DARK","WINDOWS_EMOJI_FALLBACK_FONT","DEFAULT_FONT_SIZE","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","DEFAULT_VERSION","GRID_SIZE","MIME_TYPES","excalidraw","excalidrawlib","json","svg","png","jpg","gif","binary","EXPORT_DATA_TYPES","excalidrawClipboard","excalidrawLibrary","EXPORT_SOURCE","window","location","origin","STORAGE_KEYS","LOCAL_STORAGE_LIBRARY","IMAGE_RENDER_TIMEOUT","TAP_TWICE_TIMEOUT","TOUCH_CTX_MENU_TIMEOUT","TITLE_TIMEOUT","TOAST_TIMEOUT","VERSION_TIMEOUT","SCROLL_TIMEOUT","ZOOM_STEP","IDLE_THRESHOLD","ACTIVE_THRESHOLD","MODES","VIEW","ZEN","GRID","THEME_FILTER","cssVariables","themeFilter","URL_QUERY_KEYS","addLibrary","URL_HASH_KEYS","DEFAULT_UI_OPTIONS","canvasActions","changeViewBackgroundColor","clearCanvas","export","saveFileToDisk","loadScene","saveToActiveFile","theme","saveAsImage","MQ_MAX_WIDTH_PORTRAIT","MQ_MAX_WIDTH_LANDSCAPE","MQ_MAX_HEIGHT_LANDSCAPE","MAX_DECIMALS_FOR_SVG_EXPORT","EXPORT_SCALES","DEFAULT_EXPORT_PADDING","DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT","ALLOWED_IMAGE_MIME_TYPES","MAX_ALLOWED_FILE_BYTES","SVG_NS","IV_LENGTH_BYTES","createIV","arr","Uint8Array","crypto","getRandomValues","generateEncryptionKey","async","key","subtle","generateKey","name","length","exportKey","k","getImportedKey","usage","importKey","alg","ext","key_ops","kty","encryptData","data","importedKey","iv","buffer","TextEncoder","encode","Blob","arrayBuffer","encryptedBuffer","encrypt","decryptData","encrypted","privateKey","decrypt","trackEvent","process","REACT_APP_GOOGLE_ANALYTICS_ID","gtag","category","label","value","event_category","event_label","JEST_WORKER_ID","toByteString","Promise","resolve","reject","blob","reader","FileReader","onload","event","target","result","Error","readAsBinaryString","byteStringToArrayBuffer","byteString","ArrayBuffer","bufferView","i","len","charCodeAt","byteStringToString","TextDecoder","decode","stringToBase64","str","isByteString","btoa","base64ToString","base64","atob","deflated","text","compress","deflate","error","console","version","encoding","compressed","encoded","decoded","inflate","to","DATA_VIEW_BITS_MAP","dataView","bytes","offset","pow","method","DataView","concatBuffers","buffers","reduce","acc","byteLength","cursor","set","splitBuffers","concatenatedBuffer","chunkSize","push","slice","compressData","dataBuffer","options","encodingMetadataBuffer","JSON","stringify","compression","encryption","contentsMetadataBuffer","metadata","encryptionKey","_encryptAndCompress","decompressData","encodingMetadata","parse","contentsBuffer","decryptedBuffer","decryptionKey","isCompressed","_decryptAndDecompress","module","exports","map","webpackAsyncContext","req","__webpack_require__","o","then","e","code","ids","id","all","t","keys","Object","defaultLang","languages","rtl","concat","sort","left","right","filter","lang","percentages","TEST_LANG_CODE","unshift","currentLang","currentLangData","setLanguage","document","documentElement","dir","startsWith","getLanguage","findPartsForData","parts","index","part","undefined","path","replacement","split","translation","fallbackLangData","replace","shades","oc","red","pink","grape","violet","indigo","blue","cyan","teal","green","lime","yellow","orange","canvasBackground","white","gray","elementBackground","elementStroke","black","isDarwin","test","navigator","platform","isWindows","CODES","KEYS","isArrowKey","shouldResizeFromCenter","altKey","shouldMaintainAspectRatio","shiftKey","shouldRotateWithDiscreteAngle","mockDateTime","getDateTime","date","Date","year","getFullYear","month","getMonth","padStart","day","getDate","hr","getHours","min","getMinutes","capitalizeString","charAt","toUpperCase","isWritableElement","HTMLElement","dataset","type","HTMLBRElement","HTMLTextAreaElement","HTMLInputElement","getFontFamilyString","fontFamily","fontFamilyString","entries","getFontString","fontSize","measureText","font","line","createElement","body","style","position","whiteSpace","appendChild","innerText","x","join","width","offsetWidth","height","offsetHeight","span","display","overflow","baseline","offsetTop","removeChild","debounce","fn","timeout","handle","lastArgs","ret","args","clearTimeout","setTimeout","flush","_lastArgs","cancel","distance","y","abs","resetCursor","canvas","setCursor","setCursorForShape","shape","isFullScreen","fullscreenElement","nodeName","getShortcutKey","shortcut","viewportCoordsToSceneCoords","clientX","clientY","zoom","offsetLeft","scrollX","scrollY","invScale","sceneCoordsToViewportCoords","sceneX","sceneY","getGlobalCSSVariable","getComputedStyle","getPropertyValue","RE_RTL_CHECK","RegExp","isRTL","tupleToCoors","xyTuple","muteFSAbortError","isTransparent","color","isRGBTransparent","substr","isRRGGBBTransparent","colors","resolvablePromise","promise","_resolve","_reject","withBatchedUpdates","func","unstable_batchedUpdates","nFormatter","num","digits","si","symbol","toFixed","getVersion","querySelector","content","preventUnload","preventDefault","returnValue","defaultExportScale","includes","devicePixelRatio","getDefaultAppState","collaborators","Map","currentChartType","currentItemBackgroundColor","currentItemEndArrowhead","currentItemFillStyle","currentItemFontFamily","currentItemFontSize","currentItemLinearStrokeSharpness","currentItemOpacity","currentItemRoughness","currentItemStartArrowhead","currentItemStrokeColor","currentItemStrokeSharpness","currentItemStrokeStyle","currentItemStrokeWidth","currentItemTextAlign","cursorButton","draggingElement","editingElement","editingGroupId","editingLinearElement","elementLocked","elementType","errorMessage","exportBackground","exportScale","exportEmbedScene","exportWithDarkMode","fileHandle","gridSize","isBindingEnabled","isLibraryOpen","isLoading","isResizing","isRotating","lastPointerDownWith","multiElement","openMenu","openPopup","pasteDialog","shown","previousSelectedElementIds","resizingElement","scrolledOutside","selectedElementIds","selectedGroupIds","selectionElement","shouldCacheIgnoreZoom","showHelpDialog","showStats","startBoundElement","suggestedBindings","toastMessage","viewBackgroundColor","zenModeEnabled","viewModeEnabled","pendingImageElement","APP_STATE_STORAGE_CONF","browser","server","_clearAppStateForStorage","appState","exportType","stateForExport","propConfig","nextValue","clearAppStateForLocalStorage","cleanAppStateForExport","clearAppStateForDatabase","useCallbackRefState","refValue","setRefValue","useState","useCallback","isInitializedImageElement","element","fileId","isImageElement","isTextElement","isFreeDrawElement","isFreeDrawElementType","isLinearElement","isLinearElementType","isBindingElement","isBindingElementType","isBindableElement","rotate","x1","y1","x2","y2","angle","cos","sin","rotatePoint","point","center","adjustXYWithRotation","sides","deltaX1","deltaY1","deltaX2","deltaY2","w","n","s","distance2d","xd","yd","hypot","isPathALoop","points","zoomValue","first","last","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","current","next","doSegmentsIntersect","orderedColinearOrientation","isPointWithinBounds","q","r","max","val","p1","q1","p2","q2","o1","o2","o3","o4","getGridPoint","round","getSizeFromPoints","xs","ys","rescalePoints","dimension","nextDimensionSize","prevPoints","prevDimValues","prevMaxDimension","prevMinDimension","prevDimensionSize","dimensionScaleFactor","nextMinDimension","Infinity","scaledPoints","prevPoint","currentDimension","scaledValue","scaledPoint","getElementAbsoluteCoords","getFreeDrawElementAbsoluteCoords","getLinearElementAbsoluteCoords","getCurvePathOps","sets","ops","getMinMaxXYFromCurvePathOps","transformXY","currentP","minX","minY","maxX","maxY","limits","op","p3","p0","equation","idx","getBoundsFromPoints","coords","getShapeForElement","getElementBounds","bounds","cx","cy","getLinearElementRotatedBounds","x11","y11","x12","y12","x22","y22","x21","y21","h","ww","hh","getCommonBounds","elements","forEach","getResizedElementAbsoluteCoords","nextWidth","nextHeight","gen","rough","generator","curve","strokeSharpness","linearPath","generateRoughOptions","getElementPointsCoords","sharpness","defaultAppState","isPendingImageElement","sceneState","imageCache","has","getDashArrayDashed","strokeWidth","getDashArrayDotted","getCanvasPadding","IMAGE_PLACEHOLDER_IMG","src","encodeURIComponent","IMAGE_ERROR_PLACEHOLDER_IMG","drawElementOnCanvas","rc","context","globalAlpha","opacity","lineJoin","lineCap","draw","save","fillStyle","strokeColor","pathsCache","get","getFreeDrawPath2D","fill","restore","img","image","fillRect","imageMinWidthOrHeight","size","drawImage","status","drawImagePlaceholder","shouldTemporarilyAttach","isConnected","setAttribute","textAlign","lines","lineHeight","verticalOffset","horizontalOffset","fillText","remove","elementWithCanvasCache","WeakMap","shapeCache","invalidateShapeForElement","delete","continuousPath","seed","strokeLineDash","strokeStyle","disableMultiStroke","fillWeight","hachureGap","roughness","stroke","preserveVertices","fixedDecimalPlaceDigits","backgroundColor","curveFitting","generateElementShape","rectangle","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","floor","getDiamondPoints","polygon","ellipse","startArrowhead","endArrowhead","getArrowheadShapes","arrowhead","arrowheadPoints","prevOp","nx","ny","arrow","bar","dot","triangle","px","py","minSize","x3","y3","x4","y4","getArrowheadPoints","circle","dash","shapes","generateFreeDrawShape","generateElementWithCanvas","prevElementWithCanvas","shouldRegenerateBecauseZoom","canvasZoom","elementWithCanvas","getContext","padding","canvasOffsetX","canvasOffsetY","ceil","translate","scale","mimeType","generateElementCanvas","drawElementFromCanvas","_isPendingImageElement","scaleXFactor","scaleYFactor","renderElement","renderOptimizations","shiftX","shiftY","roughSVGDrawWithPrecision","rsvg","drawable","precision","pshape","renderElementToSvg","svgRoot","files","offsetX","offsetY","degree","node","group","ownerDocument","createElementNS","getFreeDrawSvgPath","fileData","symbolId","dataURL","prepend","use","direction","textAnchor","textContent","svgPathData","Path2D","inputPoints","simulatePressure","pressures","thinning","smoothing","streamline","easing","lastCommittedPoint","med","TO_FIXED_PRECISION","getSvgPathFromStroke","getStroke","A","B","isIdKey","elementKey","Scene","callbacks","Set","nonDeletedElements","elementsMap","scene","this","sceneMapById","sceneMapByElement","getElementsIncludingDeleted","getElements","getElement","getNonDeletedElement","isNonDeletedElement","getNonDeletedElements","replaceAllElements","nextElements","clear","mapElementToScene","informMutation","callback","Array","from","addCallback","cb","add","destroy","random","Random","now","randomInteger","randomId","nanoid","mutateElement","updates","didChange","prevScale","nextScale","nextPoints","didChangePoints","nextPoint","versionNonce","getScene","newElementWith","bumpVersion","isInvisiblySmallElement","getPerfectElementSize","absWidth","absHeight","lockedAngle","atan","tan","sign","getNormalizedDimensions","selectGroup","groupId","elementsInGroup","groupIds","fromEntries","isSelectedViaGroup","getSelectedGroupForElement","find","getSelectedGroupIds","isSelected","selectGroupsForSelectedElements","nextAppState","selectedElements","getSelectedElements","selectedElement","indexOfEditingGroup","indexOf","isElementInGroup","getElementsInGroup","addToGroup","prevGroupIds","newGroupId","positionOfEditingGroupId","positionToInsert","splice","_newElementBase","boundElementIds","rest","isDeleted","newElement","opts","getTextElementPositionOffsets","metrics","verticalAlign","newTextElement","offsets","getAdjustedDimensions","nextText","nextBaseline","prevMetrics","nextX1","nextY1","nextX2","nextY2","isFinite","updateTextElement","newLinearElement","startBinding","endBinding","deepCopyElement","depth","prototype","toString","call","tmp","constructor","create","getPrototypeOf","hasOwnProperty","isArray","duplicateElement","groupIdMapForOperation","overrides","copy","mapper","endIndex","getNewGroupIdsForDuplication","assign","transformHandleSizes","mouse","pen","touch","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","OMIT_SIDES_FOR_TEXT_ELEMENT","OMIT_SIDES_FOR_LINE_SLASH","nw","se","OMIT_SIDES_FOR_LINE_BACKSLASH","ne","sw","generateTransformHandle","xx","yy","getTransformHandlesFromCoords","pointerType","omitSides","handleWidth","handleHeight","handleMarginX","handleMarginY","dashedLineMargin","centeringOffset","transformHandles","rotation","minimumSizeForEightHandles","getTransformHandles","nvector","reverse","a","b","isNumber","sub","mul","mulScalar","meet","joinScalar","norm","sqrt","inorm","normalized","inormalized","c","GA","through","orthogonal","toTuple","intersect","line1","line2","point1","point2","distanceToLine","pivot","apply","motor","isHittingElementBoundingBoxWithoutHittingElement","threshold","isHittingElementNotConsideringBoundingBox","isPointHittingElementBoundingBox","check","isStrictlyInside","isDraggableFromInside","isElementDraggableFromInside","isInsideCheck","isNearCheck","hitTestPointAgainstElement","isElementSelected","elementCenterX","elementCenterY","rotatedX","rotatedY","bindingBorderTest","maxBindingGap","isOutsideCheck","elementWidth","elementHeight","smallerDimension","distanceToBindableElement","distanceToRectangle","hitTestFreeDrawElement","hitTestLinear","warn","distanceToDiamond","distanceToEllipse","pointRel","hwidth","hheight","pointRelativeToElement","GAPoint","GALine","side","tangent","ellipseParamsForTest","tx","ty","_","ex","ey","rx","ry","qx","qy","closestPoint","intersection","rotatedPoint","P","delta","U","C","d","da","db","pointAbs","side1","side2","relX","relY","some","subshape","hitTestCurveInside","hitTestRoughShape","pointTuple","elementCoords","coordsCenter","GATransform","pointRotated","pointRelToCenterAbs","GADirection","elementPos","pointRelToPos","ax","ay","bx","by","relativizationToElementCenter","determineFocusDistance","relateToCenter","aRel","bRel","m","mabs","nabs","getSortedElementLineIntersections","nearPoint","intersections","gap","corners","getCorners","flatMap","edge","intersectSegment","offsetSegment","getCircleIntersections","getEllipseIntersections","sortedIntersections","i1","i2","hx","hy","segment","squares","discr","discrRoot","xn","yn","radius","findFocusPointForEllipse","relativeDistance","relativeDistanceAbs","orientation","pyo","findFocusPointForRectangulars","maxDistance","tangentPoint","corner","odd","operation","polygonPoints","pointsOnBezierCurves","lineThreshold","retVal","mx","my","pointInBezierEquation","isInsideTransformHandle","transformHandle","getElementWithTransformHandleType","scenePointerX","scenePointerY","transformHandleType","rotationTransformHandle","resizeTest","getTransformHandleTypeFromCoords","RESIZE_CURSORS","getCursorForResizingElement","shouldSwapCursors","rotateResizeCursor","LinearElementEditor","elementId","activePointIndex","isDragging","lastUncommittedPoint","pointerOffset","startBindingElement","endBindingElement","normalizePoints","setState","maybeSuggestBinding","newPoint","createPointAt","movePoint","binding","getHoveredElementForBinding","getPointAtIndexGlobalCoordinates","history","scenePointer","didAddPoint","hitElement","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","bindOrUnbindLinearElement","targetPoint","lastPoint","indexMaybeFromEnd","absoluteCoords","pointHandles","getPointsGlobalCoordinates","POINT_HANDLE_SIZE","pointerOnGrid","_idx","getNormalizedPoints","pointIndex","targetPosition","otherUpdates","deltaX","deltaY","nextCoords","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","rotated","linearElement","boundToElementIds","unboundFromElementIds","bindOrUnbindLinearElementEdge","onlyUnbound","bindableElement","otherEdgeBindableElement","startOrEnd","isLinearElementSimpleAndAlreadyBoundOnOppositeEdge","bindLinearElement","unbound","unbindLinearElement","bindOrUnbindSelectedElements","getElligibleElementForBindingElement","maybeBindBindableElement","getElligibleElementsForBindableElementAndWhere","where","maybeBindLinearElement","pointerCoords","hoveredElement","calculateFocusAndGap","otherBinding","isLinearElementSimpleAndAlreadyBound","alreadyBoundToId","unbindLinearElements","field","getElementAtPosition","edgePointIndex","adjacentPointIndex","edgePoint","adjacentPoint","focus","updateBoundElements","changedElement","newSize","simultaneouslyUpdated","simultaneouslyUpdatedElementIds","getSimultaneouslyUpdatedElementIds","doesNeedUpdate","maybeCalculateNewGapWhenScaling","updateBoundPoint","boundElement","bindingElement","focusPointAbsolute","adjecentPoint","adjecentPointRel","reverseRelateToCenter","determineFocusPoint","newEdgePoint","intersectElementWithLine","pointFromAbsoluteCoords","currentBinding","newWidth","newHeight","getElligibleElementsForBindingElement","getLinearElementEdgeCoors","canBindStart","isLinearElementEligibleForNewBindingByBindable","canBindEnd","maybeElement","fixBindingsAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","duplicatesServeAsOld","allBoundElementIds","allBindableElementIds","shouldReverseRoles","oldElement","boundElementId","newBindingAfterDuplication","fixBindingsAfterDeletion","deletedElements","deletedElementIds","deletedElement","newBindingAfterDeletion","normalizeAngle","rotateSingleElement","pointerX","pointerY","atan2","reshapeSingleTwoPointElement","resizeArrowDirection","getPerfectElementSizeWithRotation","nextElementX","nextElementY","rescalePointsInElement","measureFontSizeFromWH","nextFontSize","resizeSingleTextElement","nextFont","getSidesForTransformHandle","resizeSingleElement","stateAtResizeStart","transformHandleDirection","startTopLeft","startBottomRight","startCenter","rotatedPointer","esx1","esy1","esx2","esy2","boundsCurrentWidth","boundsCurrentHeight","scaleX","scaleY","eleInitialWidth","eleInitialHeight","eleNewWidth","eleNewHeight","widthRatio","heightRatio","ratio","newBoundsX1","newBoundsY1","newBoundsX2","newBoundsY2","newBoundsWidth","newBoundsHeight","newTopLeft","bottomLeft","topRight","rotatedTopLeft","newCenter","rotatedNewCenter","rescaledPoints","newOrigin","resizedElement","resizeMultipleElements","getNextXY","origX1","origY1","finalX1","finalY1","origX2","origY2","finalX2","finalY2","prev","origCoords","finalCoords","rotateMultipleElements","pointerDownState","centerX","centerY","centerAngle","origAngle","originalElements","rotatedCX","rotatedCY","dragNewElement","originX","originY","widthAspectRatio","newX","newY","normalizeText","getTransform","maxWidth","translateX","translateY","redrawTextBoundingBox","showSelectedShapeActions","Boolean","getElementMap","getSceneVersion","el","_clearElements","clearElementsForDatabase","clearElementsForExport","clearElementsForLocalStorage","SCROLLBAR_COLOR","getScrollBars","viewportWidth","viewportHeight","horizontal","vertical","elementsMinX","elementsMinY","elementsMaxX","elementsMaxY","viewportWidthWithZoom","viewportHeightWithZoom","viewportWidthDiff","viewportHeightDiff","safeArea","top","parseInt","bottom","viewportMinX","viewportMinY","viewportMaxX","viewportMaxY","sceneMinX","sceneMinY","sceneMaxX","sceneMaxY","SCROLLBAR_MARGIN","isOverScrollBars","scrollBars","isOverHorizontal","isOverVertical","scrollBar","isOverEither","isSomeElementSelected","getTargetElements","centerScrollOn","scenePoint","viewportDimensions","calculateScrollCenter","getVisibleElements","cords","viewportX1","viewportY1","viewportX2","viewportY2","isOutsideViewPort","minDistance","closestElement","getClosestElementBounds","hasBackground","hasStrokeColor","hasStrokeWidth","hasStrokeStyle","canChangeSharpness","hasText","canHaveArrowheads","isAtPositionFn","getNewZoom","newZoomValue","prevZoom","canvasOffset","zoomOnViewportPoint","getNormalizedZoom","normalizedZoom","parseFloat","CanvasError","message","super","AbortError","DOMException","Spinner","circleWidth","className","viewBox","strokeMiterlimit","ToolButton","React","forwardRef","props","ref","excalId","useExcalidrawContainer","innerRef","useRef","useImperativeHandle","sizeCn","setIsLoading","isMountedRef","onClick","useEffect","lastPointerTypeRef","clsx","visible","hidden","ToolIcon","selected","title","disabled","icon","keyBindingLabel","showAriaLabel","children","onPointerDown","onPointerUp","requestAnimationFrame","onChange","checked","defaultProps","activeElementColor","iconFillColor","handlerColor","createIcon","mirror","focusable","role","checkIcon","link","saveAs","load","clipboard","trash","palette","exportFile","exportImage","exportToFileIcon","zoomIn","zoomOut","done","menu","undo","redo","questionCircle","share","shareIOS","shareWindows","BringForwardIcon","memo","SendBackwardIcon","BringToFrontIcon","SendToBackIcon","AlignTopIcon","strokeLinecap","AlignBottomIcon","AlignLeftIcon","AlignRightIcon","DistributeHorizontallyIcon","DistributeVerticallyIcon","CenterVerticallyIcon","strokeDasharray","CenterHorizontallyIcon","users","start","stop","close","back","marginLeft","clone","shield","file","GroupIcon","UngroupIcon","FillHachureIcon","fillRule","clipRule","FillCrossHatchIcon","FillSolidIcon","StrokeWidthIcon","StrokeStyleSolidIcon","StrokeStyleDashedIcon","StrokeStyleDottedIcon","SloppinessArchitectIcon","SloppinessArtistIcon","SloppinessCartoonistIcon","EdgeSharpIcon","EdgeRoundIcon","ArrowheadNoneIcon","ArrowheadArrowIcon","flip","transform","ArrowheadDotIcon","ArrowheadBarIcon","ArrowheadTriangleIcon","FontSizeSmallIcon","FontSizeMediumIcon","FontSizeLargeIcon","FontSizeExtraLargeIcon","FontFamilyHandDrawnIcon","FontFamilyNormalIcon","FontFamilyCodeIcon","TextAlignLeftIcon","TextAlignCenterIcon","TextAlignRightIcon","actions","register","action","handleGroupEditingState","siblingElements","actionDeleteSelected","perform","commitToHistory","deleteSelectedElements","contextItemLabel","keyTest","PanelComponent","updateData","getIndicesToMove","selectedIndices","deletedIndices","includeDeletedIndex","getTargetIndex","boundaryIndex","sourceElement","indexFilter","candidateIndex","array","fromIndex","findLastIndex","findIndex","nextElement","siblingGroupId","elementsInSiblingGroup","getTargetElementsMap","indices","shiftElements","indicesToMove","targetElementsMap","groupedIndices","toContiguousGroups","leadingIndex","trailingIndex","targetIndex","leadingElements","targetElements","displacedElements","trailingElements","shiftElementsToEnd","groupElements","values","moveOneLeft","moveOneRight","moveAllLeft","moveAllRight","actionSendBackward","keyPriority","actionBringForward","actionSendToBack","actionBringToFront","actionSelectAll","actionDuplicateSelection","selectedPoint","duplicateElements","groupIdMap","newElements","duplicateAndOffsetElement","finalElements","ButtonIconSelect","option","active","Popover","onCloseRequest","fitInViewport","popoverRef","useLayoutEffect","getBoundingClientRect","innerWidth","innerHeight","handler","contains","addEventListener","removeEventListener","isValidColor","Option","keyBindings","flat","Picker","onClose","showInput","firstItem","activeItem","gallery","colorInput","onKeyDown","activeElement","nextIndex","toLowerCase","nativeEvent","stopImmediatePropagation","stopPropagation","tabIndex","_color","_colorWithoutHash","currentTarget","onFocus","ColorInput","innerValue","setInnerValue","inputRef","changeColor","inputValue","getColor","spellCheck","onBlur","ColorPicker","isActive","setActive","pickerButton","Suspense","fallback","changedColor","rFirstItem","rActiveItem","rGallery","pressedOption","keyBinding","metaKey","ctrlKey","IconPicker","rPickerButton","changeProperty","getFormValue","getAttribute","defaultValue","attributes","getCommonAttributeOfSelectedElements","DarkModeToggle","step","onWheel","shouldUpdateForNonLinearElements","every","shouldUpdateForLinearElements","ICONS","MOON","SUN","getTooltipDiv","existingDiv","div","classList","Tooltip","long","onPointerEnter","item","tooltip","minWidth","itemX","itemBottom","itemTop","itemWidth","labelWidth","labelHeight","margin","updateTooltip","onPointerLeave","ClearCanvas","onConfirm","showDialog","setShowDialog","toggleDialog","useIsMobile","small","app","_elements","zoomToFitElements","zoomToSelection","commonBounds","commonBoundsWidth","zoomValueForWidth","commonBoundsHeight","zoomValueForHeight","smallestZoomValue","zoomAdjustedToSteps","zoomValueToFitBoundsOnViewport","newZoom","actionFinalize","marginInlineStart","focusContainer","multiPointElement","isLoop","linePoints","firstPoint","ProjectName","fileName","setFileName","htmlFor","isNameEditable","parent","parentElement","focusNearestParent","isComposing","keyCode","blur","roundRect","beginPath","moveTo","lineTo","quadraticCurveTo","closePath","getClientColors","clientId","currentUser","sum","backgrounds","strokes","background","UserIdleState","hasEmojiSupport","ctx","textBaseline","getImageData","supportsEmoji","strokeRectWithRotation","strokeRect","fillCircle","arc","strokeGrid","renderLinearPointHandles","lineWidth","setLineDash","renderScene","renderScrollbars","renderSelection","renderGrid","isExport","atLeastOneVisibleElement","setTransform","normalizedCanvasWidth","normalizedCanvasHeight","clearRect","zoomTranslationX","zoomTranslationY","visibleElements","isVisibleElement","suggestedBinding","renderBindingHighlight","selections","selectionColors","remoteSelectedElementIds","socketId","elementX1","elementY1","elementX2","elementY2","addSelectionForGroupId","selection","renderSelectionBorder","locallySelectedElements","renderTransformHandles","dashedLinePadding","initialLineDash","getLineDash","remotePointerViewportCoords","isOutOfBounds","userState","remotePointerUserStates","AWAY","remotePointerButton","username","remotePointerUsernames","idleState","IDLE","ACTIVE","usernameAndIdleState","paddingHorizontal","paddingVertical","measure","measureHeight","actualBoundingBoxDescent","actualBoundingBoxAscent","SCROLLBAR_WIDTH","elementProperties","dashWidth","spaceWidth","lineDashOffset","renderHighlight","renderBindingHighlightForSuggestedPointBinding","renderBindingHighlightForBindableElement","strokeOffset","strokeDiamondWithRotation","strokeEllipseWithRotation","canvasWidth","canvasHeight","viewTransformations","topLeftSceneCoords","bottomRightSceneCoords","fileOpen","mimeTypes","extensions","_fileOpen","description","multiple","legacySetup","input","scheduleRejection","focusHandler","checkForFile","KEYUP","POINTER_UP","FOCUS","interval","setInterval","rejectPromise","clearInterval","fileSave","_fileSave","extension","AllowedExcalidrawElementTypes","diamond","freedraw","restoreElementWithProperties","extra","base","restoreElement","fontFamilyName","fontPx","_fontFamily","restoreElements","localElements","localElementsMap","migratedElement","localElement","restoreAppState","localAppState","suppliedValue","localValue","parseFileContents","contents","decodePngMetadata","readAsText","onloadend","readyState","DONE","decodeSvgMetadata","getFileHandleType","match","isImageFileHandle","isSupportedImageFile","loadFromBlob","isValidExcalidrawData","canvasToBlob","toBlob","getDataURL","onerror","readAsDataURL","resizeImageFile","maxWidthOrHeight","pica","imageBlobReduce","res","default","features","fileType","File","SVGStringToFile","SVGString","filename","filterOutDeletedFiles","nextFiles","serializeAsJSON","source","saveAsJSON","serialized","loadHTMLImageElement","Image","updateImageCache","fileIds","updatedFiles","erroredFiles","promises","imagePromise","getInitializedImageElements","SVG_EXPORT_TAG","exportToCanvas","exportPadding","createCanvas","getCanvasSize","exportToSvg","encodeSvgMetadata","innerHTML","rect","renderSceneToSvg","BAR_WIDTH","BAR_GAP","BAR_HEIGHT","NOT_SPREADSHEET","VALID_SPREADSHEET","tryParseNumber","exec","isNumericColumn","columnIndex","tryParseCells","cells","numCols","reason","hasHeader","spreadsheet","labels","valueColumnIndex","labelColumnIndex","rows","row","bgColors","commonProps","getChartDimentions","chartWidth","chartHeight","chartXLabels","chartYLabels","minYLabel","toLocaleString","chartLines","chartBaseElements","debug","debugRect","renderSpreadsheet","chartType","dots","chartTypeLine","barHeight","chartTypeBar","CLIPBOARD","PREFER_APP_CLIPBOARD","probablySupportsClipboardReadText","probablySupportsClipboardWriteText","probablySupportsClipboardBlob","HTMLCanvasElement","copyToClipboard","copyTextToSystemClipboard","getAppClipboard","parsePotentialSpreadsheet","trim","numColsFirstLine","transposedResults","nextCells","col","nextCellRow","transposeCells","tryParseSpreadsheet","parseClipboard","systemClipboard","clipboardData","getData","readText","getSystemClipboard","spreadsheetResult","appClipboardData","systemClipboardData","copied","writeText","copyTextViaExecCommand","textarea","border","yPosition","pageYOffset","scrollTop","success","select","setSelectionRange","execCommand","exportCanvas","tempSvg","outerHTML","tempCanvas","encodePngMetadata","write","ClipboardItem","copyBlobToClipboardAsPng","CheckboxItem","align","justifyContent","alignItems","justifyItems","ActiveFile","onSave","actionSaveFileToDisk","appProps","allElements","exportedElements","trunc","getExportSize","scaleButtonTitle","fileHandleExists","fileHandleType","resaveAsImageWithScene","nativeFileSystemSupported","loadedElements","loadedAppState","loadFromJSON","marginTop","marginBottom","copiedStyles","actionCopyStyles","actionPasteStyles","pastedElement","HelpIcon","enableActionGroup","requestFullscreen","exitFullscreen","allElementsInSameGroup","actionGroup","selectedGroupId","elementIdsInGroup","updatedElements","lastElementInGroup","lastGroupElementIndex","lastIndexOf","elementsAfterGroup","updatedElementsInOrder","updatedElement","contextItemPredicate","actionUngroup","nextGroupIds","removeFromSelectedGroups","Avatar","actionAddToLibrary","collaborator","shortName","names","substring","firstName","lastName","getClientInitials","pointer","library","loadLibrary","items","saveLibrary","getMaximumGroups","groups","currentGroupMembers","calculateTranslation","selectionBoundingBox","axis","groupBoundingBox","getCommonBoundingBox","noTranslation","alignSelectedElements","alignment","alignElements","updatedElementsMap","midX","midY","distributeSelectedElements","distribution","mid","end","extent","index0","g","index1","pos","box","distributeElements","actionFlipHorizontal","space","flipSelectedElements","eligibleElements","enableActionFlipHorizontal","actionFlipVertical","enableActionFlipVertical","flipDirection","flipElements","flipElement","rotateElement","originalX","originalY","originalAngle","finalOffsetX","usingNWHandle","newNCoordsX","nHandle","rotationAngle","actionCopy","actionCut","actionCopyAsSvg","_data","actionCopyAsPng","exportSelection","exportColorScheme","actionToggleGridMode","actionToggleZenMode","actionToggleStats","writeData","prevElements","updater","prevElementMap","nextElementMap","prevElement","syncHistory","ActionManager","getAppState","renderAction","UIOptions","formState","actionResult","registerAction","registerAll","handleKeyDown","executeAction","Library","libraryCache","resetLibrary","onLibraryChange","restoreLibraryItem","libraryItem","libraryItems","libraryItemsFromStorage","prevLibraryItems","serializedItems","libraryFile","loadLibraryFromBlob","existingLibraryItems","filtered","restoredItem","targetLibraryItem","libItemExcalidrawItem","isUniqueitem","getCenter","pointers","allCoords","getDistance","clearAppStatePropertiesForHistory","History","elementCache","recording","stateHistory","redoStack","lastEntry","generateEntry","dehydrateHistoryEntry","hydrateHistoryEntry","dehydratedExcalidrawElement","versions","getSnapshotForTest","dehydratedHistoryEntry","shouldCreateEntry","nextEntry","pushEntry","newEntryDehydrated","newEntry","clearRedoStack","redoOnce","entryToRestore","pop","undoOnce","currentEntry","setCurrentState","record","state","SHAPES","shortcutMap","cut","paste","copyStyles","pasteStyles","selectAll","duplicateSelection","sendBackward","bringForward","sendToBack","bringToFront","copyAsPng","copyAsSvg","ungroup","gridMode","zenMode","stats","addToLibrary","flipHorizontal","flipVertical","viewMode","getShortcutFromShortcutName","shortcuts","ContextMenu","actionManager","onContextMenu","actionName","dangerous","checkmark","contextMenuNodeByContainer","params","of","render","container","contextMenuNode","unmountComponentAtNode","handleClose","getContextMenuNode","SelectedShapeActions","isEditing","isMobile","showFillIcons","showChangeBackgroundIcons","commonSelectedType","ShapesSwitcher","setAppState","onImageAction","letter","ZoomActions","BackgroundPickerAndDarkModeToggle","showThemeBtn","CollabButton","isCollaborating","collaboratorCount","supportsContextFilters","ErrorCanvasPreview","renderPreview","previewNode","ExportButton","shade","OpenColor","ImageExportModal","onExportToPng","onExportToSvg","onExportToClipboard","someElementIsSelected","exportSelected","setExportSelected","previewRef","catch","gridTemplateColumns","userSelect","ImageExportDialog","modalIsShown","setModalIsShown","FixedSideContainer","HintViewer","hint","multiMode","targetElement","getHints","Island","PLUS_ICON","LibraryUnit","pendingElements","onRemoveFromLibrary","elementsToRender","isHovered","setIsHovered","adder","onMouseEnter","onMouseLeave","draggable","onDragStart","dataTransfer","setData","LoadingMessage","CHECKED","xmlns","UNCHECKED","LockButton","Section","heading","header","UserList","mobile","UserList_mobile","LIBRARY_ICON","LibraryButton","MobileMenu","libraryMenu","renderJSONExportDialog","renderImageExportDialog","onCollabButtonClick","onLockToggle","renderCustomFooter","renderTopRightUI","insertOnCanvasDirectly","marginRight","client","Fragment","ChartPreviewBtn","chartElements","setChartElements","parentNode","PasteChartDialog","onInsertChart","handleChartClick","autofocus","Header","href","rel","Columns","flexDirection","flexWrap","Column","ShortcutIsland","caption","Shortcut","flex","ShortcutKey","isOr","HelpDialog","Card","JSONExportModal","exportOpts","onExportToBackend","renderCustomUI","JSONExportDialog","LibraryMenuItems","onAddToLibrary","onInsertShape","setLibraryItems","libraryReturnUrl","numCells","CELLS_PER_ROW","numRows","addedPendingElements","referrer","pathname","importLibrary","importLibraryFromJSON","saveLibraryAsJSON","confirm","shouldAddPendingElements","bind","LibraryMenu","onClickOutside","listener","Element","useOnClickOutside","closest","loadingState","loadingTimerRef","race","removeFromLibrary","nextItems","indexToRemove","LayerUI","onInsertElements","showExitZenModeBtn","toggleZenMode","createExporter","Separator","closeLibrary","deselectItems","dialogs","ErrorDialog","shouldRenderSelectedShapeActions","zIndex","maxHeight","renderFixedSideContainer","areEqual","getNecessaryObj","prevAppState","langCode","Stats","boundingBox","selectedBoundingBox","colSpan","renderCustomStats","Toast","clearToast","timerRef","scheduleTimeout","actionToggleViewMode","IsMobileContext","createContext","useContext","ExcalidrawContainerContext","didTapTwice","tappedTwiceTimer","cursorX","cursorY","isHoldingSpace","isPanning","isDraggingScrollBar","currentScrollBars","touchTimeout","invalidateContextMenu","lastPointerUp","gesture","lastCenter","initialDistance","initialScale","App","Component","unmounted","detachIsMobileMqHandler","excalidrawContainerRef","createRef","resizeObserver","nearestScrollableContainer","excalidrawContainerValue","autoFocus","getSceneElementsIncludingDeleted","getSceneElements","syncActionResult","replaceFiles","addNewImagesToImageCache","gridModeEnabled","onUnload","disableEvent","onFontLoaded","onSceneUpdated","importLibraryFromUrl","url","token","hash","URLSearchParams","replaceState","search","query","request","fetch","decodeURIComponent","isValidLibrary","numShapes","alert","resetHistory","resetScene","resetLoadingState","initializeScene","launchQueue","setConsumer","launchParams","getFile","initialData","scrollToContent","libraryUrl","onResize","onScroll","getCanvasOffsets","onCut","cutAll","onCopy","copyAll","onTapStart","resetTapTwice","touches","handleCanvasDoubleClick","onTapEnd","pasteFromClipboard","elementUnderCursor","elementFromPoint","string","endsWith","imageElement","createImageElement","insertImageElement","initializeImageDimensions","onPaste","addElementsFromPasteOrLibrary","addTextFromPaste","selectShapeTool","elementsCenterX","elementsCenterY","dx","dy","gridX","gridY","obj","removePointer","pointerId","toggleLock","prevState","toggleStats","setToastMessage","restoreFileFromShare","webShareTargetCache","caches","open","loadFileToCanvas","addFiles","filesMap","updateScene","sceneData","updateCurrentCursorPosition","Proxy","ev","prop","HTMLSelectElement","maybeSuggestBindingForAll","startTextEditing","findShapeByKey","onKeyUp","onGestureStart","onGestureChange","onGestureEnd","insertAtParentCenter","existingTextElement","getTextElementAtPosition","parentCenterPosition","getTextWysiwygSnappedToCenterPosition","handleTextWysiwyg","isExistingElement","getSelectedGroupIdForElement","handleCanvasPointerMove","savePointer","scaleFactor","resetShouldCacheIgnoreZoomDebounced","isOverScrollBar","handlePointerMove","maybeSuggestBindingAtCursor","maybeSuggestBindingForLinearElementAtCursor","buttons","elementWithTransformHandleType","isHittingCommonBoundingBoxOfSelectedElements","handleTouchMove","handleCanvasPointerDown","getSelection","anchorNode","removeAllRanges","maybeOpenContextMenuAfterPointerDownOnTouchDevices","maybeCleanupAfterMissingPointerUp","handleCanvasPanUsingWheelOrSpaceDrag","button","updateGestureOnPointerDown","initialPointerDownState","handleDraggingScrollBar","clearSelectionIfNotUsingSelection","updateBindingEnabledOnPointerMove","handleSelectionOnPointerDown","handleTextOnPointerDown","handleLinearElementOnPointerDown","handleFreeDrawElementOnPointerDown","createGenericElementOnPointerDown","onPointerMove","onPointerMoveFromPointerDownHandler","onPointerUpFromPointerDownHandler","onKeyDownFromPointerDownHandler","onKeyUpFromPointerDownHandler","POINTER_MOVE","KEYDOWN","eventListeners","onMove","onUp","handleCanvasContextMenu","nextPastePrevented","isLinux","lastX","lastY","preventNextPaste","PASTE","enableNextPaste","teardown","BLUR","passive","resize","handleType","getResizeOffsetXY","arrowDirection","getResizeArrowDirection","handlePointerDown","hit","allHitElements","getElementsAtPosition","someHitElementIsSelected","isASelectedElement","hasHitCommonBoundingBoxOfSelectedElements","clearSelection","wasAddedToSelection","pressure","initializeImage","imageFile","_imageElement","showCursorImagePreview","doc","DOMParser","parseFromString","hasAttribute","normalizeSVG","generateIdForFile","hashBuffer","digest","byte","generateIdFromFile","existingFileData","maxSize","resizedFile","dataIndexStart","ab","ia","dataURLToFile","setImagePreviewCursor","created","cachedImageData","imagePreview","previewDataURL","toDataURL","forceNaturalSize","placeholderSize","minHeight","naturalHeight","naturalWidth","_updateImageCache","imageElements","uncachedImageElements","scheduleImageRefresh","throttle","shouldEnableBinding","shouldEnableBindingForPointerEvent","hoveredBindableElement","oppositeBindingBoundElement","handleCanvasRef","handleWheel","TOUCH_START","TOUCH_END","handleAppOnDrop","getAsFileSystemHandle","libraryShapes","preferSelected","_openContextMenu","maybeDragNewGenericElement","lastCoords","aspectRatio","originInGrid","maybeHandleResize","resizeX","resizeY","transformElements","maybeGroupAction","maybeUngroupAction","maybeFlipHorizontal","maybeFlipVertical","separator","viewModeOptions","appStates","MAX_STEP","log10","isNaN","onPointerUpdate","pointersMap","updateDOMRect","excalidrawContainer","currentWidth","currentHeight","currentOffsetTop","currentOffsetLeft","refresh","excalidrawRef","readyPromise","api","ready","getFiles","createRedoAction","renderCanvas","canvasScale","canvasDOMWidth","canvasDOMHeight","onPointerCancel","onTouchMove","onDoubleClick","renderFooter","onDrop","handleKeyboardGlobally","Provider","defineProperties","configurable","addEventListeners","ResizeObserver","observe","matchMedia","mediaQuery","matches","addListener","removeListener","componentWillUnmount","disconnect","removeEventListeners","COPY","CUT","SCROLL","MOUSE_MOVE","RESIZE","UNLOAD","DRAG_OVER","DROP","GESTURE_START","GESTURE_CHANGE","GESTURE_END","fonts","detectScroll","overflowY","scrollHeight","clientHeight","getNearestScrollableContainer","componentDidUpdate","prevProps","updateLanguage","deselectElements","toggle","pointerViewportCoords","pointerUsernames","pointerUserStates","user","renderingElements","updateElement","_element","onSubmit","getViewportCoords","updateWysiwygStyle","viewportX","viewportY","editable","wrap","backfaceVisibility","outline","oninput","onkeydown","submittedViaKeyboard","handleSubmit","outdent","indent","dispatchEvent","Event","TAB","repeat","RE_LEADING_TAB","selectionStart","selectionEnd","linesStartIndices","getSelectedLinesStartIndices","startIndex","startValue","endValue","removedTabs","tabMatch","startOffset","startIndices","stopEvent","cleanup","viaKeyboard","isDestroyed","onblur","observer","bindBlurEvent","unbindUpdate","SVGElement","capture","textWysiwyg","elementWithHighestZIndex","hitTest","withCmdOrCtrl","scrollbars","hasBeenDuplicated","drag","hasOccurred","handlePointerMoveOverScrollbars","getDragOffsetXY","handlePointDragging","dragX","dragY","dragDistanceX","dragDistanceY","lockDirection","distanceX","distanceY","lockX","lockY","original","dragSelectedElements","elementsToAppend","duplicatedElement","originDragX","originDragY","nextSceneElements","elementsWithinSelection","selectionX1","selectionY1","selectionX2","selectionY2","getElementsWithinSelection","childEvent","handlePointerUp","idsOfSelectedElementsThatAreInGroups","prevId","_prevState","gId","includedElementIds","getEligibleElementsForBinding","elementClickedInside","getElementContainingPosition","Modal","modalRoot","useBodyRoot","createPortal","labelledBy","setDiv","isMobileRef","isDarkTheme","Dialog","islandNode","setIslandNode","lastActiveElement","focusableElements","queryFocusableElements","currentIndex","querySelectorAll","TopErrorBoundary","hasError","sentryEventId","localStorage","errorSplash","componentDidCatch","errorInfo","_localStorage","Sentry","scope","setExtras","eventId","selectTextArea","templateStrFn","reload","createGithubIssue","readOnly","__webpack_public_path__","EXCALIDRAW_ASSET_PATH","pkg","InitializeApp","loading","setLoading","updateLang","Excalidraw","nextProps","prevInitialData","prevUIOptions","nextInitialData","nextUIOptions","prevUIOptionsKeys","nextUIOptionsKeys","isUIOptionsSame","prevKeys","nextKeys","forwardedRefComp","FILE_UPLOAD_MAX_BYTES","BROADCAST","SCENE","FIREBASE_STORAGE_PREFIXES","FileManager","saveFiles","fetchingFiles","savingFiles","savedFiles","_getFiles","_saveFiles","isFileHandled","isFileSaved","addedFiles","loadedFiles","shouldPreventUnload","shouldUpdateImageElementStatus","reset","encodeFilesForUpload","maxBytes","processedFiles","encodedFile","updateStaleImageStatuses","excalidrawAPI","FIREBASE_CONFIG","firebasePromise","firestorePromise","firebaseStoragePromise","isFirebaseInitialized","_getFirebase","firebase","initializeApp","_loadFirebase","loadFirestore","loadFirebaseStorage","firebaseSceneVersionCache","isSavedToFirebase","portal","socket","roomId","roomKey","sceneVersion","saveFilesToFirebase","prefix","storage","put","cacheControl","saveToFirebase","ciphertext","encryptElements","nextDocData","firestore","fromUint8Array","docRef","collection","didUpdate","runTransaction","transaction","exists","update","loadFromFirebase","storedScene","toUint8Array","decrypted","decodedData","decryptElements","loadFilesFromFirebase","filesIds","storageBucket","response","byteToHex","generateCollaborationLinkData","generateRandomID","decryptImported","localDataState","ok","fixedIv","importFromBackend","importUsernameFromLocalStorage","getItem","getElementsStorageSize","getTotalStorageSize","collab","APP_STORAGE_KEYS","appStateSize","collabSize","Portal","socketInitialized","broadcastedElementVersions","queueFileUpload","fileManager","broadcastScene","sceneType","syncAll","INIT","syncableElements","isSyncableElement","payload","syncableElement","broadcastPromise","_broadcastSocketData","saveCollabRoomToFirebase","broadcastIdleChange","broadcastMouseLocation","on","emit","clients","setCollaborators","isOpen","volatile","encryptAESGEM","getShareIcon","isAppleBrowser","vendor","isWindowsBrowser","appVersion","RoomDialog","activeRoomLink","onUsernameChange","onRoomCreate","onRoomDestroy","setErrorMessage","roomLinkInput","copyRoomLink","shareRoomLink","selectInput","onKeyPress","shouldDiscardRemoteElement","local","remote","Context","CollabContext","Consumer","CollabContextConsumer","CollabContextProvider","initialValue","InverseConsumer","_updateProviderValue","InverseProvider","componentDidMount","createInverseContext","CollabWrapper","PureComponent","activeIntervalId","idleTimeoutId","socketInitializationTimer","lastBroadcastedOrReceivedSceneVersion","destroySocketClient","isUnload","beforeUnload","getSyncableElements","setItem","timestamp","room","openPortal","initializeSocketClient","closePortal","queueBroadcastAllElements","loadImageFiles","pushState","onRoomClose","fetchImageFilesFromFirebase","unfetchedImages","existingRoomLinkData","scenePromise","socketIOClient","broadcastElements","initializeSocket","encryptedData","decryptedData","decryptAESGEM","remoteElements","reconciledElements","reconcileElements","handleRemoteSceneUpdate","init","UPDATE","socketID","off","initializeIdleDetector","localElementsData","duplicates","remoteElementIdx","remoteElement","_reconcileElements","setLastBroadcastedOrReceivedSceneVersion","reportIdle","reportActive","onVisibilityChange","onIdleStateChange","VISIBILITY_CHANGE","getLastBroadcastedOrReceivedSceneVersion","currentVersion","newVersion","saveUsernameToLocalStorage","contextValue","getContextValue","BEFORE_UNLOAD","sockets","LanguageList","i18n","currentLangCode","getStorageSizes","total","CustomStats","storageSizes","setStorageSizes","sizes","excalidrawPlusIcon","ExportToExcalidrawPlus","onError","customMetadata","filesToUpload","exportToExcalidrawPlus","filesStore","createStore","clearObsoleteFilesFromIndexedDB","allIds","currentFileIds","del","localFileStorage","getMany","filesData","languageDetector","LanguageDetector","languageUtils","formatLanguageCode","isWhitelisted","checkWhitelist","saveDebounced","onFilesSaved","saveToLocalStorage","jsonBackendMatch","externalUrlMatch","savedElements","savedState","importFromLocalStorage","roomLinkData","URL","getCollaborationLinkData","isExternalScene","once","collabAPI","PlusLinkJSX","unicodeBidi","ExcalidrawWrapper","detect","setLangCode","initialStatePromiseRef","excalidrawRefCallback","loadImages","isInitialLoad","onHashChange","oldURL","titleTimeout","HASHCHANGE","unloadHandler","cacheUserLanguage","renderLanguageList","isTinyDevice","borderRadius","newEl","cryptoKey","payloadBlob","Response","exportedKey","urlString","prompt","error_class","exportToBackend","removeItem","ExcalidrawApp","isLocalhost","hostname","registerValidSW","swUrl","config","serviceWorker","registration","onupdatefound","installingWorker","installing","onstatechange","controller","info","onUpdate","onSuccess","checkValidServiceWorker","headers","contentType","unregister","userAgent","registerServiceWorker","waitingServiceWorker","waiting","STATE_CHANGE","postMessage","SentryEnvHostnameMap","onlineEnv","REACT_APP_DISABLE_SENTRY","dsn","environment","release","ignoreErrors","integrations","SentryIntegrations","levels","beforeSend","__EXCALIDRAW_SHA__","ReactDOM","getElementById"],"mappings":"wGAAA,0rDAIO,MAAMA,EAAW,aAEXC,EAAqB,GACrBC,EAAyB,EACzBC,EAAiC,EACjCC,EAA2B,EAC3BC,EAAgC,GAChCC,EAAsBC,KAAKC,GAAK,GAChCC,EAAc,CACzBC,KAAM,OACNC,UAAW,YACXC,SAAU,WACVC,KAAM,OACNC,QAAS,UACTC,KAAM,OACNC,KAAM,IAEKC,EAAiB,CAC5BC,KAAM,EACNC,MAAO,EACPC,UAAW,EACXC,OAAQ,GAGH,IAAKC,G,SAAAA,K,YAAAA,E,cAAAA,E,UAAAA,E,kBAAAA,E,cAAAA,E,uBAAAA,E,gBAAAA,E,gBAAAA,E,cAAAA,E,YAAAA,E,qBAAAA,E,YAAAA,E,yBAAAA,E,6BAAAA,E,6BAAAA,E,+BAAAA,E,2BAAAA,E,uBAAAA,E,2BAAAA,E,cAAAA,E,yBAAAA,E,qBAAAA,E,wBAAAA,E,qCAAAA,E,iBAAAA,M,KA4BL,MAAMC,EAAM,CACjBC,KAAM,OACNC,YAAa,eAGFC,EAAU,CACrBC,mBAAoB,kBAITC,EAAc,CACzBC,OAAQ,EACRC,UAAW,EACXC,SAAU,GAGCC,EAAQ,CACnBC,MAAO,QACPC,KAAM,QAGKC,EAA8B,iBAE9BC,EAAoB,GACpBC,EAAwCT,EAAYC,OACpDS,EAAqB,OACrBC,EAAyB,MACzBC,EAAkB,YAIlBC,EAAY,GAEZC,EAAa,CACxBC,WAAY,kCACZC,cAAe,qCACfC,KAAM,mBACNC,IAAK,gBACLC,IAAK,YACLC,IAAK,aACLC,IAAK,YACLC,OAAQ,4BAGGC,EAAoB,CAC/BR,WAAY,aACZS,oBAAqB,uBACrBC,kBAAmB,iBAGRC,EAAgBC,OAAOC,SAASC,OAEhCC,EAAe,CAC1BC,sBAAuB,sBAIZC,EAAuB,IACvBC,EAAoB,IACpBC,EAAyB,IACzBC,EAAgB,IAChBC,EAAgB,IAChBC,EAAkB,IAClBC,EAAiB,IACjBC,EAAY,GAGZC,EAAiB,IAEjBC,EAAmB,IAEnBC,EAAQ,CACnBC,KAAM,WACNC,IAAK,UACLC,KAAM,YAGKC,EAAeC,IAAaC,YAE5BC,EAAiB,CAC5BC,WAAY,cAGDC,EAAgB,CAC3BD,WAAY,cAGDE,EAA4C,CACvDC,cAAe,CACbC,2BAA2B,EAC3BC,aAAa,EACbC,OAAQ,CAAEC,gBAAgB,GAC1BC,WAAW,EACXC,kBAAkB,EAClBC,OAAO,EACPC,aAAa,IAIJC,EAAwB,IACxBC,EAAyB,IACzBC,EAA0B,IAE1BC,EAA8B,EAE9BC,EAAgB,CAAC,EAAG,EAAG,GACvBC,EAAyB,GAEzBC,EAAoC,KAEpCC,EAA2B,CACtCvD,EAAWK,IACXL,EAAWM,IACXN,EAAWI,IACXJ,EAAWO,KAGAiD,EAAyB,QAEzBC,GAAS,8B,mCC/KtB,4MAAO,MAAMC,EAAkB,GAElBC,EAAW,KACtB,MAAMC,EAAM,IAAIC,WAAWH,GAC3B,OAAO7C,OAAOiD,OAAOC,gBAAgBH,IAG1BI,EAAwBC,UACnC,MAAMC,QAAYrD,OAAOiD,OAAOK,OAAOC,YACrC,CACEC,KAAM,UACNC,OAAQ,MAEV,EACA,CAAC,UAAW,YAEd,aAAczD,OAAOiD,OAAOK,OAAOI,UAAU,MAAOL,IAAMM,GAG/CC,EAAiB,CAACP,EAAaQ,IAC1C7D,OAAOiD,OAAOK,OAAOQ,UACnB,MACA,CACEC,IAAK,UACLC,KAAK,EACLL,EAAGN,EACHY,QAAS,CAAC,UAAW,WACrBC,IAAK,OAEP,CACEV,KAAM,UACNC,OAAQ,MAEV,EACA,CAACI,IAGQM,EAAcf,MACzBC,EACAe,KAEA,MAAMC,QAAoBT,EAAeP,EAAK,WACxCiB,EAAKxB,IACLyB,EACY,kBAATH,GACH,IAAII,aAAcC,OAAOL,GACzBA,aAAgBpB,WAChBoB,EACAA,aAAgBM,WACVN,EAAKO,cACXP,EAWN,MAAO,CAAEQ,sBATqB5E,OAAOiD,OAAOK,OAAOuB,QACjD,CACErB,KAAM,UACNc,MAEFD,EACAE,GAGwBD,OAGfQ,EAAc1B,MACzBkB,EACAS,EACAC,KAEA,MAAM3B,QAAYO,EAAeoB,EAAY,WAC7C,OAAOhF,OAAOiD,OAAOK,OAAO2B,QAC1B,CACEzB,KAAM,UACNc,MAEFjB,EACA0B,K,oFC5EG,MAAMG,EACQ,qBAAZC,IAAP,UACAA,uyBADA,aACA,EAAaC,gCACK,qBAAXpF,QACPA,OAAOqF,KACH,CAACC,EAAkB9B,EAAc+B,EAAgBC,KAC/CxF,OAAOqF,KAAK,QAAS7B,EAAM,CACzBiC,eAAgBH,EAChBI,YAAaH,EACbC,YAGe,qBAAZL,IAAP,UAAkCA,uyBAAlC,OAAkC,EAAaQ,gBAC/C,CAACL,EAAkB9B,EAAc+B,EAAgBC,U,oFCbvD,+NAQO,MAAMI,EACXxB,GAEO,IAAIyB,SAAQ,CAACC,EAASC,KAC3B,MAAMC,EACY,kBAAT5B,EACH,IAAIM,KAAK,EAAC,IAAIF,aAAcC,OAAOL,KACnC,IAAIM,KAAK,CAACN,aAAgBpB,WAAaoB,EAAO,IAAIpB,WAAWoB,KAC7D6B,EAAS,IAAIC,WACnBD,EAAOE,OAAUC,IACf,IAAKA,EAAMC,QAAyC,kBAAxBD,EAAMC,OAAOC,OACvC,OAAOP,EAAO,IAAIQ,MAAM,oCAE1BT,EAAQM,EAAMC,OAAOC,SAEvBL,EAAOO,mBAAmBR,MAIxBS,EAA2BC,IAC/B,MAAMnC,EAAS,IAAIoC,YAAYD,EAAWjD,QACpCmD,EAAa,IAAI5D,WAAWuB,GAClC,IAAK,IAAIsC,EAAI,EAAGC,EAAMJ,EAAWjD,OAAQoD,EAAIC,EAAKD,IAChDD,EAAWC,GAAKH,EAAWK,WAAWF,GAExC,OAAOtC,GAGHyC,EAAsBN,GACnB,IAAIO,YAAY,SAASC,OAAOT,EAAwBC,IAWpDS,EAAiB/D,eAAOgE,GAAuC,IAA1BC,EAAyB,wDACzE,OAAOA,EAAerH,OAAOsH,KAAKF,GAAOpH,OAAOsH,WAAW1B,EAAawB,KAI7DG,EAAiBnE,eAAOoE,GAA0C,IAA1BH,EAAyB,wDAC5E,OAAOA,EACHrH,OAAOyH,KAAKD,GACZR,EAAmBhH,OAAOyH,KAAKD,KAmBxB/C,EAASrB,UAOO,IACvBsE,GARuB,KAC3BC,EAD2B,SAE3BC,GAK0B,EAE1B,IAAiB,IAAbA,EACF,IACEF,QAAiB9B,EAAaiC,kBAAQF,IACtC,MAAOG,GACPC,QAAQD,MAAM,yBAA0BA,GAG5C,MAAO,CACLE,QAAS,IACTC,SAAU,UACVC,aAAcR,EACdS,QAAST,SAAmB9B,EAAa+B,KAIhCT,EAAS9D,UACpB,IAAIgF,EAEJ,GACO,YADChE,EAAK6D,SAQT,MAAM,IAAI1B,MAAJ,oCAAuCnC,EAAK6D,SAA5C,MAGV,OARIG,EAAUhE,EAAK8D,WACX9D,EAAK+D,cACCnB,EAAmB5C,EAAK+D,SAMlC/D,EAAK8D,WACAG,kBAAQ,IAAIrF,WAAWyD,EAAwB2B,IAAW,CAC/DE,GAAI,WAIDF,GA4BHG,EAAqB,CAAE,EAAG,EAAG,EAAG,GAAI,EAAG,IAkB7C,SAASC,EACPjE,EACAkE,EACAC,EACAlD,GAEA,GAAa,MAATA,EAAe,CACjB,GAAIA,EAAQxI,KAAK2L,IAAI,EAAGJ,EAAmBE,IAAU,EACnD,MAAM,IAAIlC,MAAJ,0EAC+Df,EAD/D,oBACgFiD,EADhF,MAIR,MAAMG,EAAM,iBAAaL,EAAmBE,IAE5C,OADA,IAAII,SAAStE,EAAOA,QAAQqE,GAAQF,EAAQlD,GACrCjB,EAET,MAAMqE,EAAM,iBAAaL,EAAmBE,IAC5C,OAAO,IAAII,SAAStE,EAAOA,QAAQqE,GAAQF,GAmB7C,MAAMI,EAAgB,WAA+B,IAAD,uBAA1BC,EAA0B,yBAA1BA,EAA0B,gBAClD,MAAMnC,EAAa,IAAI5D,WA3DM,EACQ,EA4DA+F,EAAQtF,OACzCsF,EAAQC,QAAO,CAACC,EAAK1E,IAAW0E,EAAM1E,EAAO2E,YAAY,IAG7D,IAAIC,EAAS,EAGbX,EAAS5B,EApEoB,EAoEgBuC,EA1EhB,GA2E7BA,GArE6B,EAuE7B,IAAK,MAAM5E,KAAUwE,EACnBP,EACE5B,EAxEiC,EA0EjCuC,EACA5E,EAAO2E,YAETC,GA7EmC,EA+EnCvC,EAAWwC,IAAI7E,EAAQ4E,GACvBA,GAAU5E,EAAO2E,WAGnB,OAAOtC,GAIHyC,EAAgBC,IACpB,MAAMP,EAAU,GAEhB,IAAII,EAAS,EAKb,IAFAA,GA9F6B,IAgGhB,CACX,MAAMI,EAAYf,EAChBc,EAjGiC,EAmGjCH,GAMF,GAJAA,GArGmC,EAuGnCJ,EAAQS,KAAKF,EAAmBG,MAAMN,EAAQA,EAASI,IACvDJ,GAAUI,EACNJ,GAAUG,EAAmBJ,WAC/B,MAIJ,OAAOH,GAgCIW,EAAetG,MAC1BuG,EACAC,KAUA,MAMMC,GAAyB,IAAIrF,aAAcC,OAC/CqF,KAAKC,UAP4B,CACjC/B,QAAS,EACTgC,YAAa,SACbC,WAAY,aAORC,GAAyB,IAAI1F,aAAcC,OAC/CqF,KAAKC,UAAUH,EAAQO,UAAY,QAG/B,GAAE7F,EAAF,OAAMC,QAnDcnB,OAC1BgB,EACAgG,KAEA,MAAM,gBAAExF,EAAF,GAAmBN,SAAaH,YACpCiG,EACAvC,kBAAQzD,IAGV,MAAO,CAAEE,KAAIC,OAAQ,IAAIvB,WAAW4B,KA0CPyF,CAC3BvB,EAAcoB,EAAwBP,GACtCC,EAAQQ,eAGV,OAAOtB,EAAce,EAAwBvF,EAAIC,IAqBtC+F,EAAiBlH,MAC5BwD,EACAgD,KAGA,MAAOC,EAAwBvF,EAAIC,GAAU8E,EAAazC,GAEpD2D,EAAqCT,KAAKU,OAC9C,IAAIvD,aAAcC,OAAO2C,IAG3B,IACE,MAAOK,EAAwBO,GAAkBpB,OA7BvBjG,OAC5BkB,EACAoG,EACAC,EACAC,KAEAF,EAAkB,IAAI1H,iBACd8B,YAAYR,EAAIoG,EAAiBC,IAGrCC,EACKvC,kBAAQqC,GAGVA,GAgBGG,CACJvG,EACAC,EACAqF,EAAQe,gBACNJ,EAAiBP,cAQvB,MAAO,CAELG,SANeL,KAAKU,OACpB,IAAIvD,aAAcC,OAAOgD,IAOzB9F,KAAMqG,GAER,MAAO3C,GAKP,MAJAC,QAAQD,MAAR,sDAEEyC,GAEIzC,K,socCrXVgD,EAAOC,QAAU,CAAC,YAAc,mC,0BCDhC,IAAIC,EAAM,CACT,eAAgB,CACf,IACA,GAED,eAAgB,CACf,IACA,GAED,eAAgB,CACf,IACA,GAED,eAAgB,CACf,IACA,GAED,eAAgB,CACf,IACA,GAED,eAAgB,CACf,IACA,GAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,YAAa,CACZ,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,iBAAkB,CACjB,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,qBAAsB,CACrB,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,KAGF,SAASC,EAAoBC,GAC5B,IAAIC,EAAoBC,EAAEJ,EAAKE,GAC9B,OAAOrF,QAAQC,UAAUuF,MAAK,WAC7B,IAAIC,EAAI,IAAI/E,MAAM,uBAAyB2E,EAAM,KAEjD,MADAI,EAAEC,KAAO,mBACHD,KAIR,IAAIE,EAAMR,EAAIE,GAAMO,EAAKD,EAAI,GAC7B,OAAO3F,QAAQ6F,IAAIF,EAAI/B,MAAM,GAAGuB,IAAIG,EAAoBG,IAAID,MAAK,WAChE,OAAOF,EAAoBQ,EAAEF,EAAI,MAGnCR,EAAoBW,KAAO,WAC1B,OAAOC,OAAOD,KAAKZ,IAEpBC,EAAoBQ,GAAK,GACzBX,EAAOC,QAAUE,G,+qBC9LjB,MAQaa,EAAc,CAAEP,KAAM,KAAMhG,MAAO,WA0CnCwG,EAxCoB,CAC/B,CAAER,KAAM,QAAShG,MAAO,6CAAWyG,KAAK,GACxC,CAAET,KAAM,QAAShG,MAAO,0DACxB,CAAEgG,KAAM,QAAShG,MAAO,aACxB,CAAEgG,KAAM,QAAShG,MAAO,WACxB,CAAEgG,KAAM,QAAShG,MAAO,oDACxB,CAAEgG,KAAM,QAAShG,MAAO,cACxB,CAAEgG,KAAM,QAAShG,MAAO,iCAASyG,KAAK,GACtC,CAAET,KAAM,QAAShG,MAAO,SACxB,CAAEgG,KAAM,QAAShG,MAAO,eACxB,CAAEgG,KAAM,QAAShG,MAAO,iCAASyG,KAAK,GACtC,CAAET,KAAM,QAAShG,MAAO,wCACxB,CAAEgG,KAAM,QAAShG,MAAO,UACxB,CAAEgG,KAAM,QAAShG,MAAO,oBACxB,CAAEgG,KAAM,QAAShG,MAAO,YACxB,CAAEgG,KAAM,QAAShG,MAAO,sBACxB,CAAEgG,KAAM,UAAWhG,MAAO,aAC1B,CAAEgG,KAAM,QAAShG,MAAO,sBACxB,CAAEgG,KAAM,QAAShG,MAAO,WACxB,CAAEgG,KAAM,QAAShG,MAAO,mBACxB,CAAEgG,KAAM,QAAShG,MAAO,cACxB,CAAEgG,KAAM,QAAShG,MAAO,iBACxB,CAAEgG,KAAM,QAAShG,MAAO,WACxB,CAAEgG,KAAM,QAAShG,MAAO,wCACxB,CAAEgG,KAAM,QAAShG,MAAO,UACxB,CAAEgG,KAAM,QAAShG,MAAO,2BACxB,CAAEgG,KAAM,QAAShG,MAAO,gBACxB,CAAEgG,KAAM,QAAShG,MAAO,kBACxB,CAAEgG,KAAM,QAAShG,MAAO,8CACxB,CAAEgG,KAAM,QAAShG,MAAO,mBACxB,CAAEgG,KAAM,QAAShG,MAAO,WACxB,CAAEgG,KAAM,QAAShG,MAAO,gBACxB,CAAEgG,KAAM,QAAShG,MAAO,gEACxB,CAAEgG,KAAM,QAAShG,MAAO,4BACxB,CAAEgG,KAAM,QAAShG,MAAO,4BACxB,CAAEgG,KAAM,QAAShG,MAAO,iBACxB,CAAEgG,KAAM,QAAShG,MAAO,cACxB,CAAEgG,KAAM,QAAShG,MAAO,4DACxB0G,OAAO,CAACH,IAGPI,MAAK,CAACC,EAAMC,IAAWD,EAAK5G,MAAQ6G,EAAM7G,MAAQ,GAAK,IACvD8G,QACEC,GACEC,EAAuCD,EAAKf,OAtDtB,KA0DvBiB,EAAiB,WACnBrH,eAAyBnH,IAAIE,aAC/B6N,EAAUU,QACR,CAAElB,KAAMiB,EAAgBjH,MAAO,iBAC/B,CACEgG,KAAK,GAAD,OAAKiB,EAAL,QACJjH,MAAO,kCACPyG,KAAK,IAKX,IAAIU,EAAwBZ,EACxBa,EAAkB,GAEf,MAAMC,EAAcxJ,UACzBsJ,EAAcJ,EACdO,SAASC,gBAAgBC,IAAML,EAAYV,IAAM,MAAQ,MACzDa,SAASC,gBAAgBR,KAAOI,EAAYnB,KAG1CoB,EADEL,EAAKf,KAAKyB,WAAWR,GACL,SAEM,kBACgCE,EAAYnB,KAD5C,WAMf0B,EAAc,IAAMP,EAE3BQ,EAAmB,CAAC9I,EAAW+I,KACnC,IAAK,IAAIC,EAAQ,EAAGA,EAAQD,EAAM1J,SAAU2J,EAAO,CACjD,MAAMC,EAAOF,EAAMC,GACnB,QAAmBE,IAAflJ,EAAKiJ,GACP,OAEFjJ,EAAOA,EAAKiJ,GAEd,GAAoB,kBAATjJ,EAGX,OAAOA,GAGIuH,EAAI,CAAC4B,EAAcC,KAC9B,GAAId,EAAYnB,KAAKyB,WAAWR,GAAiB,CAC/C,MAAMhJ,EAAOgK,EAAW,UACjBD,EADiB,YACTzD,KAAKC,UAAUyD,GAAa/D,MAAM,GAAI,GAD7B,KAEpB8D,EACJ,MAAM,WAAN,OAAoB/J,EAApB,YAGF,MAAM2J,EAAQI,EAAKE,MAAM,KACzB,IAAIC,EACFR,EAAiBP,EAAiBQ,IAClCD,EAAiBS,EAAkBR,GACrC,QAAoBG,IAAhBI,EACF,MAAM,IAAInH,MAAJ,qCAAwCgH,IAGhD,GAAIC,EACF,IAAK,MAAMnK,KAAOmK,EAChBE,EAAcA,EAAYE,QAAZ,YAAyBvK,EAAzB,MAAkCmK,EAAYnK,IAGhE,OAAOqK,GC9HHG,EAAUT,GAAkB,CAChCU,EAAGC,IAAIX,GACPU,EAAGE,KAAKZ,GACRU,EAAGG,MAAMb,GACTU,EAAGI,OAAOd,GACVU,EAAGK,OAAOf,GACVU,EAAGM,KAAKhB,GACRU,EAAGO,KAAKjB,GACRU,EAAGQ,KAAKlB,GACRU,EAAGS,MAAMnB,GACTU,EAAGU,KAAKpB,GACRU,EAAGW,OAAOrB,GACVU,EAAGY,OAAOtB,IAGG,OACbuB,iBAAkB,CAACb,EAAGc,MAAOd,EAAGe,KAAK,GAAIf,EAAGe,KAAK,MAAOhB,EAAO,IAC/DiB,kBAAmB,CAAC,cAAehB,EAAGe,KAAK,GAAIf,EAAGe,KAAK,MAAOhB,EAAO,IACrEkB,cAAe,CAACjB,EAAGkB,MAAOlB,EAAGe,KAAK,GAAIf,EAAGe,KAAK,MAAOhB,EAAO,KCpBvD,MAAMoB,EAAW,uBAAuBC,KAAKlP,OAAOmP,UAAUC,UACxDC,EAAY,OAAOH,KAAKlP,OAAOmP,UAAUC,UAEzCE,EACJ,QADIA,EAEJ,QAFIA,EAGF,YAHEA,EAIG,iBAJHA,EAKD,UALCA,EAMI,eANJA,EAOG,cAPHA,EAQN,SARMA,EASN,SATMA,EAWJ,QAXIA,EAYL,SAZKA,EAaJ,QAbIA,EAcR,OAdQA,EAeR,OAfQA,EAgBR,OAhBQA,EAiBR,OAjBQA,EAkBR,OAlBQA,EAmBR,OAnBQA,EAoBR,OApBQA,EAqBR,OArBQA,EAsBR,OAGQC,EACC,YADDA,EAEC,YAFDA,EAGE,aAHFA,EAID,UAJCA,EAKA,YALAA,EAMN,MANMA,EAOEN,EAAW,UAAY,UAPzBM,GAQH,SARGA,GASJ,QATIA,GAUH,SAVGA,GAWI,IAXJA,GAYJ,IAZIA,GAaN,MAbMA,GAeR,IAfQA,GAgBR,IAhBQA,GAiBR,IAjBQA,GAkBR,IAlBQA,GAoBR,IApBQA,GAqBR,IArBQA,GAsBR,IAtBQA,GAuBR,IAvBQA,GAwBR,IAxBQA,GAyBR,IAzBQA,GA0BR,IA1BQA,GA2BR,IA3BQA,GA4BR,IA5BQA,GA6BR,IA7BQA,GA8BR,IAKQC,GAAcnM,GACzBA,IAAQkM,GACRlM,IAAQkM,GACRlM,IAAQkM,GACRlM,IAAQkM,EAEGE,GAA0BrJ,GACrCA,EAAMsJ,OAEKC,GAA6BvJ,GACxCA,EAAMwJ,SAEKC,GACXzJ,GACGA,EAAMwJ,SCjEX,IAAIE,GAA8B,KAE3B,MAIMC,GAAc,KACzB,GAAID,GACF,OAAOA,GAGT,MAAME,EAAO,IAAIC,KACXC,EAAOF,EAAKG,cACZC,EAAQ,UAAGJ,EAAKK,WAAa,GAAIC,SAAS,EAAG,KAC7CC,EAAM,UAAGP,EAAKQ,WAAYF,SAAS,EAAG,KACtCG,EAAK,UAAGT,EAAKU,YAAaJ,SAAS,EAAG,KACtCK,EAAM,UAAGX,EAAKY,cAAeN,SAAS,EAAG,KAE/C,MAAM,GAAN,OAAUJ,EAAV,YAAkBE,EAAlB,YAA2BG,EAA3B,YAAkCE,GAAlC,OAAuCE,IAG5BE,GAAoBzJ,GAC/BA,EAAI0J,OAAO,GAAGC,cAAgB3J,EAAIqC,MAAM,GAqB7BuH,GACX3K,GAMCA,aAAkB4K,aAAuC,YAAxB5K,EAAO6K,QAAQC,MACjD9K,aAAkB+K,eAClB/K,aAAkBgL,qBACjBhL,aAAkBiL,mBACA,SAAhBjL,EAAO8K,MAAmC,WAAhB9K,EAAO8K,MAEzBI,GAAsB,IAI5B,IAJ6B,WAClCC,GAGI,EACJ,IAAK,MAAOC,EAAkBhG,KAAOI,OAAO6F,QAAQrT,KAClD,GAAIoN,IAAO+F,EACT,MAAM,GAAN,OAAUC,EAAV,aAA+B7S,KAGnC,OAAOA,KAII+S,GAAgB,IAMtB,IANuB,SAC5BC,EAD4B,WAE5BJ,GAII,EACJ,MAAM,GAAN,OAAUI,EAAV,cAAwBL,GAAoB,CAAEC,iBAInCK,GAAc,CAAClK,EAAcmK,KACxC,MAAMC,EAAOlF,SAASmF,cAAc,OAC9BC,EAAOpF,SAASoF,KACtBF,EAAKG,MAAMC,SAAW,WACtBJ,EAAKG,MAAME,WAAa,MACxBL,EAAKG,MAAMJ,KAAOA,EAClBG,EAAKI,YAAYN,GACjBA,EAAKO,UAAY3K,EACd8F,MAAM,MAGNzC,KAAKuH,GAAMA,GAAK,MAChBC,KAAK,MACR,MAAMC,EAAQV,EAAKW,YACbC,EAASZ,EAAKa,aAGdC,EAAOhG,SAASmF,cAAc,QACpCa,EAAKX,MAAMY,QAAU,eACrBD,EAAKX,MAAMa,SAAW,SACtBF,EAAKX,MAAMO,MAAQ,MACnBI,EAAKX,MAAMS,OAAS,MACpBZ,EAAKM,YAAYQ,GAEjB,MAAMG,EAAWH,EAAKI,UAAYJ,EAAKD,aAGvC,OAFA/F,SAASoF,KAAKiB,YAAYnB,GAEnB,CAAEU,QAAOE,SAAQK,aAGbG,GAAW,CACtBC,EACAC,KAEA,IAAIC,EAAS,EACTC,EAAqB,KACzB,MAAMC,EAAM,WAAiB,IAAD,uBAAZC,EAAY,yBAAZA,EAAY,gBAC1BF,EAAWE,EACXC,aAAaJ,GACbA,EAAStT,OAAO2T,YAAW,KACzBJ,EAAW,KACXH,KAAMK,KACLJ,IAcL,OAZAG,EAAII,MAAQ,KAEV,GADAF,aAAaJ,GACTC,EAAU,CACZ,MAAMM,EAAYN,EAClBA,EAAW,KACXH,KAAMS,KAGVL,EAAIM,OAAS,KACXP,EAAW,KACXG,aAAaJ,IAERE,GAoBIO,GAAW,CAACxB,EAAWyB,IAAchX,KAAKiX,IAAI1B,EAAIyB,GAElDE,GAAeC,IACtBA,IACFA,EAAOjC,MAAM/I,OAAS,KAIbiL,GAAY,CAACD,EAAkChL,KACtDgL,IACFA,EAAOjC,MAAM/I,OAASA,IAIbkL,GAAoB,CAC/BF,EACAG,KAEKH,IAGS,cAAVG,EACFJ,GAAYC,GAGO,UAAVG,IACTH,EAAOjC,MAAM/I,OAASjM,IAAYE,aAIzBmX,GAAe,iBACe,UAAzC,UAAA1H,SAAS2H,yBAAT,eAA4BC,WAOjBC,GAAkBC,IAC7BA,EAAWA,EACR/G,QAAQ,WAAY,OACpBA,QAAQ,aAAc,SACtBA,QAAQ,sBAAuB,SAC/BA,QAAQ,WAAY,UAEnBqB,EACK0F,EACJ/G,QAAQ,iBAAkB,OAC1BA,QAAQ,WAAY,UAElB+G,EAAS/G,QAAQ,iBAAkB,SAG/BgH,GAA8B,CAAC,EAAD,KAerC,IAdJ,QAAEC,EAAF,QAAWC,GAcR,GAbH,KACEC,EADF,WAEEC,EAFF,UAGE/B,EAHF,QAIEgC,EAJF,QAKEC,GAQC,EACH,MAAMC,EAAW,EAAIJ,EAAKvP,MAG1B,MAAO,CAAE+M,GAFEsC,EAAUE,EAAKrH,YAAY6E,EAAIyC,GAAcG,EAAWF,EAEvDjB,GADDc,EAAUC,EAAKrH,YAAYsG,EAAIf,GAAakC,EAAWD,IAIvDE,GAA8B,CAAC,EAAD,KAerC,IAdJ,OAAEC,EAAF,OAAUC,GAcP,GAbH,KACEP,EADF,WAEEC,EAFF,UAGE/B,EAHF,QAIEgC,EAJF,QAKEC,GAQC,EAGH,MAAO,CAAE3C,GAFE8C,EAASJ,EAAUD,GAAcD,EAAKvP,MAAQuP,EAAKrH,YAAY6E,EAE9DyB,GADDsB,EAASJ,EAAUjC,GAAa8B,EAAKvP,MAAQuP,EAAKrH,YAAYsG,IAI9DuB,GAAwB/R,GACnCgS,iBAAiB3I,SAASC,iBAAiB2I,iBAA3C,YAAiEjS,IAM7DkS,GAAe,IAAIC,OAAJ,aAHnB,uGAGmB,cADA,0CACA,MAORC,GAASjO,GAAiB+N,GAAaxG,KAAKvH,GAE5CkO,GACXC,IAEA,MAAOvD,EAAGyB,GAAK8B,EACf,MAAO,CAAEvD,IAAGyB,MAID+B,GAAoBjO,IAC/B,GAAoB,gBAAX,OAALA,QAAK,IAALA,OAAA,EAAAA,EAAOtE,MAGX,MAAMsE,GAuCKkO,GAAiBC,IAC5B,MAAMC,EAAoC,IAAjBD,EAAMxS,QAAuC,MAAvBwS,EAAME,OAAO,EAAG,GACzDC,EAAuC,IAAjBH,EAAMxS,QAAuC,OAAvBwS,EAAME,OAAO,EAAG,GAClE,OACED,GACAE,GACAH,IAAUI,EAAOvH,kBAAkB,IAQ1BwH,GAAoB,KAC/B,IAAIxQ,EACAC,EACJ,MAAMwQ,EAAU,IAAI1Q,SAAQ,CAAC2Q,EAAUC,KACrC3Q,EAAU0Q,EACVzQ,EAAS0Q,KAIX,OAFCF,EAAgBzQ,QAAUA,EAC1ByQ,EAAgBxQ,OAASA,EACnBwQ,GAMIG,GAGXC,GAEEvQ,IACAwQ,kCAAwBD,EAAmBvQ,IAIlCyQ,GAAa,CAACC,EAAaC,KACtC,MAAMC,EAAK,CACT,CAAExR,MAAO,EAAGyR,OAAQ,KACpB,CAAEzR,MAAO,IAAKyR,OAAQ,KACtB,CAAEzR,MAAO,IAAKyR,OAAQ,KACtB,CAAEzR,MAAO,IAAKyR,OAAQ,MAGxB,IAAI7J,EACJ,IAAKA,EAAQ4J,EAAGvT,OAAS,EAAG2J,EAAQ,KAC9B0J,GAAOE,EAAG5J,GAAO5H,OADgB4H,KAKvC,OACG0J,EAAME,EAAG5J,GAAO5H,OAAO0R,QAAQH,GAAQnJ,QAR/B,2BAQ2C,MAAQoJ,EAAG5J,GAAO6J,QAI7DE,GAAa,KAAO,IAAD,EAC9B,OACE,UAAAtK,SAASuK,cAA+B,+BAAxC,eAAiEC,UACjEpY,KAqDSqY,GAAiBlR,IAC5BA,EAAMmR,iBAENnR,EAAMoR,YAAc,ICrbhBC,GAAqBlV,IAAcmV,SAASC,kBAC9CA,iBACA,EAESC,GAAqB,KAIzB,CACL3V,MAAOxD,IAAMC,MACbmZ,cAAe,IAAIC,IACnBC,iBAAkB,MAClBC,2BAA4B,cAC5BC,wBAAyB,QACzBC,qBAAsB,UACtBC,sBAAuBrZ,IACvBsZ,oBAAqBvZ,IACrBwZ,iCAAkC,QAClCC,mBAAoB,IACpBC,qBAAsB,EACtBC,0BAA2B,KAC3BC,uBAAwB3K,EAAGkB,MAC3B0J,2BAA4B,QAC5BC,uBAAwB,QACxBC,uBAAwB,EACxBC,qBAAsB9Z,IACtB+Z,aAAc,KACdC,gBAAiB,KACjBC,eAAgB,KAChBC,eAAgB,KAChBC,qBAAsB,KACtBC,eAAe,EACfC,YAAa,YACbC,aAAc,KACdC,kBAAkB,EAClBC,YAAa9B,GACb+B,kBAAkB,EAClBC,oBAAoB,EACpBC,WAAY,KACZC,SAAU,KACVC,kBAAkB,EAClBC,eAAe,EACfC,WAAW,EACXC,YAAY,EACZC,YAAY,EACZC,oBAAqB,QACrBC,aAAc,KACd1W,KAAK,GAAD,OAAKmI,EAAE,mBAAP,YAA6BoE,MACjCoK,SAAU,KACVC,UAAW,KACXC,YAAa,CAAEC,OAAO,EAAOlW,KAAM,MACnCmW,2BAA4B,GAC5BC,gBAAiB,KACjBC,iBAAiB,EACjBxF,QAAS,EACTC,QAAS,EACTwF,mBAAoB,GACpBC,iBAAkB,GAClBC,iBAAkB,KAClBC,uBAAuB,EACvBC,gBAAgB,EAChBC,WAAW,EACXC,kBAAmB,KACnBC,kBAAmB,GACnBC,aAAc,KACdC,oBAAqBrN,EAAGc,MACxBwM,gBAAgB,EAChBrG,KAAM,CAAEvP,MAAO,EAA0BkI,YAAa,CAAE6E,EAAG,EAAGyB,EAAG,IACjEqH,iBAAiB,EACjBC,oBAAqB,OAQnBC,GAWI,CACRtZ,MAAO,CAAEuZ,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC/C5D,cAAe,CAAE2D,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACxD1D,iBAAkB,CAAEyD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC1DzD,2BAA4B,CAAEwD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACpExD,wBAAyB,CAAEuD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACjEvD,qBAAsB,CAAEsD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC9DtD,sBAAuB,CAAEqD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC/DrD,oBAAqB,CAAEoD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC7DpD,iCAAkC,CAChCmD,SAAS,EACT3Z,QAAQ,EACR4Z,QAAQ,GAEVnD,mBAAoB,CAAEkD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC5DlD,qBAAsB,CAAEiD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC9DjD,0BAA2B,CAAEgD,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACnEhD,uBAAwB,CAAE+C,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAChE/C,2BAA4B,CAAE8C,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACpE9C,uBAAwB,CAAE6C,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAChE7C,uBAAwB,CAAE4C,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAChE5C,qBAAsB,CAAE2C,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC9D3C,aAAc,CAAE0C,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACtD1C,gBAAiB,CAAEyC,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC1DzC,eAAgB,CAAEwC,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACzDxC,eAAgB,CAAEuC,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACxDvC,qBAAsB,CAAEsC,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC/DtC,cAAe,CAAEqC,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACvDrC,YAAa,CAAEoC,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACrDpC,aAAc,CAAEmC,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACvDnC,iBAAkB,CAAEkC,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC1DjC,iBAAkB,CAAEgC,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC1DlC,YAAa,CAAEiC,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACrDhC,mBAAoB,CAAE+B,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC5D/B,WAAY,CAAE8B,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACrD9B,SAAU,CAAE6B,SAAS,EAAM3Z,QAAQ,EAAM4Z,QAAQ,GACjD9I,OAAQ,CAAE6I,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACjD7B,iBAAkB,CAAE4B,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC3D5B,cAAe,CAAE2B,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACxD3B,UAAW,CAAE0B,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACpD1B,WAAY,CAAEyB,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACrDzB,WAAY,CAAEwB,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACrDxB,oBAAqB,CAAEuB,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC7DvB,aAAc,CAAEsB,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACvDjY,KAAM,CAAEgY,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC9CzG,WAAY,CAAEwG,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACrDxI,UAAW,CAAEuI,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACpDtB,SAAU,CAAEqB,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAClDrB,UAAW,CAAEoB,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACpDpB,YAAa,CAAEmB,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACtDlB,2BAA4B,CAAEiB,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACpEjB,gBAAiB,CAAEgB,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC1DhB,gBAAiB,CAAEe,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACzDxG,QAAS,CAAEuG,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACjDvG,QAAS,CAAEsG,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACjDf,mBAAoB,CAAEc,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC5Dd,iBAAkB,CAAEa,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC1Db,iBAAkB,CAAEY,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC3DZ,sBAAuB,CAAEW,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC/DX,eAAgB,CAAEU,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACzDV,UAAW,CAAES,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACnDT,kBAAmB,CAAEQ,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC5DR,kBAAmB,CAAEO,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC5DP,aAAc,CAAEM,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GACvDN,oBAAqB,CAAEK,SAAS,EAAM3Z,QAAQ,EAAM4Z,QAAQ,GAC5DhJ,MAAO,CAAE+I,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAChDL,eAAgB,CAAEI,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GACxD1G,KAAM,CAAEyG,SAAS,EAAM3Z,QAAQ,EAAO4Z,QAAQ,GAC9CJ,gBAAiB,CAAEG,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,GAC1DH,oBAAqB,CAAEE,SAAS,EAAO3Z,QAAQ,EAAO4Z,QAAQ,IAG1DC,GAA2B,CAG/BC,EACAC,KAOA,MAAMC,EAAiB,GACvB,IAAK,MAAMxY,KAAOwI,OAAOD,KAAK+P,GAAwC,CACpE,MAAMG,EAAaP,GAAuBlY,GAC1C,UAAIyY,QAAJ,IAAIA,OAAJ,EAAIA,EAAaF,GAAa,CAC5B,MAAMG,EAAYJ,EAAStY,GAG1BwY,EAAuBxY,GAAO0Y,GAGnC,OAAOF,GAGIG,GAAgCL,GACpCD,GAAyBC,EAAU,WAG/BM,GAA0BN,GAC9BD,GAAyBC,EAAU,UAG/BO,GAA4BP,GAChCD,GAAyBC,EAAU,U,YC3MrC,MAAMQ,GAAsB,KACjC,MAAOC,EAAUC,GAAeC,mBAAmB,MAEnD,MAAO,CAACF,EADYG,uBAAa/W,GAAoB6W,EAAY7W,IAAQ,M,sBCOpE,MAYMgX,GACXC,KAESA,GAA4B,UAAjBA,EAAQtL,QAAsBsL,EAAQC,OAG/CC,GACXF,KAESA,GAA4B,UAAjBA,EAAQtL,KAGjByL,GACXH,GAEkB,MAAXA,GAAoC,SAAjBA,EAAQtL,KAGvB0L,GACXJ,GAEkB,MAAXA,GAAmBK,GAAsBL,EAAQtL,MAG7C2L,GACX1D,GAEuB,aAAhBA,EAGI2D,GACXN,GAEkB,MAAXA,GAAmBO,GAAoBP,EAAQtL,MAG3C6L,GACX5D,GAGkB,UAAhBA,GAA2C,SAAhBA,EAIlB6D,GACXR,GAEkB,MAAXA,GAAmBS,GAAqBT,EAAQtL,MAG5C+L,GACX9D,GAEuB,UAAhBA,EAGI+D,GACXV,GAGa,MAAXA,IACkB,cAAjBA,EAAQtL,MACU,YAAjBsL,EAAQtL,MACS,YAAjBsL,EAAQtL,MACS,SAAjBsL,EAAQtL,MCnFDiM,GAAS,CACpBC,EACAC,EACAC,EACAC,EACAC,IAKA,EACGJ,EAAKE,GAAMvgB,KAAK0gB,IAAID,IAAUH,EAAKE,GAAMxgB,KAAK2gB,IAAIF,GAASF,GAC3DF,EAAKE,GAAMvgB,KAAK2gB,IAAIF,IAAUH,EAAKE,GAAMxgB,KAAK0gB,IAAID,GAASD,GAGnDI,GAAc,CACzBC,EACAC,EACAL,IACqBL,GAAOS,EAAM,GAAIA,EAAM,GAAIC,EAAO,GAAIA,EAAO,GAAIL,GAE3DM,GAAuB,CAClCC,EAMAzL,EACAyB,EACAyJ,EACAQ,EACAC,EACAC,EACAC,KAEA,MAAMV,EAAM1gB,KAAK0gB,IAAID,GACfE,EAAM3gB,KAAK2gB,IAAIF,GA4BrB,OA3BIO,EAAM1S,GAAK0S,EAAMK,EACnB9L,GAAK0L,EAAUE,EACNH,EAAM1S,GACfiH,GAAK0L,GAAW,EAAIP,GACpB1J,GAAKiK,EAAUN,EACfpL,GAAK4L,GAAW,EAAIT,GACpB1J,GAAKmK,GAAWR,GACPK,EAAMK,IACf9L,GAAK0L,GAAW,EAAIP,GACpB1J,GAAKiK,GAAWN,EAChBpL,GAAK4L,GAAW,EAAIT,GACpB1J,GAAKmK,EAAUR,GAGbK,EAAMM,GAAKN,EAAMO,EACnBvK,GAAKkK,EAAUE,EACNJ,EAAMM,GACf/L,GAAK2L,EAAUP,EACf3J,GAAKkK,GAAW,EAAIR,GACpBnL,GAAK6L,GAAWT,EAChB3J,GAAKoK,GAAW,EAAIV,IACXM,EAAMO,IACfhM,GAAK2L,GAAWP,EAChB3J,GAAKkK,GAAW,EAAIR,GACpBnL,GAAK6L,EAAUT,EACf3J,GAAKoK,GAAW,EAAIV,IAEf,CAACnL,EAAGyB,IAkEAwK,GAAa,CAACnB,EAAYC,EAAYC,EAAYC,KAC7D,MAAMiB,EAAKlB,EAAKF,EACVqB,EAAKlB,EAAKF,EAChB,OAAOtgB,KAAK2hB,MAAMF,EAAIC,IASXE,GAAc,SACzBC,GAGa,IADbC,EACY,uDADe,EAE3B,GAAID,EAAOpb,QAAU,EAAG,CACtB,MAAOsb,EAAOC,GAAQ,CAACH,EAAO,GAAIA,EAAOA,EAAOpb,OAAS,IAKzD,OAJiB+a,GAAWO,EAAM,GAAIA,EAAM,GAAIC,EAAK,GAAIA,EAAK,KAI3CriB,IAAyBmiB,EAE9C,OAAO,GAMIG,GAAmB,CAC9BJ,EACAtM,EACAyB,KAEA,MAAMkL,EAAWL,EAAOpb,OAGxB,GAAIyb,EAAW,EACb,OAAO,EAET,MAAMC,EAAiB,CAACC,OAAOC,iBAAkBrL,GAC3CsL,EAAW,CAAC/M,EAAGyB,GACrB,IAAIuL,EAAQ,EACZ,IAAK,IAAI1Y,EAAI,EAAGA,EAAIqY,EAAUrY,IAAK,CACjC,MAAM2Y,EAAUX,EAAOhY,GACjB4Y,EAAOZ,GAAQhY,EAAI,GAAKqY,GAC9B,GAAIQ,GAAoBF,EAASC,EAAMH,EAAGH,GAAU,CAClD,GAAqD,IAAjDQ,GAA2BH,EAASF,EAAGG,GACzC,OAAOG,GAAoBJ,EAASF,EAAGG,GAEzCF,KAIJ,OAAOA,EAAQ,IAAM,GAKjBK,GAAsB,CAACN,EAAUO,EAAUC,IAE7CD,EAAE,IAAM7iB,KAAK+iB,IAAIT,EAAE,GAAIQ,EAAE,KACzBD,EAAE,IAAM7iB,KAAK2T,IAAI2O,EAAE,GAAIQ,EAAE,KACzBD,EAAE,IAAM7iB,KAAK+iB,IAAIT,EAAE,GAAIQ,EAAE,KACzBD,EAAE,IAAM7iB,KAAK2T,IAAI2O,EAAE,GAAIQ,EAAE,IAQvBH,GAA6B,CAACL,EAAUO,EAAUC,KACtD,MAAME,GAAOH,EAAE,GAAKP,EAAE,KAAOQ,EAAE,GAAKD,EAAE,KAAOA,EAAE,GAAKP,EAAE,KAAOQ,EAAE,GAAKD,EAAE,IACtE,OAAY,IAARG,EACK,EAEFA,EAAM,EAAI,EAAI,GAIjBN,GAAsB,CAACO,EAAWC,EAAWC,EAAWC,KAC5D,MAAMC,EAAKV,GAA2BM,EAAIC,EAAIC,GACxCG,EAAKX,GAA2BM,EAAIC,EAAIE,GACxCG,EAAKZ,GAA2BQ,EAAIC,EAAIH,GACxCO,EAAKb,GAA2BQ,EAAIC,EAAIF,GAE9C,OAAIG,IAAOC,GAAMC,IAAOC,MAKb,IAAPH,IAAYT,GAAoBK,EAAIE,EAAID,QAKjC,IAAPI,IAAYV,GAAoBK,EAAIG,EAAIF,QAKjC,IAAPK,IAAYX,GAAoBO,EAAIF,EAAIG,OAKjC,IAAPI,IAAYZ,GAAoBO,EAAID,EAAIE,QAQjCK,GAAe,CAC1BlO,EACAyB,EACA2F,IAEIA,EACK,CACL3c,KAAK0jB,MAAMnO,EAAIoH,GAAYA,EAC3B3c,KAAK0jB,MAAM1M,EAAI2F,GAAYA,GAGxB,CAACpH,EAAGyB,GCrQA2M,GAAqB9B,IAChC,MAAM+B,EAAK/B,EAAO7T,KAAK6S,GAAUA,EAAM,KACjCgD,EAAKhC,EAAO7T,KAAK6S,GAAUA,EAAM,KACvC,MAAO,CACLpL,MAAOzV,KAAK+iB,OAAOa,GAAM5jB,KAAK2T,OAAOiQ,GACrCjO,OAAQ3V,KAAK+iB,OAAOc,GAAM7jB,KAAK2T,OAAOkQ,KAI7BC,GAAgB,CAC3BC,EACAC,EACAC,KAEA,MAAMC,EAAgBD,EAAWjW,KAAK6S,GAAUA,EAAMkD,KAChDI,EAAmBnkB,KAAK+iB,OAAOmB,GAC/BE,EAAmBpkB,KAAK2T,OAAOuQ,GAC/BG,EAAoBF,EAAmBC,EAEvCE,EACkB,IAAtBD,EAA0B,EAAIL,EAAoBK,EAEpD,IAAIE,EAAmBC,IAEvB,MAAMC,EAAeR,EAAWjW,KAC7B0W,GACCA,EAAU1W,KAAI,CAACxF,EAAOmc,KACpB,GAAIA,IAAqBZ,EACvB,OAAOvb,EAET,MAAMoc,EAAcpc,EAAQ8b,EAE5B,OADAC,EAAmBvkB,KAAK2T,IAAIiR,EAAaL,GAClCK,OAIb,GAA4B,IAAxBH,EAAahe,OAEf,OAAOge,EAGT,MAAM/T,EAAc0T,EAAmBG,EASvC,OAPmBE,EAAazW,KAC7B6W,GACCA,EAAY7W,KAAI,CAACxF,EAAOmc,IACfA,IAAqBZ,EAAYvb,EAAQkI,EAAclI,OC1BzDsc,GACXrF,GAEII,GAAkBJ,GACbsF,GAAiCtF,GAC/BM,GAAgBN,GAClBuF,GAA+BvF,GAEjC,CACLA,EAAQlK,EACRkK,EAAQzI,EACRyI,EAAQlK,EAAIkK,EAAQhK,MACpBgK,EAAQzI,EAAIyI,EAAQ9J,QA0BXsP,GAAmB3N,IAC9B,IAAK,MAAMlL,KAAOkL,EAAM4N,KACtB,GAAiB,SAAb9Y,EAAI+H,KACN,OAAO/H,EAAI+Y,IAGf,OAAO7N,EAAM4N,KAAK,GAAGC,KAGjBC,GAA8B,CAClCD,EACAE,KAEA,IAAIC,EAAkB,CAAC,EAAG,GAC1B,MAAM,KAAEC,EAAF,KAAQC,EAAR,KAAcC,EAAd,KAAoBC,GAASP,EAAInZ,QACrC,CAAC2Z,EAAD,KAA2B,IAAlB,GAAEC,EAAF,KAAMxe,GAAW,EAGxB,GAAW,SAAPwe,EAEFN,EAAWle,OAGN,GAAW,aAAPwe,EAAmB,CAI5B,MAAM3C,EAAK,CAAC7b,EAAK,GAAIA,EAAK,IACpB+b,EAAK,CAAC/b,EAAK,GAAIA,EAAK,IACpBye,EAAK,CAACze,EAAK,GAAIA,EAAK,IAEpB0e,EAAKR,EACXA,EAAWO,EAEX,MAAME,EAAW,CAACpX,EAAWqX,IAC3BhmB,KAAK2L,IAAI,EAAIgD,EAAG,GAAKkX,EAAGG,GACxB,EAAIrX,EAAI3O,KAAK2L,IAAI,EAAIgD,EAAG,GAAKwU,EAAG6C,GAChC,EAAIhmB,KAAK2L,IAAIgD,EAAG,IAAM,EAAIA,GAAKsU,EAAG+C,GAClCF,EAAGE,GAAOhmB,KAAK2L,IAAIgD,EAAG,GAExB,IAAIA,EAAI,EACR,KAAOA,GAAK,GAAK,CACf,IAAI4G,EAAIwQ,EAASpX,EAAG,GAChBqI,EAAI+O,EAASpX,EAAG,GAChB0W,KACD9P,EAAGyB,GAAKqO,EAAY9P,EAAGyB,IAG1B2O,EAAOH,KAAOxlB,KAAK2T,IAAIgS,EAAOH,KAAMxO,GACpC2O,EAAOJ,KAAOvlB,KAAK2T,IAAIgS,EAAOJ,KAAMhQ,GAEpCoQ,EAAOF,KAAOzlB,KAAK+iB,IAAI4C,EAAOF,KAAMlQ,GACpCoQ,EAAOD,KAAO1lB,KAAK+iB,IAAI4C,EAAOD,KAAM1O,GAEpCrI,GAAK,IAOT,OAAOgX,IAET,CAAEJ,KAAMf,IAAUgB,KAAMhB,IAAUiB,MAAOjB,IAAUkB,MAAOlB,MAG5D,MAAO,CAACe,EAAMC,EAAMC,EAAMC,IAGtBO,GACJpE,IAEA,IAAI0D,EAAOf,IACPgB,EAAOhB,IACPiB,GAAQjB,IACRkB,GAAQlB,IAEZ,IAAK,MAAOjP,EAAGyB,KAAM6K,EACnB0D,EAAOvlB,KAAK2T,IAAI4R,EAAMhQ,GACtBiQ,EAAOxlB,KAAK2T,IAAI6R,EAAMxO,GACtByO,EAAOzlB,KAAK+iB,IAAI0C,EAAMlQ,GACtBmQ,EAAO1lB,KAAK+iB,IAAI2C,EAAM1O,GAGxB,MAAO,CAACuO,EAAMC,EAAMC,EAAMC,IAGtBX,GACJtF,IAEA,MAAO8F,EAAMC,EAAMC,EAAMC,GAAQO,GAAoBxG,EAAQoC,QAE7D,MAAO,CACL0D,EAAO9F,EAAQlK,EACfiQ,EAAO/F,EAAQzI,EACfyO,EAAOhG,EAAQlK,EACfmQ,EAAOjG,EAAQzI,IAIbgO,GACJvF,IAEA,IAAIyG,EAEJ,GAAIzG,EAAQoC,OAAOpb,OAAS,IAAM0f,GAAmB1G,GAAU,CAE7D,MAAM,KAAE8F,EAAF,KAAQC,EAAR,KAAcC,EAAd,KAAoBC,GAASjG,EAAQoC,OAAO7V,QAChD,CAAC2Z,EAAD,KAAqB,IAAXpQ,EAAGyB,GAAO,EAOlB,OANA2O,EAAOH,KAAOxlB,KAAK2T,IAAIgS,EAAOH,KAAMxO,GACpC2O,EAAOJ,KAAOvlB,KAAK2T,IAAIgS,EAAOJ,KAAMhQ,GAEpCoQ,EAAOF,KAAOzlB,KAAK+iB,IAAI4C,EAAOF,KAAMlQ,GACpCoQ,EAAOD,KAAO1lB,KAAK+iB,IAAI4C,EAAOD,KAAM1O,GAE7B2O,IAET,CAAEJ,KAAMf,IAAUgB,KAAMhB,IAAUiB,MAAOjB,IAAUkB,MAAOlB,MAE5D0B,EAAS,CACPX,EAAO9F,EAAQlK,EACfiQ,EAAO/F,EAAQzI,EACfyO,EAAOhG,EAAQlK,EACfmQ,EAAOjG,EAAQzI,OAEZ,CACL,MAAMM,EAAQ6O,GAAmB1G,GAG3B0F,EAAMF,GAAgB3N,EAAM,KAE3BiO,EAAMC,EAAMC,EAAMC,GAAQN,GAA4BD,GAE7De,EAAS,CACPX,EAAO9F,EAAQlK,EACfiQ,EAAO/F,EAAQzI,EACfyO,EAAOhG,EAAQlK,EACfmQ,EAAOjG,EAAQzI,GAInB,OAAOkP,GAyIIE,GACX3G,IAEA,IAAI4G,EAEJ,MAAOhG,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EACvB,GAAIX,GAAkBJ,GAAU,CAC9B,MAAO8F,EAAMC,EAAMC,EAAMC,GAAQO,GAC/BxG,EAAQoC,OAAO7T,KAAI,QAAEuH,EAAGyB,GAAL,SACjBoJ,GAAO7K,EAAGyB,EAAGsP,EAAK7G,EAAQlK,EAAGgR,EAAK9G,EAAQzI,EAAGyI,EAAQgB,WAIzD,MAAO,CACL8E,EAAO9F,EAAQlK,EACfiQ,EAAO/F,EAAQzI,EACfyO,EAAOhG,EAAQlK,EACfmQ,EAAOjG,EAAQzI,GAEZ,GAAI+I,GAAgBN,GACzB4G,EAtDkC,EACpC5G,EACA6G,EACAC,KAEA,GAAI9G,EAAQoC,OAAOpb,OAAS,IAAM0f,GAAmB1G,GAAU,CAE7D,MAAM,KAAE8F,EAAF,KAAQC,EAAR,KAAcC,EAAd,KAAoBC,GAASjG,EAAQoC,OAAO7V,QAChD,CAAC2Z,EAAD,KAAqB,IAAXpQ,EAAGyB,GAAO,EAMlB,OALCzB,EAAGyB,GAAKoJ,GAAOX,EAAQlK,EAAIA,EAAGkK,EAAQzI,EAAIA,EAAGsP,EAAIC,EAAI9G,EAAQgB,OAC9DkF,EAAOH,KAAOxlB,KAAK2T,IAAIgS,EAAOH,KAAMxO,GACpC2O,EAAOJ,KAAOvlB,KAAK2T,IAAIgS,EAAOJ,KAAMhQ,GACpCoQ,EAAOF,KAAOzlB,KAAK+iB,IAAI4C,EAAOF,KAAMlQ,GACpCoQ,EAAOD,KAAO1lB,KAAK+iB,IAAI4C,EAAOD,KAAM1O,GAC7B2O,IAET,CAAEJ,KAAMf,IAAUgB,KAAMhB,IAAUiB,MAAM,IAAWC,MAAM,MAE3D,MAAO,CAACH,EAAMC,EAAMC,EAAMC,GAG5B,MAAMpO,EAAQ6O,GAAmB1G,GAG3B0F,EAAMF,GAAgB3N,EAAM,IAIlC,OAAO8N,GAA4BD,GAFf,CAAC5P,EAAWyB,IAC9BoJ,GAAOX,EAAQlK,EAAIA,EAAGkK,EAAQzI,EAAIA,EAAGsP,EAAIC,EAAI9G,EAAQgB,UA2B5C+F,CAA8B/G,EAAS6G,EAAIC,QAC/C,GAAqB,YAAjB9G,EAAQtL,KAAoB,CACrC,MAAOsS,EAAKC,GAAOtG,GAAOkG,EAAIhG,EAAIgG,EAAIC,EAAI9G,EAAQgB,QAC3CkG,EAAKC,GAAOxG,GAAOkG,EAAI9F,EAAI8F,EAAIC,EAAI9G,EAAQgB,QAC3CoG,EAAKC,GAAO1G,GAAOC,EAAIkG,EAAID,EAAIC,EAAI9G,EAAQgB,QAC3CsG,EAAKC,GAAO5G,GAAOG,EAAIgG,EAAID,EAAIC,EAAI9G,EAAQgB,OAKlD4F,EAAS,CAJIrmB,KAAK2T,IAAI8S,EAAKE,EAAKE,EAAKE,GACxB/mB,KAAK2T,IAAI+S,EAAKE,EAAKE,EAAKE,GACxBhnB,KAAK+iB,IAAI0D,EAAKE,EAAKE,EAAKE,GACxB/mB,KAAK+iB,IAAI2D,EAAKE,EAAKE,EAAKE,SAEhC,GAAqB,YAAjBvH,EAAQtL,KAAoB,CACrC,MAAMkN,GAAKd,EAAKF,GAAM,EAChB4G,GAAKzG,EAAKF,GAAM,EAChBI,EAAM1gB,KAAK0gB,IAAIjB,EAAQgB,OACvBE,EAAM3gB,KAAK2gB,IAAIlB,EAAQgB,OACvByG,EAAKlnB,KAAK2hB,MAAMN,EAAIX,EAAKuG,EAAItG,GAC7BwG,EAAKnnB,KAAK2hB,MAAMsF,EAAIvG,EAAKW,EAAIV,GACnC0F,EAAS,CAACC,EAAKY,EAAIX,EAAKY,EAAIb,EAAKY,EAAIX,EAAKY,OACrC,CACL,MAAOV,EAAKC,GAAOtG,GAAOC,EAAIC,EAAIgG,EAAIC,EAAI9G,EAAQgB,QAC3CkG,EAAKC,GAAOxG,GAAOC,EAAIG,EAAI8F,EAAIC,EAAI9G,EAAQgB,QAC3CoG,EAAKC,GAAO1G,GAAOG,EAAIC,EAAI8F,EAAIC,EAAI9G,EAAQgB,QAC3CsG,EAAKC,GAAO5G,GAAOG,EAAID,EAAIgG,EAAIC,EAAI9G,EAAQgB,OAKlD4F,EAAS,CAJIrmB,KAAK2T,IAAI8S,EAAKE,EAAKE,EAAKE,GACxB/mB,KAAK2T,IAAI+S,EAAKE,EAAKE,EAAKE,GACxBhnB,KAAK+iB,IAAI0D,EAAKE,EAAKE,EAAKE,GACxB/mB,KAAK+iB,IAAI2D,EAAKE,EAAKE,EAAKE,IAIvC,OAAOX,GAGIe,GACXC,IAEA,IAAKA,EAAS5gB,OACZ,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAI8e,EAAOf,IACPiB,GAAQjB,IACRgB,EAAOhB,IACPkB,GAAQlB,IAUZ,OARA6C,EAASC,SAAS7H,IAChB,MAAOY,EAAIC,EAAIC,EAAIC,GAAM4F,GAAiB3G,GAC1C8F,EAAOvlB,KAAK2T,IAAI4R,EAAMlF,GACtBmF,EAAOxlB,KAAK2T,IAAI6R,EAAMlF,GACtBmF,EAAOzlB,KAAK+iB,IAAI0C,EAAMlF,GACtBmF,EAAO1lB,KAAK+iB,IAAI2C,EAAMlF,MAGjB,CAAC+E,EAAMC,EAAMC,EAAMC,IAGf6B,GAAkC,CAC7C9H,EACA+H,EACAC,KAEA,IAAM1H,GAAgBN,KAAYI,GAAkBJ,GAClD,MAAO,CACLA,EAAQlK,EACRkK,EAAQzI,EACRyI,EAAQlK,EAAIiS,EACZ/H,EAAQzI,EAAIyQ,GAIhB,MAAM5F,EAASiC,GACb,EACA0D,EACA1D,GAAc,EAAG2D,EAAYhI,EAAQoC,SAGvC,IAAIwE,EAEJ,GAAIxG,GAAkBJ,GAEpB4G,EAASJ,GAAoBpE,OACxB,CAEL,MAAM6F,EAAMC,KAAMC,YACZC,EACwB,UAA5BpI,EAAQqI,gBACJJ,EAAIK,WACFlG,EACAmG,GAAqBvI,IAEvBiI,EAAIG,MACFhG,EACAmG,GAAqBvI,IAEvB0F,EAAMF,GAAgB4C,GAC5BxB,EAASjB,GAA4BD,GAGvC,MAAOI,EAAMC,EAAMC,EAAMC,GAAQW,EACjC,MAAO,CACLd,EAAO9F,EAAQlK,EACfiQ,EAAO/F,EAAQzI,EACfyO,EAAOhG,EAAQlK,EACfmQ,EAAOjG,EAAQzI,IAINiR,GAAyB,CACpCxI,EACAoC,EACAqG,KAGA,MAAMR,EAAMC,KAAMC,YACZC,EACU,UAAdK,EACIR,EAAIK,WACFlG,EACAmG,GAAqBvI,IAEvBiI,EAAIG,MAAMhG,EAA8BmG,GAAqBvI,IAC7D0F,EAAMF,GAAgB4C,IACrBtC,EAAMC,EAAMC,EAAMC,GAAQN,GAA4BD,GAC7D,MAAO,CACLI,EAAO9F,EAAQlK,EACfiQ,EAAO/F,EAAQzI,EACfyO,EAAOhG,EAAQlK,EACfmQ,EAAOjG,EAAQzI,I,aCvcnB,MAAMmR,GAAkBvN,KAElBwN,GAAwB,CAC5B3I,EACA4I,IAEA7I,GAA0BC,KACzB4I,EAAWC,WAAWC,IAAI9I,EAAQC,QAE/B8I,GAAsBC,GAAwB,CAAC,EAAG,EAAIA,GAEtDC,GAAsBD,GAAwB,CAAC,IAAK,EAAIA,GAExDE,GAAoBlJ,GACP,aAAjBA,EAAQtL,KAA4C,GAAtBsL,EAAQgJ,YAAmB,GAiGrDG,GAAwB/Y,SAASmF,cAAc,OACrD4T,GAAsBC,IAAtB,eAAoC1mB,IAAWI,IAA/C,YAAsDumB,mBAAmB,ijBAIzE,MAAMC,GAA8BlZ,SAASmF,cAAc,OAC3D+T,GAA4BF,IAA5B,eAA0C1mB,IAAWI,IAArD,YAA4DumB,mBAAmB,0hCAI/E,MA0BME,GAAsB,CAC1BvJ,EACAwJ,EACAC,EACAb,KAGA,OADAa,EAAQC,YAAc1J,EAAQ2J,QAAU,IAChC3J,EAAQtL,MACd,IAAK,YACL,IAAK,UACL,IAAK,UACH+U,EAAQG,SAAW,QACnBH,EAAQI,QAAU,QAClBL,EAAGM,KAAKpD,GAAmB1G,IAC3B,MAEF,IAAK,QACL,IAAK,OACHyJ,EAAQG,SAAW,QACnBH,EAAQI,QAAU,QAEjBnD,GAAmB1G,GAAwB6H,SAAShQ,IACnD2R,EAAGM,KAAKjS,MAEV,MAEF,IAAK,WAAY,CAEf4R,EAAQM,OACRN,EAAQO,UAAYhK,EAAQiK,YAE5B,MAAMnZ,EAutBL,SAA2BkP,GAChC,OAAOkK,GAAWC,IAAInK,GAxtBLoK,CAAkBpK,GAE/ByJ,EAAQO,UAAYhK,EAAQiK,YAC5BR,EAAQY,KAAKvZ,GAEb2Y,EAAQa,UACR,MAEF,IAAK,QAAS,CAAC,IAAD,EACZ,MAAMC,EAAMxK,GAA0BC,GAA1B,UACR4I,EAAWC,WAAWsB,IAAInK,EAAQC,eAD1B,aACR,EAA2CuK,WAC3C3Z,EACO,MAAP0Z,GAAiBA,aAAenhB,QArEb,EAC3B4W,EACAyJ,EACApH,KAEAoH,EAAQO,UAAY,UACpBP,EAAQgB,SAAS,EAAG,EAAGzK,EAAQhK,MAAOgK,EAAQ9J,QAE9C,MAAMwU,EAAwBnqB,KAAK2T,IAAI8L,EAAQhK,MAAOgK,EAAQ9J,QAExDyU,EAAOpqB,KAAK2T,IAChBwW,EACAnqB,KAAK2T,IAA4B,GAAxBwW,EAA6B,MAGxCjB,EAAQmB,UACa,UAAnB5K,EAAQ6K,OACJvB,GACAH,GACJnJ,EAAQhK,MAAQ,EAAI2U,EAAO,EAC3B3K,EAAQ9J,OAAS,EAAIyU,EAAO,EAC5BA,EACAA,IAwDIG,CAAqB9K,EAASyJ,EAASb,EAAWtQ,KAAKvP,OARvD0gB,EAAQmB,UACNL,EACA,EACA,EACAvK,EAAQhK,MACRgK,EAAQ9J,QAKZ,MAEF,QACE,IAAIiK,GAAcH,GAoChB,MAAM,IAAIlW,MAAJ,6BAAgCkW,EAAQtL,OApCpB,CAC1B,MAAMnF,EAAM4J,GAAM6G,EAAQ9U,MACpB6f,EAA0Bxb,IAAQka,EAAQ/R,OAAOsT,YACnDD,GAGF3a,SAASoF,KAAKI,YAAY6T,EAAQ/R,QAEpC+R,EAAQ/R,OAAOuT,aAAa,MAAO1b,EAAM,MAAQ,OACjDka,EAAQM,OACRN,EAAQpU,KAAOH,GAAc8K,GAC7ByJ,EAAQO,UAAYhK,EAAQiK,YAC5BR,EAAQyB,UAAYlL,EAAQkL,UAG5B,MAAMC,EAAQnL,EAAQ9U,KAAKiG,QAAQ,SAAU,MAAMH,MAAM,MACnDoa,EAAapL,EAAQ9J,OAASiV,EAAMnkB,OACpCqkB,EAAiBrL,EAAQ9J,OAAS8J,EAAQzJ,SAC1C+U,EACkB,WAAtBtL,EAAQkL,UACJlL,EAAQhK,MAAQ,EACM,UAAtBgK,EAAQkL,UACRlL,EAAQhK,MACR,EACN,IAAK,IAAIrF,EAAQ,EAAGA,EAAQwa,EAAMnkB,OAAQ2J,IACxC8Y,EAAQ8B,SACNJ,EAAMxa,GACN2a,GACC3a,EAAQ,GAAKya,EAAaC,GAG/B5B,EAAQa,UACJS,GACFtB,EAAQ/R,OAAO8T,UAOvB/B,EAAQC,YAAc,GAGlB+B,GAAyB,IAAIC,QAK7BC,GAAa,IAAID,QAKVhF,GAAsB1G,GACjC2L,GAAWxB,IAAInK,GAEJ4L,GAA6B5L,GACxC2L,GAAWE,OAAO7L,GAEPuI,GAAuB,SAClCvI,GAEa,IADb8L,EACY,wDACZ,MAAM3e,EAAmB,CACvB4e,KAAM/L,EAAQ+L,KACdC,eAC0B,WAAxBhM,EAAQiM,YACJlD,GAAmB/I,EAAQgJ,aACH,WAAxBhJ,EAAQiM,YACRhD,GAAmBjJ,EAAQgJ,kBAC3BnY,EAGNqb,mBAA4C,UAAxBlM,EAAQiM,YAG5BjD,YAC0B,UAAxBhJ,EAAQiM,YACJjM,EAAQgJ,YAAc,GACtBhJ,EAAQgJ,YAIdmD,WAAYnM,EAAQgJ,YAAc,EAClCoD,WAAkC,EAAtBpM,EAAQgJ,YACpBqD,UAAWrM,EAAQqM,UACnBC,OAAQtM,EAAQiK,YAChBsC,iBAAkBT,EAElBU,wBAAyB,GAG3B,OAAQxM,EAAQtL,MACd,IAAK,YACL,IAAK,UACL,IAAK,UASH,OARAvH,EAAQ6c,UAAYhK,EAAQgK,UAC5B7c,EAAQkd,KACsB,gBAA5BrK,EAAQyM,qBACJ5b,EACAmP,EAAQyM,gBACO,YAAjBzM,EAAQtL,OACVvH,EAAQuf,aAAe,GAElBvf,EAET,IAAK,OAQH,OAPIgV,GAAYnC,EAAQoC,UACtBjV,EAAQ6c,UAAYhK,EAAQgK,UAC5B7c,EAAQkd,KACsB,gBAA5BrK,EAAQyM,qBACJ5b,EACAmP,EAAQyM,iBAETtf,EAET,IAAK,WACL,IAAK,QACH,OAAOA,EACT,QACE,MAAM,IAAIrD,MAAJ,6BAAgCkW,EAAQtL,SAU9CiY,GAAuB,CAC3B3M,EACAmI,KAEA,IAAItQ,EAAQ8T,GAAWxB,IAAInK,IAAY,KAEvC,IAAKnI,EAAO,CAGV,OAFA4T,GAAuBI,OAAO7L,GAEtBA,EAAQtL,MACd,IAAK,YACH,GAAgC,UAA5BsL,EAAQqI,gBAA6B,CACvC,MAAMzG,EAAI5B,EAAQhK,MACZwR,EAAIxH,EAAQ9J,OACZmN,EAAqB,IAAjB9iB,KAAK2T,IAAI0N,EAAG4F,GACtB3P,EAAQsQ,EAAUrX,KAAV,YACDuS,EADC,gBACQzB,EAAIyB,EADZ,gBACqBzB,EADrB,eAC6BA,EAD7B,YACkCyB,EADlC,cACyCzB,EADzC,YAEJ4F,EAAInE,EAFA,cAGAzB,EAHA,YAGK4F,EAHL,aAGW5F,EAAIyB,EAHf,YAGoBmE,EAHpB,cAG2BnE,EAH3B,YAGgCmE,EAHhC,gBAGyCA,EAHzC,eAIJA,EAAInE,EAJA,gBAKEA,EALF,mBAKcA,EALd,MAMNkF,GAAqBvI,GAAS,SAGhCnI,EAAQsQ,EAAUyE,UAChB,EACA,EACA5M,EAAQhK,MACRgK,EAAQ9J,OACRqS,GAAqBvI,IAGzB,MACF,IAAK,UAAW,CACd,MAAO6M,EAAMC,EAAMC,EAAQC,EAAQC,EAASC,EAASC,EAAOC,GDpWnCpN,KAG/B,MAAM6M,EAAOtsB,KAAK8sB,MAAMrN,EAAQhK,MAAQ,GAAK,EAEvC+W,EAAS/M,EAAQhK,MACjBgX,EAASzsB,KAAK8sB,MAAMrN,EAAQ9J,OAAS,GAAK,EAMhD,MAAO,CAAC2W,EARK,EAQOE,EAAQC,EALZH,EACA7M,EAAQ9J,OACV,EACA8W,IC2VNM,CAAiBtN,GACnBnI,EAAQsQ,EAAUoF,QAChB,CACE,CAACV,EAAMC,GACP,CAACC,EAAQC,GACT,CAACC,EAASC,GACV,CAACC,EAAOC,IAEV7E,GAAqBvI,IAEvB,MAEF,IAAK,UACHnI,EAAQsQ,EAAUqF,QAChBxN,EAAQhK,MAAQ,EAChBgK,EAAQ9J,OAAS,EACjB8J,EAAQhK,MACRgK,EAAQ9J,OACRqS,GAAqBvI,IAEvB,MACF,IAAK,OACL,IAAK,QAAS,CACZ,MAAM7S,EAAUob,GAAqBvI,GAI/BoC,EAASpC,EAAQoC,OAAOpb,OAASgZ,EAAQoC,OAAS,CAAC,CAAC,EAAG,IAiB7D,GAXIvK,EAF4B,UAA5BmI,EAAQqI,gBACNlb,EAAQkd,KACF,CAAClC,EAAUoF,QAAQnL,EAA8BjV,IAEjD,CACNgb,EAAUG,WAAWlG,EAA8BjV,IAI/C,CAACgb,EAAUC,MAAMhG,EAA8BjV,IAIpC,UAAjB6S,EAAQtL,KAAkB,CAC5B,MAAM,eAAE+Y,EAAiB,KAAnB,aAAyBC,EAAe,SAAY1N,EAEpD2N,EAAqB,CACzB3N,EACAnI,EACAnC,EACAkY,KAEA,MAAMC,ED3PgB,EAChC7N,EACAnI,EACAnC,EACAkY,KAEA,MAAMlI,EAAMF,GAAgB3N,EAAM,IAClC,GAAI6N,EAAI1e,OAAS,EACf,OAAO,KAIT,MAAM2J,EAAqB,UAAb+E,EAAuB,EAAIgQ,EAAI1e,OAAS,EAEhDW,EAAO+d,EAAI/U,GAAOhJ,KAClBye,EAAK,CAACze,EAAK,GAAIA,EAAK,IACpB+b,EAAK,CAAC/b,EAAK,GAAIA,EAAK,IACpB6b,EAAK,CAAC7b,EAAK,GAAIA,EAAK,IAKpBmmB,EAASpI,EAAI/U,EAAQ,GAC3B,IAAI0V,EAAY,CAAC,EAAG,GACF,SAAdyH,EAAO3H,GACTE,EAAKyH,EAAOnmB,KACW,aAAdmmB,EAAO3H,KAChBE,EAAK,CAACyH,EAAOnmB,KAAK,GAAImmB,EAAOnmB,KAAK,KAIpC,MAAM2e,EAAW,CAACpX,EAAWqX,IAC3BhmB,KAAK2L,IAAI,EAAIgD,EAAG,GAAKkX,EAAGG,GACxB,EAAIrX,EAAI3O,KAAK2L,IAAI,EAAIgD,EAAG,GAAKwU,EAAG6C,GAChC,EAAIhmB,KAAK2L,IAAIgD,EAAG,IAAM,EAAIA,GAAKsU,EAAG+C,GAClCF,EAAGE,GAAOhmB,KAAK2L,IAAIgD,EAAG,IAGjB4R,EAAIC,GAAmB,UAAbrL,EAAuB2Q,EAAKD,GAMtCxF,EAAIC,GAAM,CAACyF,EAAS,GAAK,GAAIA,EAAS,GAAK,IAI5ChP,EAAW/W,KAAK2hB,MAAMpB,EAAKF,EAAIG,EAAKF,GACpCkN,GAAMjN,EAAKF,GAAMtJ,EACjB0W,GAAMjN,EAAKF,GAAMvJ,EAEjBqT,EAAO,CACXsD,MAAO,GACPC,IAAK,GACLC,IAAK,GACLC,SAAU,IACVR,GAEF,IAAI5mB,EAAS,EAEb,GAAkB,UAAd4mB,EAAuB,CAEzB,MAAO/G,EAAIC,GAAM9G,EAAQoC,OAAOpC,EAAQoC,OAAOpb,OAAS,IACjDqnB,EAAIC,GACTtO,EAAQoC,OAAOpb,OAAS,EACpBgZ,EAAQoC,OAAOpC,EAAQoC,OAAOpb,OAAS,GACvC,CAAC,EAAG,GAEVA,EAASzG,KAAK2hB,MAAM2E,EAAKwH,EAAIvH,EAAKwH,QAGlC,IAAK,IAAIlkB,EAAI,EAAGA,EAAI4V,EAAQoC,OAAOpb,OAAQoD,IAAK,CAC9C,MAAOikB,EAAIC,GAAMtO,EAAQoC,OAAOhY,EAAI,IAAM,CAAC,EAAG,IACvCyc,EAAIC,GAAM9G,EAAQoC,OAAOhY,GAChCpD,GAAUzG,KAAK2hB,MAAM2E,EAAKwH,EAAIvH,EAAKwH,GAMvC,MAAMC,EAAUhuB,KAAK2T,IAAIyW,EAAM3jB,EAAS,GAClCmd,EAAKrD,EAAKiN,EAAKQ,EACfnK,EAAKrD,EAAKiN,EAAKO,EAErB,GAAkB,QAAdX,EAEF,MAAO,CAAC9M,EAAIC,EADFxgB,KAAK2hB,MAAMkC,EAAKrD,EAAIoD,EAAKrD,GAAMd,EAAQgJ,aAInD,MAAMhI,EAAQ,CACZiN,MAAO,GACPC,IAAK,GACLE,SAAU,IACVR,IAGKY,EAAIC,GAAM9N,GAAOwD,EAAIC,EAAItD,EAAIC,GAAMC,EAAQzgB,KAAKC,GAAM,MACtDkuB,EAAIC,GAAMhO,GAAOwD,EAAIC,EAAItD,EAAIC,EAAKC,EAAQzgB,KAAKC,GAAM,KAC5D,MAAO,CAACsgB,EAAIC,EAAIyN,EAAIC,EAAIC,EAAIC,ICwJMC,CACtB5O,EACAnI,EACAnC,EACAkY,GAGF,GAAwB,OAApBC,EACF,MAAO,GAIT,GAAkB,QAAdD,EAAqB,CACvB,MAAO9X,EAAGyB,EAAG8L,GAAKwK,EAElB,MAAO,CACL1F,EAAU0G,OAAO/Y,EAAGyB,EAAG8L,EAAG,IACrBlW,EACHkd,KAAMrK,EAAQiK,YACdD,UAAW,QACXsC,OAAQ,UAKd,GAAkB,aAAdsB,EAA0B,CAC5B,MAAO9X,EAAGyB,EAAGuJ,EAAIC,EAAIyN,EAAIC,GAAMZ,EAK/B,cAFO1gB,EAAQ6e,eAER,CACL7D,EAAUoF,QACR,CACE,CAACzX,EAAGyB,GACJ,CAACuJ,EAAIC,GACL,CAACyN,EAAIC,GACL,CAAC3Y,EAAGyB,IAEN,IACKpK,EACHkd,KAAMrK,EAAQiK,YACdD,UAAW,WAOnB,MAAOlJ,EAAIC,EAAIyN,EAAIC,EAAIC,EAAIC,GAAMd,EAEjC,GAA4B,WAAxB7N,EAAQiM,YAA0B,CAEpC,MAAM6C,EAAO7F,GAAmBjJ,EAAQgJ,YAAc,GACtD7b,EAAQ6e,eAAiB,CAAC8C,EAAK,GAAIA,EAAK,GAAK,eAGtC3hB,EAAQ6e,eAEjB,MAAO,CACL7D,EAAU7S,KAAKkZ,EAAIC,EAAI3N,EAAIC,EAAI5T,GAC/Bgb,EAAU7S,KAAKoZ,EAAIC,EAAI7N,EAAIC,EAAI5T,KAInC,GAAuB,OAAnBsgB,EAAyB,CAC3B,MAAMsB,EAASpB,EACb3N,EACAnI,EACA,QACA4V,GAEF5V,EAAM9K,QAAQgiB,GAGhB,GAAqB,OAAjBrB,EAAuB,CAKzB,MAAMqB,EAASpB,EACb3N,EACAnI,EACA,MACA6V,GAEF7V,EAAM9K,QAAQgiB,IAIlB,MAEF,IAAK,WACHC,GAAsBhP,GACtBnI,EAAQ,GACR,MAEF,IAAK,OACL,IAAK,QAEHA,EAAQ,GAIZ8T,GAAWhf,IAAIqT,EAASnI,KAItBoX,GAA4B,CAChCjP,EACA4I,KAEA,MAAMtQ,EAAasQ,EAAaA,EAAWtQ,KAAOoQ,GAAgBpQ,KAC5D4W,EAAwBzD,GAAuBtB,IAAInK,GACnDmP,EACJD,GACAA,EAAsBE,aAAe9W,EAAKvP,SAC1C,OAAC6f,QAAD,IAACA,OAAD,EAACA,EAAYxK,uBAEf,IACG8Q,GACDC,GACAD,EAAsB1pB,QAAUojB,EAAWpjB,MAC3C,CACA,MAAM6pB,EAzgBoB,EAC5BrP,EACA1H,EACAsQ,KACiC,IAAD,EAChC,MAAMlR,EAAStH,SAASmF,cAAc,UAChCkU,EAAU/R,EAAO4X,WAAW,MAC5BC,EAAUrG,GAAiBlJ,GAEjC,IAAIwP,EAAgB,EAChBC,EAAgB,EAEpB,GAAInP,GAAgBN,IAAYI,GAAkBJ,GAAU,CAC1D,IAAKY,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAEhDY,EAAKrgB,KAAK8sB,MAAMzM,GAChBE,EAAKvgB,KAAKmvB,KAAK5O,GACfD,EAAKtgB,KAAK8sB,MAAMxM,GAChBE,EAAKxgB,KAAKmvB,KAAK3O,GAEfrJ,EAAO1B,MACLsB,GAASsJ,EAAIE,GAAMvd,OAAO2X,iBAAmB5C,EAAKvP,MAClDwmB,EAAUjX,EAAKvP,MAAQ,EACzB2O,EAAOxB,OACLoB,GAASuJ,EAAIE,GAAMxd,OAAO2X,iBAAmB5C,EAAKvP,MAClDwmB,EAAUjX,EAAKvP,MAAQ,EAEzBymB,EACExP,EAAQlK,EAAI8K,EACRrgB,KAAK8sB,MAAM/V,GAAS0I,EAAQlK,EAAG8K,IAC/Brd,OAAO2X,iBACP5C,EAAKvP,MACL,EAEN0mB,EACEzP,EAAQzI,EAAIsJ,EACRtgB,KAAK8sB,MAAM/V,GAAS0I,EAAQzI,EAAGsJ,IAC/Btd,OAAO2X,iBACP5C,EAAKvP,MACL,EAEN0gB,EAAQkG,UAAUH,EAAeC,QAEjC/X,EAAO1B,MACLgK,EAAQhK,MAAQzS,OAAO2X,iBAAmB5C,EAAKvP,MAC/CwmB,EAAUjX,EAAKvP,MAAQ,EACzB2O,EAAOxB,OACL8J,EAAQ9J,OAAS3S,OAAO2X,iBAAmB5C,EAAKvP,MAChDwmB,EAAUjX,EAAKvP,MAAQ,EAG3B0gB,EAAQM,OACRN,EAAQkG,UAAUJ,EAAUjX,EAAKvP,MAAOwmB,EAAUjX,EAAKvP,OACvD0gB,EAAQmG,MACNrsB,OAAO2X,iBAAmB5C,EAAKvP,MAC/BxF,OAAO2X,iBAAmB5C,EAAKvP,OAGjC,MAAMygB,EAAKtB,KAAMxQ,OAAOA,GAkBxB,MAfuB,SAArBkR,EAAWpjB,OACXua,GAA0BC,KACzB2I,GAAsB3I,EAAS4I,KAChC,UAAAA,EAAWC,WAAWsB,IAAInK,EAAQC,eAAlC,eAA2C4P,YAAantB,IAAWI,MAMnE2mB,EAAQ7Z,OAAS,kDAGnB2Z,GAAoBvJ,EAASwJ,EAAIC,EAASb,GAC1Ca,EAAQa,UAED,CACLtK,UACAtI,SACAlS,MAAOojB,EAAWpjB,MAClB4pB,WAAY9W,EAAKvP,MACjBymB,gBACAC,kBAub0BK,CAAsB9P,EAAS1H,EAAMsQ,GAI/D,OAFA6C,GAAuB9e,IAAIqT,EAASqP,GAE7BA,EAET,OAAOH,GAGHa,GAAwB,CAC5BV,EACA7F,EACAC,EACAb,KAEA,MAAM5I,EAAUqP,EAAkBrP,QAC5BuP,EAAUrG,GAAiBlJ,GACjC,IAAKY,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAG5CI,GAAkBJ,KACpBY,EAAKrgB,KAAK8sB,MAAMzM,GAChBE,EAAKvgB,KAAKmvB,KAAK5O,GACfD,EAAKtgB,KAAK8sB,MAAMxM,GAChBE,EAAKxgB,KAAKmvB,KAAK3O,IAGjB,MAAM8F,IAAOjG,EAAKE,GAAM,EAAI8H,EAAWpQ,SAAWjV,OAAO2X,iBACnD4L,IAAOjG,EAAKE,GAAM,EAAI6H,EAAWnQ,SAAWlV,OAAO2X,iBAEnD8U,EAAyBrH,GAAsB3I,EAAS4I,GAExDqH,EACJ,UAAWZ,EAAkBrP,UAAYgQ,EACrCX,EAAkBrP,QAAQ4P,MAAM,GAChC,EACAM,EACJ,UAAWb,EAAkBrP,UAAYgQ,EACrCX,EAAkBrP,QAAQ4P,MAAM,GAChC,EAENnG,EAAQM,OACRN,EAAQmG,MACL,EAAIrsB,OAAO2X,iBAAoB+U,EAC/B,EAAI1sB,OAAO2X,iBAAoBgV,GAElCzG,EAAQkG,UAAU9I,EAAKoJ,EAAcnJ,EAAKoJ,GAC1CzG,EAAQ9I,OAAOX,EAAQgB,MAAQiP,EAAeC,GAE9CzG,EAAQmB,UACNyE,EAAkB3X,SACfoJ,EAAKF,GAAM,EAAKrd,OAAO2X,iBACvBqU,EAAUF,EAAkBD,WAAcC,EAAkBD,aAC5DrO,EAAKF,GAAM,EAAKtd,OAAO2X,iBACvBqU,EAAUF,EAAkBD,WAAcC,EAAkBD,WAC/DC,EAAkB3X,OAAQ1B,MAAQqZ,EAAkBD,WACpDC,EAAkB3X,OAAQxB,OAASmZ,EAAkBD,YAEvD3F,EAAQa,WAKG6F,GAAgB,CAC3BnQ,EACAwJ,EACAC,EACA2G,EACAxH,KAEA,MAAMT,EAAYqB,EAAGrB,UACrB,OAAQnI,EAAQtL,MACd,IAAK,YACH+U,EAAQM,OACRN,EAAQkG,UACN3P,EAAQlK,EAAI8S,EAAWpQ,QACvBwH,EAAQzI,EAAIqR,EAAWnQ,SAEzBgR,EAAQO,UAAY,wBACpBP,EAAQgB,SAAS,EAAG,EAAGzK,EAAQhK,MAAOgK,EAAQ9J,QAC9CuT,EAAQa,UACR,MAEF,IAAK,WAGH,GAFAqC,GAAqB3M,EAASmI,GAE1BiI,EAAqB,CACvB,MAAMf,EAAoBJ,GACxBjP,EACA4I,GAEFmH,GAAsBV,EAAmB7F,EAAIC,EAASb,OACjD,CACL,MAAOhI,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EAAI8H,EAAWpQ,QAChCsO,GAAMjG,EAAKE,GAAM,EAAI6H,EAAWnQ,QAChC4X,GAAUvP,EAAKF,GAAM,GAAKZ,EAAQlK,EAAI8K,GACtC0P,GAAUvP,EAAKF,GAAM,GAAKb,EAAQzI,EAAIsJ,GAC5C4I,EAAQM,OACRN,EAAQkG,UAAU9I,EAAIC,GACtB2C,EAAQ9I,OAAOX,EAAQgB,OACvByI,EAAQkG,WAAWU,GAASC,GAC5B/G,GAAoBvJ,EAASwJ,EAAIC,EAASb,GAC1Ca,EAAQa,UAGV,MAEF,IAAK,YACL,IAAK,UACL,IAAK,UACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,OAEH,GADAqC,GAAqB3M,EAASmI,GAC1BiI,EAAqB,CACvB,MAAMf,EAAoBJ,GACxBjP,EACA4I,GAEFmH,GAAsBV,EAAmB7F,EAAIC,EAASb,OACjD,CACL,MAAOhI,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EAAI8H,EAAWpQ,QAChCsO,GAAMjG,EAAKE,GAAM,EAAI6H,EAAWnQ,QAChC4X,GAAUvP,EAAKF,GAAM,GAAKZ,EAAQlK,EAAI8K,GACtC0P,GAAUvP,EAAKF,GAAM,GAAKb,EAAQzI,EAAIsJ,GAC5C4I,EAAQM,OACRN,EAAQkG,UAAU9I,EAAIC,GACtB2C,EAAQ9I,OAAOX,EAAQgB,OACvByI,EAAQkG,WAAWU,GAASC,GAC5B/G,GAAoBvJ,EAASwJ,EAAIC,EAASb,GAC1Ca,EAAQa,UAEV,MAEF,QAEE,MAAM,IAAIxgB,MAAJ,6BAAgCkW,EAAQtL,SAK9C6b,GAA4B,CAChCC,EACAC,EACAC,KAEA,GAAyB,qBAAdA,EACT,OAAOF,EAAK1G,KAAK2G,GAEnB,MAAME,EAAmB,CACvBlL,KAAMgL,EAAShL,KACf5N,MAAO4Y,EAAS5Y,MAChB1K,QAAS,IAAKsjB,EAAStjB,QAASqf,wBAAyBkE,IAE3D,OAAOF,EAAK1G,KAAK6G,IAGNC,GAAqB,CAChC5Q,EACAwQ,EACAK,EACAC,EACAC,EACAC,KAEA,MAAOpQ,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAM/F,EAAKF,GAAM,GAAKZ,EAAQlK,EAAI8K,GAClCkG,GAAM/F,EAAKF,GAAM,GAAKb,EAAQzI,EAAIsJ,GAClCoQ,EAAU,IAAMjR,EAAQgB,MAASzgB,KAAKC,GACtC2nB,EAAYqI,EAAKrI,UACvB,OAAQnI,EAAQtL,MACd,IAAK,YAGH,MAAM,IAAI5K,MAAM,gDAElB,IAAK,YACL,IAAK,UACL,IAAK,UAAW,CACd6iB,GAAqB3M,EAASmI,GAC9B,MAAM+I,EAAOX,GACXC,EACA9J,GAAmB1G,GACnBna,KAEI8jB,EAAU3J,EAAQ2J,QAAU,IAClB,IAAZA,IACFuH,EAAKjG,aAAa,iBAAlB,UAAuCtB,IACvCuH,EAAKjG,aAAa,eAAlB,UAAqCtB,KAEvCuH,EAAKjG,aAAa,iBAAkB,SACpCiG,EAAKjG,aACH,YADF,oBAEe8F,GAAW,EAF1B,YAGIC,GAAW,EAHf,oBAIcC,EAJd,YAIwBpK,EAJxB,YAI8BC,EAJ9B,MAMA+J,EAAQjb,YAAYsb,GACpB,MAEF,IAAK,OACL,IAAK,QAAS,CACZvE,GAAqB3M,EAASmI,GAC9B,MAAMgJ,EAAQN,EAAQO,cAAeC,gBAAgBlrB,IAAQ,KACvDwjB,EAAU3J,EAAQ2J,QAAU,IAClCwH,EAAMlG,aAAa,iBAAkB,SAEpCvE,GAAmB1G,GAAwB6H,SAAShQ,IACnD,MAAMqZ,EAAOX,GACXC,EACA3Y,EACAhS,KAEc,IAAZ8jB,IACFuH,EAAKjG,aAAa,iBAAlB,UAAuCtB,IACvCuH,EAAKjG,aAAa,eAAlB,UAAqCtB,KAEvCuH,EAAKjG,aACH,YADF,oBAEe8F,GAAW,EAF1B,YAGIC,GAAW,EAHf,oBAIcC,EAJd,YAIwBpK,EAJxB,YAI8BC,EAJ9B,MAOmB,SAAjB9G,EAAQtL,MACRyN,GAAYnC,EAAQoC,SACQ,gBAA5BpC,EAAQyM,iBAERyE,EAAKjG,aAAa,YAAa,WAEjCkG,EAAMvb,YAAYsb,MAEpBL,EAAQjb,YAAYub,GACpB,MAEF,IAAK,WAAY,CACfnC,GAAsBhP,GACtB,MAAM2J,EAAU3J,EAAQ2J,QAAU,IAC5BuH,EAAOL,EAAQO,cAAeC,gBAAgBlrB,IAAQ,KAC5C,IAAZwjB,IACFuH,EAAKjG,aAAa,iBAAlB,UAAuCtB,IACvCuH,EAAKjG,aAAa,eAAlB,UAAqCtB,KAEvCuH,EAAKjG,aACH,YADF,oBAEe8F,GAAW,EAF1B,YAGIC,GAAW,EAHf,oBAIcC,EAJd,YAIwBpK,EAJxB,YAI8BC,EAJ9B,MAMA,MAAMhW,EAAO+f,EAAQO,cAAeC,gBAAgBlrB,IAAQ,QAC5D+qB,EAAKjG,aAAa,SAAU,QAC5BiG,EAAKjG,aAAa,OAAQjL,EAAQiK,aAClCnZ,EAAKma,aAAa,IAAKqG,GAAmBtR,IAC1CkR,EAAKtb,YAAY9E,GACjB+f,EAAQjb,YAAYsb,GACpB,MAEF,IAAK,QAAS,CACZ,MAAMK,EACJxR,GAA0BC,IAAY8Q,EAAM9Q,EAAQC,QACtD,GAAIsR,EAAU,CACZ,MAAMC,EAAQ,gBAAYD,EAASviB,IACnC,IAAIwL,EAASqW,EAAQlW,cAAR,WAA0B6W,IACvC,IAAKhX,EAAQ,CACXA,EAASqW,EAAQO,cAAeC,gBAAgBlrB,IAAQ,UACxDqU,EAAOxL,GAAKwiB,EAEZ,MAAMhH,EAAQqG,EAAQO,cAAeC,gBAAgBlrB,IAAQ,SAE7DqkB,EAAMS,aAAa,QAAS,QAC5BT,EAAMS,aAAa,SAAU,QAC7BT,EAAMS,aAAa,OAAQsG,EAASE,SAEpCjX,EAAO5E,YAAY4U,GAEnBqG,EAAQa,QAAQlX,GAGlB,MAAMmX,EAAMd,EAAQO,cAAeC,gBAAgBlrB,IAAQ,OAC3DwrB,EAAI1G,aAAa,OAAjB,WAA6BuG,IAE7BG,EAAI1G,aAAa,QAAjB,UAA6B1qB,KAAK0jB,MAAMjE,EAAQhK,SAChD2b,EAAI1G,aAAa,SAAjB,UAA8B1qB,KAAK0jB,MAAMjE,EAAQ9J,UAEjDyb,EAAI1G,aACF,YADF,oBAEe8F,GAAW,EAF1B,YAGIC,GAAW,EAHf,oBAIcC,EAJd,YAIwBpK,EAJxB,YAI8BC,EAJ9B,MAOA+J,EAAQjb,YAAY+b,GAEtB,MAEF,QACE,IAAIxR,GAAcH,GA6ChB,MAAM,IAAIlW,MAAJ,6BAAgCkW,EAAQtL,OA7CpB,CAC1B,MAAMiV,EAAU3J,EAAQ2J,QAAU,IAC5BuH,EAAOL,EAAQO,cAAeC,gBAAgBlrB,IAAQ,KAC5C,IAAZwjB,IACFuH,EAAKjG,aAAa,iBAAlB,UAAuCtB,IACvCuH,EAAKjG,aAAa,eAAlB,UAAqCtB,KAEvCuH,EAAKjG,aACH,YADF,oBAEe8F,GAAW,EAF1B,YAGIC,GAAW,EAHf,oBAIcC,EAJd,YAIwBpK,EAJxB,YAI8BC,EAJ9B,MAMA,MAAMqE,EAAQnL,EAAQ9U,KAAKiG,QAAQ,SAAU,MAAMH,MAAM,MACnDoa,EAAapL,EAAQ9J,OAASiV,EAAMnkB,OACpCqkB,EAAiBrL,EAAQ9J,OAAS8J,EAAQzJ,SAC1C+U,EACkB,WAAtBtL,EAAQkL,UACJlL,EAAQhK,MAAQ,EACM,UAAtBgK,EAAQkL,UACRlL,EAAQhK,MACR,EACA4b,EAAYzY,GAAM6G,EAAQ9U,MAAQ,MAAQ,MAC1C2mB,EACkB,WAAtB7R,EAAQkL,UACJ,SACsB,UAAtBlL,EAAQkL,WAAuC,QAAd0G,EACjC,MACA,QACN,IAAK,IAAIxnB,EAAI,EAAGA,EAAI+gB,EAAMnkB,OAAQoD,IAAK,CACrC,MAAMc,EAAO2lB,EAAQO,cAAeC,gBAAgBlrB,IAAQ,QAC5D+E,EAAK4mB,YAAc3G,EAAM/gB,GACzBc,EAAK+f,aAAa,IAAlB,UAA0BK,IAC1BpgB,EAAK+f,aAAa,IAAlB,WAA2B7gB,EAAI,GAAKghB,EAAaC,IACjDngB,EAAK+f,aAAa,cAAenW,GAAoBkL,IACrD9U,EAAK+f,aAAa,YAAlB,UAAkCjL,EAAQ7K,SAA1C,OACAjK,EAAK+f,aAAa,OAAQjL,EAAQiK,aAClC/e,EAAK+f,aAAa,cAAe4G,GACjC3mB,EAAK+f,aAAa,QAAS,qBAC3B/f,EAAK+f,aAAa,YAAa2G,GAC/BV,EAAKtb,YAAY1K,GAEnB2lB,EAAQjb,YAAYsb,MASfhH,GAAa,IAAIwB,QAA2C,IAElE,SAASsD,GAAsBhP,GACpC,MAAM+R,EAAcT,GAAmBtR,GACjClP,EAAO,IAAIkhB,OAAOD,GAExB,OADA7H,GAAWvd,IAAIqT,EAASlP,GACjBA,EAOF,SAASwgB,GAAmBtR,GAEjC,MAAMiS,EAAcjS,EAAQkS,iBACxBlS,EAAQoC,OACRpC,EAAQoC,OAAOpb,OACfgZ,EAAQoC,OAAO7T,KAAI,CAAC,EAAQnE,KAAT,IAAE0L,EAAGyB,GAAL,QAAe,CAACzB,EAAGyB,EAAGyI,EAAQmS,UAAU/nB,OAC3D,CAAC,CAAC,EAAG,EAAG,KAGN+C,EAAyB,CAC7B+kB,iBAAkBlS,EAAQkS,iBAC1BvH,KAA4B,KAAtB3K,EAAQgJ,YACdoJ,SAAU,GACVC,UAAW,GACXC,WAAY,GACZC,OAASrjB,GAAM3O,KAAK2gB,IAAKhS,EAAI3O,KAAKC,GAAM,GACxC+hB,OAAQvC,EAAQwS,oBAGlB,OAYF,SAA8BpQ,GAC5B,IAAKA,EAAOpb,OACV,MAAO,GAGT,MAAMsc,EAAMlB,EAAOpb,OAAS,EAE5B,OAAOob,EACJ7V,QACC,CAACC,EAAK4U,EAAOhX,EAAG9D,KACV8D,IAAMkZ,EACR9W,EAAIO,KAAKqU,EAAOqR,GAAIrR,EAAO9a,EAAI,IAAK,IAAKA,EAAI,GAAI,KAEjDkG,EAAIO,KAAKqU,EAAOqR,GAAIrR,EAAO9a,EAAI8D,EAAI,KAE9BoC,IAET,CAAC,IAAK4V,EAAO,GAAI,MAElBrM,KAAK,KACL5E,QAAQuhB,GAAoB,MAhCxBC,CAAqBC,aAAUX,EAA2B9kB,IAGnE,SAASslB,GAAII,EAAaC,GACxB,MAAO,EAAED,EAAE,GAAKC,EAAE,IAAM,GAAID,EAAE,GAAKC,EAAE,IAAM,GAM7C,MAAMJ,GAAqB,mDC77B3B,MAAMK,GAAWC,GACW,kBAAfA,EAMb,MAAMC,GAAO,cAAD,KA2BFC,UAAqC,IAAIC,IA3BvC,KA6BFC,mBAA6D,GA7B3D,KA8BFxL,SAAyC,GA9BvC,KA+BFyL,YAAc,IAAIhY,IAvBF,yBAAC2X,EAAwBM,GAC3CP,GAAQC,GACVO,KAAKC,aAAa7mB,IAAIqmB,EAAYM,GAElCC,KAAKE,kBAAkB9mB,IAAIqmB,EAAYM,GAI5B,gBAACN,GACd,OAAID,GAAQC,GACHO,KAAKC,aAAarJ,IAAI6I,IAAe,KAEvCO,KAAKE,kBAAkBtJ,IAAI6I,IAAe,KAcnDU,8BACE,OAAOH,KAAK3L,SAId+L,cACE,OAAOJ,KAAKH,mBAGdQ,WAAW5kB,GACT,OAAOukB,KAAKF,YAAYlJ,IAAInb,IAAO,KAGrC6kB,qBACE7kB,GAEA,MAAMgR,EAAUuT,KAAKK,WAAW5kB,GAChC,OAAIgR,GAAW8T,GAAoB9T,GAC1BA,EAEF,KAIT+T,sBACEhlB,GAEA,MAAMlF,EAA0C,GAOhD,OANAkF,EAAI8Y,SAAS7Y,IACX,MAAMgR,EAAUuT,KAAKM,qBAAqB7kB,GAC3B,MAAXgR,GACFnW,EAAOkD,KAAKiT,MAGTnW,EAGTmqB,mBAAmBC,GACjBV,KAAK3L,SAAWqM,EAChBV,KAAKF,YAAYa,QACjBD,EAAapM,SAAS7H,IACpBuT,KAAKF,YAAY1mB,IAAIqT,EAAQhR,GAAIgR,GACjCiT,GAAMkB,kBAAkBnU,EAASuT,SAEnCA,KAAKH,mBAAqBW,GAAsBR,KAAK3L,UACrD2L,KAAKa,iBAGPA,iBACE,IAAK,MAAMC,KAAYC,MAAMC,KAAKhB,KAAKL,WACrCmB,IAIJG,YAAYC,GACV,GAAIlB,KAAKL,UAAUpK,IAAI2L,GACrB,MAAM,IAAI3qB,MAKZ,OAFAypB,KAAKL,UAAUwB,IAAID,GAEZ,KACL,IAAKlB,KAAKL,UAAUpK,IAAI2L,GACtB,MAAM,IAAI3qB,MAEZypB,KAAKL,UAAUrH,OAAO4I,IAI1BE,UACE1B,GAAMO,aAAa3L,SAAQ,CAACyL,EAAON,KAC7BM,IAAUC,MACZN,GAAMO,aAAa3H,OAAOmH,MAK9BO,KAAKL,UAAUgB,SA/GbjB,GAKWQ,kBAAoB,IAAI/H,QALnCuH,GAMWO,aAAe,IAAInY,IA6GrB4X,U,SCrIf,IAAI2B,GAAS,IAAIC,KAAOrhB,KAAKshB,OAGtB,MAAMC,GAAgB,IAAMx0B,KAAK8sB,MAAMuH,GAAO5R,OAAS,GAAK,IAOtDgS,GAAW,IACkCC,eCE7CC,GAAgB,SAC3BlV,EACAmV,GAEc,IADdf,IACa,yDACTgB,GAAY,EAIhB,MAAM,OAAEhT,EAAF,OAAUnC,GAAWkV,EAEL,qBAAX/S,IACT+S,EAAU,IAAKjR,GAAkB9B,MAAY+S,IAG/C,IAAK,MAAMvuB,KAAOuuB,EAAS,CACzB,MAAMpsB,EAASosB,EAAgBvuB,GAC/B,GAAqB,qBAAVmC,EAAuB,CAChC,GACGiX,EAAgBpZ,KAASmC,IAGR,kBAAVA,GACI,OAAVA,GACQ,aAARnC,GACQ,UAARA,GAEF,SAGF,GAAY,UAARA,EAAiB,CACnB,MAAMyuB,EAAarV,EAAgBpZ,GAC7B0uB,EAAYvsB,EAClB,GAAIssB,EAAU,KAAOC,EAAU,IAAMD,EAAU,KAAOC,EAAU,GAC9D,cAEG,GAAY,WAAR1uB,EAAkB,CAC3B,MAAM4d,EAAcxE,EAAgBpZ,GAC9B2uB,EAAaxsB,EACnB,GAAIyb,EAAWxd,SAAWuuB,EAAWvuB,OAAQ,CAC3C,IAAIwuB,GAAkB,EAClB7kB,EAAQ6T,EAAWxd,OACvB,OAAS2J,GAAO,CACd,MAAMsU,EAAmBT,EAAW7T,GAC9B8kB,EAAmBF,EAAW5kB,GACpC,GACEsU,EAAU,KAAOwQ,EAAU,IAC3BxQ,EAAU,KAAOwQ,EAAU,GAC3B,CACAD,GAAkB,EAClB,OAGJ,IAAKA,EACH,UAKLxV,EAAgBpZ,GAAOmC,EACxBqsB,GAAY,GAGhB,IAAKA,EACH,OAAOpV,EAeY,IAAD,GAXQ,qBAAnBmV,EAAQjf,QACU,qBAAlBif,EAAQnf,OACE,oBAAViK,GACW,qBAAXmC,GAEPwJ,GAA0B5L,GAG5BA,EAAQzU,UACRyU,EAAQ0V,aAAeX,KAEnBX,KACF,UAAAnB,GAAM0C,SAAS3V,UAAf,SAAyBoU,kBAG3B,OAAOpU,GAGI4V,GAAiB,CAC5B5V,EACAmV,KAEA,IAAIC,GAAY,EAChB,IAAK,MAAMxuB,KAAOuuB,EAAS,CACzB,MAAMpsB,EAASosB,EAAgBvuB,GAC/B,GAAqB,qBAAVmC,EAAuB,CAChC,GACGiX,EAAgBpZ,KAASmC,IAER,kBAAVA,GAAgC,OAAVA,GAE9B,SAEFqsB,GAAY,GAIhB,OAAKA,EAIE,IACFpV,KACAmV,EACH5pB,QAASyU,EAAQzU,QAAU,EAC3BmqB,aAAcX,MAPP/U,GAgBE6V,GAAc,CACzB7V,EACAzU,KAEAyU,EAAQzU,SAAU,OAACA,QAAD,IAACA,IAAWyU,EAAQzU,SAAW,EACjDyU,EAAQ0V,aAAeX,KAChB/U,GC3II8V,GACX9V,GAEIM,GAAgBN,IAAYI,GAAkBJ,GACzCA,EAAQoC,OAAOpb,OAAS,EAER,IAAlBgZ,EAAQhK,OAAkC,IAAnBgK,EAAQ9J,OAM3B6f,GAAwB,CACnCpZ,EACA3G,EACAE,KAEA,MAAM8f,EAAWz1B,KAAKiX,IAAIxB,GACpBigB,EAAY11B,KAAKiX,IAAItB,GAE3B,GACkB,SAAhByG,GACgB,UAAhBA,GACgB,aAAhBA,EACA,CACA,MAAMuZ,EACJ31B,KAAK0jB,MAAM1jB,KAAK41B,KAAKF,EAAYD,GAAY11B,KAC7CA,IACkB,IAAhB41B,EACFhgB,EAAS,EACAggB,IAAgB31B,KAAKC,GAAK,EACnCwV,EAAQ,EAERE,EACE3V,KAAK0jB,MAAM+R,EAAWz1B,KAAK61B,IAAIF,IAAgB31B,KAAK81B,KAAKngB,IACzDA,MAEqB,cAAhByG,IACTzG,EAAS8f,EAAWz1B,KAAK81B,KAAKngB,IAEhC,MAAO,CAAEF,QAAOE,WAsCLogB,GACXtW,IAOA,MAAMjJ,EAAM,CACVf,MAAOgK,EAAQhK,MACfE,OAAQ8J,EAAQ9J,OAChBJ,EAAGkK,EAAQlK,EACXyB,EAAGyI,EAAQzI,GAGb,GAAIyI,EAAQhK,MAAQ,EAAG,CACrB,MAAM+R,EAAYxnB,KAAKiX,IAAIwI,EAAQhK,OACnCe,EAAIf,MAAQ+R,EACZhR,EAAIjB,EAAIkK,EAAQlK,EAAIiS,EAGtB,GAAI/H,EAAQ9J,OAAS,EAAG,CACtB,MAAM8R,EAAaznB,KAAKiX,IAAIwI,EAAQ9J,QACpCa,EAAIb,OAAS8R,EACbjR,EAAIQ,EAAIyI,EAAQzI,EAAIyQ,EAGtB,OAAOjR,GC1GIwf,GAAc,CACzBC,EACAtX,EACA0I,KAEA,MAAM6O,EAAkB7O,EAAShY,QAAQoQ,GACvCA,EAAQ0W,SAASzb,SAASub,KAG5B,OAAIC,EAAgBzvB,OAAS,EAEzBkY,EAAShB,iBAAiBsY,IAC1BtX,EAAS1C,iBAAmBga,EAErB,IACFtX,EACHhB,iBAAkB,IAAKgB,EAAShB,iBAAkB,CAACsY,IAAU,GAC7Dha,eAAgB,MAGb0C,EAGF,IACFA,EACHhB,iBAAkB,IAAKgB,EAAShB,iBAAkB,CAACsY,IAAU,GAC7DvY,mBAAoB,IACfiB,EAASjB,sBACT7O,OAAOunB,YACRF,EAAgBloB,KAAKyR,GAAY,CAACA,EAAQhR,IAAI,SAUzC4nB,GAAqB,CAChC1X,EACAc,IACoD,MAAjD6W,GAA2B3X,EAAUc,GAE7B6W,GAA6B,CACxC3X,EACAc,IAEAA,EAAQ0W,SACL9mB,QAAQ4mB,GAAYA,IAAYtX,EAAS1C,iBACzCsa,MAAMN,GAAYtX,EAAShB,iBAAiBsY,KAEpCO,GAAuB7X,GAClC9P,OAAO6F,QAAQiK,EAAShB,kBACrBtO,QAAO,QAAE4mB,EAASQ,GAAX,SAA2BA,KAClCzoB,KAAI,QAAEioB,EAASQ,GAAX,SAA2BR,KAMvBS,GAAkC,CAC7C/X,EACA0I,KAEA,IAAIsP,EAAyB,IAAKhY,EAAUhB,iBAAkB,IAE9D,MAAMiZ,EAAmBC,GAAoBxP,EAAU1I,GAEvD,IAAKiY,EAAiBnwB,OACpB,MAAO,IAAKkwB,EAAc1a,eAAgB,MAG5C,IAAK,MAAM6a,KAAmBF,EAAkB,CAC9C,IAAIT,EAAWW,EAAgBX,SAC/B,GAAIxX,EAAS1C,eAAgB,CAE3B,MAAM8a,EAAsBZ,EAASa,QAAQrY,EAAS1C,gBAClD8a,GAAuB,IACzBZ,EAAWA,EAAS1pB,MAAM,EAAGsqB,IAGjC,GAAIZ,EAAS1vB,OAAS,EAAG,CACvB,MAAMwvB,EAAUE,EAASA,EAAS1vB,OAAS,GAC3CkwB,EAAeX,GAAYC,EAASU,EAActP,IAItD,OAAOsP,GAiBIM,GAAmB,CAACxX,EAA4BwW,IAC3DxW,EAAQ0W,SAASzb,SAASub,GAEfiB,GAAqB,CAChC7P,EACA4O,IACG5O,EAAShY,QAAQoQ,GAAYwX,GAAiBxX,EAASwW,KAyB/CkB,GAAa,CACxBC,EACAC,EACApb,KAGA,MAAMka,EAAW,IAAIiB,GACfE,EAA2Brb,EAC7Bka,EAASa,QAAQ/a,IAChB,EACCsb,EACJD,GAA4B,EAAIA,EAA2BnB,EAAS1vB,OAEtE,OADA0vB,EAASqB,OAAOD,EAAkB,EAAGF,GAC9BlB,GCtHHsB,GAAkB,CACtBtjB,EADsB,iBAEtB,EACEoB,EADF,EAEEyB,EAFF,YAGE0S,EAHF,gBAIEwC,EAJF,UAKEzC,EALF,YAMEhB,EANF,YAOEiD,EAPF,UAQEI,EARF,QASE1C,EATF,MAUE3T,EAAQ,EAVV,OAWEE,EAAS,EAXX,MAYE8K,EAAQ,EAZV,SAaE0V,EAAW,GAbb,gBAcErO,EAdF,gBAeE4P,EAAkB,QACfC,GAlBiB,QAoBlB,CACJlpB,GAAIkpB,EAAKlpB,IAAMgmB,KACftgB,OACAoB,IACAyB,IACAvB,QACAE,SACA8K,QACAiJ,cACAwC,kBACAzC,YACAhB,cACAiD,cACAI,YACA1C,UACA+M,WACArO,kBACA0D,KAAI,UAAEmM,EAAKnM,YAAP,QAAegJ,KACnBxpB,QAAS2sB,EAAK3sB,SAAW,EACzBmqB,aAAY,UAAEwC,EAAKxC,oBAAP,QAAuB,EACnCyC,WAAW,EACXF,oBAGWG,GACXC,GAIAL,GAA0CK,EAAK3jB,KAAM2jB,GAGjDC,GAAgC,CACpCD,EAIAE,KAKO,CACLziB,EACqB,WAAnBuiB,EAAKnN,UACDqN,EAAQviB,MAAQ,EACG,UAAnBqiB,EAAKnN,UACLqN,EAAQviB,MACR,EACNuB,EAA0B,WAAvB8gB,EAAKG,cAA6BD,EAAQriB,OAAS,EAAI,IAIjDuiB,GACXJ,IAQA,MAAME,EAAUnjB,GAAYijB,EAAKntB,KAAMgK,GAAcmjB,IAC/CK,EAAUJ,GAA8BD,EAAME,GAiBpD,OAhBoB3C,GAClB,IACKoC,GAAuC,OAAQK,GAClDntB,KAAMmtB,EAAKntB,KACXiK,SAAUkjB,EAAKljB,SACfJ,WAAYsjB,EAAKtjB,WACjBmW,UAAWmN,EAAKnN,UAChBsN,cAAeH,EAAKG,cACpB1iB,EAAGuiB,EAAKviB,EAAI4iB,EAAQ5iB,EACpByB,EAAG8gB,EAAK9gB,EAAImhB,EAAQnhB,EACpBvB,MAAOuiB,EAAQviB,MACfE,OAAQqiB,EAAQriB,OAChBK,SAAUgiB,EAAQhiB,UAEpB,KAKEoiB,GAAwB,CAC5B3Y,EACA4Y,KAQA,MACE5iB,MAAO+R,EACP7R,OAAQ8R,EACRzR,SAAUsiB,GACRzjB,GAAYwjB,EAAU1jB,GAAc8K,KAClC,UAAEkL,EAAF,cAAasN,GAAkBxY,EAErC,IAAIlK,EACAyB,EAEJ,GAAkB,WAAd2T,GAA4C,WAAlBsN,EAA4B,CACxD,MAAMM,EAAc1jB,GAAY4K,EAAQ9U,KAAMgK,GAAc8K,IACtD0Y,EAAUJ,GAA8BtY,EAAS,CACrDhK,MAAO+R,EAAY+Q,EAAY9iB,MAC/BE,OAAQ8R,EAAa8Q,EAAY5iB,SAGnCJ,EAAIkK,EAAQlK,EAAI4iB,EAAQ5iB,EACxByB,EAAIyI,EAAQzI,EAAImhB,EAAQnhB,MACnB,CACL,MAAOqJ,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,IAE3C+Y,EAAQC,EAAQC,EAAQC,GAAUpR,GACvC9H,EACA+H,EACAC,GAEIxG,GAAWZ,EAAKmY,GAAU,EAC1BtX,GAAWZ,EAAKmY,GAAU,EAC1BtX,GAAWZ,EAAKmY,GAAU,EAC1BtX,GAAWZ,EAAKmY,GAAU,GAE/BpjB,EAAGyB,GAAK+J,GACP,CACEQ,GAAG,EACHjT,EAAiB,WAAdqc,GAAwC,SAAdA,EAC7BtJ,EAAiB,WAAdsJ,GAAwC,UAAdA,GAE/BlL,EAAQlK,EACRkK,EAAQzI,EACRyI,EAAQgB,MACRQ,EACAC,EACAC,EACAC,GAIJ,MAAO,CACL3L,MAAO+R,EACP7R,OAAQ8R,EACRlS,EAAG6M,OAAOwW,SAASrjB,GAAKA,EAAIkK,EAAQlK,EACpCyB,EAAGoL,OAAOwW,SAAS5hB,GAAKA,EAAIyI,EAAQzI,EACpChB,SAAUsiB,IAIDO,GAAoB,CAC/BpZ,EAD+B,KAGJ,IAD3B,KAAE9U,EAAF,UAAQitB,GACkB,EAC1B,OAAOvC,GAAe5V,EAAS,CAC7B9U,OACAitB,UAAS,OAAEA,QAAF,IAAEA,IAAanY,EAAQmY,aAC7BQ,GAAsB3Y,EAAS9U,MAoBzBmuB,GACXhB,IAOO,IACFL,GAAyCK,EAAK3jB,KAAM2jB,GACvDjW,OAAQiW,EAAKjW,QAAU,GACvBoQ,mBAAoB,KACpB8G,aAAc,KACdC,WAAY,KACZ9L,eAAgB4K,EAAK5K,eACrBC,aAAc2K,EAAK3K,eAwBV8L,GAAkB,SAACjW,GAAiC,IAAvBkW,EAAsB,uDAAN,EACxD,GAAW,MAAPlW,GAA8B,kBAARA,EACxB,OAAOA,EAGT,GAA4C,oBAAxCnU,OAAOsqB,UAAUC,SAASC,KAAKrW,GAA4B,CAC7D,MAAMsW,EACuB,oBAApBtW,EAAIuW,YACP1qB,OAAO2qB,OAAO3qB,OAAO4qB,eAAezW,IACpC,GACN,IAAK,MAAM3c,KAAO2c,EAChB,GAAIA,EAAI0W,eAAerzB,GAAM,CAE3B,GAAc,IAAV6yB,IAAwB,UAAR7yB,GAA2B,WAARA,GACrC,SAEFizB,EAAIjzB,GAAO4yB,GAAgBjW,EAAI3c,GAAM6yB,EAAQ,GAGjD,OAAOI,EAGT,GAAIvF,MAAM4F,QAAQ3W,GAAM,CACtB,IAAIrc,EAAIqc,EAAIvc,OACZ,MAAMV,EAAM,IAAIguB,MAAMptB,GACtB,KAAOA,KACLZ,EAAIY,GAAKsyB,GAAgBjW,EAAIrc,GAAIuyB,EAAQ,GAE3C,OAAOnzB,EAGT,OAAOid,GAiBI4W,GAAmB,CAC9B3d,EACA4d,EACApa,EACAqa,KAEA,IAAIC,EAAiBd,GAAgBxZ,GA4BrC,OAhBEsa,EAAKtrB,GAAKgmB,KAEZsF,EAAKvO,KAAOgJ,KACZuF,EAAK5D,SD1NqC,EAC1CA,EACAla,EACA+d,KAEA,MAAMD,EAAO,IAAI5D,GACXmB,EAA2Brb,EAC7Bka,EAASa,QAAQ/a,IAChB,EACCge,EACJ3C,GAA4B,EAAIA,EAA2BnB,EAAS1vB,OACtE,IAAK,IAAI2J,EAAQ,EAAGA,EAAQ6pB,EAAU7pB,IACpC2pB,EAAK3pB,GAAS4pB,EAAOD,EAAK3pB,IAG5B,OAAO2pB,GC2MSG,CACdH,EAAK5D,SACLla,GACCga,IACM4D,EAAuBtR,IAAI0N,IAC9B4D,EAAuBztB,IAAI6pB,EAASxB,MAE/BoF,EAAuBjQ,IAAIqM,MAGlC6D,IACFC,EAAOlrB,OAAOsrB,OAAOJ,EAAMD,IAEtBC,GCzUHK,GAAuD,CAC3DC,MAAO,EACPC,IAAK,GACLC,MAAO,IAKIC,GAAmC,CAC9ClsB,GAAG,EACHiT,GAAG,EACHD,GAAG,EACHD,GAAG,GAGCoZ,GAA8B,CAClCnsB,GAAG,EACHiT,GAAG,EACHD,GAAG,EACHD,GAAG,GAGCqZ,GAA4B,CAChCpsB,GAAG,EACHiT,GAAG,EACHD,GAAG,EACHD,GAAG,EACHsZ,IAAI,EACJC,IAAI,GAGAC,GAAgC,CACpCvsB,GAAG,EACHiT,GAAG,EACHD,GAAG,EACHD,GAAG,EACHyZ,IAAI,EACJC,IAAI,GAGAC,GAA0B,CAC9BzlB,EACAyB,EACAvB,EACAE,EACA2Q,EACAC,EACA9F,KAEA,MAAOwa,EAAIC,GAAM9a,GAAO7K,EAAIE,EAAQ,EAAGuB,EAAIrB,EAAS,EAAG2Q,EAAIC,EAAI9F,GAC/D,MAAO,CAACwa,EAAKxlB,EAAQ,EAAGylB,EAAKvlB,EAAS,EAAGF,EAAOE,IAGrCwlB,GAAgC,WAE3C1a,EACA1I,EACAqjB,GAEsB,IALrB/a,EAAIC,EAAIC,EAAIC,GAKQ,EADrB6a,EACqB,uDADiC,GAEtD,MAAMjR,EAAOgQ,GAAqBgB,GAC5BE,EAAclR,EAAOrS,EAAKvP,MAC1B+yB,EAAenR,EAAOrS,EAAKvP,MAE3BgzB,EAAgBpR,EAAOrS,EAAKvP,MAC5BizB,EAAgBrR,EAAOrS,EAAKvP,MAE5BiN,EAAQ8K,EAAKF,EACb1K,EAAS6K,EAAKF,EACdgG,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EAEjBkb,EAAmB,EAAI3jB,EAAKvP,MAE5BmzB,GAAmBvR,EAAO,IAAM,EAAIrS,EAAKvP,OAEzCozB,EAAqC,CACzCjB,GAAIU,EAAUV,QACVrqB,EACA0qB,GACE3a,EAAKqb,EAAmBF,EAAgBG,EACxCrb,EAAKob,EAAmBD,EAAgBE,EACxCL,EACAC,EACAjV,EACAC,EACA9F,GAENqa,GAAIO,EAAUP,QACVxqB,EACA0qB,GACEza,EAAKmb,EAAmBC,EACxBrb,EAAKob,EAAmBD,EAAgBE,EACxCL,EACAC,EACAjV,EACAC,EACA9F,GAENsa,GAAIM,EAAUN,QACVzqB,EACA0qB,GACE3a,EAAKqb,EAAmBF,EAAgBG,EACxCnb,EAAKkb,EAAmBC,EACxBL,EACAC,EACAjV,EACAC,EACA9F,GAENma,GAAIS,EAAUT,QACVtqB,EACA0qB,GACEza,EAAKmb,EAAmBC,EACxBnb,EAAKkb,EAAmBC,EACxBL,EACAC,EACAjV,EACAC,EACA9F,GAENob,SAAUR,EAAUQ,cAChBvrB,EACA0qB,GACE3a,EAAK5K,EAAQ,EAAI6lB,EAAc,EAC/Bhb,EACEob,EACAD,EACAE,EA1HuB,GA2HM5jB,EAAKvP,MACpC8yB,EACAC,EACAjV,EACAC,EACA9F,IAMFqb,EACH,EAAI1B,GAAqBC,MAAStiB,EAAKvP,MAkD1C,OAjDIxI,KAAKiX,IAAIxB,GAASqmB,IACfT,EAAU/Z,IACbsa,EAAiBta,EAAI0Z,GACnB3a,EAAK5K,EAAQ,EAAI6lB,EAAc,EAC/Bhb,EAAKob,EAAmBD,EAAgBE,EACxCL,EACAC,EACAjV,EACAC,EACA9F,IAGC4a,EAAU9Z,IACbqa,EAAiBra,EAAIyZ,GACnB3a,EAAK5K,EAAQ,EAAI6lB,EAAc,EAC/B9a,EAAKkb,EAAmBC,EACxBL,EACAC,EACAjV,EACAC,EACA9F,KAIFzgB,KAAKiX,IAAItB,GAAUmmB,IAChBT,EAAUha,IACbua,EAAiBva,EAAI2Z,GACnB3a,EAAKqb,EAAmBF,EAAgBG,EACxCrb,EAAK3K,EAAS,EAAI4lB,EAAe,EACjCD,EACAC,EACAjV,EACAC,EACA9F,IAGC4a,EAAU/sB,IACbstB,EAAiBttB,EAAI0sB,GACnBza,EAAKmb,EAAmBC,EACxBrb,EAAK3K,EAAS,EAAI4lB,EAAe,EACjCD,EACAC,EACAjV,EACAC,EACA9F,KAKCmb,GAGIG,GAAsB,SACjCtc,EACA1H,GAEsB,IADtBqjB,EACqB,uDADM,QAEvBC,EAAsD,GAC1D,GACmB,UAAjB5b,EAAQtL,MACS,SAAjBsL,EAAQtL,MACS,aAAjBsL,EAAQtL,MAER,GAA8B,IAA1BsL,EAAQoC,OAAOpb,OAAc,CAE/B,MAAO,CAAEwc,GAAMxD,EAAQoC,OACT,IAAVoB,EAAG,IAAsB,IAAVA,EAAG,GACpBoY,EAAYR,GACH5X,EAAG,GAAK,GAAKA,EAAG,GAAK,EAC9BoY,EAAYX,GACHzX,EAAG,GAAK,GAAKA,EAAG,GAAK,EAC9BoY,EAAYR,GACH5X,EAAG,GAAK,GAAKA,EAAG,GAAK,EAC9BoY,EAAYX,GACHzX,EAAG,GAAK,GAAKA,EAAG,GAAK,IAC9BoY,EAAYR,SAGU,SAAjBpb,EAAQtL,OACjBknB,EAAYZ,IAGd,OAAOU,GACLrW,GAAyBrF,GACzBA,EAAQgB,MACR1I,EACAqjB,EACAC,ICrOSxa,GAAQ,CAACtL,EAAWyB,IAAqB,CAAC,EAAG,EAAG,EAAG,EAAGA,EAAGzB,EAAG,EAAG,GAqC/DymB,GAAU,WAAoD,IAAnDxzB,EAAkD,uDAAlC,EAAG4H,EAA+B,uDAAf,EACzD,MAAM9G,EAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACrC,GAAI8G,EAAQ,GAAKA,EAAQ,EACvB,MAAM,IAAI7G,MAAJ,gDAAsD6G,EAAtD,MAKR,OAHc,IAAV5H,IACFc,EAAO8G,GAAS5H,GAEXc,GAkBI2yB,GAAWD,GAA8B,CACpDA,EAAQ,GACRA,EAAQ,GACRA,EAAQ,GACRA,EAAQ,IACPA,EAAQ,IACRA,EAAQ,IACRA,EAAQ,IACRA,EAAQ,IAwCE7H,GAAM,CAAC+H,EAAYC,IAC1BC,GAASD,GACJ,CAACD,EAAE,GAAKC,EAAGD,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAEnD,CACLA,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,IAKAE,GAAM,CAACH,EAAYC,IAC1BC,GAASD,GACJ,CAACD,EAAE,GAAKC,EAAGD,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAEnD,CACLA,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,IAKAG,GAAM,CAACJ,EAAYC,IAC1BC,GAASD,GACJ,CACLD,EAAE,GAAKC,EACPD,EAAE,GAAKC,EACPD,EAAE,GAAKC,EACPD,EAAE,GAAKC,EACPD,EAAE,GAAKC,EACPD,EAAE,GAAKC,EACPD,EAAE,GAAKC,EACPD,EAAE,GAAKC,GAGJ,CACLI,GAAUL,EAAGC,GACbA,EAAE,GAAKD,EAAE,GACPC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACXC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GACPC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACXC,EAAE,GAAKD,EAAE,GACPC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACXC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GACPC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,IAIFK,GAAY,CAACL,EAAYC,IACpCA,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAGxCM,GAAO,CAACN,EAAYC,IAAwB,CACvDA,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACvBC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACvBC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACvBC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GACPC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,IAIA1mB,GAAO,CAAC0mB,EAAYC,IAAwB,CACvDM,GAAWP,EAAGC,GACdD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GACnDD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GACnDD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GACnDD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GACvBD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GACvBD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GACvBD,EAAE,GAAKC,EAAE,IAGEM,GAAa,CAACP,EAAYC,IACrCD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GACTD,EAAE,GAAKC,EAAE,GAGEvO,GAAM,CAACsO,EAAYC,IAAwB,CACtDA,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GACPC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACTC,EAAE,GAAKD,EAAE,GACXC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACnDC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACvBC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,IAGZQ,GAAQR,GACnBl8B,KAAK28B,KAAK38B,KAAKiX,IAAIilB,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,KAE3DU,GAASV,GACpBl8B,KAAK28B,KAAK38B,KAAKiX,IAAIilB,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,KAE3DW,GAAcX,IACzB,MAAM5a,EAAIob,GAAKR,GACf,GAAU,IAAN5a,GAAiB,IAANA,EACb,OAAO4a,EAET,MAAMpG,EAAOoG,EAAE,GAAK,GAAK,EAAI,EAC7B,OAAOI,GAAIJ,EAAGpG,EAAOxU,IAGVwb,GAAeZ,IAC1B,MAAM5a,EAAIsb,GAAMV,GAChB,OAAU,IAAN5a,GAAiB,IAANA,EACN4a,EAEFI,GAAIJ,EAAG,EAAI5a,IAGd8a,GAAYF,GAAqC,kBAANA,EC9RpCnW,IDgSciW,GAAQ,EAAG,GACXA,GAAQ,EAAG,GACXA,GAAQ,EAAG,GACVA,GAAQ,EAAG,GACXA,GAAQ,EAAG,GACXA,GAAQ,EAAG,GACVA,GAAQ,EAAG,GCtShB,CAACE,EAAWC,EAAWY,IAC7CC,GAAc,CAAC,EAAGD,EAAGb,EAAGC,EAAG,EAAG,EAAG,EAAG,KAEzBc,GAAU,CAACjJ,EAAa1oB,IACnC0xB,GAAcA,GAAQ1xB,EAAI0oB,IAEfkJ,GAAa,CAACnoB,EAAY8L,IACrCmc,GAAOjoB,EAAM8L,GCxBFmT,GAAO,QAAEze,EAAGyB,GAAL,QAA8C,CAChE,EACA,EACA,EACA,EACAA,EACAzB,EACA,EACA,IAGW4nB,GAAWtc,GAAmC,CAACA,EAAM,GAAIA,EAAM,IAa/Duc,GAAY,CAACC,EAAaC,IACrCN,GAAcA,GAAQK,EAAOC,IAOlBvmB,GAAW,CAACwmB,EAAeC,IACtCR,GAAQxnB,GAAK+nB,EAAQC,IAEVC,GAAiB,CAAC5c,EAAc9L,IAC3CioB,GAAcnc,EAAO9L,GChCVif,GAAQnT,GAAwB,CAC3C,EACA,EACA,EACA,EACAA,EAAM,GACNA,EAAM,GACN,EACA,GCRWgb,GAAW,CAAC6B,EAAcjd,IACrCuc,GAAOA,GAAOU,EAAO19B,KAAK2gB,IAAIF,EAAQ,IAAKzgB,KAAK0gB,IAAID,EAAQ,IA2BjDkd,GAAQ,CACnBC,EACA5B,IAEAgB,GAAcA,GAAOA,GAAOY,EAAO5B,GAAUgB,GAAWY,K,aCL1D,MAoCaC,GAAmD,CAC9Dpe,EACAd,EACApJ,EACAyB,KAEA,MAAM8mB,EAAY,GAAKnf,EAAS5G,KAAKvP,MAErC,OACGu1B,GAA0Cte,EAASd,EAAU,CAACpJ,EAAGyB,KAClEgnB,GAAiCve,EAAS,CAAClK,EAAGyB,GAAI8mB,IAIhDC,GAA4C,CAChDte,EACAd,EACAkC,KAEA,MAAMid,EAAY,GAAKnf,EAAS5G,KAAKvP,MAE/By1B,EACa,SAAjBxe,EAAQtL,KACJ+pB,GA1DNze,KAEA,GAAqB,UAAjBA,EAAQtL,KACV,OAAO,EAGT,GAAqB,aAAjBsL,EAAQtL,KACV,OAAO,EAGT,MAAMgqB,EAAoD,gBAA5B1e,EAAQyM,gBAEtC,MAAqB,SAAjBzM,EAAQtL,KACHgqB,GAAyBvc,GAAYnC,EAAQoC,QAE/Csc,GAAyBxe,GAAeF,IA4CzC2e,CAA6B3e,GAC7B4e,GACAC,GAEN,OAAOC,GAA2B,CAAE9e,UAASoB,QAAOid,YAAWG,WAG3DO,GAAoB,CACxB7f,EACAc,IACGd,EAASjB,mBAAmB+B,EAAQhR,IAEnCuvB,GAAmC,CACvCve,EADuC,EAGvCqe,KACI,IAFHvoB,EAAGyB,GAED,EACH,MAAOqJ,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5Cgf,GAAkBpe,EAAKE,GAAM,EAC7Bme,GAAkBpe,EAAKE,GAAM,GAE5Bme,EAAUC,GAAYxe,GAC3B7K,EACAyB,EACAynB,EACAC,GACCjf,EAAQgB,OAGX,OACEke,EAAWte,EAAKyd,GAChBa,EAAWpe,EAAKud,GAChBc,EAAWte,EAAKwd,GAChBc,EAAWpe,EAAKsd,GAIPe,GAAoB,CAC/Bpf,EAD+B,KAGlB,IADb,EAAElK,EAAF,EAAKyB,GACO,EACZ,MAAM8mB,EAAYgB,GAAcrf,EAASA,EAAQhK,MAAOgK,EAAQ9J,QAGhE,OAAO4oB,GAA2B,CAAE9e,UAASoB,MADxB,CAACtL,EAAGyB,GAC2B8mB,YAAWG,MAFjDc,MAKHD,GAAgB,CAC3Brf,EACAuf,EACAC,KAGA,MACMC,GAD8B,YAAjBzf,EAAQtL,KAAqB,EAAInU,KAAK28B,KAAK,GAAK,GAC7B38B,KAAK2T,IAAIqrB,EAAcC,GAE7D,OAAOj/B,KAAK+iB,IAAI,GAAI/iB,KAAK2T,IAAI,IAAOurB,EAAkB,MAUlDX,GAA8B9nB,IAClC,OAAQA,EAAKgJ,QAAQtL,MACnB,IAAK,YACL,IAAK,QACL,IAAK,OACL,IAAK,UACL,IAAK,UACH,MAAM4C,EAAWooB,GAA0B1oB,EAAKgJ,QAAShJ,EAAKoK,OAC9D,OAAOpK,EAAKwnB,MAAMlnB,EAAUN,EAAKqnB,WACnC,IAAK,WACH,QACGrnB,EAAKwnB,MACJmB,GAAoB3oB,EAAKgJ,QAAShJ,EAAKoK,OACvCpK,EAAKqnB,YAMFuB,GAAuB5oB,EAAKgJ,QAAShJ,EAAKoK,MAAOpK,EAAKqnB,WAE/D,IAAK,QACL,IAAK,OACH,OAAOwB,GAAc7oB,GACvB,IAAK,YAIH,OAHA1L,QAAQw0B,KACN,gEAEK,IAIAJ,GAA4B,CACvC1f,EACAoB,KAEA,OAAQpB,EAAQtL,MACd,IAAK,YACL,IAAK,QACL,IAAK,OACH,OAAOirB,GAAoB3f,EAASoB,GACtC,IAAK,UACH,OAAO2e,GAAkB/f,EAASoB,GACpC,IAAK,UACH,OAAO4e,GAAkBhgB,EAASoB,KAIlCqd,GAAmB,CAACnnB,EAAkB+mB,IACnC/mB,EAAW,EAGdsnB,GAAgB,CAACtnB,EAAkB+mB,IAChC/mB,EAAW+mB,EAGdQ,GAAc,CAACvnB,EAAkB+mB,IAC9B99B,KAAKiX,IAAIF,GAAY+mB,EAGxBiB,GAAiB,CAAChoB,EAAkB+mB,IACjC,GAAK/mB,GAAYA,EAAW+mB,EAG/BsB,GAAsB,CAC1B3f,EAKAoB,KAEA,MAAO,CAAE6e,EAAUC,EAAQC,GAAWC,GAAuBpgB,EAASoB,GACtE,OAAO7gB,KAAK+iB,IACV+c,GAAuBJ,EAAUK,GAAgB,EAAG,GAAIH,IACxDE,GAAuBJ,EAAUK,GAAgB,EAAG,GAAIJ,MAItDH,GAAoB,CACxB/f,EACAoB,KAEA,MAAO,CAAE6e,EAAUC,EAAQC,GAAWC,GAAuBpgB,EAASoB,GAChEmf,EAAOD,GAAgBH,EAASD,GAASC,EAAUD,GACzD,OAAOG,GAAuBJ,EAAUM,IAGpCP,GAAoB,CACxBhgB,EACAoB,KAEA,MAAO6e,EAAUO,GAAWC,GAAqBzgB,EAASoB,GAC1D,OJ3MmB9L,EI2MCkrB,GJ3MsBjgC,KAAK81B,KAAK/gB,EAAK,II2M1B+qB,GAAuBJ,EAAUO,GJ3M7ClrB,OI8MfmrB,GAAuB,CAC3BzgB,EACAoB,KAEA,MAAO,CAAE6e,EAAUC,EAAQC,GAAWC,GAAuBpgB,EAASoB,IAC/DiN,EAAIC,GAAM+R,GAAgBJ,GAGjC,IAAIS,EAAK,KACLC,EAAK,KAET,MAAMlE,EAAIyD,EACJxD,EAAIyD,EAIV,CAAC,EAAG,EAAG,EAAG,GAAGtY,SAAS+Y,IACpB,MAGMC,GAAOpE,EAAIA,EAAIC,EAAIA,GAAKgE,GAAM,EAAKjE,EACnCqE,GAAOpE,EAAIA,EAAID,EAAIA,GAAKkE,GAAM,EAAKjE,EAEnCqE,EANKtE,EAAIiE,EAMCG,EACVG,EANKtE,EAAIiE,EAMCG,EAEVG,EAAK5S,EAAKwS,EACVK,EAAK5S,EAAKwS,EAEVzd,EAAI9iB,KAAK2hB,MAAM8e,EAAID,GACnB3d,EAAI7iB,KAAK2hB,MAAMgf,EAAID,GAEzBP,EAAKngC,KAAK2T,IAAI,EAAG3T,KAAK+iB,IAAI,GAAK2d,EAAK5d,EAAKD,EAAIyd,GAAMpE,IACnDkE,EAAKpgC,KAAK2T,IAAI,EAAG3T,KAAK+iB,IAAI,GAAK4d,EAAK7d,EAAKD,EAAI0d,GAAMpE,IACnD,MAAMxtB,EAAI3O,KAAK2hB,MAAMye,EAAID,GACzBA,GAAMxxB,EACNyxB,GAAMzxB,KAGR,MAAMiyB,EAAe5D,GAASd,EAAIiE,EAAIhE,EAAIiE,GJxQX,IAAiBS,EI2QhD,MAAO,CAACnB,EJ1QRxC,GAAWD,GIyQ8ByC,EJ1QOmB,EI0QGD,GJzQRC,KI6QvCxB,GAAyB,CAC7B5f,EACAoB,EACAid,KAOA,IAAIvoB,EACAyB,EAEJ,GAAsB,IAAlByI,EAAQgB,MACVlL,EAAIsL,EAAM,GAAKpB,EAAQlK,EACvByB,EAAI6J,EAAM,GAAKpB,EAAQzI,MAClB,CAEL,MAAOuO,EAAMC,EAAMC,EAAMC,GAAQZ,GAAyBrF,GACpDqhB,EAAelgB,GACnBC,EACA,CAAC0E,GAAQE,EAAOF,GAAQ,EAAGC,GAAQE,EAAOF,GAAQ,IACjD/F,EAAQgB,OAEXlL,EAAIurB,EAAa,GAAKrhB,EAAQlK,EAC9ByB,EAAI8pB,EAAa,GAAKrhB,EAAQzI,EAGhC,IACI+pB,GADCzO,EAAGC,GAAK9S,EAAQoC,OAIrB,GACEL,GAAW8Q,EAAE,GAAIA,EAAE,GAAI/c,EAAGyB,GAAK8mB,GAC/Btc,GAAW+Q,EAAE,GAAIA,EAAE,GAAIhd,EAAGyB,GAAK8mB,EAE/B,OAAO,EAIT,IAAK,IAAIj0B,EAAI,EAAGA,EAAI4V,EAAQoC,OAAOpb,OAAQoD,IAAK,CAC9C,MAAMm3B,EAAQ,CAACzO,EAAE,GAAKD,EAAE,GAAIC,EAAE,GAAKD,EAAE,IAC/B7rB,EAASzG,KAAK2hB,MAAMqf,EAAM,GAAIA,EAAM,IAEpCC,EAAI,CAACD,EAAM,GAAKv6B,EAAQu6B,EAAM,GAAKv6B,GACnCy6B,EAAI,CAAC3rB,EAAI+c,EAAE,GAAItb,EAAIsb,EAAE,IACrB6O,GAAKD,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,IAAMjhC,KAAK2hB,MAAMsf,EAAE,GAAIA,EAAE,IAC3DF,EAAI,CAACzO,EAAE,GAAK2O,EAAE,GAAKE,EAAG7O,EAAE,GAAK2O,EAAE,GAAKE,GAEpC,MAAMC,EAAK5f,GAAWuf,EAAE,GAAIA,EAAE,GAAIzO,EAAE,GAAIA,EAAE,IACpC+O,EAAK7f,GAAWuf,EAAE,GAAIA,EAAE,GAAIxO,EAAE,GAAIA,EAAE,IAI1C,GAFAwO,EAAIM,EAAKD,GAAMA,EAAK36B,EAAS8rB,EAAI6O,EAAKC,GAAMA,EAAK56B,EAAS6rB,EAAIyO,EAE1D/gC,KAAK2hB,MAAM3K,EAAI+pB,EAAE,GAAIxrB,EAAIwrB,EAAE,IAAMjD,EACnC,OAAO,EAGTxL,EAAIC,EACJA,EAAI9S,EAAQoC,OAAOhY,EAAI,GAGzB,OAAO,GAGHy1B,GAAiB7oB,IACrB,MAAM,QAAEgJ,EAAF,UAAWqe,GAAcrnB,EAC/B,IAAK0P,GAAmB1G,GACtB,OAAO,EAET,MAAOoB,EAAOygB,EAAU3B,EAAQC,GAAWC,GACzCppB,EAAKgJ,QACLhJ,EAAKoK,OAED0gB,EAAQxB,GAAgB,EAAG,GAAIH,GAC/B4B,EAAQzB,GAAgB,EAAG,GAAIJ,GACrC,IACGtB,GAAcyB,GAAuBwB,EAAUC,GAAQzD,KACvDO,GAAcyB,GAAuBwB,EAAUE,GAAQ1D,GAExD,OAAO,EAET,MAAO2D,EAAMC,GAAQ5B,GAAgBjf,GAE/BvJ,EAAQ6O,GAAmB1G,GAEjC,GAAIhJ,EAAKwnB,QAAUI,GAAe,CAIhC,GAHY/mB,EAAMqqB,MAAMC,GACtBC,GAAmBD,EAAUH,EAAMC,EAAMjiB,EAAQqI,mBAGjD,OAAO,EAKX,OAAOxQ,EAAMqqB,MAAMC,GACjBE,GAAkBF,EAAUH,EAAMC,EAAM5D,MAgBtC+B,GAAyB,CAC7BpgB,EACAsiB,KAEA,MAAMlhB,EAAQif,GAAaiC,GACrBC,EAAgBld,GAAyBrF,GACzCqB,EAASmhB,GAAaD,GAEtB5hB,EAAS8hB,GAAqBphB,EAAQrB,EAAQgB,OAC9C0hB,EAAeD,GAAkB9hB,EAAQS,GAEzCuhB,EHzZYvhB,IAAwB,CAC1C,EACA,EACA,EACA,EACA7gB,KAAKiX,IAAI4J,EAAM,IACf7gB,KAAKiX,IAAI4J,EAAM,IACf,EACA,GGiZ4Bif,CADH9C,GAAOmF,EAAcE,GAAiBvhB,KAEzDwhB,GL1Ye/sB,EK0YQkK,EAAQlK,EL1YoB,CACzD,EACA,EACA,EACA,EKsYwCkK,EAAQzI,ELpYhDzB,EACA,EACA,IARoB,IAACA,EK2YrB,MAAMgtB,EAAgBvF,GAAOmF,EAAcG,IACpCE,EAAIC,EAAIC,EAAIC,GAAMX,EAGzB,MAAO,CAACO,EAAeH,GAFJM,EAAKF,GAAM,GACVG,EAAKF,GAAM,IAkB3BG,GACJnjB,IAEA,MAAMuiB,EAAgBld,GAAyBrF,GACzCqB,EAASmhB,GAAaD,GAEtB5hB,EAAS8hB,GAAqBphB,EAAQrB,EAAQgB,OAC9C2O,EAAY4N,GD7b4C,CAC9D,EACA,EACA,EACA,GACE,IALwB3L,EC8bAgR,GAAiBvhB,IDzbzB,GAClB,GAAMuQ,EAAU,GAChB,EACA,IAR0BA,MCgc1B,ODzaA2L,GCyamC5N,EAARhP,IAGvB6hB,GAAe,IAAyC,IAAvCO,EAAIC,EAAIC,EAAIC,GAA0B,EAC3D,OAAO3F,IAAUwF,EAAKE,GAAM,GAAID,EAAKE,GAAM,IAQhCE,GAAyB,CACpCpjB,EAEAyc,EAEAC,KAEA,MAAM2G,EAAiBF,GAA8BnjB,GAC/CsjB,EAAOb,GAAkBY,EAAgBhD,GAAa5D,IACtD8G,EAAOd,GAAkBY,EAAgBhD,GAAa3D,IACtDpnB,EAAOgrB,GAAegD,EAAMC,GAC5BngB,EAAIpD,EAAQ9J,OAAS8J,EAAQhK,MAC7BkqB,EAASlgB,EAAQhK,MAAQ,EACzBmqB,EAAUngB,EAAQ9J,OAAS,EAC3B2L,EAAIvM,EAAK,GACTkuB,EAAIluB,EAAK,GACTgoB,EAAIhoB,EAAK,GACTmuB,EAAOljC,KAAKiX,IAAIgsB,GAChBE,EAAOnjC,KAAKiX,IAAIqK,GACtB,OAAQ7B,EAAQtL,MACd,IAAK,YACL,IAAK,QACL,IAAK,OACH,OAAO4oB,GAAK4C,GAAUwD,EAAOtgB,EAAIqgB,IACnC,IAAK,UACH,OAAOA,EAAOC,EAAOpG,GAAKoG,EAAOxD,GAAU5C,GAAKmG,EAAOtD,GACzD,IAAK,UACH,OAAO7C,GAAK4C,EAAS3/B,KAAK28B,KAAKrb,GAAK,EAAIuB,GAAK,EAAIogB,GAAK,MAgEtDG,GAAoC,SACxC3jB,EAEA1K,EAEAsuB,GAEgB,IACZC,EAFJC,EACe,uDADD,EAGd,OAAQ9jB,EAAQtL,MACd,IAAK,YACL,IAAK,QACL,IAAK,OACL,IAAK,UACH,MAAMqvB,EAAUC,GAAWhkB,GAC3B6jB,EAAgBE,EACbE,SAAQ,CAAC7iB,EAAOhX,KACf,MAAM85B,EAA6B,CAAC9iB,EAAO2iB,GAAS35B,EAAI,GAAK,IAC7D,OAAO+5B,GAAiB7uB,EAAM8uB,GAAcF,EAAMJ,OAEnDt0B,OACCu0B,EAAQE,SAAS7iB,GAAUijB,GAAuBjjB,EAAO0iB,EAAKxuB,MAElE,MACF,IAAK,UACHuuB,EAAgBS,GAAwBtkB,EAAS8jB,EAAKxuB,GAG1D,GAAIuuB,EAAc78B,OAAS,EAEzB,MAAO,GAET,MAAMu9B,EAAsBV,EAAcp0B,MACxC,CAAC+0B,EAAIC,IACHpE,GAAiBmE,EAAIZ,GAAavD,GAAiBoE,EAAIb,KAE3D,MAAO,CACLW,EAAoB,GACpBA,EAAoBA,EAAoBv9B,OAAS,KAI/Cg9B,GAAa,SACjBhkB,GAMgB,IADhB4P,EACe,uDADC,EAEhB,MAAM8U,EAAM9U,EAAQ5P,EAAQhK,MAAS,EAC/B2uB,EAAM/U,EAAQ5P,EAAQ9J,OAAU,EACtC,OAAQ8J,EAAQtL,MACd,IAAK,YACL,IAAK,QACL,IAAK,OACH,MAAO,CACL6oB,GAASmH,EAAIC,GACbpH,GAASmH,GAAKC,GACdpH,IAAUmH,GAAKC,GACfpH,IAAUmH,EAAIC,IAElB,IAAK,UACH,MAAO,CACLpH,GAAS,EAAGoH,GACZpH,GAASmH,EAAI,GACbnH,GAAS,GAAIoH,GACbpH,IAAUmH,EAAI,MAQhBP,GAAmB,CACvB7uB,EACAsvB,KAEA,MAAOnI,EAAGC,GAAKkI,EAGf,OAFcvE,GAAuB5D,EAAGnnB,GAC1B+qB,GAAuB3D,EAAGpnB,IACnB,EAEZ,GAEF,CAAC+qB,GAAkB/qB,EAAMgrB,GAAe7D,EAAGC,MAG9C0H,GAAgB,CACpBQ,EACAttB,KAEA,MAAOmlB,EAAGC,GAAKkI,EACT34B,ED1nB6B,EACnC2lB,EACAta,KAEA,MAAMsY,EAAQ,GAAMtY,EACpB,MAAO,CAAC,EAAG,EAAG,EAAG,EAAGsY,EAAQgC,EAAU,GAAIhC,EAAQgC,EAAU,GAAI,EAAG,ICqnBpD6Q,EF7nBMlO,EE8nBAkI,EF7nBrBc,GAAe,CAAC,EAAG,EAAG,EAAG,GADS1xB,EE8nBV6wB,GF7nBO,GAAKnI,EAAK,GAAI1oB,EAAG,GAAK0oB,EAAK,GAAI,EAAG,KE8nB/Djd,GF/nBkB,IAACid,EAAa1oB,EEioBlC,MAAO,CAAC42B,GAAkBx2B,EAAQwwB,GAAIgG,GAAkBx2B,EAAQywB,KAG5D4H,GAA0B,CAC9BtkB,EACA8jB,EACAxuB,KAEA,MAAMmnB,EAAIzc,EAAQhK,MAAQ,EAAI8tB,EACxBpH,EAAI1c,EAAQ9J,OAAS,EAAI4tB,EACzBN,EAAIluB,EAAK,GACTuM,EAAIvM,EAAK,GACTgoB,EAAIhoB,EAAK,GACTuvB,EAAUpI,EAAIA,EAAI+G,EAAIA,EAAI9G,EAAIA,EAAI7a,EAAIA,EACtCijB,EAAQD,EAAUvH,EAAIA,EAC5B,GAAgB,IAAZuH,GAAiBC,GAAS,EAC5B,MAAO,GAET,MAAMC,EAAYxkC,KAAK28B,KAAK4H,GACtBE,GAAMvI,EAAIA,EAAI+G,EAAIlG,EAClB2H,GAAMvI,EAAIA,EAAI7a,EAAIyb,EACxB,MAAO,CACLC,IACGyH,EAAKvI,EAAIC,EAAI7a,EAAIkjB,GAAaF,GAC9BI,EAAKxI,EAAIC,EAAI8G,EAAIuB,GAAaF,GAEjCtH,IACGyH,EAAKvI,EAAIC,EAAI7a,EAAIkjB,GAAaF,GAC9BI,EAAKxI,EAAIC,EAAI8G,EAAIuB,GAAaF,KAKxBR,GAAyB,CACpChjB,EACA6jB,EACA5vB,KAEA,GAAe,IAAX4vB,EACF,OAAgD,IAAzC7E,GAAuB/qB,EAAM+L,GAAgB,CAACA,GAAU,GAEjE,MAAMmiB,EAAIluB,EAAK,GACTuM,EAAIvM,EAAK,GACTgoB,EAAIhoB,EAAK,IACRmnB,EAAGC,GAAK2D,GAAgBhf,GAEzBwjB,EAAUrB,EAAIA,EAAI3hB,EAAIA,EACtBijB,EAFII,IAEYL,GAAWrB,EAAI/G,EAAI5a,EAAI6a,EAAIY,IAAM,EACvD,GAAgB,IAAZuH,GAAiBC,GAAS,EAC5B,MAAO,GAET,MAAMC,EAAYxkC,KAAK28B,KAAK4H,GACtBE,EAAKvI,EAAI5a,EAAIA,EAAI6a,EAAI8G,EAAI3hB,EAAI2hB,EAAIlG,EACjC2H,EAAKvI,EAAI8G,EAAIA,EAAI/G,EAAI+G,EAAI3hB,EAAIA,EAAIyb,EAEvC,MAAO,CACLC,IAAUyH,EAAKnjB,EAAIkjB,GAAaF,GAAUI,EAAKzB,EAAIuB,GAAaF,GAChEtH,IAAUyH,EAAKnjB,EAAIkjB,GAAaF,GAAUI,EAAKzB,EAAIuB,GAAaF,KAMvDM,GAA2B,CACtC3X,EAGA4X,EAGAhkB,KAEA,MAAMikB,EAAsB9kC,KAAKiX,IAAI4tB,GAC/B3I,EAAKjP,EAAQxX,MAAQqvB,EAAuB,EAC5C3I,EAAKlP,EAAQtX,OAASmvB,EAAuB,EAE7CC,EAAc/kC,KAAK81B,KAAK+O,IACvB/W,EAAIkX,GAAOlF,GAAgBjf,GAG5BkN,EAAa,IAARiX,EAAY,KAASA,EAE1BV,EAAUxW,GAAM,EAAIqO,GAAK,EAAIpO,GAAM,EAAImO,GAAK,EAE5C+G,IACFnV,EAAKqO,GAAK,EACV4I,EAAchX,EAAK/tB,KAAK28B,KAAK38B,KAAK+iB,IAAI,EAAGuhB,EAAUpI,GAAK,EAAIC,GAAK,KACnEmI,EAEIhjB,IAAM2hB,EAAInV,EAAK,GAAKC,EAEpBxY,IAAM2mB,GAAK,GAAI+G,GAAM3hB,GAAK,EAAI6a,GAAK,EAAI8G,GAAK,EAAI/G,GAAK,GAC3D,OAAOc,GAASznB,IAAK0tB,EAAI1tB,EAAI,GAAK+L,IAGvB2jB,GAAgC,CAC3CxlB,EAOAolB,EAGAhkB,KAEA,MAAMikB,EAAsB9kC,KAAKiX,IAAI4tB,GAC/BE,EAAc/kC,KAAK81B,KAAK+O,GACxBrB,EAAUC,GAAWhkB,EAASqlB,GAEpC,IAAII,EAAc,EACdC,EAAgC,KAQpC,OAPA3B,EAAQlc,SAAS8d,IACf,MAAMruB,EAAWguB,EAAchF,GAAelf,EAAOukB,GAAQ,GACzDruB,EAAWmuB,IACbA,EAAcnuB,EACdouB,EAAeC,MAGZD,GAoCHtD,GAAqB,CACzB3R,EACA3a,EACAyB,EACAkR,KAEA,MAAM/C,EAAMF,GAAgBiL,GACtBrO,EAAkB,GACxB,IAAIwjB,GAAM,EACV,IAAK,MAAMC,KAAangB,EACD,SAAjBmgB,EAAU1f,IACZyf,GAAOA,EACHA,GACFxjB,EAAOrV,KAAK,CAAC84B,EAAUl+B,KAAK,GAAIk+B,EAAUl+B,KAAK,MAEvB,aAAjBk+B,EAAU1f,IACfyf,IACFxjB,EAAOrV,KAAK,CAAC84B,EAAUl+B,KAAK,GAAIk+B,EAAUl+B,KAAK,KAC/Cya,EAAOrV,KAAK,CAAC84B,EAAUl+B,KAAK,GAAIk+B,EAAUl+B,KAAK,KAC/Cya,EAAOrV,KAAK,CAAC84B,EAAUl+B,KAAK,GAAIk+B,EAAUl+B,KAAK,MAIrD,GAAIya,EAAOpb,QAAU,EAAG,CACtB,GAAkB,UAAdyhB,EACF,OAAOjG,GAAiBJ,EAAQtM,EAAGyB,GAErC,MAAMuuB,EAAgBC,aAAqB3jB,EAAe,GAAI,GAC9D,OAAOI,GAAiBsjB,EAAehwB,EAAGyB,GAE5C,OAAO,GAGH8qB,GAAoB,CACxB5R,EACA3a,EACAyB,EACAyuB,KAGA,MAAMtgB,EAAMF,GAAgBiL,GAI5B,IAAI5K,EAAkB,CAAC,EAAG,GAE1B,OAAOH,EAAIwc,MAAK,CAAC,EAAc3b,KAAS,IAAvB,GAAEJ,EAAF,KAAMxe,GAAgB,EAGrC,GAAW,SAAPwe,EAEFN,EAAWle,OAGN,GAAW,aAAPwe,EAAmB,CAI5B,MAAM3C,EAAK,CAAC7b,EAAK,GAAIA,EAAK,IACpB+b,EAAK,CAAC/b,EAAK,GAAIA,EAAK,IACpBye,EAAK,CAACze,EAAK,GAAIA,EAAK,IAEpB0e,EAAKR,EACXA,EAAWO,EAKX,MAAM6f,EArGkB,EAC5B5f,EACA7C,EACAE,EACA0C,EAJ4B,EAM5B4f,KACI,IAFHE,EAAIC,GAEF,EAEH,MAAM7f,EAAW,CAACpX,EAAWqX,IAC3BhmB,KAAK2L,IAAI,EAAIgD,EAAG,GAAKkX,EAAGG,GACxB,EAAIrX,EAAI3O,KAAK2L,IAAI,EAAIgD,EAAG,GAAKwU,EAAG6C,GAChC,EAAIhmB,KAAK2L,IAAIgD,EAAG,IAAM,EAAIA,GAAKsU,EAAG+C,GAClCF,EAAGE,GAAOhmB,KAAK2L,IAAIgD,EAAG,GAGxB,IAAIA,EAAI,EACR,KAAOA,GAAK,GAAK,CACf,MAAMwxB,EAAKpa,EAASpX,EAAG,GACjByxB,EAAKra,EAASpX,EAAG,GAIvB,GAFa3O,KAAK28B,KAAK38B,KAAK2L,IAAIw0B,EAAKwF,EAAI,GAAK3lC,KAAK2L,IAAIy0B,EAAKwF,EAAI,IAErDH,EACT,OAAO,EAGT92B,GAAK,IAGP,OAAO,GAuEYk3B,CACb/f,EACA7C,EACAE,EACA0C,EACA,CAACtQ,EAAGyB,GACJyuB,GAMF,OAAOC,EAOT,OAAO,MCx3BLI,GAA0B,CAC9BC,EACAxwB,EACAyB,IAEAzB,GAAKwwB,EAAgB,IACrBxwB,GAAKwwB,EAAgB,GAAKA,EAAgB,IAC1C/uB,GAAK+uB,EAAgB,IACrB/uB,GAAK+uB,EAAgB,GAAKA,EAAgB,GAwC/BC,GAAoC,CAC/C3e,EACA1I,EACAsnB,EACAC,EACAnuB,EACAqjB,IAEO/T,EAASrb,QAAO,CAAC1C,EAAQmW,KAC9B,GAAInW,EACF,OAAOA,EAET,MAAM68B,EAlDgB,EACxB1mB,EACAd,EACApJ,EACAyB,EACAe,EACAqjB,KAEA,IAAKzc,EAASjB,mBAAmB+B,EAAQhR,IACvC,OAAO,EAGT,MAAQotB,SAAUuK,KAA4BxK,GAC5CG,GAAoBtc,EAAS1H,EAAMqjB,GAErC,GACEgL,GACAN,GAAwBM,EAAyB7wB,EAAGyB,GAEpD,MAAO,WAGT,MAAM3H,EAASR,OAAOD,KAAKgtB,GAAkBvsB,QAAQhJ,IACnD,MAAM0/B,EACJnK,EAAiBv1B,GACnB,QAAK0/B,GAGED,GAAwBC,EAAiBxwB,EAAGyB,MAGrD,OAAI3H,EAAO5I,OAAS,GACX4I,EAAO,IAkBcg3B,CAC1B5mB,EACAd,EACAsnB,EACAC,EACAnuB,EACAqjB,GAEF,OAAO+K,EAAsB,CAAE1mB,UAAS0mB,uBAAwB,OAC/D,MAGQG,GAAmC,CAAC,EAE/CL,EACAC,EACAnuB,EACAqjB,KAC8B,IAL7B/a,EAAIC,EAAIC,EAAIC,GAKgB,EAC7B,MAAMob,EAAmBT,GACvB,CAAC9a,EAAIC,EAAIC,EAAIC,GACb,EACAzI,EACAqjB,EACAZ,IAWF,OARc3rB,OAAOD,KAAKgtB,GAAkBrF,MAAMlwB,IAChD,MAAM0/B,EACJnK,EAAiBv1B,GACnB,OACE0/B,GACAD,GAAwBC,EAAiBE,EAAeC,QAG3C,GAGbK,GAAiB,CAAC,KAAM,OAAQ,KAAM,QAa/BC,GAA+BhpB,IAI1C,MAAM,QAAEiC,EAAF,oBAAW0mB,GAAwB3oB,EACnCipB,EACJhnB,GAAWzf,KAAK81B,KAAKrW,EAAQ9J,QAAU3V,KAAK81B,KAAKrW,EAAQhK,UAAY,EACvE,IAAItJ,EAAS,KAEb,OAAQg6B,GACN,IAAK,IACL,IAAK,IACHh6B,EAAS,KACT,MACF,IAAK,IACL,IAAK,IACHA,EAAS,KACT,MACF,IAAK,KACL,IAAK,KAEDA,EADEs6B,EACO,OAEA,OAEX,MACF,IAAK,KACL,IAAK,KAEDt6B,EADEs6B,EACO,OAEA,OAEX,MACF,IAAK,WACH,MAAO,OAOX,OAJIt6B,GAAUsT,IACZtT,EAnDuB,EAACA,EAAgBsU,KAC1C,MAAMrQ,EAAQm2B,GAAevP,QAAQ7qB,GACrC,GAAIiE,GAAS,EAAG,CACd,MAAM8rB,EAAIl8B,KAAK0jB,MAAMjD,GAASzgB,KAAKC,GAAK,IACxCkM,EAASo6B,IAAgBn2B,EAAQ8rB,GAAKqK,GAAe9/B,QAEvD,OAAO0F,GA6CIu6B,CAAmBv6B,EAAQsT,EAAQgB,QAGvCtU,EAAM,UAAMA,EAAN,WAAwB,IClJhC,MAAMw6B,GAYXpN,YAAY9Z,EAA8CsT,GAAe,KAXlE6T,eAWiE,OARjEC,sBAQiE,OANjEC,gBAMiE,OALjEC,0BAKiE,OAJjEC,mBAIiE,OAHjEC,yBAGiE,OAFjEC,uBAEiE,EACtElU,KAAK4T,UAAYnnB,EAAQhR,GAGzBikB,GAAMkB,kBAAkBZ,KAAK4T,UAAW7T,GACxC4T,GAAoBQ,gBAAgB1nB,GAEpCuT,KAAK6T,iBAAmB,KACxB7T,KAAK+T,qBAAuB,KAC5B/T,KAAK8T,YAAa,EAClB9T,KAAKgU,cAAgB,CAAEzxB,EAAG,EAAGyB,EAAG,GAChCgc,KAAKiU,oBAAsB,OAC3BjU,KAAKkU,kBAAoB,OAaV,kBAACz4B,GAA4D,IAAD,EAC3E,MAAMgR,EAAO,UAAGiT,GAAM0C,SAAS3mB,UAAlB,aAAG,EAAoB6kB,qBAAqB7kB,GACzD,OAAIgR,GAGG,KAIiB,2BACxBd,EACAyoB,EACAnB,EACAC,EACAmB,GAKA,IAAK1oB,EAASzC,qBACZ,OAAO,EAET,MAAM,qBAAEA,GAAyByC,GAC3B,iBAAEkoB,EAAF,UAAoBD,EAApB,WAA+BE,GAAe5qB,EAE9CuD,EAAUknB,GAAoBtT,WAAWuT,GAC/C,IAAKnnB,EACH,OAAO,EAGT,GAAwB,MAApBonB,GAA4BA,GAAoB,EAAG,EAClC,IAAfC,GACFM,EAAS,CACPlrB,qBAAsB,IACjBA,EACH4qB,YAAY,KAKlB,MAAMQ,EAAWX,GAAoBY,cACnC9nB,EACAwmB,EAAgB/pB,EAAqB8qB,cAAczxB,EACnD2wB,EAAgBhqB,EAAqB8qB,cAAchwB,EACnD2H,EAAShC,UAMX,OAJAgqB,GAAoBa,UAAU/nB,EAASonB,EAAkBS,GACrDrnB,GAAiBR,IACnB4nB,EAAoB5nB,EAA8B,IAArBonB,EAAyB,QAAU,QAE3D,EAET,OAAO,EAGa,uBACpBz9B,EACA8S,EACAyC,GAEA,MAAM,UAAEioB,EAAF,iBAAaC,EAAb,WAA+BC,GAAe5qB,EAC9CuD,EAAUknB,GAAoBtT,WAAWuT,GAC/C,IAAKnnB,EACH,OAAOvD,EAGT,IAAIurB,EAAU,GACd,GACEX,IACsB,IAArBD,GAA0BA,IAAqBpnB,EAAQoC,OAAOpb,OAAS,GACxE,CACImb,GAAYnC,EAAQoC,OAAQlD,EAAS5G,KAAKvP,QAC5Cm+B,GAAoBa,UAClB/nB,EACAonB,EACqB,IAArBA,EACIpnB,EAAQoC,OAAOpC,EAAQoC,OAAOpb,OAAS,GACvCgZ,EAAQoC,OAAO,IAcvB4lB,EAAU,CACR,CAAsB,IAArBZ,EAAyB,sBAAwB,qBAZ7BjqB,GAAiB+B,GACpC+oB,GACE7uB,GACE8tB,GAAoBgB,iCAClBloB,EACAonB,IAGJnU,GAAM0C,SAAS3V,IAEjB,MAMN,MAAO,IACFvD,KACAurB,EACHX,YAAY,EACZE,cAAe,CAAEzxB,EAAG,EAAGyB,EAAG,IAIN,yBACtB5N,EACAuV,EACAyoB,EACAQ,EACAC,GAKA,MAAMrxB,EAAmE,CACvEsxB,aAAa,EACbC,WAAY,MAGd,IAAKppB,EAASzC,qBACZ,OAAO1F,EAGT,MAAM,UAAEowB,GAAcjoB,EAASzC,qBACzBuD,EAAUknB,GAAoBtT,WAAWuT,GAE/C,IAAKnnB,EACH,OAAOjJ,EAGT,GAAIpN,EAAMsJ,OA2BR,OA1B0D,MAAtDiM,EAASzC,qBAAqB6qB,sBAChCpS,GAAclV,EAAS,CACrBoC,OAAQ,IACHpC,EAAQoC,OACX8kB,GAAoBY,cAClB9nB,EACAooB,EAAatyB,EACbsyB,EAAa7wB,EACb2H,EAAShC,aAKjBirB,EAAQI,kBACRZ,EAAS,CACPlrB,qBAAsB,IACjByC,EAASzC,qBACZ2qB,iBAAkBpnB,EAAQoC,OAAOpb,OAAS,EAC1CsgC,qBAAsB,KACtBG,kBAAmBQ,GACjBG,EACAnV,GAAM0C,SAAS3V,OAIrBjJ,EAAIsxB,aAAc,EACXtxB,EAGT,MAAMyxB,EAAoBtB,GAAoBuB,yBAC5CzoB,EACAd,EAAS5G,KACT8vB,EAAatyB,EACbsyB,EAAa7wB,GAKf,GAAIixB,GAAqB,EACvBzxB,EAAIuxB,WAAatoB,MACZ,CAML,MAAM,oBAAEwnB,EAAF,kBAAuBC,GAC3BvoB,EAASzC,qBACPU,GAAiB+B,IAAasB,GAAiBR,IACjD0oB,GACE1oB,EACAwnB,EACAC,GAKN,MAAO7mB,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EACjB4nB,EACJH,GAAqB,GACrB7nB,GACEX,EAAQlK,EAAIkK,EAAQoC,OAAOomB,GAAmB,GAC9CxoB,EAAQzI,EAAIyI,EAAQoC,OAAOomB,GAAmB,GAC9C3hB,EACAC,EACA9G,EAAQgB,OAeZ,OAZA2mB,EAAS,CACPlrB,qBAAsB,IACjByC,EAASzC,qBACZ2qB,iBAAkBoB,GAAqB,EAAIA,EAAoB,KAC/DjB,cAAeoB,EACX,CACE7yB,EAAGsyB,EAAatyB,EAAI6yB,EAAY,GAChCpxB,EAAG6wB,EAAa7wB,EAAIoxB,EAAY,IAElC,CAAE7yB,EAAG,EAAGyB,EAAG,MAGZR,EAGe,yBACtBpN,EACA68B,EACAC,EACAhqB,EACAS,GAEA,MAAM,UAAEiqB,EAAF,qBAAaG,GAAyB7qB,EACtCuD,EAAUknB,GAAoBtT,WAAWuT,GAC/C,IAAKnnB,EACH,OAAOvD,EAGT,MAAM,OAAE2F,GAAWpC,EACb4oB,EAAYxmB,EAAOA,EAAOpb,OAAS,GAEzC,IAAK2C,EAAMsJ,OAIT,OAHI21B,IAActB,GAChBJ,GAAoBa,UAAU/nB,EAASoC,EAAOpb,OAAS,EAAG,UAErD,IAAKyV,EAAsB6qB,qBAAsB,MAG1D,MAAMO,EAAWX,GAAoBY,cACnC9nB,EACAwmB,EAAgB/pB,EAAqB8qB,cAAczxB,EACnD2wB,EAAgBhqB,EAAqB8qB,cAAchwB,EACnD2F,GAaF,OAVI0rB,IAActB,EAChBJ,GAAoBa,UAClB/nB,EACAA,EAAQoC,OAAOpb,OAAS,EACxB6gC,GAGFX,GAAoBa,UAAU/nB,EAAS,MAAO6nB,GAGzC,IACFprB,EACH6qB,qBAAsBtnB,EAAQoC,OAAOpC,EAAQoC,OAAOpb,OAAS,IAIhC,kCAC/BgZ,GAEA,MAAOY,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EACvB,OAAOf,EAAQoC,OAAO7T,KAAK6S,IACzB,IAAI,EAAEtL,EAAF,EAAKyB,GAAMyI,EAEf,OADClK,EAAGyB,GAAKoJ,GAAO7K,EAAIsL,EAAM,GAAI7J,EAAI6J,EAAM,GAAIyF,EAAIC,EAAI9G,EAAQgB,OACrD,CAAClL,EAAGyB,MAIwB,wCACrCyI,EACA6oB,GAEA,MAAMl4B,EACJk4B,EAAoB,EAChB7oB,EAAQoC,OAAOpb,OAAS6hC,EACxBA,GACCjoB,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EAEjBK,EAAQpB,EAAQoC,OAAOzR,IACvB,EAAEmF,EAAF,EAAKyB,GAAMyI,EACjB,OAAOW,GAAO7K,EAAIsL,EAAM,GAAI7J,EAAI6J,EAAM,GAAIyF,EAAIC,EAAI9G,EAAQgB,OAG9B,+BAC5BhB,EACA8oB,GAEA,MAAOloB,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,GAChBjL,EAAGyB,GAAKoJ,GACbmoB,EAAe,GACfA,EAAe,GACfjiB,EACAC,GACC9G,EAAQgB,OAEX,MAAO,CAAClL,EAAIkK,EAAQlK,EAAGyB,EAAIyI,EAAQzI,GAGN,gCAC7ByI,EACA1H,EACAxC,EACAyB,GAEA,MAAMwxB,EAAexV,KAAKyV,2BAA2BhpB,GACrD,IAAIuG,EAAMwiB,EAAa/hC,OAIvB,OAASuf,GAAO,GAAG,CACjB,MAAMnF,EAAQ2nB,EAAaxiB,GAC3B,GACExE,GAAWjM,EAAGyB,EAAG6J,EAAM,GAAIA,EAAM,IAAM9I,EAAKvP,MAE5CwqB,KAAK0V,kBAAoB,EAAI,EAE7B,OAAO1iB,EAGX,OAAQ,EAGU,qBAClBvG,EACAwmB,EACAC,EACAvpB,GAEA,MAAMgsB,EAAgBllB,GAAawiB,EAAeC,EAAevpB,IAC1D0D,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,GAChBme,EAAUC,GAAYxe,GAC3BuoB,EAAc,GACdA,EAAc,GACdriB,EACAC,GACC9G,EAAQgB,OAGX,MAAO,CAACke,EAAWlf,EAAQlK,EAAGqpB,EAAWnf,EAAQzI,GAQzB,2BAACyI,GACzB,MAAM,OAAEoC,GAAWpC,EAEb+Q,EAAU3O,EAAO,GAAG,GACpB4O,EAAU5O,EAAO,GAAG,GAE1B,MAAO,CACLA,OAAQA,EAAO7T,KAAI,CAAC6S,EAAO+nB,IAClB,CAAC/nB,EAAM,GAAK2P,EAAS3P,EAAM,GAAK4P,KAEzClb,EAAGkK,EAAQlK,EAAIib,EACfxZ,EAAGyI,EAAQzI,EAAIyZ,GAOG,uBAAChR,GACrBkV,GAAclV,EAASknB,GAAoBkC,oBAAoBppB,IAGzC,yBACtBA,EACAqpB,EACAp9B,GAEA,MAAO6J,EAAGyB,GAAKyI,EAAQoC,OAAOinB,GAC9BnC,GAAoBa,UAAU/nB,EAASqpB,EAAY,CACjDvzB,EAAI7J,EAAO6J,EACXyB,EAAItL,EAAOsL,IAIC,iBACdyI,EACAqpB,EACAC,EACAC,GAEA,MAAM,OAAEnnB,GAAWpC,EAOnB,IAGIuV,EAHAxE,EAAU,EACVC,EAAU,EAGd,GAAuB,WAAnBsY,EAA6B,CAE/B,GAAmB,QAAfD,EACF,MAAM,IAAIv/B,MAAM,6BAElByrB,EAAanT,EAAOpV,QACpBuoB,EAAWwC,OAAOsR,EAAY,GACX,IAAfA,IAGFtY,EAAUwE,EAAW,GAAG,GACxBvE,EAAUuE,EAAW,GAAG,GACxBA,EAAaA,EAAWhnB,KAAI,CAAC6S,EAAOmF,IACtB,IAARA,EACK,CAAC,EAAG,GAEN,CAACnF,EAAM,GAAK2P,EAAS3P,EAAM,GAAK4P,WAGtC,GAAmB,QAAfqY,EACT9T,EAAa,IAAInT,EAAQknB,OACpB,CACL,MAAME,EAASF,EAAe,GAAKlnB,EAAOinB,GAAY,GAChDI,EAASH,EAAe,GAAKlnB,EAAOinB,GAAY,GACtD9T,EAAanT,EAAO7T,KAAI,CAAC6S,EAAOmF,IAC1BA,IAAQ8iB,EACE,IAAR9iB,GACFwK,EAAUyY,EACVxY,EAAUyY,EACHroB,IAET2P,EAAU,EACVC,EAAU,EAEH,CAAC5P,EAAM,GAAKooB,EAAQpoB,EAAM,GAAKqoB,IAEjC1Y,GAAWC,EACb,CAAC5P,EAAM,GAAK2P,EAAS3P,EAAM,GAAK4P,GACjC5P,IAIR,MAAMsoB,EAAalhB,GACjBxI,EACAuV,EACAvV,EAAQqI,iBAAmB,SAEvBshB,EAAanhB,GACjBxI,EACAoC,EACApC,EAAQqI,iBAAmB,SAEvBuhB,GAAeF,EAAW,GAAKA,EAAW,IAAM,EAChDG,GAAeH,EAAW,GAAKA,EAAW,IAAM,EAChDI,GAAeH,EAAW,GAAKA,EAAW,IAAM,EAChDI,GAAeJ,EAAW,GAAKA,EAAW,IAAM,EAGhDK,EAAUrpB,GAAOoQ,EAASC,EAFrB8Y,EAAcF,EACdG,EAAcF,EACwB7pB,EAAQgB,OAEzDkU,GAAclV,EAAS,IAClBupB,EACHnnB,OAAQmT,EACRzf,EAAGkK,EAAQlK,EAAIk0B,EAAQ,GACvBzyB,EAAGyI,EAAQzI,EAAIyyB,EAAQ,MA/fhB9C,GA+BJ+B,kBAAoB,GCnBtB,MAMM9rB,GAAoB+B,GACxBA,EAAS/B,iBAGLurB,GAA4B,CACvCuB,EACAzC,EACAC,KAEA,MAAMyC,EAA0D,IAAI/W,IAC9DgX,EAA8D,IAAIhX,IACxEiX,GACEH,EACAzC,EACAC,EACA,QACAyC,EACAC,GAEFC,GACEH,EACAxC,EACAD,EACA,MACA0C,EACAC,GAGF,MAAME,EAAc/V,MAAMC,KAAK4V,GAAuBv6B,QACnDZ,IAAQk7B,EAAkBphB,IAAI9Z,KAEjCikB,GAAM0C,SAASsU,GACZlW,sBAAsBsW,GACtBxiB,SAAS7H,IAAa,IAAD,EACpBkV,GAAclV,EAAS,CACrBiY,gBAAe,UAAEjY,EAAQiY,uBAAV,aAAE,EAAyBroB,QACvCZ,GAAOA,IAAOi7B,EAAcj7B,WAMjCo7B,GAAgC,CACpCH,EACAK,EACAC,EACAC,EAEAN,EAEAC,KAEA,GAAwB,SAApBG,EACF,GAAuB,MAAnBA,EAI4B,MAA5BC,IAC8B,SAA7BA,EACIE,GACCR,EACAK,EACAE,GAEa,UAAfA,GACAD,EAAyBv7B,KAAOs7B,EAAgBt7B,MAEpD07B,GAAkBT,EAAeK,EAAiBE,GAClDN,EAAkBxV,IAAI4V,EAAgBt7B,SAEnC,CACL,MAAM27B,EAAUC,GAAoBX,EAAeO,GACpC,MAAXG,GACFR,EAAsBzV,IAAIiW,KAMrBE,GACXjjB,IAEAA,EAASC,SAAS7H,IACZQ,GAAiBR,GACnB0oB,GACE1oB,EACA8qB,GAAqC9qB,EAAS,SAC9C8qB,GAAqC9qB,EAAS,QAEvCU,GAAkBV,IAC3B+qB,GAAyB/qB,OAKzB+qB,GACJT,IAEAU,GAA+CV,GAAiBziB,SAC9D,QAAEoiB,EAAegB,GAAjB,SACEvC,GACEuB,EACU,QAAVgB,EAAkB,OAASX,EACjB,UAAVW,EAAoB,OAASX,OAKxBY,GAAyB,CACpCjB,EACA/qB,EACAoU,EACA6X,KAEkC,MAA9BjsB,EAASX,mBACXmsB,GAAkBT,EAAe/qB,EAASX,kBAAmB,SAE/D,MAAM6sB,EAAiBnD,GAA4BkD,EAAe7X,GAE9C,MAAlB8X,GACCX,GACCR,EACAmB,EACA,QAGFV,GAAkBT,EAAemB,EAAgB,QAI/CV,GAAoB,CACxBT,EACAmB,EACAZ,KACU,IAAD,EACTtV,GAAc+U,EAAe,CAC3B,CAAgB,UAAfO,EAAyB,eAAiB,cAAe,CACxDrD,UAAWiE,EAAep8B,MACvBq8B,GAAqBpB,EAAemB,EAAgBZ,MAG3DtV,GAAckW,EAAgB,CAC5BnT,gBAAiB3D,MAAMC,KACrB,IAAIpB,IAAI,IAAC,UAAIiY,EAAenT,uBAAnB,QAAsC,GAAKgS,EAAcj7B,SAMlEy7B,GAAqD,CACzDR,EACAK,EACAE,KAEA,MAAMc,EACJrB,EAA6B,UAAfO,EAAyB,aAAe,gBACxD,OAAOe,GACLtB,EADyC,OAEzCqB,QAFyC,IAEzCA,OAFyC,EAEzCA,EAAcnE,UACdmD,IAISiB,GAAuC,CAClDtB,EACAuB,EACAlB,IAGEkB,IAAqBlB,EAAgBt7B,IAAMi7B,EAAc7nB,OAAOpb,OAAS,EAIhEykC,GACX7jB,IAEAA,EAASC,SAAS7H,IACZQ,GAAiBR,IACnB0oB,GAA0B1oB,EAAS,KAAM,UAKzC4qB,GAAsB,CAC1BX,EACAO,KAEA,MAAMkB,EAAuB,UAAflB,EAAyB,eAAiB,aAClDxC,EAAUiC,EAAcyB,GAC9B,OAAe,MAAX1D,EACK,MAET9S,GAAc+U,EAAe,CAAE,CAACyB,GAAQ,OACjC1D,EAAQb,YAGJc,GAA8B,CACzCkD,EAIA7X,IAEuBqY,GACrBrY,EAAMK,eACL3T,GACCU,GAAkBV,IAAYof,GAAkBpf,EAASmrB,KAKzDE,GAAuB,CAC3BpB,EACAmB,EACAZ,KAEA,MAAM5Y,EAA2B,UAAf4Y,GAA0B,EAAI,EAC1CoB,GAAgC,IAAfha,EAAmB,EAAIqY,EAAc7nB,OAAOpb,OAAS,EACtE6kC,EAAqBD,EAAiBha,EACtCka,EAAY5E,GAAoBgB,iCACpC+B,EACA2B,GAEIG,EAAgB7E,GAAoBgB,iCACxC+B,EACA4B,GAEF,MAAO,CACLG,MAAO5I,GAAuBgI,EAAgBW,EAAeD,GAC7DhI,IAAKvjC,KAAK+iB,IAAI,EAAGoc,GAA0B0L,EAAgBU,MASlDG,GAAsB,CACjCC,EACA/+B,KAII,IAAD,EACH,MAAM8qB,EAAe,UAAGiU,EAAejU,uBAAlB,QAAqC,GAC1D,GAA+B,IAA3BA,EAAgBjxB,OAClB,OAEF,MAAM,QAAEmlC,EAAF,sBAAWC,GAAX,OAAqCj/B,QAArC,IAAqCA,IAAW,GAChDk/B,EAAkCC,GACtCF,GAGAnZ,GAAM0C,SAASuW,GAAiBnY,sBAC9BkE,GAEFpQ,SAASoiB,IACT,MAAMK,EAAkB4B,EAExB,IAAKK,GAAetC,EAAeK,GACjC,OAEF,MAAMhR,EAAekT,GACnBlC,EACAL,EAAc3Q,aACd6S,GAEI5S,EAAaiT,GACjBlC,EACAL,EAAc1Q,WACd4S,GAGEE,EAAgCvjB,IAAImhB,EAAcj7B,IACpDkmB,GAAc+U,EAAe,CAAE3Q,eAAcC,gBAG/CkT,GACExC,EACA,QACA3Q,EACA4S,GAEFO,GACExC,EACA,MACA1Q,EACA2S,QAKAK,GAAiB,CACrBG,EACAR,KACI,IAAD,IACH,OACE,UAAAQ,EAAapT,oBAAb,eAA2B6N,aAAc+E,EAAel9B,KACxD,UAAA09B,EAAanT,kBAAb,eAAyB4N,aAAc+E,EAAel9B,IAIpDs9B,GACJF,GAEO,IAAIjZ,KAAKiZ,GAAyB,IAAI79B,KAAKyR,GAAYA,EAAQhR,MAGlEy9B,GAAmB,CACvBxC,EACAO,EACAxC,EACAkE,KAEA,GACa,MAAXlE,GAECA,EAAQb,YAAc+E,EAAel9B,IAAMi7B,EAAc7nB,OAAOpb,OAAS,EAE1E,OAEF,MAAM2lC,EAAiB1Z,GAAM0C,SAASsU,GAAgBrW,WACpDoU,EAAQb,WAEV,GAAsB,MAAlBwF,EAEF,OAEF,MAAM/a,EAA2B,UAAf4Y,GAA0B,EAAI,EAC1CoB,GAAgC,IAAfha,EAAmB,EAAIqY,EAAc7nB,OAAOpb,OAAS,EACtE6kC,EAAqBD,EAAiBha,EACtCma,EAAgB7E,GAAoBgB,iCACxC+B,EACA4B,GAEIe,EH6H2B,EACjC5sB,EAGAgsB,EACAa,KAEA,GAAc,IAAVb,EAAa,CACf,MAAMzJ,EAAgBld,GAAyBrF,GACzCqB,EAASmhB,GAAaD,GAC5B,OAAOlC,GAAgBhf,GAEzB,MAAMgiB,EAAiBF,GAA8BnjB,GAC/C8sB,EAAmBrK,GACvBY,EACAhD,GAAawM,IAETE,EAAwBxP,GAAW8F,GACzC,IAAIjiB,EACJ,OAAQpB,EAAQtL,MACd,IAAK,YACL,IAAK,QACL,IAAK,OACL,IAAK,UACH0M,EAAQokB,GAA8BxlB,EAASgsB,EAAOc,GACtD,MACF,IAAK,UACH1rB,EAAQ+jB,GAAyBnlB,EAASgsB,EAAOc,GAGrD,OAAOzM,GAAgBoC,GAAkBsK,EAAuB3rB,KG3JrC4rB,CACzBL,EACA3E,EAAQgE,MACRD,GAEF,IAAIkB,EAGJ,GAAoB,IAAhBjF,EAAQlE,IACVmJ,EAAeL,MACV,CACL,MAAM/I,EHqJ8B,SACtC7jB,EAEAyc,EAEAC,GAGa,IADboH,EACY,uDADE,EAEd,MAAMT,EAAiBF,GAA8BnjB,GAC/CsjB,EAAOb,GAAkBY,EAAgBhD,GAAa5D,IACtD8G,EAAOd,GAAkBY,EAAgBhD,GAAa3D,IACtDpnB,EAAOgrB,GAAegD,EAAMC,GAC5BwJ,EAAwBxP,GAAW8F,GAOzC,OANsBM,GACpB3jB,EACA1K,EACAguB,EACAQ,GAEmBv1B,KAAK6S,GACxBif,GAAgBoC,GAAkBsK,EAAuB3rB,MG1KnC8rB,CACpBP,EACAZ,EACAa,EACA5E,EAAQlE,KAKRmJ,EAH2B,IAAzBpJ,EAAc78B,OAGD4lC,EAGA/I,EAAc,GAGjCqD,GAAoBa,UAClBkC,EACA2B,EACA1E,GAAoBiG,wBAAwBlD,EAAegD,GAC3D,CAAE,CAAgB,UAAfzC,EAAyB,eAAiB,cAAexC,KAI1DwE,GAAkC,CACtCN,EACAkB,EACAjB,KAEA,GAAsB,MAAlBiB,GAAqC,MAAXjB,EAC5B,OAAOiB,EAET,MAAM,IAAEtJ,EAAF,MAAOkI,EAAP,UAAc7E,GAAciG,GAC1Bp3B,MAAOq3B,EAAUn3B,OAAQo3B,GAAcnB,GACzC,MAAEn2B,EAAF,OAASE,GAAWg2B,EAQ1B,MAAO,CAAE/E,YAAWrD,IAPLvjC,KAAK+iB,IAClB,EACA/iB,KAAK2T,IACHmrB,GAAc6M,EAAgBmB,EAAUC,GACxCxJ,GAAOuJ,EAAWC,EAAYD,EAAWr3B,EAAQs3B,EAAYp3B,KAGhC81B,UAsB7BuB,GACJtD,GAEO,CACLa,GAAqCb,EAAe,SACpDa,GAAqCb,EAAe,QACpDr6B,QACCoQ,GACY,MAAXA,IAIA8qB,GAAuC,CAC3Cb,EACAO,IAEOvC,GACLuF,GAA0BvD,EAAeO,GACzCvX,GAAM0C,SAASsU,IAIbuD,GAA4B,CAChCvD,EACAO,KAEA,MAAM75B,EAAuB,UAAf65B,EAAyB,GAAK,EAC5C,OAAOpxB,GACL8tB,GAAoBgB,iCAAiC+B,EAAet5B,KAIlEq6B,GACJV,GAEOrX,GAAM0C,SAAS2U,GACnB3W,cACAplB,KAAKyR,IACJ,IAAKQ,GAAiBR,GACpB,OAAO,KAET,MAAMytB,EAAeC,GACnB1tB,EACA,QACAsqB,GAEIqD,EAAaD,GACjB1tB,EACA,MACAsqB,GAEF,OAAKmD,GAAiBE,EAGf,CACL3tB,EACAytB,GAAgBE,EAAa,OAASF,EAAe,QAAU,MAC/DnD,GALO,QAQV16B,QAAQg+B,GAAiC,MAAhBA,IAGxBF,GAAiD,CACrDzD,EACAO,EACAF,IAKqB,MAFnBL,EAA6B,UAAfO,EAAyB,eAAiB,gBAGvDC,GACCR,EACAK,EACAE,IAEFpL,GACEkL,EACAkD,GAA0BvD,EAAeO,IAQlCqD,GAA8B,CACzCC,EACAC,EACAC,EAKAC,KAIA,MAAMC,EAAmD,IAAI/a,IACvDgb,EAAsD,IAAIhb,IAC1Dib,EAA8C,yBAAzBH,EAC3BF,EAAYlmB,SAASwmB,IACnB,MAAM,gBAAEpW,GAAoBoW,EAS5B,GARuB,MAAnBpW,GAA2BA,EAAgBjxB,OAAS,IACtDixB,EAAgBpQ,SAASymB,IACnBF,IAAuBJ,EAAoBllB,IAAIwlB,IACjDJ,EAAmBxZ,IAAI4Z,MAG3BH,EAAsBzZ,IAAIsZ,EAAoB7jB,IAAIkkB,EAAWr/B,MAE3DwR,GAAiB6tB,GAAa,CAChC,GAA+B,MAA3BA,EAAW/U,aAAsB,CACnC,MAAM,UAAE6N,GAAckH,EAAW/U,aAC7B8U,IAAuBJ,EAAoBllB,IAAIqe,IACjDgH,EAAsBzZ,IAAIyS,GAG9B,GAA6B,MAAzBkH,EAAW9U,WAAoB,CACjC,MAAM,UAAE4N,GAAckH,EAAW9U,WAC7B6U,IAAuBJ,EAAoBllB,IAAIqe,IACjDgH,EAAsBzZ,IAAIyS,GAGC,MAA3BkH,EAAW/U,cAAiD,MAAzB+U,EAAW9U,YAChD2U,EAAmBxZ,IAAIsZ,EAAoB7jB,IAAIkkB,EAAWr/B,SAO9D8+B,EAAcl+B,QAAO,QAAC,GAAEZ,GAAH,SACnBk/B,EAAmBplB,IAAI9Z,MAEzB6Y,SAAS7H,IACT,MAAM,aAAEsZ,EAAF,WAAgBC,GAAevZ,EACrCkV,GAAclV,EAAS,CACrBsZ,aAAciV,GACZjV,EACA0U,GAEFzU,WAAYgV,GAA2BhV,EAAYyU,QAKvDF,EACGl+B,QAAO,QAAC,GAAEZ,GAAH,SAAYm/B,EAAsBrlB,IAAI9Z,MAC7C6Y,SAASyiB,IACR,MAAM,gBAAErS,GAAoBqS,EACL,MAAnBrS,GAA2BA,EAAgBjxB,OAAS,GACtDkuB,GAAcoV,EAAiB,CAC7BrS,gBAAiBA,EAAgB1pB,KAC9B+/B,IAAD,uBACEN,EAAoB7jB,IAAImkB,UAD1B,QAC6CA,WAOnDC,GAA6B,CACjCvG,EACAgG,KACyB,IAAD,EACxB,GAAe,MAAXhG,EACF,OAAO,KAET,MAAM,UAAEb,EAAF,MAAa6E,EAAb,IAAoBlI,GAAQkE,EAClC,MAAO,CACLgE,QACAlI,MACAqD,UAAS,UAAE6G,EAAoB7jB,IAAIgd,UAA1B,QAAwCA,IAIxCqH,GAA2B,CACtCV,EACAW,KAEA,MAAMC,EAAoB,IAAIvb,IAC5Bsb,EAAgBlgC,KAAKyR,GAAYA,EAAQhR,MAGrCipB,EAAgD,IAAI9E,IAC1Dsb,EAAgB5mB,SAAS8mB,IACiB,IAAD,EAAnCjuB,GAAkBiuB,KACpB,UAAAA,EAAe1W,uBAAf,SAAgCpQ,SAAS7Y,IAClC0/B,EAAkB5lB,IAAI9Z,IACzBipB,EAAgBvD,IAAI1lB,UAM1B8+B,EAAcl+B,QAAO,QAAC,GAAEZ,GAAH,SACnBipB,EAAgBnP,IAAI9Z,MAEtB6Y,SAAS7H,IACT,MAAM,aAAEsZ,EAAF,WAAgBC,GAAevZ,EACrCkV,GAAclV,EAAS,CACrBsZ,aAAcsV,GAAwBtV,EAAcoV,GACpDnV,WAAYqV,GAAwBrV,EAAYmV,SAKhDE,GAA0B,CAC9B5G,EACA0G,IAEe,MAAX1G,GAAmB0G,EAAkB5lB,IAAIkf,EAAQb,WAC5C,KAEFa,ECvnBI6G,GAAkB7tB,GACzBA,GAAS,EAAIzgB,KAAKC,GACbwgB,EAAQ,EAAIzgB,KAAKC,GAEnBwgB,EAoGH8tB,GAAsB,CAC1B9uB,EACA+uB,EACAC,EACA57B,KAEA,MAAOwN,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EACvB,IAAIC,EAAS,EAAIzgB,KAAKC,GAAM,EAAID,KAAK0uC,MAAMD,EAAWloB,EAAIioB,EAAWloB,GACjEzT,IACF4N,GAAS1gB,IAAsB,EAC/B0gB,GAASA,EAAQ1gB,KAEnB0gB,EAAQ6tB,GAAe7tB,GACvBkU,GAAclV,EAAS,CAAEgB,WA+BdkuB,GAA+B,CAC1ClvB,EACAmvB,EACA/7B,EACA27B,EACAC,KAKA,MAAOpuB,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,GAEhBme,EAAUC,GAAYxe,GAC3BouB,EACAC,EACAnoB,EACAC,GACC9G,EAAQgB,OAEX,IAAKhL,EAAOE,GACe,QAAzBi5B,EACI,CAACjQ,EAAWlf,EAAQlK,EAAGqpB,EAAWnf,EAAQzI,GAC1C,CACEyI,EAAQlK,EAAIkK,EAAQoC,OAAO,GAAG,GAAK8c,EACnClf,EAAQzI,EAAIyI,EAAQoC,OAAO,GAAG,GAAK+c,GAEvC/rB,KACD4C,EAAOE,GA1C8B,EACxCyG,EACA3G,EACAE,EACA8K,KAEA,MAAM2J,EAAOoL,GACXpZ,KACGgE,GAAO3K,EAAOE,EAAQ,EAAG,EAAG8K,IAEjC,OAAOL,GAAOgK,EAAK3U,MAAO2U,EAAKzU,OAAQ,EAAG,GAAI8K,IAgC1BouB,CAChBpvB,EAAQtL,KACRsB,EACAE,EACA8J,EAAQgB,QAGZ,MAAOquB,EAAcC,GAAgBhuB,GACV,QAAzB6tB,EACI,CAAErtB,GAAG,EAAMjT,GAAG,GACd,CAAEgT,GAAG,EAAMD,GAAG,GAClB5B,EAAQlK,EACRkK,EAAQzI,EACRyI,EAAQgB,MACR,EACA,GACChB,EAAQoC,OAAO,GAAG,GAAKpM,GAAS,GAChCgK,EAAQoC,OAAO,GAAG,GAAKlM,GAAU,GAEpCgf,GAAclV,EAAS,CACrBlK,EAAGu5B,EACH93B,EAAG+3B,EACHltB,OAAQ,CACN,CAAC,EAAG,GACJ,CAACpM,EAAOE,OAKRq5B,GAAyB,CAC7BvvB,EACAhK,EACAE,IAEAoK,GAAgBN,IAAYI,GAAkBJ,GAC1C,CACEoC,OAAQiC,GACN,EACArO,EACAqO,GAAc,EAAGnO,EAAQ8J,EAAQoC,UAGrC,GAIAotB,GAAwB,CAC5BxvB,EACA+H,EACAC,KAGA,MAAMynB,EAAezvB,EAAQ7K,UAAY4S,EAAY/H,EAAQhK,OAC7D,GAAIy5B,EATgB,EAUlB,OAAO,KAET,MAAMlX,EAAUnjB,GACd4K,EAAQ9U,KACRgK,GAAc,CAAEC,SAAUs6B,EAAc16B,WAAYiL,EAAQjL,cAE9D,MAAO,CACL4V,KAAM8kB,EACNl5B,SAAUgiB,EAAQhiB,UAAYyR,EAAauQ,EAAQriB,UAwBjDw5B,GAA0B,CAC9B1vB,EACA0mB,EACA1zB,EACA+7B,EACAC,KAEA,MAAOpuB,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,GAEhBme,EAAUC,GAAYxe,GAC3BouB,EACAC,EACAnoB,EACAC,GACC9G,EAAQgB,OAEX,IAAI4O,EACJ,OAAQ8W,GACN,IAAK,KACH9W,EAAQrvB,KAAK+iB,KACV4b,EAAWte,IAAOE,EAAKF,IACvBue,EAAWte,IAAOE,EAAKF,IAE1B,MACF,IAAK,KACH+O,EAAQrvB,KAAK+iB,KACVxC,EAAKoe,IAAape,EAAKF,IACvBG,EAAKoe,IAAape,EAAKF,IAE1B,MACF,IAAK,KACH+O,EAAQrvB,KAAK+iB,KACV4b,EAAWte,IAAOE,EAAKF,IACvBG,EAAKoe,IAAape,EAAKF,IAE1B,MACF,IAAK,KACH+O,EAAQrvB,KAAK+iB,KACVxC,EAAKoe,IAAape,EAAKF,IACvBue,EAAWte,IAAOE,EAAKF,IAI9B,GAAI+O,EAAQ,EAAG,CACb,MAAM7H,EAAY/H,EAAQhK,MAAQ4Z,EAC5B5H,EAAahI,EAAQ9J,OAAS0Z,EAC9B+f,EAAWH,GAAsBxvB,EAAS+H,EAAWC,GAC3D,GAAiB,OAAb2nB,EACF,OAEF,MAAO5W,EAAQC,EAAQC,EAAQC,GAAUpR,GACvC9H,EACA+H,EACAC,GAEIxG,GAAWZ,EAAKmY,GAAU,EAC1BtX,GAAWZ,EAAKmY,GAAU,EAC1BtX,GAAWZ,EAAKmY,GAAU,EAC1BtX,GAAWZ,EAAKmY,GAAU,GACzBmW,EAAcC,GAAgBhuB,GAjFN,EACjColB,EACA1zB,KAEO,CACL6O,EACE,cAAcpP,KAAKi0B,IAClB1zB,GAA0B,cAAcP,KAAKi0B,GAChD5kB,EACE,cAAcrP,KAAKi0B,IAClB1zB,GAA0B,cAAcP,KAAKi0B,GAChD9kB,EACE,cAAcnP,KAAKi0B,IAClB1zB,GAA0B,cAAcP,KAAKi0B,GAChD73B,EACE,cAAc4D,KAAKi0B,IAClB1zB,GAA0B,cAAcP,KAAKi0B,KAkE9CkJ,CAA2BlJ,EAAqB1zB,GAChDgN,EAAQlK,EACRkK,EAAQzI,EACRyI,EAAQgB,MACRQ,EACAC,EACAC,EACAC,GAEFuT,GAAclV,EAAS,CACrB7K,SAAUw6B,EAAShlB,KACnB3U,MAAO+R,EACP7R,OAAQ8R,EACRzR,SAAUo5B,EAASp5B,SACnBT,EAAGu5B,EACH93B,EAAG+3B,MAKIO,GAAsB,CACjCC,EACA58B,EACA8M,EACA+vB,EACA/8B,EACA+7B,EACAC,KAGA,MAAOpuB,EAAIC,EAAIC,EAAIC,GAAM+G,GACvBgoB,EACAA,EAAmB95B,MACnB85B,EAAmB55B,QAEf85B,EAAsB,CAACpvB,EAAIC,GAC3BovB,EAA0B,CAACnvB,EAAIC,GAC/BmvB,EpBlQC,GADmBzT,EoBmQauT,GpBlQ5B,IADyBtT,EoBmQiBuT,GpBlQnC,IAAM,GAAIxT,EAAE,GAAKC,EAAE,IAAM,GADlB,IAACD,EAAUC,EoBsQpC,MAAMyT,EAAiBhvB,GACrB,CAAC4tB,EAAUC,GACXkB,GACCJ,EAAmB9uB,QAIfovB,EAAMC,EAAMC,EAAMC,GAAQzoB,GAC/B9H,EACAA,EAAQhK,MACRgK,EAAQ9J,QAEJs6B,EAAqBF,EAAOF,EAC5BK,EAAsBF,EAAOF,EAMnC,IAAIK,GAFuBT,EAAiB,GAAKD,EAAa,IAE5BQ,EAC9BG,GAFwBV,EAAiB,GAAKD,EAAa,IAE5BS,EAE/BV,EAAyB90B,SAAS,OACpCy1B,GAAUP,EAAe,GAAKH,EAAa,IAAMQ,GAE/CT,EAAyB90B,SAAS,OACpC01B,GAAUR,EAAe,GAAKH,EAAa,IAAMS,GAE/CV,EAAyB90B,SAAS,OACpCy1B,GAAUT,EAAiB,GAAKE,EAAe,IAAMK,GAEnDT,EAAyB90B,SAAS,OACpC01B,GAAUV,EAAiB,GAAKE,EAAe,IAAMM,GAGvD,MAAMG,EAAkBd,EAAmB95B,MACrC66B,EAAmBf,EAAmB55B,OAG5C,IAAI46B,EAAc9wB,EAAQhK,MAAQ06B,EAC9BK,EAAe/wB,EAAQ9J,OAASy6B,EASpC,GANI39B,IACF89B,EAAc,EAAIA,EAAcF,EAChCG,EAAe,EAAIA,EAAeF,GAIhC39B,EAA2B,CAC7B,MAAM89B,EAAazwC,KAAKiX,IAAIs5B,GAAeF,EACrCK,EAAc1wC,KAAKiX,IAAIu5B,GAAgBF,EAK7C,GAJwC,IAApCd,EAAyB/oC,SAC3B+pC,GAAgBC,EAChBF,GAAeG,GAEuB,IAApClB,EAAyB/oC,OAAc,CACzC,MAAMkqC,EAAQ3wC,KAAK+iB,IAAI0tB,EAAYC,GACnCH,EAAcF,EAAkBM,EAAQ3wC,KAAK81B,KAAKya,GAClDC,EAAeF,EAAmBK,EAAQ3wC,KAAK81B,KAAK0a,IAIxD,MAAOI,EAAaC,EAAaC,EAAaC,GAC5CxpB,GACEgoB,EACAgB,EACAC,GAEEQ,EAAiBF,EAAcF,EAC/BK,EAAkBF,EAAcF,EAGtC,IAAIK,EAAa,IAAIzB,GAOrB,GANI,CAAC,IAAK,IAAK,MAAM/0B,SAAS80B,KAC5B0B,EAAa,CACXxB,EAAiB,GAAK1vC,KAAKiX,IAAI+5B,GAC/BtB,EAAiB,GAAK1vC,KAAKiX,IAAIg6B,KAGF,OAA7BzB,EAAmC,CACrC,MAAM2B,EAAa,CAAC1B,EAAa,GAAIC,EAAiB,IACtDwB,EAAa,CAACC,EAAW,GAAIA,EAAW,GAAKnxC,KAAKiX,IAAIg6B,IAExD,GAAiC,OAA7BzB,EAAmC,CACrC,MAAM4B,EAAW,CAAC1B,EAAiB,GAAID,EAAa,IACpDyB,EAAa,CAACE,EAAS,GAAKpxC,KAAKiX,IAAI+5B,GAAiBI,EAAS,IAI7Dz+B,IACE,CAAC,IAAK,KAAK+H,SAAS80B,KACtB0B,EAAW,GAAKvB,EAAY,GAAKqB,EAAiB,GAEhD,CAAC,IAAK,KAAKt2B,SAAS80B,KACtB0B,EAAW,GAAKvB,EAAY,GAAKsB,EAAkB,IAKnDV,EAAc,IACZf,EAAyB90B,SAAS,OACpCw2B,EAAW,IAAMlxC,KAAKiX,IAAI+5B,IAExBxB,EAAyB90B,SAAS,OACpCw2B,EAAW,IAAMlxC,KAAKiX,IAAI+5B,KAI1BR,EAAe,IACbhB,EAAyB90B,SAAS,OACpCw2B,EAAW,IAAMlxC,KAAKiX,IAAIg6B,IAExBzB,EAAyB90B,SAAS,OACpCw2B,EAAW,IAAMlxC,KAAKiX,IAAIg6B,KAI1Bx+B,IACFy+B,EAAW,GAAKvB,EAAY,GAAK3vC,KAAKiX,IAAI+5B,GAAkB,EAC5DE,EAAW,GAAKvB,EAAY,GAAK3vC,KAAKiX,IAAIg6B,GAAmB,GAI/D,MAAMxwB,EAAQ8uB,EAAmB9uB,MAC3B4wB,EAAiBzwB,GAAYswB,EAAYvB,EAAalvB,GACtD6wB,EAAmB,CACvBJ,EAAW,GAAKlxC,KAAKiX,IAAI+5B,GAAkB,EAC3CE,EAAW,GAAKlxC,KAAKiX,IAAIg6B,GAAmB,GAExCM,EAAmB3wB,GAAY0wB,EAAW3B,EAAalvB,GAC7DywB,EAAatwB,GAAYywB,EAAgBE,GAAmB9wB,GAG5D,MAAM+wB,EAAiBxC,GACrBO,EACAgB,EACAC,GAIIiB,EAAY,IAAIP,GACtBO,EAAU,IAAMlC,EAAmBh6B,EAAIq7B,EACvCa,EAAU,IAAMlC,EAAmBv4B,EAAI65B,EAEvC,MAAMa,EAAiB,CACrBj8B,MAAOzV,KAAKiX,IAAIs5B,GAChB56B,OAAQ3V,KAAKiX,IAAIu5B,GACjBj7B,EAAGk8B,EAAU,GACbz6B,EAAGy6B,EAAU,MACVD,GAGD,UAAW/xB,GAAW,UAAW8vB,GACnC5a,GAAclV,EAAS,CACrB4P,MAAO,EAEJrvB,KAAK81B,KAAKqa,IAAWZ,EAAmBlgB,MAAM,IAC7CkgB,EAAmBlgB,MAAM,IAC1BrvB,KAAK81B,KAAKsa,IAAWb,EAAmBlgB,MAAM,IAC7CkgB,EAAmBlgB,MAAM,MAMN,IAAzBqiB,EAAej8B,OACW,IAA1Bi8B,EAAe/7B,QACfyM,OAAOwW,SAAS8Y,EAAen8B,IAC/B6M,OAAOwW,SAAS8Y,EAAe16B,KAE/B00B,GAAoBjsB,EAAS,CAC3BmsB,QAAS,CAAEn2B,MAAOi8B,EAAej8B,MAAOE,OAAQ+7B,EAAe/7B,UAEjEgf,GAAclV,EAASiyB,KAIrBC,GAAyB,CAC7BtqB,EACA8e,EACAqI,EACAC,KAEA,MAAOpuB,EAAIC,EAAIC,EAAIC,GAAM4G,GAAgBC,GACzC,IAAIgI,EACAuiB,EAKJ,OAAQzL,GACN,IAAK,KACH9W,EAAQrvB,KAAK+iB,KACVyrB,EAAWnuB,IAAOE,EAAKF,IACvBouB,EAAWnuB,IAAOE,EAAKF,IAE1BsxB,EAAY,CAACnyB,EAAD,OAAoD,IAAzCoyB,EAAQC,GAAgC,GAAtBC,EAASC,GAAa,EAG7D,MAAO,CAAEz8B,EAFCkK,EAAQlK,GAAKs8B,EAASxxB,IAAOgP,EAAQ,GAAKwiB,EAASE,EAEjD/6B,EADFyI,EAAQzI,GAAK86B,EAASxxB,IAAO+O,EAAQ,GAAKyiB,EAASE,IAG/D,MACF,IAAK,KACH3iB,EAAQrvB,KAAK+iB,KACVxC,EAAKiuB,IAAajuB,EAAKF,IACvBG,EAAKiuB,IAAajuB,EAAKF,IAE1BsxB,EAAY,CAACnyB,EAAD,OAA4D,IAAjD,CAAC,CAAGwyB,EAAQC,GAAoC,GAA1B,CAAC,CAAGC,EAASC,GAAa,EAGrE,MAAO,CAAE78B,EAFCkK,EAAQlK,GAAKgL,EAAK0xB,IAAW5iB,EAAQ,GAAK4iB,EAASE,EAEjDn7B,EADFyI,EAAQzI,GAAKwJ,EAAK0xB,IAAW7iB,EAAQ,GAAK6iB,EAASE,IAG/D,MACF,IAAK,KACH/iB,EAAQrvB,KAAK+iB,KACVyrB,EAAWnuB,IAAOE,EAAKF,IACvBG,EAAKiuB,IAAajuB,EAAKF,IAE1BsxB,EAAY,CAACnyB,EAAD,OAA4D,IAAjDoyB,EAAD,EAAaK,GAAoC,GAA1BH,EAAD,EAAcK,GAAa,EAGrE,MAAO,CAAE78B,EAFCkK,EAAQlK,GAAKs8B,EAASxxB,IAAOgP,EAAQ,GAAKwiB,EAASE,EAEjD/6B,EADFyI,EAAQzI,GAAKwJ,EAAK0xB,IAAW7iB,EAAQ,GAAK6iB,EAASE,IAG/D,MACF,IAAK,KACH/iB,EAAQrvB,KAAK+iB,KACVxC,EAAKiuB,IAAajuB,EAAKF,IACvBouB,EAAWnuB,IAAOE,EAAKF,IAE1BsxB,EAAY,CAACnyB,EAAD,OAAwD,IAA7C,CAAEqyB,EAAQG,GAAkC,GAAxB,CAAED,EAASG,GAAa,EAGjE,MAAO,CAAE58B,EAFCkK,EAAQlK,GAAKgL,EAAK0xB,IAAW5iB,EAAQ,GAAK4iB,EAASE,EAEjDn7B,EADFyI,EAAQzI,GAAK86B,EAASxxB,IAAO+O,EAAQ,GAAKyiB,EAASE,IAKnE,GAAI3iB,EAAQ,EAAG,CACb,MAAMuF,EAAUvN,EAASrb,QACvB,CAACqmC,EAAM5yB,KACL,IAAK4yB,EACH,OAAOA,EAET,MAAM58B,EAAQgK,EAAQhK,MAAQ4Z,EACxB1Z,EAAS8J,EAAQ9J,OAAS0Z,EAChC,IAAIva,EAAiD,GACrD,GAAqB,SAAjB2K,EAAQtL,KAAiB,CAC3B,MAAMi7B,EAAWH,GAAsBxvB,EAAShK,EAAOE,GACvD,GAAiB,OAAby5B,EACF,OAAO,KAETt6B,EAAO,CAAEF,SAAUw6B,EAAShlB,KAAMpU,SAAUo5B,EAASp5B,UAEvD,MAAMs8B,EAAaxtB,GAAyBrF,GAEtC+xB,EAAiBxC,GAAuBvvB,EAAShK,EAAOE,GAE9D+1B,GAAoBjsB,EAAS,CAC3BmsB,QAAS,CAAEn2B,QAAOE,UAClBk2B,sBAAuBxkB,IAGzB,MAAMkrB,EAAchrB,GAClB,IACK9H,KACA+xB,GAEL/7B,EACAE,IAGI,EAAEJ,EAAF,EAAKyB,GAAM46B,EAAUnyB,EAAS6yB,EAAYC,GAChD,MAAO,IAAIF,EAAM,CAAE58B,QAAOE,SAAQJ,IAAGyB,OAAMw6B,KAAmB18B,MAEhE,IAYE8f,GACFvN,EAASC,SAAQ,CAAC7H,EAASrP,KACzBukB,GAAclV,EAASmV,EAAQxkB,SAMjCoiC,GAAyB,CAC7BC,EACAprB,EACAmnB,EACAC,EACA57B,EACA6/B,EACAC,KAEA,IAAIC,EACD,EAAI5yC,KAAKC,GAAM,EAAID,KAAK0uC,MAAMD,EAAWkE,EAASnE,EAAWkE,GAC5D7/B,IACF+/B,GAAe7yC,IAAsB,EACrC6yC,GAAeA,EAAc7yC,KAE/BsnB,EAASC,SAAQ,CAAC7H,EAASrP,KAAW,IAAD,IACnC,MAAOiQ,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5C6G,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EACjBqyB,EAAS,oBACbJ,EAAiBK,iBAAiBlpB,IAAInK,EAAQhR,WADjC,aACb,EAAmDgS,aADtC,QAC+ChB,EAAQgB,OAC/DsyB,EAAWC,GAAa5yB,GAC7BkG,EACAC,EACAmsB,EACAC,EACAC,EAAcC,EAAYpzB,EAAQgB,OAEpCkU,GAAclV,EAAS,CACrBlK,EAAGkK,EAAQlK,GAAKw9B,EAAYzsB,GAC5BtP,EAAGyI,EAAQzI,GAAKg8B,EAAYzsB,GAC5B9F,MAAO6tB,GAAesE,EAAcC,SCjqB7BI,GAAiB,CAC5Bl3B,EACAK,EACA82B,EACAC,EACA59B,EACAyB,EACAvB,EACAE,EACAhD,EACAF,EAGA2gC,KAEIzgC,IACEygC,EACFz9B,EAASF,EAAQ29B,KAEd39B,QAAOE,UAAW6f,GACnBpZ,EACA3G,EACAuB,EAAIm8B,GAAWx9B,EAASA,IAGtBA,EAAS,IACXA,GAAUA,KAKhB,IAAI09B,EAAO99B,EAAI29B,EAAUA,EAAUz9B,EAAQy9B,EACvCI,EAAOt8B,EAAIm8B,EAAUA,EAAUx9B,EAASw9B,EAExC1gC,IAGF4gC,EAAOH,GAFPz9B,GAASA,GAEgB,EACzB69B,EAAOH,GAFPx9B,GAAUA,GAEgB,GAGd,IAAVF,GAA0B,IAAXE,GACjBgf,GAAc5Y,EAAiB,CAC7BxG,EAAG89B,EACHr8B,EAAGs8B,EACH79B,QACAE,YC7FA49B,GAAiB5oC,GAEnBA,EAEGiG,QAAQ,MAAO,YAEfA,QAAQ,YAAa,MAItB4iC,GAAe,CACnB/9B,EACAE,EACA8K,EACA9B,EACA80B,KAEA,MAAM,KAAE17B,EAAF,UAAQ9B,EAAR,WAAmB+B,GAAe2G,EAClC+R,EAAU,IAAMjQ,EAASzgB,KAAKC,GAGpC,IAAIyzC,GAAej+B,EAAqB,EAAbuC,IAAmBD,EAAKvP,MAAQ,GAAM,EACjE,MAAMmrC,GAAeh+B,EAAqB,EAAZM,IAAkB8B,EAAKvP,MAAQ,GAAM,EAInE,OAHIiN,EAAQg+B,GAA2B,IAAf17B,EAAKvP,QAC3BkrC,EAAcD,EAAW,GAAM17B,EAAKvP,MAAQ,IAExC,aAAN,OAAoBkrC,EAApB,eAAqCC,EAArC,qBAA4D57B,EAAKvP,MAAjE,oBAAkFkoB,EAAlF,SC9BWkjB,GAAyBn0B,IACpC,MAAMuY,EAAUnjB,GAAY4K,EAAQ9U,KAAMgK,GAAc8K,IACxDkV,GAAclV,EAAS,CACrBhK,MAAOuiB,EAAQviB,MACfE,OAAQqiB,EAAQriB,OAChBK,SAAUgiB,EAAQhiB,YCLT69B,GAA2B,CACtCl1B,EACA0I,IAEAysB,SACGn1B,EAASN,kBACPM,EAAS3C,gBACR6a,GAAoBxP,EAAU1I,GAAUlY,QACf,cAAzBkY,EAASvC,cCiDJ23B,GAAiB1sB,GAC5BA,EAASrb,QACP,CAACC,EAA2CwT,KAC1CxT,EAAIwT,EAAQhR,IAAMgR,EACXxT,IAET,IAGS+nC,GAAmB3sB,GAC9BA,EAASrb,QAAO,CAACC,EAAKgoC,IAAOhoC,EAAMgoC,EAAGjpC,SAAS,GAOpCwoB,GAAyBnM,GACpCA,EAAShY,QACNoQ,IAAaA,EAAQmY,YAGbrE,GACX9T,IAC8BA,EAAQmY,UAElCsc,GACJ7sB,GAEAmM,GAAsBnM,GAAUrZ,KAAKyR,GACnCO,GAAoBP,EAAQtL,MACxB,IAAKsL,EAASwS,mBAAoB,MAClCxS,IAGK00B,GACX9sB,GACG6sB,GAAe7sB,GAEP+sB,GACX/sB,GACG6sB,GAAe7sB,GAEPgtB,GACXhtB,GACG6sB,GAAe7sB,GCjGPitB,GAAkB,kBAElBC,GAAgB,CAC3BltB,EACAmtB,EACAC,EAH2B,KAaX,IAThB,QACEx8B,EADF,QAEEC,EAFF,KAGEH,GAMa,EACf,GAAwB,IAApBsP,EAAS5gB,OACX,MAAO,CACLiuC,WAAY,KACZC,SAAU,MAId,MAAOC,EAAcC,EAAcC,EAAcC,GAC/C3tB,GAAgBC,GAGZ2tB,EAAwBR,EAAgBz8B,EAAKvP,MAC7CysC,EAAyBR,EAAiB18B,EAAKvP,MAE/C0sC,EAAoBV,EAAgBQ,EACpCG,EAAqBV,EAAiBQ,EAEtCG,EAAW,CACfC,IAAKC,SAAS/8B,GAAqB,QACnCg9B,OAAQD,SAAS/8B,GAAqB,QACtCpJ,KAAMmmC,SAAS/8B,GAAqB,QACpCnJ,MAAOkmC,SAAS/8B,GAAqB,SAGjCK,EAAQ3I,IAAcjB,IAGtBwmC,EAA0BN,EAAoB,EAA9Bj9B,EAAkCm9B,EAASjmC,KAC3DsmC,EAA0BN,EAAqB,EAA/Bj9B,EAAmCk9B,EAASC,IAC5DK,EAAeF,EAAeR,EAAwBI,EAAShmC,MAC/DumC,EAAeF,EAAeR,EAAyBG,EAASG,OAGhEK,EAAY51C,KAAK2T,IAAIihC,EAAcY,GACnCK,EAAY71C,KAAK2T,IAAIkhC,EAAcY,GACnCK,EAAY91C,KAAK+iB,IAAI+xB,EAAcY,GACnCK,EAAY/1C,KAAK+iB,IAAIgyB,EAAcY,GAIzC,MAAO,CACLjB,WACEc,IAAiBI,GAAaF,IAAiBI,EAC3C,KACA,CACEvgC,EACEvV,KAAK+iB,IAAIqyB,EAASjmC,KAhEA,IAiEhBqmC,EAAeI,IAAcE,EAAYF,GACzCpB,EACJx9B,EACEy9B,EAnEiB,EAqEjBz0C,KAAK+iB,IAtEa,EAsESqyB,EAASG,QACtC9/B,OACIigC,EAAeF,IAAiBM,EAAYF,GAC5CpB,EACFx0C,KAAK+iB,IAAIizB,EAAsBZ,EAASjmC,KAAOimC,EAAShmC,OAC1DuG,OA1EmB,GA4E3Bg/B,SACEc,IAAiBI,GAAaF,IAAiBI,EAC3C,KACA,CACExgC,EAAGqD,EACC5Y,KAAK+iB,IAAIqyB,EAASjmC,KAlFF,GAmFhBqlC,EAlFe,EAoFfx0C,KAAK+iB,IAAIqyB,EAAShmC,MArFF,GAsFpB4H,GACIy+B,EAAeI,IAAcE,EAAYF,GACzCpB,EACFz0C,KAAK+iB,IAAIqyB,EAASC,IAzFA,GA0FpB5/B,MAzFmB,EA0FnBE,QACIggC,EAAeF,IAAiBM,EAAYF,GAC5CpB,EACFz0C,KAAK+iB,IAAIizB,EAAsBZ,EAASC,IAAMD,EAASG,WAKxDU,GAAmB,CAC9BC,EACA3gC,EACAyB,KAMA,MAAOm/B,EAAkBC,GAAkB,CACzCF,EAAWxB,WACXwB,EAAWvB,UACX3mC,KAAKqoC,GAEU,MAAbA,GACAA,EAAU9gC,GAAKA,GACfA,GAAK8gC,EAAU9gC,EAAI8gC,EAAU5gC,OAC7B4gC,EAAUr/B,GAAKA,GACfA,GAAKq/B,EAAUr/B,EAAIq/B,EAAU1gC,SAIjC,MAAO,CAAE2gC,aADYH,GAAoBC,EAClBD,mBAAkBC,mBCrG9BG,GAAwB,CACnClvB,EACA1I,IAEA0I,EAASsa,MAAMliB,GAAYd,EAASjB,mBAAmB+B,EAAQhR,MAqBpDooB,GAAsB,CACjCxP,EACA1I,IACG0I,EAAShY,QAAQoQ,GAAYd,EAASjB,mBAAmB+B,EAAQhR,MAEzD+nC,GAAoB,CAC/BnvB,EACA1I,IAEAA,EAAS3C,eACL,CAAC2C,EAAS3C,gBACV6a,GAAoBxP,EAAU1I,GC9BvB83B,GAAiB,IAQvB,IARwB,WAC7BC,EAD6B,mBAE7BC,EAF6B,KAG7B5+B,GAKI,EACJ,MAAO,CACLE,QACG0+B,EAAmBlhC,MAAQ,GAAM,EAAIsC,EAAKvP,OAC3CkuC,EAAWnhC,EACXwC,EAAKrH,YAAY6E,GAAK,EAAIwC,EAAKvP,OACjC0P,QACGy+B,EAAmBhhC,OAAS,GAAM,EAAIoC,EAAKvP,OAC5CkuC,EAAW1/B,EACXe,EAAKrH,YAAYsG,GAAK,EAAIe,EAAKvP,SAIxBouC,GAAwB,CACnCvvB,EACA1I,EACAxH,KAIA,KAFAkQ,EHciCA,IACjCA,EAAShY,QACN4kC,IAAQA,EAAGrc,YAAcrC,GAAwB0e,KGhBzC4C,CAAmBxvB,IAEhB5gB,OACZ,MAAO,CACLwR,QAAS,EACTC,QAAS,GAGb,IAAKmI,EAAIC,EAAIC,EAAIC,GAAM4G,GAAgBC,GAtDf,EACxB1I,EACAxH,EACA2/B,KAEA,MAAOz2B,EAAIC,EAAIC,EAAIC,GAAMs2B,GACjBvhC,EAAGwhC,EAAY//B,EAAGggC,GAAe5+B,GACvC,CAAEC,OAAQgI,EAAI/H,OAAQgI,GACtB3B,IAEMpJ,EAAG0hC,EAAYjgC,EAAGkgC,GAAe9+B,GACvC,CAAEC,OAAQkI,EAAIjI,OAAQkI,GACtB7B,GAEF,OACEs4B,EAAaF,EAAap4B,EAASlJ,OACnCyhC,EAAaF,EAAar4B,EAAShJ,QAwCjCwhC,CAAkBx4B,EAAUxH,EAAQ,CAACkJ,EAAIC,EAAIC,EAAIC,OAClDH,EAAIC,EAAIC,EAAIC,G1BsasB,EACrC6G,EACA2M,KAEA,IAAK3M,EAAS5gB,OACZ,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAI2wC,EAAc5yB,IACd6yB,EAAiBhwB,EAAS,GAY9B,OAVAA,EAASC,SAAS7H,IAChB,MAAOY,EAAIC,EAAIC,EAAIC,GAAM4F,GAAiB3G,GACpC1I,EAAWyK,IAAYnB,EAAKE,GAAM,GAAID,EAAKE,GAAM,EAAGwT,EAAKze,EAAGye,EAAKhd,GAEnED,EAAWqgC,IACbA,EAAcrgC,EACdsgC,EAAiB53B,MAId2G,GAAiBixB,I0B3bHC,CACjBjwB,EACAzP,GACE,CAAEC,QAAS8G,EAAS1G,QAASH,QAAS6G,EAASzG,SAC/CyG,KAQN,OAAO83B,GAAe,CACpBC,WAAY,CAAEnhC,GAJC8K,EAAKE,GAAM,EAIAvJ,GAHXsJ,EAAKE,GAAM,GAI1Bm2B,mBAAoB,CAAElhC,MAAOkJ,EAASlJ,MAAOE,OAAQgJ,EAAShJ,QAC9DoC,KAAM4G,EAAS5G,QC9ENw/B,GAAiBpjC,GACnB,cAATA,GACS,YAATA,GACS,YAATA,GACS,SAATA,EAEWqjC,GAAkBrjC,GAA0B,UAATA,EAEnCsjC,GAAkBtjC,GACpB,cAATA,GACS,YAATA,GACS,YAATA,GACS,aAATA,GACS,UAATA,GACS,SAATA,EAEWujC,GAAkBvjC,GACpB,cAATA,GACS,YAATA,GACS,YAATA,GACS,UAATA,GACS,SAATA,EAEWwjC,GAAsBxjC,GACxB,cAATA,GAAiC,UAATA,GAA6B,SAATA,EAEjCyjC,GAAWzjC,GAA0B,SAATA,EAE5B0jC,GAAqB1jC,GAA0B,UAATA,EAEtCi3B,GAAuB,CAClC/jB,EACAywB,KAEA,IAAI/P,EAAa,KAIjB,IAAK,IAAI33B,EAAQiX,EAAS5gB,OAAS,EAAG2J,GAAS,IAAKA,EAAO,CACzD,MAAMqP,EAAU4H,EAASjX,GACzB,IAAIqP,EAAQmY,WAGRkgB,EAAer4B,GAAU,CAC3BsoB,EAAatoB,EACb,OAIJ,OAAOsoB,GCtDIgQ,GAAa,SACxBC,EACAC,EACAC,GAEU,IADVC,EACS,uDAD4B,CAAE5iC,EAAG,EAAGyB,EAAG,GAEhD,MAAO,CACLxO,MAAOwvC,EACPtnC,YAAa,CACX6E,EACE4iC,EAAoB5iC,EACpB2iC,EAAa/oC,MACZgpC,EAAoB5iC,EAAI2iC,EAAa/oC,KAAO8oC,EAASvnC,YAAY6E,IAC/DyiC,EAAeC,EAASzvC,OAC7BwO,EACEmhC,EAAoBnhC,EACpBkhC,EAAa7C,KACZ8C,EAAoBnhC,EAAIkhC,EAAa7C,IAAM4C,EAASvnC,YAAYsG,IAC9DghC,EAAeC,EAASzvC,UAKtB4vC,GAAqBrgC,IAChC,MAAMsgC,EAAiBC,WAAWvgC,EAAKmC,QAAQ,IAE/C,OADoBla,KAAK+iB,IAAI,GAAK/iB,KAAK2T,IAAI0kC,EAAgB,M,MCzBtD,MAAME,WAAoBhvC,MAC/BgwB,cAGG,IAFDif,EAEA,uDAFkB,0BAClBhyC,EACA,uDAD2B,eAE3BiyC,QACAzlB,KAAKxsB,KAAOA,EACZwsB,KAAKwlB,QAAUA,GAIZ,MAAME,WAAmBC,aAC9Bpf,cACEkf,MAD+C,uDAAnB,kBACb,e,kBCYJG,OAvBC,IAMT,IANU,KACfxuB,EAAO,MADQ,YAEfyuB,EAAc,GAIV,EACJ,OACE,sBAAKC,UAAU,UAAf,SACE,sBAAKC,QAAQ,cAAc7jC,MAAO,CAAEO,MAAO2U,EAAMzU,OAAQyU,GAAzD,SACE,yBACE9D,GAAG,KACHC,GAAG,KACHzD,EAAG,GAAK+1B,EAAc,EACtBpwB,YAAaowB,EACb/uB,KAAK,OACLkvB,iBAAiB,YC0BpB,MAAMC,GAAaC,IAAMC,YAAW,CAACC,EAAwBC,KAClE,MAAQ5qC,GAAI6qC,GAAYC,KAClBC,EAAWN,IAAMO,OAAO,MAC9BP,IAAMQ,oBAAoBL,GAAK,IAAMG,EAASh3B,UAC9C,MAAMm3B,EAAM,wBAAoBP,EAAMhvB,OAE/BtN,EAAW88B,GAAgBt6B,oBAAS,GAErCu6B,EAAeJ,kBAAO,GAEtBK,EAAU1zC,UAAoC,IAAD,EACjD,MAAMoQ,EAAM,YAAa4iC,IAAb,UAAsBA,EAAMU,eAA5B,aAAsB,OAAAV,EAAgBhwC,IAElD,GAAIoN,GAAO,SAAUA,EACnB,IACEojC,GAAa,SACPpjC,EACN,MAAO1L,GACP,KAAMA,aAAiB4tC,IACrB,MAAM5tC,EALV,QAQM+uC,EAAar3B,SACfo3B,GAAa,KAMrBG,qBACE,IAAM,KACJF,EAAar3B,SAAU,IAEzB,IAGF,MAAMw3B,EAAqBP,iBAA2B,MAEtD,MAAmB,WAAfL,EAAMjlC,MAAoC,SAAfilC,EAAMjlC,KAEjC,0BACE2kC,UAAWmB,aACT,uBACAN,EACAP,EAAMN,UACNM,EAAMc,UAAYd,EAAMe,OACpB,6BACA,6BACJ,CACEC,UAAWhB,EAAMe,OACjB,qBAAsBf,EAAMiB,SAC5B,kBAAkC,SAAfjB,EAAMjlC,OAG7B,cAAailC,EAAM,eACnBe,OAAQf,EAAMe,OACdG,MAAOlB,EAAMkB,MACb,aAAYlB,EAAM,cAClBjlC,KAAK,SACL2lC,QAASA,EACTT,IAAKG,EACLe,SAAUz9B,EArBZ,WAuBIs8B,EAAMoB,MAAQpB,EAAM7wC,QACpB,uBAAKuwC,UAAU,iBAAiB,cAAY,OAA5C,UACGM,EAAMoB,MAAQpB,EAAM7wC,MACpB6wC,EAAMqB,iBACL,uBAAM3B,UAAU,uBAAhB,SACGM,EAAMqB,qBAKdrB,EAAMsB,eACL,uBAAK5B,UAAU,kBAAf,UACGM,EAAM,cADT,IACyBt8B,GAAa,eAAC,GAAD,OAGvCs8B,EAAMuB,YAMX,yBACE7B,UAAWmB,aAAK,WAAYb,EAAMN,WAClCwB,MAAOlB,EAAMkB,MACbM,cAAgBxxC,IACd4wC,EAAmBx3B,QAAUpZ,EAAMgyB,aAAe,MAEpDyf,YAAa,KACXC,uBAAsB,KACpBd,EAAmBx3B,QAAU,SARnC,UAYE,wBACEs2B,UAAS,8BAAyBa,GAClCxlC,KAAK,QACL3N,KAAM4yC,EAAM5yC,KACZ,aAAY4yC,EAAM,cAClB,oBAAmBA,EAAM,qBACzB,cAAaA,EAAM,eACnB3qC,GAAE,UAAK6qC,EAAL,YAAgBF,EAAM3qC,IACxBssC,SAAU,KAAO,IAAD,EACd,UAAA3B,EAAM2B,gBAAN,cAAA3B,EAAiB,CAAEhe,YAAa4e,EAAmBx3B,WAErDw4B,QAAS5B,EAAM4B,QACf3B,IAAKG,IAEP,uBAAKV,UAAU,iBAAf,UACGM,EAAMoB,KACNpB,EAAMqB,iBACL,uBAAM3B,UAAU,uBAAhB,SAAwCM,EAAMqB,2BAOxDxB,GAAWgC,aAAe,CACxBf,SAAS,EACTpB,UAAW,GACX1uB,KAAM,UC1JR,MAAM8wB,GAAsBj2C,GAC1BA,IAAUxD,IAAMC,MAAQoP,EAAGY,OAAO,GAAKZ,EAAGY,OAAO,GAC7CypC,GAAiBl2C,GACrBA,IAAUxD,IAAMC,MAAQoP,EAAGkB,MAAQlB,EAAGe,KAAK,GACvCupC,GAAgBn2C,GACpBA,IAAUxD,IAAMC,MAAQoP,EAAGc,MAAQ,UAQxBypC,GAAa,SACxBla,GAEI,IADJrJ,EACG,uDADmB,IAEtB,MAAM,MACJriB,EAAQ,IADJ,OAEJE,EAASF,EAFL,OAGJ6lC,EAHI,MAIJpmC,GACkB,kBAAT4iB,EAAqB,CAAEriB,MAAOqiB,GAAkBA,EAC3D,OACE,sBACE,cAAY,OACZyjB,UAAU,QACVC,KAAK,MACLzC,QAAO,cAAStjC,EAAT,YAAkBE,GACzBmjC,UAAWmB,aAAK,CAAE,aAAcqB,IAChCpmC,MAAOA,EANT,SAQgB,kBAANisB,EAAiB,uBAAMrX,KAAK,eAAeqX,EAAGA,IAAQA,KAKvDsa,GAAYJ,GACvB,2BAAUvxB,KAAK,OAAOiC,OAAO,eAAelK,OAAO,mBACnD,CACEpM,MAAO,GACPE,OAAQ,KAIC+lC,GAAOL,GAClB,kuCACA,CAAEC,QAAQ,IAGC9xB,GAAO6xB,GAClB,4bACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGXgmC,GAASN,GACpB,kYACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGXimC,GAAOP,GAClB,qUACA,CAAE5lC,MAAO,IAAKE,OAAQ,IAAK2lC,QAAQ,IAGxBO,GAAYR,GACvB,gUACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGXmmC,GAAQT,GACnB,0WACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGXomC,GAAUV,GACrB,qeAGWW,GAAaX,GACxB,iXACA,CAAE5lC,MAAO,IAAKE,OAAQ,IAAK2lC,QAAQ,IAGxBW,GAAcZ,GACzB,uCACE,uBAAMla,EAAE,iJACR,uBAAMA,EAAE,sdAEV,CAAE1rB,MAAO,IAAKE,OAAQ,IAAK2lC,QAAQ,IAGxBY,GAAmBb,GAC9B,6bACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGXwmC,GAASd,GACpB,kPACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGXymC,GAAUf,GACrB,uHACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGX0mC,GAAOhB,GAClB,sRAGWiB,GAAOjB,GAClB,yVAGWkB,GAAOlB,GAClB,miBACA,CAAEC,QAAQ,IAGCkB,GAAOnB,GAClB,oiBACA,CAAEC,QAAQ,IAGCmB,GAAiBpB,GAC5B,inBACA,CAAEC,QAAQ,IAGCoB,GAAQrB,GACnB,0WACA,CAAE5lC,MAAO,GAAIE,OAAQ,KAGVgnC,GAAWtB,GACtB,qKACA,CAAE5lC,MAAO,GAAIE,OAAQ,KAGVinC,GAAevB,GAC1B,uCACE,uBACEtvB,OAAO,eACPjC,KAAK,eACLqX,EAAE,6UAEJ,uBACEpV,OAAO,eACPjC,KAAK,eACLqX,EAAE,gGAGN,CAAE1rB,MAAO,GAAIE,OAAQ,KAeVknC,IAVYxB,GACvB,uBACEtvB,OAAO,eACPtD,YAAY,KACZqB,KAAK,eACLqX,EAAE,6SAEJ,CAAE1rB,MAAO,OAGqByjC,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACzCo2C,GACE,uCACE,uBACEla,EAAE,0HACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,MAEd,uBACE0Y,EAAE,kJACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,GAAI6lC,QAAQ,QAIZyB,GAAmB7D,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACzCo2C,GACE,uCACE,uBACEla,EAAE,kJACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,MAEd,uBACE0Y,EAAE,kJACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,SAGhB,CAAEhT,MAAO,GAAI6lC,QAAQ,OAIZ0B,GAAmB9D,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACzCo2C,GACE,uCACE,uBACEla,EAAE,sHACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,MAEd,uBACE0Y,EAAE,iJACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,GAAI6lC,QAAQ,OAIZ2B,GAAiB/D,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACvCo2C,GACE,uCACE,uBACEla,EAAE,iJACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,MAEd,uBACE0Y,EAAE,8GACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,SAGhB,CAAEhT,MAAO,GAAI6lC,QAAQ,OAUZ4B,GAAehE,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACrCo2C,GACE,uCACE,uBACEla,EAAE,aACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZ00B,cAAc,UAEhB,uBACEhc,EAAE,uRACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,GAAI6lC,QAAQ,OAIZ8B,GAAkBlE,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACxCo2C,GACE,uCACE,uBACEla,EAAE,cACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZ00B,cAAc,UAEhB,uBACEhc,EAAE,4RACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,GAAI6lC,QAAQ,OAIZ+B,GAAgBnE,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACtCo2C,GACE,uCACE,uBACEla,EAAE,aACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZ00B,cAAc,UAEhB,uBACEhc,EAAE,4TACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,QAIA6nC,GAAiBpE,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACvCo2C,GACE,uCACE,uBACEla,EAAE,cACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZ00B,cAAc,UAEhB,uBACEhc,EAAE,8TACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,QAIA8nC,GAA6BrE,IAAM4D,MAC9C,QAAC,MAAE73C,GAAH,SACEo2C,GACE,uCACE,uBACEla,EAAE,kBACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZ00B,cAAc,UAEhB,uBACEhc,EAAE,iHACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,QAIF+nC,GAA2BtE,IAAM4D,MAC5C,QAAC,MAAE73C,GAAH,SACEo2C,GACE,uCACE,uBACEla,EAAE,oBACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZ00B,cAAc,UAEhB,uBACEhc,EAAE,iHACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,SAGhB,CAAEhT,MAAO,QAIFgoC,GAAuBvE,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC7Co2C,GACE,uCACE,uBACEla,EAAE,mQACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,MAEd,uBACE0Y,EAAE,cACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZi1B,gBAAgB,SAChBP,cAAc,aAGlB,CAAE1nC,MAAO,GAAI6lC,QAAQ,OAIZqC,GAAyBzE,IAAM4D,MAC1C,QAAC,MAAE73C,GAAH,SACEo2C,GACE,uCACE,uBACEla,EAAE,wRACFrX,KAAMoxB,GAAmBj2C,GACzB8mB,OAAQmvB,GAAmBj2C,GAC3BwjB,YAAY,MAEd,uBACE0Y,EAAE,cACFrX,KAAMqxB,GAAcl2C,GACpB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IACZi1B,gBAAgB,SAChBP,cAAc,aAGlB,CAAE1nC,MAAO,QAIFmoC,GAAQvC,GACnB,0fACA,CAAE5lC,MAAO,IAAKE,OAAQ,IAAK2lC,QAAQ,IAIxBuC,GAAQxC,GACnB,qLAGWyC,GAAOzC,GAClB,8KAGW0C,GAAQ1C,GACnB,kaACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGXqoC,GAAO3C,GAClB,iPACA,CAAE5lC,MAAO,IAAKE,OAAQ,IAAKT,MAAO,CAAE+oC,WAAY,WAAa3C,QAAQ,IAG1D4C,GAAQ7C,GACnB,qPACA,CAAEC,QAAQ,IAIC6C,GAAS9C,GACpB,sWACA,CAAE5lC,MAAO,KAGE2oC,GAAO/C,GAClB,gZACA,CAAE5lC,MAAO,IAAKE,OAAQ,MAGX0oC,GAAYnF,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAClCo2C,GACE,uCACE,uBAAMla,EAAE,oBAAoBrX,KAAMqxB,GAAcl2C,KAChD,uBACEk8B,EAAE,wUACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAY,MAEd,uBAAM0Y,EAAE,uBAAuBrX,KAAMqxB,GAAcl2C,KACnD,uBACEk8B,EAAE,sWACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAY,MAEd,qBACEqB,KAAMsxB,GAAan2C,GACnB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IAHd,UAKE,uBAAMlT,EAAE,MAAMyB,EAAE,MAAMvB,MAAM,KAAKE,OAAO,OACxC,uBAAMJ,EAAE,MAAMyB,EAAE,QAAQvB,MAAM,KAAKE,OAAO,OAC1C,uBAAMJ,EAAE,QAAQyB,EAAE,QAAQvB,MAAM,KAAKE,OAAO,OAC5C,uBAAMJ,EAAE,QAAQyB,EAAE,MAAMvB,MAAM,KAAKE,OAAO,aAG9C,CAAEF,MAAO,IAAKE,OAAQ,IAAK2lC,QAAQ,OAI1BgD,GAAcpF,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACpCo2C,GACE,uCACE,uBAAMla,EAAE,oBAAoBrX,KAAMqxB,GAAcl2C,KAChD,uBACEk8B,EAAE,wUACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAY,MAEd,uBAAM0Y,EAAE,uBAAuBrX,KAAMqxB,GAAcl2C,KACnD,uBACEk8B,EAAE,sWACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAY,MAEd,qBACEqB,KAAMsxB,GAAan2C,GACnB8mB,OAAQovB,GAAcl2C,GACtBwjB,YAAY,IAHd,UAKE,uBAAMlT,EAAE,MAAMyB,EAAE,MAAMvB,MAAM,KAAKE,OAAO,OACxC,uBAAMJ,EAAE,OAAOyB,EAAE,QAAQvB,MAAM,KAAKE,OAAO,OAC3C,uBAAMJ,EAAE,QAAQyB,EAAE,QAAQvB,MAAM,KAAKE,OAAO,OAC5C,uBAAMJ,EAAE,QAAQyB,EAAE,OAAOvB,MAAM,KAAKE,OAAO,OAC3C,uBAAMJ,EAAE,QAAQyB,EAAE,MAAMvB,MAAM,KAAKE,OAAO,OAC1C,uBAAMJ,EAAE,MAAMyB,EAAE,QAAQvB,MAAM,KAAKE,OAAO,aAG9C,CAAEF,MAAO,IAAKE,OAAQ,IAAK2lC,QAAQ,OAI1BiD,GAAkBrF,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACxCo2C,GACE,uBACEmD,SAAS,UACTC,SAAS,UACTtd,EAAE,sOACFrX,KAAMqxB,GAAcl2C,KAEtB,CAAEwQ,MAAO,GAAIE,OAAQ,QAIZ+oC,GAAqBxF,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC3Co2C,GACE,qBAAGvxB,KAAMqxB,GAAcl2C,GAAQu5C,SAAS,UAAUC,SAAS,UAA3D,UACE,uBAAMtd,EAAE,wOACR,uBAAMA,EAAE,4NAEV,CAAE1rB,MAAO,GAAIE,OAAQ,QAIZgpC,GAAgBzF,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACtCo2C,GAAW,uBAAMla,EAAE,kBAAkBrX,KAAMqxB,GAAcl2C,KAAY,CACnEwQ,MAAO,GACPE,OAAQ,QAICipC,GAAkB1F,IAAM4D,MACnC,QAAC,MAAE73C,EAAF,YAASwjB,GAAV,SACE4yB,GACE,uBACEla,EAAE,WACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAaA,EACb00B,cAAc,QACdrzB,KAAK,SAEP,CAAErU,MAAO,GAAIE,OAAQ,QAIdkpC,GAAuB3F,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC7Co2C,GACE,uBACEla,EAAE,WACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACbqB,KAAK,OACLqzB,cAAc,UAEhB,CACE1nC,MAAO,GACPE,OAAQ,QAKDmpC,GAAwB5F,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC9Co2C,GACE,uBACEla,EAAE,WACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,IACbi1B,gBAAiB,QACjB5zB,KAAK,OACLqzB,cAAc,UAEhB,CAAE1nC,MAAO,GAAIE,OAAQ,QAIZopC,GAAwB7F,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC9Co2C,GACE,uBACEla,EAAE,WACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,IACbi1B,gBAAiB,SACjB5zB,KAAK,OACLqzB,cAAc,UAEhB,CAAE1nC,MAAO,GAAIE,OAAQ,QAIZqpC,GAA0B9F,IAAM4D,MAC3C,QAAC,MAAE73C,GAAH,SACEo2C,GACE,uBACEla,EAAE,kKACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACb00B,cAAc,QACdrzB,KAAK,SAEP,CAAErU,MAAO,GAAIE,OAAQ,GAAI2lC,QAAQ,OAI1B2D,GAAuB/F,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC7Co2C,GACE,uBACEla,EAAE,kQACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACb00B,cAAc,QACdrzB,KAAK,SAEP,CAAErU,MAAO,GAAIE,OAAQ,GAAI2lC,QAAQ,OAIxB4D,GAA2BhG,IAAM4D,MAC5C,QAAC,MAAE73C,GAAH,SACEo2C,GACE,uBACEla,EAAE,wTACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACb00B,cAAc,QACdrzB,KAAK,SAEP,CAAErU,MAAO,GAAIE,OAAQ,GAAI2lC,QAAQ,OAI1B6D,GAAgBjG,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACtCo2C,GACE,uBACEla,EAAE,mBACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACb00B,cAAc,QACdrzB,KAAK,SAEP,CAAErU,MAAO,GAAIE,OAAQ,GAAI2lC,QAAQ,OAIxB8D,GAAgBlG,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SACtCo2C,GACE,uBACEla,EAAE,kCACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACb00B,cAAc,QACdrzB,KAAK,SAEP,CAAErU,MAAO,GAAIE,OAAQ,GAAI2lC,QAAQ,OAIxB+D,GAAoBnG,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC1Co2C,GACE,uBACEla,EAAE,WACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACbqB,KAAK,SAEP,CACErU,MAAO,GACPE,OAAQ,QAKD2pC,GAAqBpG,IAAM4D,MACtC,QAAC,MAAE73C,EAAF,KAASs6C,GAAO,GAAjB,SACElE,GACE,qBACEmE,UAAWD,EAAO,gCAAkC,GACpDxzB,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACbqB,KAAK,OAJP,UAME,uBAAMqX,EAAE,oCACR,uBAAMA,EAAE,+BAEV,CAAE1rB,MAAO,GAAIE,OAAQ,QAId8pC,GAAmBvG,IAAM4D,MACpC,QAAC,MAAE73C,EAAF,KAASs6C,GAAO,GAAjB,SACElE,GACE,qBACEtvB,OAAQovB,GAAcl2C,GACtB6kB,KAAMqxB,GAAcl2C,GACpBu6C,UAAWD,EAAO,gCAAkC,GAHtD,UAKE,uBAAMpe,EAAE,cAAc1Y,YAAa,IACnC,yBAAQ3F,EAAE,IAAI08B,UAAU,8BAE1B,CAAE/pC,MAAO,GAAIE,OAAQ,QAId+pC,GAAmBxG,IAAM4D,MACpC,QAAC,MAAE73C,EAAF,KAASs6C,GAAO,GAAjB,SACElE,GACE,oBAAGmE,UAAWD,EAAO,gCAAkC,GAAvD,SACE,uBACEpe,EAAE,wCACFpV,OAAQovB,GAAcl2C,GACtBwjB,YAAa,EACbqB,KAAK,WAGT,CAAErU,MAAO,GAAIE,OAAQ,QAIdgqC,GAAwBzG,IAAM4D,MACzC,QAAC,MAAE73C,EAAF,KAASs6C,GAAO,GAAjB,SACElE,GACE,qBACEtvB,OAAQovB,GAAcl2C,GACtB6kB,KAAMqxB,GAAcl2C,GACpBu6C,UAAWD,EAAO,gCAAkC,GAHtD,UAKE,uBAAMpe,EAAE,cAAc1Y,YAAa,IACnC,uBAAM0Y,EAAE,4CAEV,CAAE1rB,MAAO,GAAIE,OAAQ,QAIdiqC,GAAoB1G,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC1Co2C,GACE,uBACEvxB,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,ykDAEJ,CAAE1rB,MAAO,GAAIE,OAAQ,QAIZkqC,GAAqB3G,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC3Co2C,GACE,uBACEvxB,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,oeAEJ,CAAE1rB,MAAO,GAAIE,OAAQ,QAIZmqC,GAAoB5G,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC1Co2C,GACE,uBACEvxB,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,kGAEJ,CAAE1rB,MAAO,GAAIE,OAAQ,QAIZoqC,GAAyB7G,IAAM4D,MAC1C,QAAC,MAAE73C,GAAH,SACEo2C,GACE,uBACEvxB,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,+RAEJ,CAAE1rB,MAAO,IAAKE,OAAQ,QAIfqqC,GAA0B9G,IAAM4D,MAC3C,QAAC,MAAE73C,GAAH,SACEo2C,GACE,uBACEvxB,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,yPAEJ,CAAE1rB,MAAO,IAAKE,OAAQ,SAIfsqC,GAAuB/G,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC7Co2C,GACE,uCACE,uBACEvxB,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,gPAEJ,uBACErX,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,4bAGN,CAAE1rB,MAAO,GAAIE,OAAQ,QAIZuqC,GAAqBhH,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC3Co2C,GACE,qCACE,uBACEvxB,KAAMqxB,GAAcl2C,GACpBk8B,EAAE,miBAGN,CAAE1rB,MAAO,IAAKE,OAAQ,SAIbwqC,GAAoBjH,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC1Co2C,GACE,uBACEla,EAAE,scACFrX,KAAMqxB,GAAcl2C,GACpBk4C,cAAc,UAEhB,CAAE1nC,MAAO,IAAKE,OAAQ,SAIbyqC,GAAsBlH,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC5Co2C,GACE,uBACEla,EAAE,8bACFrX,KAAMqxB,GAAcl2C,KAEtB,CAAEwQ,MAAO,IAAKE,OAAQ,SAIb0qC,GAAqBnH,IAAM4D,MAAK,QAAC,MAAE73C,GAAH,SAC3Co2C,GACE,uBACEla,EAAE,8cACFrX,KAAMqxB,GAAcl2C,GACpBk4C,cAAc,UAEhB,CAAE1nC,MAAO,IAAKE,OAAQ,SC/2BnB,IAAI2qC,GAA6B,GAEjC,MAAMC,GAAYC,IACvBF,GAAUA,GAAQrxC,OAAOuxC,GAClBA,GC0BHC,GAA0B,CAC9B9hC,EACA0I,KAEA,GAAI1I,EAAS1C,eAAgB,CAC3B,MAAMykC,EAAkBxpB,GACtB1D,GAAsBnM,GACtB1I,EAAS1C,gBAEX,GAAIykC,EAAgBj6C,OAClB,MAAO,IACFkY,EACHjB,mBAAoB,CAAE,CAACgjC,EAAgB,GAAGjyC,KAAK,IAIrD,OAAOkQ,GAGIgiC,GAAuBJ,GAAS,CAC3C/5C,KAAM,yBACNo6C,QAAS,CAACv5B,EAAU1I,KAClB,GAAIA,EAASzC,qBAAsB,CACjC,MAAM,UACJ0qB,EADI,iBAEJC,EAFI,oBAGJI,EAHI,kBAIJC,GACEvoB,EAASzC,qBACPuD,EAAUknB,GAAoBtT,WAAWuT,GAC/C,IAAKnnB,EACH,OAAO,EAET,GAEsB,MAApBonB,IACsB,IAAtBA,GAEApnB,EAAQoC,OAAOpb,OAAS,EACxB,CACA,MAAMitB,EAAerM,EAAShY,QAAQ4kC,GAAOA,EAAGxlC,KAAOgR,EAAQhR,KAG/D,MAAO,CACL4Y,SAAUqM,EACV/U,SAAU,IAJS8hC,GAAwB9hC,EAAU+U,GAMnDxX,qBAAsB,MAExB2kC,iBAAiB,GAMrB,MAAMpZ,EAAU,CACdR,oBACuB,IAArBJ,EAAyB,KAAOI,EAClCC,kBACEL,IAAqBpnB,EAAQoC,OAAOpb,OAAS,EACzC,KACAygC,GAKR,OAFAP,GAAoBa,UAAU/nB,EAASonB,EAAkB,UAElD,CACLxf,WACA1I,SAAU,IACLA,EACHzC,qBAAsB,IACjByC,EAASzC,wBACTurB,EACHZ,iBAAkBA,EAAmB,EAAIA,EAAmB,EAAI,IAGpEga,iBAAiB,GAIrB,IAAMx5B,SAAUqM,EAAc/U,SAAUgY,GAlGb,EAC7BtP,EACA1I,KAEO,CACL0I,SAAUA,EAASrZ,KAAKimC,GAClBt1B,EAASjB,mBAAmBu2B,EAAGxlC,IAC1B4mB,GAAe4e,EAAI,CAAErc,WAAW,IAElCqc,IAETt1B,SAAU,IACLA,EACHjB,mBAAoB,MAsFpBojC,CAAuBz5B,EAAU1I,GAQnC,OAPAsvB,GACEva,EACArM,EAAShY,QAAO,QAAC,GAAEZ,GAAH,SAAYkQ,EAASjB,mBAAmBjP,OAG1DkoB,EAAe8pB,GAAwB9pB,EAAcjD,GAE9C,CACLrM,SAAUqM,EACV/U,SAAU,IACLgY,EACHva,YAAa,YACbc,aAAc,MAEhB2jC,gBAAiBtK,GACf/iB,GAAsBnM,GACtB1I,KAINoiC,iBAAkB,gBAClBC,QAAU53C,GAAUA,EAAM/C,MAAQkM,GAAkBnJ,EAAM/C,MAAQkM,GAClE0uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLqmC,KAAMsB,GACNxB,MAAO3rC,EAAE,iBACT,aAAYA,EAAE,iBACdmrC,QAAS,IAAMoH,EAAW,MAC1BhH,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QCpIhEwiC,GAAmB,CACvB95B,EACA1I,KAEA,IAAIyiC,EAA4B,GAC5BC,EAA2B,GAC3BC,EAAsB,KACtBlxC,GAAS,EACb,OAASA,EAAQiX,EAAS5gB,QACpBkY,EAASjB,mBAAmB2J,EAASjX,GAAO3B,KAC1C4yC,EAAe56C,SACjB26C,EAAkBA,EAAgBnyC,OAAOoyC,GACzCA,EAAiB,IAEnBD,EAAgB50C,KAAK4D,GACrBkxC,EAAsBlxC,EAAQ,GACrBiX,EAASjX,GAAOwnB,WAAa0pB,IAAwBlxC,GAC9DkxC,EAAsBlxC,EAAQ,EAC9BixC,EAAe70C,KAAK4D,IAEpBixC,EAAiB,GAGrB,OAAOD,GAkBHG,GAAiB,CACrB5iC,EACA0I,EACAm6B,EACAnwB,KAEA,MAAMowB,EAAgBp6B,EAASm6B,GAEzBE,EAAejiC,IACfA,EAAQmY,aAKRjZ,EAAS1C,gBACJwD,EAAQ0W,SAASzb,SAASiE,EAAS1C,iBAKxC0lC,EACU,SAAdtwB,EzCiPyB,SAC3BuwB,EACA1tB,GAEI,IADJ2tB,EACG,uDADiBD,EAAMn7C,OAAS,EAE/Bo7C,EAAY,IACdA,EAAYD,EAAMn7C,OAASo7C,GAE7BA,EAAY7hD,KAAK2T,IAAIiuC,EAAMn7C,OAAS,EAAGzG,KAAK+iB,IAAI8+B,EAAW,IAC3D,IAAIzxC,EAAQyxC,EAAY,EACxB,OAASzxC,GAAS,GAChB,GAAI8jB,EAAG0tB,EAAMxxC,GAAQA,EAAOwxC,GAC1B,OAAOxxC,EAGX,OAAQ,EyC/PF0xC,CAAcz6B,EAAUq6B,EAAa1hD,KAAK+iB,IAAI,EAAGy+B,EAAgB,IzC8NhD,SACvBI,EACA1tB,GAEI,IADJ2tB,EACG,uDADiB,EAEhBA,EAAY,IACdA,EAAYD,EAAMn7C,OAASo7C,GAE7BA,EAAY7hD,KAAK2T,IAAIiuC,EAAMn7C,OAAQzG,KAAK+iB,IAAI8+B,EAAW,IACvD,IAAIzxC,EAAQyxC,EAAY,EACxB,OAASzxC,EAAQwxC,EAAMn7C,QACrB,GAAIytB,EAAG0tB,EAAMxxC,GAAQA,EAAOwxC,GAC1B,OAAOxxC,EAGX,OAAQ,EyC5OF2xC,CAAU16B,EAAUq6B,EAAaF,EAAgB,GAEjDQ,EAAc36B,EAASs6B,GAE7B,IAAKK,EACH,OAAQ,EAGV,GAAIrjC,EAAS1C,eAAgB,CAC3B,IAEe,OAAbwlC,QAAa,IAAbA,OAAA,EAAAA,EAAetrB,SAAS3gB,KAAK,QAA7B,OAAqCwsC,QAArC,IAAqCA,OAArC,EAAqCA,EAAa7rB,SAAS3gB,KAAK,KAEhE,OAAOmsC,EACF,KAAI,OAACK,QAAD,IAACA,OAAD,EAACA,EAAa7rB,SAASzb,SAASiE,EAAS1C,iBAElD,OAAQ,EAIZ,IAAK+lC,EAAY7rB,SAAS1vB,OACxB,OAAOk7C,EAGT,MAAMM,EAAiBtjC,EAAS1C,eAC5B+lC,EAAY7rB,SACV6rB,EAAY7rB,SAASa,QAAQrY,EAAS1C,gBAAkB,GAE1D+lC,EAAY7rB,SAAS6rB,EAAY7rB,SAAS1vB,OAAS,GAEjDy7C,EAAyBhrB,GAAmB7P,EAAU46B,GAE5D,OAAIC,EAAuBz7C,OAGJ,SAAd4qB,EACHhK,EAAS2P,QAAQkrB,EAAuB,IACxC76B,EAAS2P,QACPkrB,EAAuBA,EAAuBz7C,OAAS,IAIxDk7C,GAGHQ,GAAuB,CAC3B96B,EACA+6B,IAEOA,EAAQp2C,QAAO,CAACC,EAAKmE,KAC1B,MAAMqP,EAAU4H,EAASjX,GAEzB,OADAnE,EAAIwT,EAAQhR,IAAMgR,EACXxT,IACN,IAGCo2C,GAAgB,CACpB1jC,EACA0I,EACAgK,KAEA,MAAMixB,EAAgBnB,GAAiB95B,EAAU1I,GAC3C4jC,EAAoBJ,GAAqB96B,EAAUi7B,GACzD,IAAIE,EArGsBZ,KAC1B,IAAIz1C,EAAS,EACb,OAAOy1C,EAAM51C,QAAO,CAACC,EAAKzD,EAAO4H,KAC3BA,EAAQ,GAAKwxC,EAAMxxC,EAAQ,KAAO5H,EAAQ,IAC5C2D,IAAWA,IAEZF,EAAIE,KAAYF,EAAIE,GAAU,KAAKK,KAAKhE,GAClCyD,IACN,KA6FkBw2C,CAAmBH,GAoDxC,MAlDkB,UAAdjxB,IACFmxB,EAAiBA,EAAevmB,WAGlCumB,EAAel7B,SAAQ,CAAC86B,EAASv4C,KAC/B,MAAM64C,EAAeN,EAAQ,GACvBO,EAAgBP,EAAQA,EAAQ37C,OAAS,GACzC+6C,EAA8B,SAAdnwB,EAAuBqxB,EAAeC,EAEtDC,EAAcrB,GAClB5iC,EACA0I,EACAm6B,EACAnwB,GAGF,IAAqB,IAAjBuxB,GAAsBpB,IAAkBoB,EAC1C,OAGF,MAAMC,EACU,SAAdxxB,EACIhK,EAAS5a,MAAM,EAAGm2C,GAClBv7B,EAAS5a,MAAM,EAAGi2C,GAClBI,EAAiBz7B,EAAS5a,MAAMi2C,EAAcC,EAAgB,GAC9DI,EACU,SAAd1xB,EACIhK,EAAS5a,MAAMm2C,EAAaF,GAC5Br7B,EAAS5a,MAAMk2C,EAAgB,EAAGC,EAAc,GAChDI,EACU,SAAd3xB,EACIhK,EAAS5a,MAAMk2C,EAAgB,GAC/Bt7B,EAAS5a,MAAMm2C,EAAc,GAEnCv7B,EACgB,SAAdgK,EACI,IACKwxB,KACAC,KACAC,KACAC,GAEL,IACKH,KACAE,KACAD,KACAE,MAIN37B,EAASrZ,KAAKyR,GACf8iC,EAAkB9iC,EAAQhR,IACrB6mB,GAAY7V,GAEdA,KAILwjC,GAAqB,CACzB57B,EACA1I,EACA0S,KAEA,MAAMixB,EAAgBnB,GAAiB95B,EAAU1I,GAC3C4jC,EAAoBJ,GAAqB96B,EAAUi7B,GACnDS,EAAyC,GAE/C,IAAIL,EACAC,EACJ,GAAkB,SAAdtxB,EAAsB,CACxB,GAAI1S,EAAS1C,eAAgB,CAC3B,MAAMinC,EAAgBhsB,GACpB7P,EACA1I,EAAS1C,gBAEX,IAAKinC,EAAcz8C,OACjB,OAAO4gB,EAETq7B,EAAer7B,EAAS2P,QAAQksB,EAAc,SAE9CR,EAAe,EAGjBC,EAAgBL,EAAcA,EAAc77C,OAAS,OAChD,CACL,GAAIkY,EAAS1C,eAAgB,CAC3B,MAAMinC,EAAgBhsB,GACpB7P,EACA1I,EAAS1C,gBAEX,IAAKinC,EAAcz8C,OACjB,OAAO4gB,EAETs7B,EAAgBt7B,EAAS2P,QAAQksB,EAAcA,EAAcz8C,OAAS,SAEtEk8C,EAAgBt7B,EAAS5gB,OAAS,EAGpCi8C,EAAeJ,EAAc,GAG/B,IAAK,IAAIlyC,EAAQsyC,EAActyC,EAAQuyC,EAAgB,EAAGvyC,IACnDkyC,EAAc5nC,SAAStK,IAC1B2yC,EAAkBv2C,KAAK6a,EAASjX,IAIpC,MAAM0yC,EAAiBj0C,OAAOs0C,OAAOZ,GAAmBv0C,KAAKyR,GACpD6V,GAAY7V,KAGfojC,EAAkBx7B,EAAS5a,MAAM,EAAGi2C,GACpCM,EAAmB37B,EAAS5a,MAAMk2C,EAAgB,GAExD,MAAqB,SAAdtxB,EACH,IACKwxB,KACAC,KACAC,KACAC,GAEL,IACKH,KACAE,KACAD,KACAE,IAOEI,GAAc,CACzB/7B,EACA1I,IAEO0jC,GAAc1jC,EAAU0I,EAAU,QAG9Bg8B,GAAe,CAC1Bh8B,EACA1I,IAEO0jC,GAAc1jC,EAAU0I,EAAU,SAG9Bi8B,GAAc,CACzBj8B,EACA1I,IAEOskC,GAAmB57B,EAAU1I,EAAU,QAGnC4kC,GAAe,CAC1Bl8B,EACA1I,IAEOskC,GAAmB57B,EAAU1I,EAAU,SCvRnC6kC,GAAqBjD,GAAS,CACzC/5C,KAAM,eACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACL0I,SAAU+7B,GAAY/7B,EAAU1I,GAChCA,WACAkiC,iBAAiB,IAGrBE,iBAAkB,sBAClB0C,YAAa,GACbzC,QAAU53C,GACRA,EAAMmJ,KACLnJ,EAAMwJ,UACPxJ,EAAMmF,OAAS+D,EACjB2uC,eAAgB,QAAC,WAAEC,EAAF,SAAcviC,GAAf,SACd,yBACExK,KAAK,SACL2kC,UAAU,eACVgB,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,uBAAP,mBAAmC+I,GAAe,gBAJzD,SAME,eAACqlC,GAAD,CAAkB93C,MAAO0Z,EAAS1Z,aAK3By+C,GAAqBnD,GAAS,CACzC/5C,KAAM,eACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACL0I,SAAUg8B,GAAah8B,EAAU1I,GACjCA,WACAkiC,iBAAiB,IAGrBE,iBAAkB,sBAClB0C,YAAa,GACbzC,QAAU53C,GACRA,EAAMmJ,KACLnJ,EAAMwJ,UACPxJ,EAAMmF,OAAS+D,EACjB2uC,eAAgB,QAAC,WAAEC,EAAF,SAAcviC,GAAf,SACd,yBACExK,KAAK,SACL2kC,UAAU,eACVgB,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,uBAAP,mBAAmC+I,GAAe,gBAJzD,SAME,eAACmlC,GAAD,CAAkB53C,MAAO0Z,EAAS1Z,aAK3B0+C,GAAmBpD,GAAS,CACvC/5C,KAAM,aACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACL0I,SAAUi8B,GAAYj8B,EAAU1I,GAChCA,WACAkiC,iBAAiB,IAGrBE,iBAAkB,oBAClBC,QAAU53C,GACR6I,EACI7I,EAAMmJ,IACNnJ,EAAMsJ,QACNtJ,EAAMmF,OAAS+D,EACflJ,EAAMmJ,IACNnJ,EAAMwJ,UACNxJ,EAAMmF,OAAS+D,EACrB2uC,eAAgB,QAAC,WAAEC,EAAF,SAAcviC,GAAf,SACd,yBACExK,KAAK,SACL2kC,UAAU,eACVgB,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,qBAAP,mBAEC+I,GADJzF,EACmB,kBACA,sBAPvB,SAUE,eAACgrC,GAAD,CAAgBh4C,MAAO0Z,EAAS1Z,aAKzB2+C,GAAqBrD,GAAS,CACzC/5C,KAAM,eACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACL0I,SAAUk8B,GAAal8B,EAAU1I,GACjCA,WACAkiC,iBAAiB,IAGrBE,iBAAkB,sBAClBC,QAAU53C,GACR6I,EACI7I,EAAMmJ,IACNnJ,EAAMsJ,QACNtJ,EAAMmF,OAAS+D,EACflJ,EAAMmJ,IACNnJ,EAAMwJ,UACNxJ,EAAMmF,OAAS+D,EACrB2uC,eAAgB,QAAC,WAAEC,EAAF,SAAcviC,GAAf,SACd,yBACExK,KAAK,SACL2kC,UAAU,eACVgB,QAAU1wC,GAAU83C,EAAW,MAC/B5G,MAAK,UAAK3rC,EAAE,uBAAP,mBAEC+I,GADJzF,EACmB,kBACA,sBAPvB,SAUE,eAAC+qC,GAAD,CAAkB/3C,MAAO0Z,EAAS1Z,aClI3B4+C,GAAkBtD,GAAS,CACtC/5C,KAAM,YACNo6C,QAAS,CAACv5B,EAAU1I,KACdA,EAASzC,sBAGN,CACLyC,SAAU+X,GACR,IACK/X,EACH1C,eAAgB,KAChByB,mBAAoB2J,EAASrb,QAAO,CAACgC,EAAKyR,KACnCA,EAAQmY,YACX5pB,EAAIyR,EAAQhR,KAAM,GAEbT,IACN,KAELwlB,GAAsBnM,IAExBw5B,iBAAiB,GAGrBE,iBAAkB,mBAClBC,QAAU53C,GAAUA,EAAMmJ,IAAqBnJ,EAAM/C,MAAQkM,KCRlDuxC,GAA2BvD,GAAS,CAC/C/5C,KAAM,qBACNo6C,QAAS,CAACv5B,EAAU1I,KAElB,GAAIA,EAASzC,qBAAsB,CACjC,MAAM,iBAAE2qB,EAAF,UAAoBD,GAAcjoB,EAASzC,qBAC3CuD,EAAUknB,GAAoBtT,WAAWuT,GAC/C,IAAKnnB,GAAgC,OAArBonB,EACd,OAAO,EAET,MAAM,OAAEhlB,GAAWpC,EACbskC,EAAgBliC,EAAOglB,GACvB3R,EAAYrT,EAAOglB,EAAmB,GAa5C,OAZAlS,GAAclV,EAAS,CACrBoC,OAAQ,IACHA,EAAOpV,MAAM,EAAGo6B,EAAmB,GACtC3R,EACI,EACG6uB,EAAc,GAAK7uB,EAAU,IAAM,GACnC6uB,EAAc,GAAK7uB,EAAU,IAAM,GAEtC,CAAC6uB,EAAc,GAAK,GAAIA,EAAc,GAAK,OAC5CliC,EAAOpV,MAAMo6B,EAAmB,MAGhC,CACLloB,SAAU,IACLA,EACHzC,qBAAsB,IACjByC,EAASzC,qBACZ2qB,iBAAkBA,EAAmB,IAGzCxf,WACAw5B,iBAAiB,GAIrB,MAAO,IACFmD,GAAkB38B,EAAU1I,GAC/BkiC,iBAAiB,IAGrBE,iBAAkB,4BAClBC,QAAU53C,GAAUA,EAAMmJ,IAAqBnJ,EAAM/C,MAAQkM,GAC7D0uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLqmC,KAAM0D,GACN5D,MAAK,UAAK3rC,EAAE,6BAAP,mBAAyC+I,GAC5C,gBAEF,aAAY/I,EAAE,6BACdmrC,QAAS,IAAMoH,EAAW,MAC1BhH,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKhEqlC,GAAoB,CACxB38B,EACA1I,KAEA,MAAMslC,EAAa,IAAInpC,IACjBopC,EAAmC,GACnC1W,EAAmC,GACnCC,EAAsB,IAAI3yB,IAE1BqpC,EAA6B1kC,IACjC,MAAMoY,EAAa+B,GACjBjb,EAAS1C,eACTgoC,EACAxkC,EACA,CACElK,EAAGkK,EAAQlK,EAAIrT,IAAY,EAC3B8U,EAAGyI,EAAQzI,EAAI9U,IAAY,IAM/B,OAHAurC,EAAoBrhC,IAAIqT,EAAQhR,GAAIopB,EAAWppB,IAC/C++B,EAAYhhC,KAAKiT,GACjBykC,EAAY13C,KAAKqrB,GACVA,GAGHusB,EAAqC,GAE3C,IAAIh0C,EAAQ,EACZ,KAAOA,EAAQiX,EAAS5gB,QAAQ,CAC9B,MAAMgZ,EAAU4H,EAASjX,GACzB,GAAIuO,EAASjB,mBAAmB+B,EAAQhR,IAAK,CAC3C,GAAIgR,EAAQ0W,SAAS1vB,OAAQ,CAC3B,MAAMwvB,EAAUK,GAA2B3X,EAAUc,GAErD,GAAIwW,EAAS,CACX,MAAMitB,EAAgBhsB,GAAmB7P,EAAU4O,GACnDmuB,EAAc53C,QACT02C,KACAA,EAAcl1C,KAAKyR,GACpB0kC,EAA0B1kC,MAG9BrP,GAAgB8yC,EAAcz8C,OAC9B,UAGJ29C,EAAc53C,KAAKiT,EAAS0kC,EAA0B1kC,SAEtD2kC,EAAc53C,KAAKiT,GAErBrP,IAKF,OAFAk9B,GAA4B8W,EAAe5W,EAAaC,GAEjD,CACLpmB,SAAU+8B,EACVzlC,SAAU+X,GACR,IACK/X,EACHhB,iBAAkB,GAClBD,mBAAoBwmC,EAAYl4C,QAAO,CAACC,EAAKwT,KAC3CxT,EAAIwT,EAAQhR,KAAM,EACXxC,IACN,KAELunB,GAAsB4wB,MC/IfC,GAAmB,QAAmB,QACjDz3C,EADiD,MAEjDpE,EAFiD,SAGjDuyC,EAHiD,MAIjDnqB,GAJ8B,SAW9B,sBAAKkoB,UAAU,4BAAf,SACGlsC,EAAQoB,KAAKs2C,GACZ,yBAEExL,UAAWmB,aAAK,CAAEsK,OAAQ/7C,IAAU87C,EAAO97C,QAC3C8xC,MAAOgK,EAAO35C,KAHhB,UAKE,wBACEwJ,KAAK,QACL3N,KAAMoqB,EACNmqB,SAAU,IAAMA,EAASuJ,EAAO97C,OAChCwyC,QAASxyC,IAAU87C,EAAO97C,QAE3B87C,EAAO9J,OAVH8J,EAAO35C,W,MCLb,MAAM65C,GAAU,IAMT,IANU,SACtB7J,EADsB,KAEtBxrC,EAFsB,IAGtBkmC,EAHsB,eAItBoP,EAJsB,cAKtBC,GAAgB,GACL,EACX,MAAMC,EAAalL,iBAAuB,MA+B1C,OA5BAmL,2BAAgB,KACd,GAAIF,GAAiBC,EAAWniC,QAAS,CACvC,MAAM/C,EAAUklC,EAAWniC,SACrB,EAAEjN,EAAF,EAAKyB,EAAL,MAAQvB,EAAR,OAAeE,GAAW8J,EAAQolC,wBAElCrQ,EAAgBxxC,OAAO8hD,WACzBvvC,EAAIE,EAAQ++B,IACd/0B,EAAQvK,MAAM/F,KAAd,UAAwBqlC,EAAgB/+B,EAAxC,OAEF,MAAMg/B,EAAiBzxC,OAAO+hD,YAC1B/tC,EAAIrB,EAAS8+B,IACfh1B,EAAQvK,MAAMmgC,IAAd,UAAuBZ,EAAiB9+B,EAAxC,UAGH,CAAC+uC,IAEJ3K,qBAAU,KACR,GAAI0K,EAAgB,CAClB,MAAMO,EAAW57C,IAAyB,IAAD,GACnC,UAACu7C,EAAWniC,eAAZ,aAAC,EAAoByiC,SAAS77C,EAAMC,UACtCuQ,mCAAwB,IAAM6qC,EAAer7C,MAIjD,OADAyG,SAASq1C,iBAAiB,cAAeF,GAAS,GAC3C,IAAMn1C,SAASs1C,oBAAoB,cAAeH,GAAS,MAEnE,CAACP,IAGF,sBAAK3L,UAAU,UAAU5jC,MAAO,CAAEmgC,MAAKlmC,QAAQkqC,IAAKsL,EAApD,SACGhK,K,MC1CP,MAAMyK,GAAgBnsC,IACpB,MAAM/D,GAAQ,IAAImwC,QAASnwC,MAE3B,OADAA,EAAM+D,MAAQA,IACL/D,EAAM+D,OAoBXqsC,GAAc,CAClB,CAAC,IAAK,IAAK,IAAK,IAAK,KACrB,CAAC,IAAK,IAAK,IAAK,IAAK,KACrB,CAAC,IAAK,IAAK,IAAK,IAAK,MACrBC,OAEIC,GAAS,IAgBR,IAhBS,OACdnsC,EADc,MAEdJ,EAFc,SAGd8hC,EAHc,QAId0K,EAJc,MAKdl9C,EALc,UAMdm9C,GAAY,EANE,KAOdvxC,GASI,EACJ,MAAMwxC,EAAYzM,IAAMO,SAClBmM,EAAa1M,IAAMO,SACnBoM,EAAU3M,IAAMO,SAChBqM,EAAa5M,IAAMO,SAEzBP,IAAMa,WAAU,KAEV6L,EAAWpjC,QACbojC,EAAWpjC,QAAQipB,QACVqa,EAAWtjC,QACpBsjC,EAAWtjC,QAAQipB,QACVoa,EAAQrjC,SACjBqjC,EAAQrjC,QAAQipB,UAEjB,IAmDH,OACE,uBACEqN,UAAS,yCAAoC3kC,GAC7CqnC,KAAK,SACL,aAAW,OACX,aAAY7sC,EAAE,sBACdo3C,UAvDmB38C,IACrB,GAAIA,EAAM/C,MAAQkM,GAAU,CAC1B,MAAM,cAAEyzC,GAAkBn2C,SAEkB,IAAD,EAD3C,GAAIzG,EAAMwJ,UACR,GAAIozC,IAAkBL,EAAUnjC,QAC9B,UAAAsjC,EAAWtjC,eAAX,SAAoBipB,QACpBriC,EAAMmR,sBAEH,GAAIyrC,IAAkBF,EAAWtjC,QAAS,CAAC,IAAD,EAC/C,UAAAmjC,EAAUnjC,eAAV,SAAmBipB,QACnBriC,EAAMmR,uBAEH,GAAI/H,GAAWpJ,EAAM/C,KAAM,CAChC,MAAM,cAAE2/C,GAAkBn2C,SACpB+I,EAAQ3I,IAAcjB,IACtBoB,EAAQ2jB,MAAMoF,UAAUnC,QAAQqC,KACpCwsB,EAASrjC,QAASm4B,SAClBqL,GAEF,IAAe,IAAX51C,EAAc,CAChB,MAAM3J,EAASo/C,EAASrjC,QAASm4B,SAASl0C,QAAUi/C,EAAY,EAAI,GAC9DO,EACJ78C,EAAM/C,OAASuS,EAAQrG,EAAkBA,IACpCnC,EAAQ,GAAK3J,EACd2C,EAAM/C,OAASuS,EAAQrG,EAAmBA,IACzC9L,EAAS2J,EAAQ,GAAK3J,EACvB2C,EAAM/C,MAAQkM,GACbnC,EAAQ,GAAK3J,EACd2C,EAAM/C,MAAQkM,GACb9L,EAAS2J,EAAQ,GAAK3J,EACvB2J,EACLy1C,EAASrjC,QAASm4B,SAAUsL,GAAmBxa,QAElDriC,EAAMmR,sBACD,GACL+qC,GAAY5qC,SAAStR,EAAM/C,IAAI6/C,iBAC9BlyC,GAAkB5K,EAAMC,QACzB,CACA,MAAM+G,EAAQk1C,GAAYtuB,QAAQ5tB,EAAM/C,IAAI6/C,eAC3CL,EAASrjC,QAASm4B,SAAUvqC,GAAeq7B,QAC5CriC,EAAMmR,sBACGnR,EAAM/C,MAAQkM,IAAenJ,EAAM/C,MAAQkM,KACpDnJ,EAAMmR,iBACNkrC,KAEFr8C,EAAM+8C,YAAYC,2BAClBh9C,EAAMi9C,mBAIN,UAOE,sBAAKvN,UAAU,uDACf,sBAAKA,UAAU,0BACf,uBACEA,UAAU,uBACVO,IAAMpF,IACAA,IACF4R,EAAQrjC,QAAUyxB,IAGtBqS,SAAU,EAPZ,UASGjtC,EAAOrL,KAAI,CAACu4C,EAAQ18C,KACnB,MAAM28C,EAAoBD,EAAO31C,QAAQ,IAAK,IAC9C,OACE,0BACEkoC,UAAU,sBACVgB,QAAU1wC,IACPA,EAAMq9C,cAAoChb,QAC3CsP,EAASwL,IAEXjM,MAAK,UAAK3rC,EAAE,UAAD,OAAW63C,KAAjB,OACFxtC,GAAcutC,GAA2B,GAA1C,YAA8BA,EAA9B,KADG,mBAECjB,GAAYz7C,GAAGkK,eACrB,aAAYpF,EAAE,UAAD,OAAW63C,IACxB,oBAAmBlB,GAAYz7C,GAC/BqL,MAAO,CAAE+D,MAAOstC,GAEhBlN,IAAMpF,IACAA,GAAY,IAANpqC,IACR87C,EAAUnjC,QAAUyxB,GAElBA,GAAMsS,IAAWttC,IACnB2sC,EAAWpjC,QAAUyxB,IAGzByS,QAAS,KACP3L,EAASwL,IAtBb,UAyBGvtC,GAAcutC,GACb,sBAAKzN,UAAU,kCACbxoC,EACJ,uBAAMwoC,UAAU,0BAAhB,SAA2CwM,GAAYz7C,OAhBlD08C,MAoBVb,GACC,eAACiB,GAAD,CACE1tC,MAAOA,EACP1Q,MAAOA,EACPwyC,SAAW9hC,IACT8hC,EAAS9hC,IAEXogC,IAAKyM,WAQXa,GAAazN,IAAMC,YACvB,CAAC,EAUCE,KACI,IAVJ,MACEpgC,EADF,SAEE8hC,EAFF,MAGExyC,GAOC,EACH,MAAOq+C,EAAYC,GAAiB3N,IAAM55B,SAASrG,GAC7C6tC,EAAW5N,IAAMO,OAAO,MAE9BP,IAAMa,WAAU,KACd8M,EAAc5tC,KACb,CAACA,IAEJigC,IAAMQ,oBAAoBL,GAAK,IAAMyN,EAAStkC,UAE9C,MAAMukC,EAAc7N,IAAM35B,aACvBynC,IACC,MAAMx+C,EAAQw+C,EAAWd,cACnBjtC,EAvMIA,IACZD,GAAcC,IAIXmsC,GAAansC,GAHXA,EAKLmsC,GAAa,IAAD,OAAKnsC,IAAjB,WACIA,GACJ,KA8LgBguC,CAASz+C,GACnByQ,GACF8hC,EAAS9hC,GAEX4tC,EAAcr+C,KAEhB,CAACuyC,IAGH,OACE,yBAAOjC,UAAU,wBAAjB,UACE,sBAAKA,UAAU,oBAAf,eACA,wBACEoO,YAAY,EACZpO,UAAU,qBACV,aAAYvwC,EACZwyC,SAAW3xC,GAAU29C,EAAY39C,EAAMC,OAAOb,OAC9CA,OAAQo+C,GAAc,IAAIh2C,QAAQ,KAAM,IACxCu2C,OAAQ,IAAMN,EAAc5tC,GAC5BogC,IAAKyN,UAOFM,GAAc,IAcpB,IAdqB,KAC1BjzC,EAD0B,MAE1B8E,EAF0B,SAG1B8hC,EAH0B,MAI1BxyC,EAJ0B,SAK1B8+C,EAL0B,UAM1BC,GAQI,EACJ,MAAMC,EAAerO,IAAMO,OAA0B,MAErD,OACE,iCACE,uBAAKX,UAAU,iCAAf,UACE,yBACEA,UAAU,4BACV,aAAYvwC,EACZ2M,MAAO+D,EAAQ,CAAE,iBAAkBA,QAAU3I,EAC7CwpC,QAAS,IAAMwN,GAAWD,GAC1BhO,IAAKkO,IAEP,eAACZ,GAAD,CACE1tC,MAAOA,EACP1Q,MAAOA,EACPwyC,SAAW9hC,IACT8hC,EAAS9hC,SAIf,eAAC,IAAMuuC,SAAP,CAAgBC,SAAS,GAAzB,SACGJ,EACC,eAAC,GAAD,CACE5C,eAAiBr7C,GACfA,EAAMC,SAAWk+C,EAAa/kC,SAAW8kC,GAAU,GAFvD,SAKE,eAAC9B,GAAD,CACEnsC,OAAQA,EAAOlF,GACf8E,MAAOA,GAAS,KAChB8hC,SAAW2M,IACT3M,EAAS2M,IAEXjC,QAAS,KAAO,IAAD,EACb6B,GAAU,GACV,UAAAC,EAAa/kC,eAAb,SAAsBipB,SAExBljC,MAAOA,EACPm9C,WAAW,EACXvxC,KAAMA,MAGR,W,MCnSZ,SAASqxC,GAAT,GAYI,IAZe,QACjB54C,EADiB,MAEjBpE,EAFiB,MAGjBD,EAHiB,SAIjBwyC,EAJiB,QAKjB0K,GAOC,EACD,MAAMkC,EAAazO,IAAMO,SACnBmO,EAAc1O,IAAMO,SACpBoO,EAAW3O,IAAMO,OAAuB,MAE9CP,IAAMa,WAAU,KAEV6N,EAAYplC,QACdolC,EAAYplC,QAAQipB,QACXoc,EAASrlC,SAClBqlC,EAASrlC,QAAQipB,UAElB,IA8DH,OACE,sBACEqN,UAAS,SACT0C,KAAK,SACL,aAAW,OACX,aAAYjzC,EACZw9C,UAlEmB38C,IACrB,MAAM0+C,EAAgBl7C,EAAQ2pB,MAC3B+tB,GAAWA,EAAOyD,aAAe3+C,EAAM/C,IAAI6/C,gBAG9C,GAAM98C,EAAM4+C,SAAW5+C,EAAMsJ,QAAUtJ,EAAM6+C,UAAYH,EAKlD,GAAI1+C,EAAM/C,MAAQkM,GAIvBoE,YAAW,KACMixC,EAAYplC,UACT3S,SAASm2C,eAEzBP,MAED,QACE,GAAIjzC,GAAWpJ,EAAM/C,KAAM,CAEhC,MAAM,cAAE2/C,GAAkBn2C,SACpB+I,EAAQ3I,IAAcjB,IACtBoB,EAAQ2jB,MAAMoF,UAAUnC,QAAQqC,KACpCwuB,EAAUrlC,QAASm4B,SACnBqL,GAEF,IAAe,IAAX51C,EAAc,CAChB,MAAM3J,EAASmG,EAAQnG,OACvB,IAAIw/C,EAAY71C,EAEhB,OAAQhH,EAAM/C,KAEZ,KAAKuS,EAAQrG,EAAkBA,EAC/B,KAAKA,EACH0zC,GAAa71C,EAAQ,GAAK3J,EAC1B,MAGF,KAAKmS,EAAQrG,EAAmBA,EAChC,KAAKA,EACH0zC,GAAax/C,EAAS2J,EAAQ,GAAK3J,EAKtCohD,EAASrlC,QAASm4B,SAAUsL,GAAmBxa,QAElDriC,EAAMmR,sBACGnR,EAAM/C,MAAQkM,IAAenJ,EAAM/C,MAAQkM,KAEpDnJ,EAAMmR,iBACNkrC,SAjDsE,CAEtE,MAAMr1C,EAAQxD,EAAQoqB,QAAQ8wB,GAC7BD,EAAUrlC,QAASm4B,SAAUvqC,GAAeq7B,QAC7CriC,EAAMmR,iBA+CRnR,EAAM+8C,YAAYC,2BAClBh9C,EAAMi9C,mBAIN,SAOE,sBAAKvN,UAAU,iBAAiBO,IAAKwO,EAArC,SACGj7C,EAAQoB,KAAI,CAACs2C,EAAQz6C,IACpB,0BACEivC,UAAU,gBACVgB,QAAU1wC,IACPA,EAAMq9C,cAAoChb,QAC3CsP,EAASuJ,EAAO97C,QAElB8xC,MAAK,UAAKgK,EAAO35C,KAAZ,mBAAsB25C,EAAOyD,WAAWh0C,eAC7C,aAAYuwC,EAAO35C,MAAQ,OAC3B,oBAAmB25C,EAAOyD,WAE1B1O,IAAMpF,IACAA,GAAY,IAANpqC,IACR89C,EAAWnlC,QAAUyxB,GAEnBA,GAAMqQ,EAAO97C,QAAUA,IACzBo/C,EAAYplC,QAAUyxB,IAG1ByS,QAAS,KACP3L,EAASuJ,EAAO97C,QAnBpB,UAsBG87C,EAAO9J,KACR,uBAAM1B,UAAU,oBAAhB,SAAqCwL,EAAOyD,eAdvCzD,EAAO35C,YAsBjB,SAASu9C,GAAT,GAYH,IAAD,MAZ2B,MAC5B1/C,EAD4B,MAE5BD,EAF4B,QAG5BqE,EAH4B,SAI5BmuC,EAJ4B,MAK5BnqB,EAAQ,IAOP,EACD,MAAOy2B,EAAUC,GAAapO,IAAM55B,UAAS,GACvC6oC,EAAgBjP,IAAMO,OAAY,MAClC7gC,EAAQ3I,IAAcjB,IAE5B,OACE,yBAAO8pC,UAAW,mBAAlB,UACE,yBACEtyC,KAAMoqB,EACNkoB,UAAWuO,EAAW,SAAW,GACjC,aAAY9+C,EACZuxC,QAAS,IAAMwN,GAAWD,GAC1BhO,IAAK8O,EALP,mBAOGv7C,EAAQ2pB,MAAM+tB,GAAWA,EAAO97C,QAAUA,WAP7C,aAOG,EAAkDgyC,OAErD,eAAC,IAAMgN,SAAP,CAAgBC,SAAS,GAAzB,SACGJ,EACC,uCACE,eAAC,GAAD,CACE5C,eAAiBr7C,GACfA,EAAMC,SAAW8+C,EAAc3lC,SAAW8kC,GAAU,MAEjD1uC,EAAQ,CAAExJ,MAAO,KAAQ,CAAED,MAAO,KAJzC,SAME,eAAC,GAAD,CACEvC,QAASA,EACTpE,MAAOA,EACPD,MAAOA,EACPwyC,SAAUA,EACV0K,QAAS,KAAO,IAAD,EACb6B,GAAU,GACV,UAAAa,EAAc3lC,eAAd,SAAuBipB,aAI7B,sBAAKqN,UAAU,uBAEf,UCvHZ,MAAMsP,GAAiB,CACrB/gC,EACA1I,EACAmV,IAEOzM,EAASrZ,KAAKyR,IAAa,IAAD,EAC/B,OACEd,EAASjB,mBAAmB+B,EAAQhR,KACpCgR,EAAQhR,MAAR,UAAekQ,EAAS3C,sBAAxB,aAAe,EAAyBvN,IAEjCqlB,EAASrU,GAEXA,KAIL4oC,GAAe,SACnBhhC,EACA1I,EACA2pC,EACAC,GACW,IAAD,IACV,MAAMvsC,EAAiB2C,EAAS3C,eAC1B6W,EAAqBW,GAAsBnM,GACjD,2BACGrL,GAAkBssC,EAAatsC,UADlC,QAEGu6B,GAAsB1jB,EAAoBlU,GlBtDK,EAClD0I,EACA1I,EACA2pC,KAEA,MAAME,EAAaz0B,MAAMC,KACvB,IAAIpB,IACFiE,GAAoBxP,EAAU1I,GAAU3Q,KAAKyR,GAC3C6oC,EAAa7oC,OAInB,OAA6B,IAAtB+oC,EAAW/hD,OAAe+hD,EAAW,GAAK,MkB2C3CC,CACE51B,EACAlU,EACA2pC,GAEFC,SARN,QASE,MCzFSG,ID6F0BnI,GAAS,CAC9C/5C,KAAM,oBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,IACDA,EAAMiT,wBAA0B,CAClC4L,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GACrCuD,GAAevD,EAAG9/B,MACrBkhB,GAAe4e,EAAI,CACjBvqB,YAAalhB,EAAMiT,yBAErBw4B,KAGRt1B,SAAU,IACLA,KACAnW,GAELq4C,kBAAmBr4C,EAAMiT,yBAG7BwlC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,uCACE,qBAAI,cAAY,OAAhB,SAAwBvyC,EAAE,mBAC1B,eAAC,GAAD,CACEwF,KAAK,gBACL5L,MAAOoG,EAAE,iBACTsK,MAAOovC,GACLhhC,EACA1I,GACCc,GAAYA,EAAQiK,aACrB/K,EAASlD,wBAEXs/B,SAAW9hC,GAAUioC,EAAW,CAAEzlC,uBAAwBxC,IAC1DouC,SAAiC,sBAAvB1oC,EAASvB,UACnBkqC,UAAY/C,GACVrD,EAAW,CAAE9jC,UAAWmnC,EAAS,oBAAsB,eAOtBhE,GAAS,CAClD/5C,KAAM,wBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,IACDA,EAAMwS,4BAA8B,CACtCqM,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GAC5C5e,GAAe4e,EAAI,CACjB/nB,gBAAiB1jB,EAAMwS,gCAI7B2D,SAAU,IACLA,KACAnW,GAELq4C,kBAAmBr4C,EAAMwS,6BAG7BimC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,uCACE,qBAAI,cAAY,OAAhB,SAAwBvyC,EAAE,uBAC1B,eAAC,GAAD,CACEwF,KAAK,oBACL5L,MAAOoG,EAAE,qBACTsK,MAAOovC,GACLhhC,EACA1I,GACCc,GAAYA,EAAQyM,iBACrBvN,EAAS3D,4BAEX+/B,SAAW9hC,GAAUioC,EAAW,CAAElmC,2BAA4B/B,IAC9DouC,SAAiC,0BAAvB1oC,EAASvB,UACnBkqC,UAAY/C,GACVrD,EAAW,CAAE9jC,UAAWmnC,EAAS,wBAA0B,eAOhChE,GAAS,CAC5C/5C,KAAM,kBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GAC5C5e,GAAe4e,EAAI,CACjBxqB,UAAWjhB,MAGfmW,SAAU,IAAKA,EAAUzD,qBAAsB1S,GAC/Cq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,sCACE,kCAASvyC,EAAE,iBACX,eAAC01C,GAAD,CACEz3C,QAAS,CACP,CACEpE,MAAO,UACPmC,KAAMgE,EAAE,kBACR6rC,KAAM,eAAC+D,GAAD,CAAiBt5C,MAAO0Z,EAAS1Z,SAEzC,CACEuD,MAAO,cACPmC,KAAMgE,EAAE,qBACR6rC,KAAM,eAACkE,GAAD,CAAoBz5C,MAAO0Z,EAAS1Z,SAE5C,CACEuD,MAAO,QACPmC,KAAMgE,EAAE,gBACR6rC,KAAM,eAACmE,GAAD,CAAe15C,MAAO0Z,EAAS1Z,UAGzC2rB,MAAM,OACNpoB,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYA,EAAQgK,WACrB9K,EAASzD,sBAEX6/B,SAAWvyC,IACT04C,EAAW14C,YAOkB+3C,GAAS,CAC9C/5C,KAAM,oBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GAC5C5e,GAAe4e,EAAI,CACjBxrB,YAAajgB,MAGjBmW,SAAU,IAAKA,EAAU/C,uBAAwBpT,GACjDq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,sCACE,kCAASvyC,EAAE,wBACX,eAAC01C,GAAD,CACEzzB,MAAM,eACNhkB,QAAS,CACP,CACEpE,MAAO,EACPmC,KAAMgE,EAAE,eACR6rC,KAAM,eAACoE,GAAD,CAAiB35C,MAAO0Z,EAAS1Z,MAAOwjB,YAAa,KAE7D,CACEjgB,MAAO,EACPmC,KAAMgE,EAAE,eACR6rC,KAAM,eAACoE,GAAD,CAAiB35C,MAAO0Z,EAAS1Z,MAAOwjB,YAAa,KAE7D,CACEjgB,MAAO,EACPmC,KAAMgE,EAAE,oBACR6rC,KAAM,eAACoE,GAAD,CAAiB35C,MAAO0Z,EAAS1Z,MAAOwjB,YAAa,OAG/DjgB,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYA,EAAQgJ,aACrB9J,EAAS/C,wBAEXm/B,SAAWvyC,GAAU04C,EAAW14C,WAMF+3C,GAAS,CAC7C/5C,KAAM,mBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GAC5C5e,GAAe4e,EAAI,CACjBzoB,KAAMgJ,KACN1I,UAAWtjB,MAGfmW,SAAU,IAAKA,EAAUpD,qBAAsB/S,GAC/Cq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,sCACE,kCAASvyC,EAAE,uBACX,eAAC01C,GAAD,CACEzzB,MAAM,aACNhkB,QAAS,CACP,CACEpE,MAAO,EACPmC,KAAMgE,EAAE,oBACR6rC,KAAM,eAACwE,GAAD,CAAyB/5C,MAAO0Z,EAAS1Z,SAEjD,CACEuD,MAAO,EACPmC,KAAMgE,EAAE,iBACR6rC,KAAM,eAACyE,GAAD,CAAsBh6C,MAAO0Z,EAAS1Z,SAE9C,CACEuD,MAAO,EACPmC,KAAMgE,EAAE,qBACR6rC,KAAM,eAAC0E,GAAD,CAA0Bj6C,MAAO0Z,EAAS1Z,UAGpDuD,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYA,EAAQqM,WACrBnN,EAASpD,sBAEXw/B,SAAWvyC,GAAU04C,EAAW14C,WAMD+3C,GAAS,CAC9C/5C,KAAM,oBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GAC5C5e,GAAe4e,EAAI,CACjBvoB,YAAaljB,MAGjBmW,SAAU,IAAKA,EAAUhD,uBAAwBnT,GACjDq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,sCACE,kCAASvyC,EAAE,wBACX,eAAC01C,GAAD,CACEzzB,MAAM,cACNhkB,QAAS,CACP,CACEpE,MAAO,QACPmC,KAAMgE,EAAE,4BACR6rC,KAAM,eAACqE,GAAD,CAAsB55C,MAAO0Z,EAAS1Z,SAE9C,CACEuD,MAAO,SACPmC,KAAMgE,EAAE,6BACR6rC,KAAM,eAACsE,GAAD,CAAuB75C,MAAO0Z,EAAS1Z,SAE/C,CACEuD,MAAO,SACPmC,KAAMgE,EAAE,6BACR6rC,KAAM,eAACuE,GAAD,CAAuB95C,MAAO0Z,EAAS1Z,UAGjDuD,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYA,EAAQiM,aACrB/M,EAAShD,wBAEXo/B,SAAWvyC,GAAU04C,EAAW14C,WAML+3C,GAAS,CAC1C/5C,KAAM,gBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GAC5C5e,GAAe4e,EAAI,CACjB7qB,QAAS5gB,MAGbmW,SAAU,IAAKA,EAAUrD,mBAAoB9S,GAC7Cq4C,iBAAiB,IAGrBI,eAAgB,cAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,yBAAOpI,UAAU,gBAAjB,UACGnqC,EAAE,kBACH,wBACEwF,KAAK,QACLR,IAAI,IACJoP,IAAI,MACJ4lC,KAAK,KACL5N,SAAW3xC,GAAU83C,GAAY93C,EAAMC,OAAOb,OAC9CogD,QAAUx/C,IACRA,EAAMi9C,kBACN,MAIM79C,GAJSY,EAAMC,OAICb,MAElBY,EAAM8/B,OAAS,GAAK1gC,EAJZ,IAKV04C,EAAW14C,EANA,IAOFY,EAAM8/B,OAAS,GAAK1gC,EALnB,GAMV04C,EAAW14C,EARA,KAWfA,MAAK,UACH6/C,GACEhhC,EACA1I,GACCc,GAAYA,EAAQ2J,SACrBzK,EAASrD,2BALR,aAMEhL,UAOqBiwC,GAAS,CAC3C/5C,KAAM,iBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,IAC5C,GAAIr0B,GAAcq0B,GAAK,CACrB,MAAMx0B,EAAiC4V,GAAe4e,EAAI,CACxDr/B,SAAUpM,IAGZ,OADAorC,GAAsBn0B,GACfA,EAGT,OAAOw0B,KAETt1B,SAAU,IACLA,EACHvD,oBAAqB5S,GAEvBq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,sCACE,kCAASvyC,EAAE,qBACX,eAAC01C,GAAD,CACEzzB,MAAM,YACNhkB,QAAS,CACP,CACEpE,MAAO,GACPmC,KAAMgE,EAAE,gBACR6rC,KAAM,eAACoF,GAAD,CAAmB36C,MAAO0Z,EAAS1Z,SAE3C,CACEuD,MAAO,GACPmC,KAAMgE,EAAE,iBACR6rC,KAAM,eAACqF,GAAD,CAAoB56C,MAAO0Z,EAAS1Z,SAE5C,CACEuD,MAAO,GACPmC,KAAMgE,EAAE,gBACR6rC,KAAM,eAACsF,GAAD,CAAmB76C,MAAO0Z,EAAS1Z,SAE3C,CACEuD,MAAO,GACPmC,KAAMgE,EAAE,oBACR6rC,KAAM,eAACuF,GAAD,CAAwB96C,MAAO0Z,EAAS1Z,UAGlDuD,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYG,GAAcH,IAAYA,EAAQ7K,UAC/C+J,EAASvD,qBAAuBvZ,KAElCk5C,SAAWvyC,GAAU04C,EAAW14C,WAMF+3C,GAAS,CAC7C/5C,KAAM,mBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,IAC5C,GAAIr0B,GAAcq0B,GAAK,CACrB,MAAMx0B,EAAiC4V,GAAe4e,EAAI,CACxDz/B,WAAYhM,IAGd,OADAorC,GAAsBn0B,GACfA,EAGT,OAAOw0B,KAETt1B,SAAU,IACLA,EACHxD,sBAAuB3S,GAEzBq4C,iBAAiB,IAGrBI,eAAgB,IAAyC,IAAxC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAiB,EACtD,MAAMt0C,EAIA,CACJ,CACEpE,MAAOnH,IAAYC,OACnBqJ,KAAMgE,EAAE,oBACR6rC,KAAM,eAACwF,GAAD,CAAyB/6C,MAAO0Z,EAAS1Z,SAEjD,CACEuD,MAAOnH,IAAYE,UACnBoJ,KAAMgE,EAAE,iBACR6rC,KAAM,eAACyF,GAAD,CAAsBh7C,MAAO0Z,EAAS1Z,SAE9C,CACEuD,MAAOnH,IAAYG,SACnBmJ,KAAMgE,EAAE,eACR6rC,KAAM,eAAC0F,GAAD,CAAoBj7C,MAAO0Z,EAAS1Z,UAI9C,OACE,sCACE,kCAAS0J,EAAE,uBACX,eAAC01C,GAAD,CACEzzB,MAAM,cACNhkB,QAASA,EACTpE,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYG,GAAcH,IAAYA,EAAQjL,YAC/CmK,EAASxD,uBAAyBrZ,KAEpCi5C,SAAWvyC,GAAU04C,EAAW14C,WAOL+3C,GAAS,CAC5C/5C,KAAM,kBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KACrB,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,IAC5C,GAAIr0B,GAAcq0B,GAAK,CACrB,MAAMx0B,EAAiC4V,GAAe4e,EAAI,CACxDtpB,UAAWniB,IAGb,OADAorC,GAAsBn0B,GACfA,EAGT,OAAOw0B,KAETt1B,SAAU,IACLA,EACH9C,qBAAsBrT,GAExBq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,sCACE,kCAASvyC,EAAE,sBACX,eAAC01C,GAAD,CACEzzB,MAAM,aACNhkB,QAAS,CACP,CACEpE,MAAO,OACPmC,KAAMgE,EAAE,eACR6rC,KAAM,eAAC2F,GAAD,CAAmBl7C,MAAO0Z,EAAS1Z,SAE3C,CACEuD,MAAO,SACPmC,KAAMgE,EAAE,iBACR6rC,KAAM,eAAC4F,GAAD,CAAqBn7C,MAAO0Z,EAAS1Z,SAE7C,CACEuD,MAAO,QACPmC,KAAMgE,EAAE,gBACR6rC,KAAM,eAAC6F,GAAD,CAAoBp7C,MAAO0Z,EAAS1Z,UAG9CuD,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYG,GAAcH,IAAYA,EAAQkL,WAC/ChM,EAAS9C,sBAEXk/B,SAAWvyC,GAAU04C,EAAW14C,WAMH+3C,GAAS,CAC5C/5C,KAAM,kBACNo6C,QAAS,CAACv5B,EAAU1I,EAAUnW,KAC5B,MAAMs6C,EAAiBtM,GACrBhjB,GAAsBnM,GACtB1I,GAEIkqC,EAAmC/F,EAAer8C,OACpDq8C,EAAegG,OAAO7U,IAAQl0B,GAAgBk0B,MAC7Cj0B,GAAoBrB,EAASvC,aAC5B2sC,EAAgCjG,EAAer8C,OACjDq8C,EAAegG,MAAM/oC,IACrBC,GAAoBrB,EAASvC,aACjC,MAAO,CACLiL,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,GAC5C5e,GAAe4e,EAAI,CACjBnsB,gBAAiBtf,MAGrBmW,SAAU,IACLA,EACHjD,2BAA4BmtC,EACxBrgD,EACAmW,EAASjD,2BACbL,iCAAkC0tC,EAC9BvgD,EACAmW,EAAStD,kCAEfwlC,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,sCACE,kCAASvyC,EAAE,kBACX,eAAC01C,GAAD,CACEzzB,MAAM,QACNhkB,QAAS,CACP,CACEpE,MAAO,QACPmC,KAAMgE,EAAE,gBACR6rC,KAAM,eAAC2E,GAAD,CAAel6C,MAAO0Z,EAAS1Z,SAEvC,CACEuD,MAAO,QACPmC,KAAMgE,EAAE,gBACR6rC,KAAM,eAAC4E,GAAD,CAAen6C,MAAO0Z,EAAS1Z,UAGzCuD,MAAO6/C,GACLhhC,EACA1I,GACCc,GAAYA,EAAQqI,iBACpB6vB,GAAmBh5B,EAASvC,eAC1B4D,GAAoBrB,EAASvC,aAC1BuC,EAAStD,iCACTsD,EAASjD,6BACb,MAEJq/B,SAAWvyC,GAAU04C,EAAW14C,WAMH+3C,GAAS,CAC5C/5C,KAAM,kBACNo6C,QAAS,CACPv5B,EACA1I,EACAnW,KAEO,CACL6e,SAAU+gC,GAAe/gC,EAAU1I,GAAWs1B,IAC5C,GAAIl0B,GAAgBk0B,GAAK,CACvB,MAAM,SAAE9+B,EAAF,KAAYhB,GAAS3L,EAE3B,GAAiB,UAAb2M,EAAsB,CAIxB,OAHyCkgB,GAAe4e,EAAI,CAC1D/mB,eAAgB/Y,IAGb,GAAiB,QAAbgB,EAAoB,CAI7B,OAHyCkgB,GAAe4e,EAAI,CAC1D9mB,aAAchZ,KAMpB,OAAO8/B,KAETt1B,SAAU,IACLA,EACH,CAAoB,UAAnBnW,EAAM2M,SACH,4BACA,2BAA4B3M,EAAM2L,MAExC0sC,iBAAiB,IAGrBI,eAAgB,IAAyC,IAAxC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAiB,EACtD,MAAMtoC,EAAQ3I,IAAcjB,IAE5B,OACE,sCACE,kCAASL,EAAE,uBACX,uBAAKmqC,UAAU,iBAAf,UACE,eAAC,GAAD,CACEvwC,MAAM,kBACNqE,QAAS,CACP,CACEpE,MAAO,KACPmC,KAAMgE,EAAE,yBACR6rC,KAAM,eAAC6E,GAAD,CAAmBp6C,MAAO0Z,EAAS1Z,QACzC8iD,WAAY,KAEd,CACEv/C,MAAO,QACPmC,KAAMgE,EAAE,0BACR6rC,KACE,eAAC8E,GAAD,CAAoBr6C,MAAO0Z,EAAS1Z,MAAOs6C,MAAO3mC,IAEpDmvC,WAAY,KAEd,CACEv/C,MAAO,MACPmC,KAAMgE,EAAE,wBACR6rC,KAAM,eAACkF,GAAD,CAAkBz6C,MAAO0Z,EAAS1Z,MAAOs6C,MAAO3mC,IACtDmvC,WAAY,KAEd,CACEv/C,MAAO,MACPmC,KAAMgE,EAAE,wBACR6rC,KAAM,eAACiF,GAAD,CAAkBx6C,MAAO0Z,EAAS1Z,MAAOs6C,MAAO3mC,IACtDmvC,WAAY,KAEd,CACEv/C,MAAO,WACPmC,KAAMgE,EAAE,6BACR6rC,KACE,eAACmF,GAAD,CAAuB16C,MAAO0Z,EAAS1Z,MAAOs6C,MAAO3mC,IAEvDmvC,WAAY,MAGhBv/C,MAAO6/C,GACLhhC,EACA1I,GACCc,GACCM,GAAgBN,IAAYo4B,GAAkBp4B,EAAQtL,MAClDsL,EAAQyN,eACRvO,EAASnD,2BACfmD,EAASnD,2BAEXu/B,SAAWvyC,GAAU04C,EAAW,CAAE/rC,SAAU,QAAShB,KAAM3L,MAE7D,eAAC,GAAD,CACED,MAAM,gBACNqoB,MAAM,aACNhkB,QAAS,CACP,CACEpE,MAAO,KACPmC,KAAMgE,EAAE,yBACRo5C,WAAY,IACZvN,KAAM,eAAC6E,GAAD,CAAmBp6C,MAAO0Z,EAAS1Z,SAE3C,CACEuD,MAAO,QACPmC,KAAMgE,EAAE,0BACRo5C,WAAY,IACZvN,KACE,eAAC8E,GAAD,CAAoBr6C,MAAO0Z,EAAS1Z,MAAOs6C,KAAM3mC,KAGrD,CACEpQ,MAAO,MACPmC,KAAMgE,EAAE,wBACRo5C,WAAY,IACZvN,KAAM,eAACkF,GAAD,CAAkBz6C,MAAO0Z,EAAS1Z,MAAOs6C,KAAM3mC,KAEvD,CACEpQ,MAAO,MACPmC,KAAMgE,EAAE,wBACRo5C,WAAY,IACZvN,KAAM,eAACiF,GAAD,CAAkBx6C,MAAO0Z,EAAS1Z,MAAOs6C,KAAM3mC,KAEvD,CACEpQ,MAAO,WACPmC,KAAMgE,EAAE,6BACR6rC,KACE,eAACmF,GAAD,CAAuB16C,MAAO0Z,EAAS1Z,MAAOs6C,KAAM3mC,IAEtDmvC,WAAY,MAGhBv/C,MAAO6/C,GACLhhC,EACA1I,GACCc,GACCM,GAAgBN,IAAYo4B,GAAkBp4B,EAAQtL,MAClDsL,EAAQ0N,aACRxO,EAAS1D,yBACf0D,EAAS1D,yBAEX8/B,SAAWvyC,GAAU04C,EAAW,CAAE/rC,SAAU,MAAOhB,KAAM3L,eChyBtC4wC,IAK7B,MAAMkB,EACJlB,EAAMkB,QACW,SAAhBlB,EAAM5wC,MAAmBmG,EAAE,qBAAuBA,EAAE,qBAEvD,OACE,eAACsqC,GAAD,CACE9kC,KAAK,OACLqmC,KAAMpB,EAAM5wC,QAAU/G,IAAMC,MAAQsnD,GAAMC,KAAOD,GAAME,IACvD5O,MAAOA,EACP,aAAYA,EACZR,QAAS,IACPV,EAAM2B,SAAS3B,EAAM5wC,QAAU/G,IAAME,KAAOF,IAAMC,MAAQD,IAAME,MAElE,cAAY,uBAKZqnD,GAAQ,CACZE,IACE,sBAAKzzC,MAAM,MAAME,OAAO,MAAMmjC,UAAU,aAAaC,QAAQ,cAA7D,SACE,uBACEjvB,KAAK,eACLqX,EAAE,klBAIR8nB,KACE,sBAAKxzC,MAAM,MAAME,OAAO,MAAMmjC,UAAU,aAAaC,QAAQ,cAA7D,SACE,uBACEjvB,KAAK,eACLqX,EAAE,uT,MCzCV,MAAMgoB,GAAgB,KACpB,MAAMC,EAAcv5C,SAASuK,cAC3B,uBAEF,GAAIgvC,EACF,OAAOA,EAET,MAAMC,EAAMx5C,SAASmF,cAAc,OAGnC,OAFAnF,SAASoF,KAAKI,YAAYg0C,GAC1BA,EAAIC,UAAUn1B,IAAI,sBACXk1B,GAoDIE,GAAU,IAAsD,IAArD,SAAE5O,EAAF,MAAYpyC,EAAZ,KAAmBihD,GAAO,GAA0B,EAM1E,OALAzP,qBAAU,IACD,IACLoP,KAAgBG,UAAUr+B,OAAO,gCAClC,IAGD,sBACE6tB,UAAU,6BACV2Q,eAAiBrgD,GA1DD,EACpBsgD,EACAC,EACAphD,EACAihD,KAEAG,EAAQL,UAAUn1B,IAAI,+BACtBw1B,EAAQz0C,MAAM00C,SAAWJ,EAAO,OAAS,OACzCG,EAAQz0C,MAAMu+B,SAAW+V,EAAO,OAAS,OAEzCG,EAAQp4B,YAAchpB,EAEtB,MACEgN,EAAGs0C,EACHtU,OAAQuU,EACRzU,IAAK0U,EACLt0C,MAAOu0C,GACLN,EAAK7E,yBAEDpvC,MAAOw0C,EAAYt0C,OAAQu0C,GACjCP,EAAQ9E,wBAEJrQ,EAAgBxxC,OAAO8hD,WAKvB31C,EAAO06C,EAAQG,EAAY,EAAIC,EAAa,EAC5CjyC,EACJ7I,EAAO86C,GAAczV,EAAgBrlC,EAAO86C,EAAazV,EAAgB,EAErEa,EAAMyU,EANG,EAOT7zC,EACJo/B,EAAM6U,GAVelnD,OAAO+hD,YAWxB+E,EAAaC,EAAUG,EAAcC,GACrC,EAENt7C,OAAOsrB,OAAOwvB,EAAQz0C,MAAO,CAC3BmgC,IAAI,GAAD,OAAKA,EAAMp/B,EAAX,MACH9G,KAAK,GAAD,OAAKA,EAAO6I,EAAZ,SAoBAoyC,CACEhhD,EAAMq9C,cACN0C,KACA5gD,EACAihD,GAGJa,eAAgB,IACdlB,KAAgBG,UAAUr+B,OAAO,+BAXrC,SAcG0vB,K,MCrBQ2P,OAzDK,IAA+C,IAA9C,UAAEC,GAA2C,EAChE,MAAOC,EAAYC,GAAiBnrC,oBAAS,GACvCorC,EAAe,KACnBD,GAAeD,IAGjB,OACE,uCACE,eAACvR,GAAD,CACE9kC,KAAK,SACLqmC,KAAMsB,GACNxB,MAAO3rC,EAAE,sBACT,aAAYA,EAAE,sBACd+rC,cAAeiQ,KACf7Q,QAAS4Q,EACT,cAAY,wBAGbF,GACC,eAAC,GAAD,CACE/F,eAAgBiG,EAChBpQ,MAAO3rC,EAAE,2BACTmqC,UAAU,eACV8R,OAAO,EAJT,SAME,uCACE,qBAAG9R,UAAU,wBAAb,cAAuCnqC,EAAE,wBACzC,uBAAKmqC,UAAU,uBAAf,UACE,eAACG,GAAD,CACE9kC,KAAK,SACLmmC,MAAO3rC,EAAE,iBACT,aAAYA,EAAE,iBACdpG,MAAOoG,EAAE,iBACTmrC,QAAS,KACPyQ,IACAG,KAEF,cAAY,8BACZ5R,UAAU,0BAEZ,eAACG,GAAD,CACE9kC,KAAK,SACLmmC,MAAO3rC,EAAE,kBACT,aAAYA,EAAE,kBACdpG,MAAOoG,EAAE,kBACTmrC,QAAS4Q,EACT,cAAY,6BACZ5R,UAAU,qCCpCqByH,GAAS,CACtD/5C,KAAM,4BACNo6C,QAAS,CAACvgB,EAAG1hB,EAAUnW,KACd,CACLmW,SAAU,IAAKA,KAAanW,GAC5Bq4C,kBAAmBr4C,EAAM2V,sBAG7B8iC,eAAgB,IAA+B,IAA9B,SAAEtiC,EAAF,WAAYuiC,GAAiB,EAC5C,OACE,sBAAKhsC,MAAO,CAAEC,SAAU,YAAxB,SACE,eAAC,GAAD,CACE5M,MAAOoG,EAAE,2BACTwF,KAAK,mBACL8E,MAAO0F,EAASR,oBAChB48B,SAAW9hC,GAAUioC,EAAW,CAAE/iC,oBAAqBlF,IACvDouC,SAAiC,sBAAvB1oC,EAASvB,UACnBkqC,UAAY/C,GACVrD,EAAW,CAAE9jC,UAAWmnC,EAAS,oBAAsB,OAEzD,cAAY,kCAOWhE,GAAS,CACxC/5C,KAAM,cACNo6C,QAAS,CAACv5B,EAAU1I,EAAU0hB,EAAGwqB,KAC/BA,EAAIviC,WAAWqL,QACR,CACLtM,SAAUA,EAASrZ,KAAKyR,GACtB4V,GAAe5V,EAAS,CAAEmY,WAAW,MAEvCjZ,SAAU,IACL/D,KACH2V,MAAO,GACPtrB,MAAO0Z,EAAS1Z,MAChBkX,cAAewC,EAASxC,cACxBG,iBAAkBqC,EAASrC,iBAC3BE,iBAAkBmC,EAASnC,iBAC3BG,SAAUgC,EAAShC,SACnBoB,UAAWY,EAASZ,UACpBV,YAAasB,EAAStB,aAExBwjC,iBAAiB,IAIrBI,eAAgB,QAAC,WAAEC,GAAH,SAAoB,eAAC,GAAD,CAAaqJ,UAAWrJ,OAGlCX,GAAS,CACnC/5C,KAAM,SACNo6C,QAAS,CAACkK,EAAWnsC,KACnB,MAAM5G,EAAOggC,GACXK,GAAkBz5B,EAAS5G,KAAKvP,MAAQ5E,KACxC+a,EAAS5G,KACT,CAAE5I,KAAMwP,EAAS3G,WAAYq9B,IAAK12B,EAAS1I,WAC3C,CAAEV,EAAGoJ,EAASlJ,MAAQ,EAAGuB,EAAG2H,EAAShJ,OAAS,IAEhD,MAAO,CACLgJ,SAAU,IACLA,EACH5G,QAEF8oC,iBAAiB,IAGrBI,eAAgB,QAAC,WAAEC,GAAH,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLqmC,KAAM2B,GACN7B,MAAK,UAAK3rC,EAAE,kBAAP,mBAA8B+I,GAAe,gBAClD,aAAY/I,EAAE,kBACdmrC,QAAS,KACPoH,EAAW,OAEb92B,KAAK,WAGT42B,QAAU53C,IACPA,EAAMmF,OAAS+D,GAAelJ,EAAMmF,OAAS+D,KAC7ClJ,EAAMmJ,IAAqBnJ,EAAMwJ,YAGT2tC,GAAS,CACpC/5C,KAAM,UACNo6C,QAAS,CAACkK,EAAWnsC,KACnB,MAAM5G,EAAOggC,GACXK,GAAkBz5B,EAAS5G,KAAKvP,MAAQ5E,KACxC+a,EAAS5G,KACT,CAAE5I,KAAMwP,EAAS3G,WAAYq9B,IAAK12B,EAAS1I,WAC3C,CAAEV,EAAGoJ,EAASlJ,MAAQ,EAAGuB,EAAG2H,EAAShJ,OAAS,IAGhD,MAAO,CACLgJ,SAAU,IACLA,EACH5G,QAEF8oC,iBAAiB,IAGrBI,eAAgB,QAAC,WAAEC,GAAH,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLqmC,KAAM4B,GACN9B,MAAK,UAAK3rC,EAAE,mBAAP,mBAA+B+I,GAAe,gBACnD,aAAY/I,EAAE,mBACdmrC,QAAS,KACPoH,EAAW,OAEb92B,KAAK,WAGT42B,QAAU53C,IACPA,EAAMmF,OAAS+D,GAAelJ,EAAMmF,OAAS+D,KAC7ClJ,EAAMmJ,IAAqBnJ,EAAMwJ,YAGP2tC,GAAS,CACtC/5C,KAAM,YACNo6C,QAAS,CAACkK,EAAWnsC,KACZ,CACLA,SAAU,IACLA,EACH5G,KAAMggC,GACJ,EACAp5B,EAAS5G,KACT,CAAE5I,KAAMwP,EAAS3G,WAAYq9B,IAAK12B,EAAS1I,WAC3C,CACEV,EAAGoJ,EAASlJ,MAAQ,EACpBuB,EAAG2H,EAAShJ,OAAS,KAI3BkrC,iBAAiB,IAGrBI,eAAgB,QAAC,WAAEC,EAAF,SAAcviC,GAAf,SACd,eAAC,GAAD,CAASpW,MAAOoG,EAAE,qBAAlB,SACE,gBAACsqC,GAAD,CACE9kC,KAAK,SACL2kC,UAAU,oBACVwB,MAAO3rC,EAAE,qBACT,aAAYA,EAAE,qBACdmrC,QAAS,KACPoH,EAAW,OAEb92B,KAAK,QARP,WAU0B,IAAtBzL,EAAS5G,KAAKvP,OAAa0R,QAAQ,GAVvC,UAcJ8mC,QAAU53C,IACPA,EAAMmF,OAAS+D,GAAclJ,EAAMmF,OAAS+D,KAC5ClJ,EAAMmJ,IAAqBnJ,EAAMwJ,YA/J/B,MAqLDm4C,GAAoB,CACxB1jC,EACA1I,EACAqsC,KAEA,MAAMn4B,EAAqBW,GAAsBnM,GAC3CuP,EAAmBC,GAAoBhE,EAAoBlU,GAE3DssC,EACJD,GAAmBp0B,EAAiBnwB,OAAS,EACzC2gB,GAAgBwP,GAChBxP,GAAgByL,GAEhB/Q,EAhC+B,EACrCuE,EACAswB,KAEA,MAAOt2B,EAAIC,EAAIC,EAAIC,GAAM6F,EACnB6kC,EAAoB3qC,EAAKF,EACzB8qC,EAAoBxU,EAAmBlhC,MAAQy1C,EAC/CE,EAAqB5qC,EAAKF,EAC1B+qC,EAAqB1U,EAAmBhhC,OAASy1C,EACjDE,EAAoBtrD,KAAK2T,IAAIw3C,EAAmBE,GAChDE,EACJvrD,KAAK8sB,MAAMw+B,EAAoB1nD,KAAaA,IAK9C,OAJsC5D,KAAK2T,IACzC3T,KAAK+iB,IAAIwoC,EAAqB3nD,KAC9B,IAkBgB4nD,CAA+BP,EAAc,CAC7Dx1C,MAAOkJ,EAASlJ,MAChBE,OAAQgJ,EAAShJ,SAEb81C,EAAU1T,GAAWj2B,EAAWnD,EAAS5G,KAAM,CACnD5I,KAAMwP,EAAS3G,WACfq9B,IAAK12B,EAAS1I,aAGToK,EAAIC,EAAIC,EAAIC,GAAMyqC,EACnBvY,GAAWryB,EAAKE,GAAM,EACtBoyB,GAAWryB,EAAKE,GAAM,EAC5B,MAAO,CACL7B,SAAU,IACLA,KACA83B,GAAe,CAChBC,WAAY,CAAEnhC,EAAGm9B,EAAS17B,EAAG27B,GAC7BgE,mBAAoB,CAClBlhC,MAAOkJ,EAASlJ,MAChBE,OAAQgJ,EAAShJ,QAEnBoC,KAAM0zC,IAER1zC,KAAM0zC,GAER5K,iBAAiB,IC9NR6K,IDkOuBnL,GAAS,CAC3C/5C,KAAM,kBACNo6C,QAAS,CAACv5B,EAAU1I,IAAaosC,GAAkB1jC,EAAU1I,GAAU,GACvEqiC,QAAU53C,GACRA,EAAMmF,OAAS+D,GACflJ,EAAMwJ,WACLxJ,EAAMsJ,SACNtJ,EAAMmJ,KAGoBguC,GAAS,CACtC/5C,KAAM,YACNo6C,QAAS,CAACv5B,EAAU1I,IAAaosC,GAAkB1jC,EAAU1I,GAAU,GACvEqiC,QAAU53C,GACRA,EAAMmF,OAAS+D,GACflJ,EAAMwJ,WACLxJ,EAAMsJ,SACNtJ,EAAMmJ,KAGsBguC,GAAS,CACxC/5C,KAAM,cACNo6C,QAAS,CAACvgB,EAAG1hB,EAAUnW,KACd,CACLmW,SAAU,IACLA,EACH1Z,MACEuD,IAAUmW,EAAS1Z,QAAUxD,IAAMC,MAAQD,IAAME,KAAOF,IAAMC,QAElEm/C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAEtiC,EAAF,WAAYuiC,GAAb,SACd,sBAAKhsC,MAAO,CAAEy2C,kBAAmB,WAAjC,SACE,eAACjD,GAAD,CACElgD,MAAOmW,EAAS1Z,MAChB81C,SAAW91C,IACTi8C,EAAWj8C,SAKnB+7C,QAAU53C,GAAUA,EAAMsJ,QAAUtJ,EAAMwJ,UAAYxJ,EAAMmF,OAAS+D,IC5QzCiuC,GAAS,CACrC/5C,KAAM,WACNo6C,QAAS,CAACv5B,EAAU1I,EAAU0hB,EAArB,KAAwD,IAAD,MAA/B,OAAElpB,EAAF,eAAUy0C,GAAqB,EAC9D,GAAIjtC,EAASzC,qBAAsB,CACjC,MAAM,UAAE0qB,EAAF,oBAAaK,EAAb,kBAAkCC,GACtCvoB,EAASzC,qBACLuD,EAAUknB,GAAoBtT,WAAWuT,GAE/C,GAAInnB,EAQF,OAPIQ,GAAiBR,IACnB0oB,GACE1oB,EACAwnB,EACAC,GAGG,CACL7f,SACE5H,EAAQoC,OAAOpb,OAAS,GAAK8uB,GAAwB9V,GACjD4H,EAAShY,QAAQ4kC,GAAOA,EAAGxlC,KAAOgR,EAAQhR,UAC1C6B,EACNqO,SAAU,IACLA,EACHzC,qBAAsB,MAExB2kC,iBAAiB,GAKvB,IAAIqD,EAAc78B,EAEd1I,EAASL,qBACXqW,GAAchW,EAASL,oBAAqB,CAAEsZ,WAAW,IAAQ,GAG/D50B,OAAO6M,SAASm2C,yBAAyB/xC,aAC3C23C,IAGF,MAAMC,EAAoBltC,EAASzB,aAC/ByB,EAASzB,aACyB,cAAlC,UAAAyB,EAAS3C,sBAAT,eAAyB7H,MACzBwK,EAAS3C,eACT,KAEJ,GAAI6vC,EAAmB,CAErB,GAC6B,aAA3BA,EAAkB13C,MACe,UAAjCwK,EAAS1B,oBACT,CACA,MAAM,OAAE4E,EAAF,mBAAUoQ,GAAuB45B,EAEpC55B,GACDpQ,EAAOA,EAAOpb,OAAS,KAAOwrB,GAE9B0C,GAAck3B,EAAmB,CAC/BhqC,OAAQgqC,EAAkBhqC,OAAOpV,MAAM,GAAI,KAI7C8oB,GAAwBs2B,KAC1B3H,EAAcA,EAAYz3C,MAAM,GAAI,IAMtC,MAAMq/C,EAASlqC,GAAYiqC,EAAkBhqC,OAAQlD,EAAS5G,KAAKvP,OACnE,IAC6B,SAA3BqjD,EAAkB13C,MACS,aAA3B03C,EAAkB13C,OAEd23C,EAAQ,CACV,MAAMC,EAAaF,EAAkBhqC,OAC/BmqC,EAAaD,EAAW,GAC9Bp3B,GAAck3B,EAAmB,CAC/BhqC,OAAQkqC,EAAW/9C,KAAI,CAAC6S,EAAOzQ,IAC7BA,IAAU27C,EAAWtlD,OAAS,EACzB,CAACulD,EAAW,GAAIA,EAAW,IAC5BnrC,MAMZ,GACEZ,GAAiB4rC,KAChBC,GACDD,EAAkBhqC,OAAOpb,OAAS,EAClC,CACA,MAAO8O,EAAGyB,GAAK2vB,GAAoBgB,iCACjCkkB,GACC,GAEHlhB,GACEkhB,EACAltC,EACA+T,GAAM0C,SAASy2B,GACf,CAAEt2C,IAAGyB,MAIJ2H,EAASxC,eAA0C,aAAzBwC,EAASvC,cACtCuC,EAASjB,mBAAmBmuC,EAAkBp9C,KAAM,GAWxD,OANIkQ,EAASxC,eAA0C,aAAzBwC,EAASvC,cACpCyvC,GAED30C,GAAYC,GAGP,CACLkQ,SAAU68B,EACVvlC,SAAU,IACLA,EACHvC,aACGuC,EAASxC,eAA0C,aAAzBwC,EAASvC,cACpCyvC,EACIltC,EAASvC,YACT,YACNL,gBAAiB,KACjBmB,aAAc,KACdlB,eAAgB,KAChBgC,kBAAmB,KACnBC,kBAAmB,GACnBP,mBACEmuC,IACCltC,EAASxC,eACe,aAAzBwC,EAASvC,YACL,IACKuC,EAASjB,mBACZ,CAACmuC,EAAkBp9C,KAAK,GAE1BkQ,EAASjB,mBACfY,oBAAqB,MAEvBuiC,gBAA0C,aAAzBliC,EAASvC,cAG9B4kC,QAAS,CAAC53C,EAAOuV,IACdvV,EAAM/C,MAAQkM,KACsB,OAAlCoM,EAASzC,uBACNyC,EAAS5C,iBAA6C,OAA1B4C,EAASzB,gBACzC9T,EAAM/C,MAAQkM,IAAenJ,EAAM/C,MAAQkM,KACjB,OAA1BoM,EAASzB,aACb+jC,eAAgB,QAAC,SAAEtiC,EAAF,WAAYuiC,GAAb,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLqmC,KAAM6B,GACN/B,MAAO3rC,EAAE,gBACT,aAAYA,EAAE,gBACdmrC,QAASoH,EACThH,QAAkC,MAAzBv7B,EAASzB,mB,YC/JjB,MAAM+uC,GAAe7S,IAC1B,MAAM,GAAE3qC,GAAO8qC,MACR2S,EAAUC,GAAe7sC,mBAAiB85B,EAAM5wC,OAoBvD,OACE,uBAAKswC,UAAU,cAAf,UACE,wBAAOA,UAAU,oBAAoBsT,QAAQ,WAA7C,mBACMhT,EAAM7wC,OADZ,OACoB6wC,EAAMiT,eAAiB,GAAK,OAE/CjT,EAAMiT,eACL,wBACEvT,UAAU,YACVqO,OA1BY/9C,IvDgaaqW,KACjC,IAAI6sC,EAAS7sC,EAAQ8sC,cACrB,KAAOD,GAAQ,CACb,GAAIA,EAAOhG,UAAY,EAErB,YADAgG,EAAO7gB,QAGT6gB,EAASA,EAAOC,gBuDtahBC,CAAmBpjD,EAAMC,QACzB,MAAMb,EAAQY,EAAMC,OAAOb,MACvBA,IAAU4wC,EAAM5wC,OAClB4wC,EAAM2B,SAASvyC,IAuBXu9C,UAnBe38C,IACrB,GAAkB,UAAdA,EAAM/C,IAAiB,CAEzB,GADA+C,EAAMmR,iBACFnR,EAAM+8C,YAAYsG,aAAiC,MAAlBrjD,EAAMsjD,QACzC,OAEFtjD,EAAMq9C,cAAckG,SAchBl+C,GAAE,UAAKA,EAAL,aACFjG,MAAO0jD,EACPnR,SAAW3xC,GAAU+iD,EAAY/iD,EAAMC,OAAOb,SAGhD,uBAAMswC,UAAU,gCAAgCrqC,GAAE,UAAKA,EAAL,aAAlD,SACG2qC,EAAM5wC,YC3CJokD,GAAY,CACvB1jC,EACA3T,EACAyB,EACAvB,EACAE,EACAgvB,KAEAzb,EAAQ2jC,YACR3jC,EAAQ4jC,OAAOv3C,EAAIovB,EAAQ3tB,GAC3BkS,EAAQ6jC,OAAOx3C,EAAIE,EAAQkvB,EAAQ3tB,GACnCkS,EAAQ8jC,iBAAiBz3C,EAAIE,EAAOuB,EAAGzB,EAAIE,EAAOuB,EAAI2tB,GACtDzb,EAAQ6jC,OAAOx3C,EAAIE,EAAOuB,EAAIrB,EAASgvB,GACvCzb,EAAQ8jC,iBACNz3C,EAAIE,EACJuB,EAAIrB,EACJJ,EAAIE,EAAQkvB,EACZ3tB,EAAIrB,GAENuT,EAAQ6jC,OAAOx3C,EAAIovB,EAAQ3tB,EAAIrB,GAC/BuT,EAAQ8jC,iBAAiBz3C,EAAGyB,EAAIrB,EAAQJ,EAAGyB,EAAIrB,EAASgvB,GACxDzb,EAAQ6jC,OAAOx3C,EAAGyB,EAAI2tB,GACtBzb,EAAQ8jC,iBAAiBz3C,EAAGyB,EAAGzB,EAAIovB,EAAQ3tB,GAC3CkS,EAAQ+jC,YACR/jC,EAAQY,OACRZ,EAAQ6C,UChCGmhC,GAAkB,CAACC,EAAkBxuC,KAChD,UAAIA,QAAJ,IAAIA,OAAJ,EAAIA,EAAU9D,cAAe,CAC3B,MAAMuyC,EAAczuC,EAAS9D,cAAc+O,IAAIujC,GAC/C,UAAIC,QAAJ,IAAIA,OAAJ,EAAIA,EAAan0C,MACf,OAAOm0C,EAAYn0C,MAIvB,MAAMo0C,EAAMF,EAAS18C,MAAM,IAAIzE,QAAO,CAACkwB,EAAG9xB,IAAQ8xB,EAAI9xB,EAAIL,WAAW,IAAI,GAGnEujD,EAAcj0C,EAAOvH,kBAAkBrF,MAAM,GAC7C8gD,EAAUl0C,EAAOtH,cAActF,MAAM,GAC3C,MAAO,CACL+gD,WAAYF,EAAYD,EAAMC,EAAY7mD,QAC1CslB,OAAQwhC,EAAQF,EAAME,EAAQ9mD,UCgO3B,IAAKgnD,I,SAAAA,K,gBAAAA,E,YAAAA,E,aAAAA,Q,KC7LZ,MAAMC,G3DyVuB,MAC3B,MACMC,EADS99C,SAASmF,cAAc,UACnB+Z,WAAW,MAC9B,IAAK4+B,EACH,OAAO,EAST,OANAA,EAAIlkC,UAAY,OAChBkkC,EAAIC,aAAe,MACnBD,EAAI74C,KAAO,aAGX64C,EAAI3iC,SAAS,eAAM,EAAG,GACoC,IAAnD2iC,EAAIE,aAPI,MAOyB,EAAG,GAAGzmD,KAAK,I2DtW7B0mD,GAElBC,GAAyB,SAC7B7kC,EACA3T,EACAyB,EACAvB,EACAE,EACA2Q,EACAC,EACA9F,GAEI,IADJqJ,EACG,wDACHZ,EAAQM,OACRN,EAAQkG,UAAU9I,EAAIC,GACtB2C,EAAQ9I,OAAOK,GACXqJ,GACFZ,EAAQgB,SAAS3U,EAAI+Q,EAAItP,EAAIuP,EAAI9Q,EAAOE,GAE1CuT,EAAQ8kC,WAAWz4C,EAAI+Q,EAAItP,EAAIuP,EAAI9Q,EAAOE,GAC1CuT,EAAQa,WAqCJkkC,GAAa,CACjB/kC,EACA5C,EACAC,EACAoe,KAEAzb,EAAQ2jC,YACR3jC,EAAQglC,IAAI5nC,EAAIC,EAAIoe,EAAQ,EAAa,EAAV3kC,KAAKC,IACpCipB,EAAQY,OACRZ,EAAQ6C,UAGJoiC,GAAa,CACjBjlC,EACAvM,EACA6T,EACAC,EACAhb,EACAE,KAEAuT,EAAQM,OACRN,EAAQwC,YAAc,kBACtBxC,EAAQ2jC,YACR,IAAK,IAAIt3C,EAAIib,EAASjb,EAAIib,EAAU/a,EAAmB,EAAXkH,EAAcpH,GAAKoH,EAC7DuM,EAAQ4jC,OAAOv3C,EAAGkb,EAAU9T,GAC5BuM,EAAQ6jC,OAAOx3C,EAAGkb,EAAU9a,EAAoB,EAAXgH,GAEvC,IAAK,IAAI3F,EAAIyZ,EAASzZ,EAAIyZ,EAAU9a,EAAoB,EAAXgH,EAAc3F,GAAK2F,EAC9DuM,EAAQ4jC,OAAOt8B,EAAU7T,EAAU3F,GACnCkS,EAAQ6jC,OAAOv8B,EAAU/a,EAAmB,EAAXkH,EAAc3F,GAEjDkS,EAAQ6C,SACR7C,EAAQa,WAGJqkC,GAA2B,CAC/BllC,EACAvK,EACA0J,EACA5I,KAEAyJ,EAAQM,OACRN,EAAQkG,UAAU/G,EAAWpQ,QAASoQ,EAAWnQ,SACjDgR,EAAQmlC,UAAY,EAAIhmC,EAAWtQ,KAAKvP,MAExCm+B,GAAoB8B,2BAA2BhpB,GAAS6H,SACtD,CAACzG,EAAOmF,KAAS,IAAD,EACdkD,EAAQwC,YAAc,MACtBxC,EAAQolC,YAAY,IACpBplC,EAAQO,WACN,UAAA9K,EAASzC,4BAAT,eAA+B2qB,oBAAqB7gB,EAChD,2BACA,2BACN,MAAM,kBAAE0iB,GAAsB/B,GAC9BsnB,GACE/kC,EACArI,EAAM,GACNA,EAAM,GACN6nB,EAAoB,EAAIrgB,EAAWtQ,KAAKvP,UAI9C0gB,EAAQa,WAGGwkC,GAAc,SACzBlnC,EACA1I,EACAf,EACAyR,EACApG,EACA9R,EACAkR,GAoBI,IAlBJ,iBACEmmC,GAAmB,EADrB,gBAEEC,GAAkB,EAFpB,oBAME5+B,GAAsB,EANxB,WAOE6+B,GAAa,EAPf,SAUEC,GAAW,GAQV,uDADC,GAEJ,GAAe,OAAXx3C,EACF,MAAO,CAAEy3C,0BAA0B,GAGrC,MAAM1lC,EAAU/R,EAAO4X,WAAW,MAElC7F,EAAQ2lC,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,GACpC3lC,EAAQM,OACRN,EAAQmG,MAAMA,EAAOA,GAGrB,MAAMy/B,EAAwB33C,EAAO1B,MAAQ4Z,EACvC0/B,EAAyB53C,EAAOxB,OAAS0Z,EAO/C,GALIs/B,GAAiC,SAArBtmC,EAAWpjB,QACzBikB,EAAQ7Z,OAASlL,KAI2B,kBAAnCkkB,EAAWlK,oBAAkC,EAEjB,gBAAnCkK,EAAWlK,qBAC+B,IAA1CkK,EAAWlK,oBAAoB1X,QACW,IAA1C4hB,EAAWlK,oBAAoB1X,QAC/B,gBAAgByL,KAAKmW,EAAWlK,uBAEhC+K,EAAQ8lC,UAAU,EAAG,EAAGF,EAAuBC,GAEjD7lC,EAAQM,OACRN,EAAQO,UAAYpB,EAAWlK,oBAC/B+K,EAAQgB,SAAS,EAAG,EAAG4kC,EAAuBC,GAC9C7lC,EAAQa,eAERb,EAAQ8lC,UAAU,EAAG,EAAGF,EAAuBC,GAIjD,MAAME,EAAmB5mC,EAAWtQ,KAAKrH,YAAY6E,EAC/C25C,EAAmB7mC,EAAWtQ,KAAKrH,YAAYsG,EACrDkS,EAAQM,OACRN,EAAQkG,UAAU6/B,EAAkBC,GACpChmC,EAAQmG,MAAMhH,EAAWtQ,KAAKvP,MAAO6f,EAAWtQ,KAAKvP,OAGjDkmD,GAAc/vC,EAAShC,UACzBwxC,GACEjlC,EACAvK,EAAShC,UACR3c,KAAKmvB,KAAK8/B,EAAmB5mC,EAAWtQ,KAAKvP,MAAQmW,EAAShC,UAC7DgC,EAAShC,SACR0L,EAAWpQ,QAAU0G,EAAShC,UAChC3c,KAAKmvB,KAAK+/B,EAAmB7mC,EAAWtQ,KAAKvP,MAAQmW,EAAShC,UAC7DgC,EAAShC,SACR0L,EAAWnQ,QAAUyG,EAAShC,SACjCmyC,EAAwBzmC,EAAWtQ,KAAKvP,MACxCumD,EAAyB1mC,EAAWtQ,KAAKvP,OAK7C,MAAM2mD,EAAkB9nC,EAAShY,QAAQoQ,GACvC2vC,GAAiB3vC,EAASqvC,EAAuBC,EAAwB,CACvEh3C,KAAMsQ,EAAWtQ,KACjBC,WAAY2G,EAAS3G,WACrB/B,UAAW0I,EAAS1I,UACpBgC,QAASoQ,EAAWpQ,QACpBC,QAASmQ,EAAWnQ,YAYxB,GARAi3C,EAAgB7nC,SAAS7H,IACvB,IACEmQ,GAAcnQ,EAASwJ,EAAIC,EAAS2G,EAAqBxH,GACzD,MAAOvd,GACPC,QAAQD,MAAMA,OAId6T,EAASzC,qBAAsB,CACjC,MAAMuD,EAAUknB,GAAoBtT,WAClC1U,EAASzC,qBAAqB0qB,WAE5BnnB,GACF2uC,GAAyBllC,EAASvK,EAAU0J,EAAY5I,GAK5D,GAAI7B,EACF,IACEgS,GACEhS,EACAqL,EACAC,EACA2G,EACAxH,GAEF,MAAOvd,GACPC,QAAQD,MAAMA,GAalB,GATI8R,GAAiB+B,IACnBA,EAASV,kBACN5O,QAAQo4B,GAAuB,MAAXA,IACpBngB,SAAS+nC,IACRC,GAAuBpmC,EAASb,EAAYgnC,MAMhDZ,IACC9vC,EAASzB,eACTyB,EAASzC,qBACV,CACA,MAAMqzC,EAAaloC,EAASrb,QAAO,CAACC,EAAKwT,KACvC,MAAM+vC,EAAkB,GAiBxB,GAdE7wC,EAASjB,mBAAmB+B,EAAQhR,MACnC4nB,GAAmB1X,EAAUc,IAE9B+vC,EAAgBhjD,KAAKsE,EAAGkB,OAGtBqW,EAAWonC,yBAAyBhwC,EAAQhR,KAC9C+gD,EAAgBhjD,QACX6b,EAAWonC,yBAAyBhwC,EAAQhR,IAAIT,KAAK0hD,IACtD,MAAM,WAAElC,GAAeN,GAAgBwC,EAAU/wC,GACjD,OAAO6uC,MAITgC,EAAgB/oD,OAAQ,CAC1B,MAAOkpD,EAAWC,EAAWC,EAAWC,GACtChrC,GAAyBrF,GAC3BxT,EAAIO,KAAK,CACPiU,MAAOhB,EAAQgB,MACfkvC,YACAC,YACAC,YACAC,YACAN,oBAGJ,OAAOvjD,IACN,IAEG8jD,EAA0B95B,IAC9B,MAAMitB,EAAgBhsB,GAAmB7P,EAAU4O,IAC5C05B,EAAWC,EAAWC,EAAWC,GACtC1oC,GAAgB87B,GAClBqM,EAAW/iD,KAAK,CACdiU,MAAO,EACPkvC,YACAE,YACAD,YACAE,YACAN,gBAAiB,CAAC1+C,EAAGkB,UAIzB,IAAK,MAAMikB,KAAWO,GAAoB7X,GAExCoxC,EAAuB95B,GAGrBtX,EAAS1C,gBACX8zC,EAAuBpxC,EAAS1C,gBAGlCszC,EAAWjoC,SAAS0oC,GAClBC,GAAsB/mC,EAASb,EAAY2nC,KAG7C,MAAME,EAA0Br5B,GAAoBxP,EAAU1I,GAK9D,GAFAuK,EAAQM,OACRN,EAAQkG,UAAU/G,EAAWpQ,QAASoQ,EAAWnQ,SACV,IAAnCg4C,EAAwBzpD,OAAc,CACxCyiB,EAAQO,UAAY3Y,EAAGc,MACvB,MAAMgqB,EAAmBG,GACvBm0B,EAAwB,GACxB7nC,EAAWtQ,KACX,SAEG4G,EAASN,iBACZ8xC,GACEjnC,EACAb,EACAuT,EACAs0B,EAAwB,GAAGzvC,YAG1B,GAAIyvC,EAAwBzpD,OAAS,IAAMkY,EAAS3B,WAAY,CACrE,MAAMozC,EAAoB,EAAI/nC,EAAWtQ,KAAKvP,MAC9C0gB,EAAQO,UAAY3Y,EAAGc,MACvB,MAAOyO,EAAIC,EAAIC,EAAIC,GAAM4G,GAAgB8oC,GACnCG,EAAkBnnC,EAAQonC,cAChCpnC,EAAQolC,YAAY,CAAC,EAAIjmC,EAAWtQ,KAAKvP,QACzC,MAAM6lD,EAAYnlC,EAAQmlC,UAC1BnlC,EAAQmlC,UAAY,EAAIhmC,EAAWtQ,KAAKvP,MACxCulD,GACE7kC,EACA7I,EAAK+vC,EACL9vC,EAAK8vC,EACL7vC,EAAKF,EAAyB,EAApB+vC,EACV5vC,EAAKF,EAAyB,EAApB8vC,GACT/vC,EAAKE,GAAM,GACXD,EAAKE,GAAM,EACZ,GAEF0I,EAAQmlC,UAAYA,EACpBnlC,EAAQolC,YAAY+B,GACpB,MAAMz0B,EAAmBT,GACvB,CAAC9a,EAAIC,EAAIC,EAAIC,GACb,EACA6H,EAAWtQ,KACX,QACAyiB,IAEF21B,GAAuBjnC,EAASb,EAAYuT,EAAkB,GAEhE1S,EAAQa,UAIVb,EAAQa,UAGR,IAAK,MAAMojC,KAAY9kC,EAAWkoC,4BAA6B,CAC7D,IAAI,EAAEh7C,EAAF,EAAKyB,GAAMqR,EAAWkoC,4BAA4BpD,GAEtD53C,GAAKoJ,EAAS3G,WACdhB,GAAK2H,EAAS1I,UAEd,MAAMR,EAAQ,EACRE,EAAS,GAET66C,EACJj7C,EAAI,GACJA,EAAIu5C,EAAwBr5C,GAC5BuB,EAAI,GACJA,EAAI+3C,EAAyBp5C,EAE/BJ,EAAIvV,KAAK+iB,IAAIxN,EAAG,GAChBA,EAAIvV,KAAK2T,IAAI4B,EAAGu5C,EAAwBr5C,GACxCuB,EAAIhX,KAAK+iB,IAAI/L,EAAG,GAChBA,EAAIhX,KAAK2T,IAAIqD,EAAG+3C,EAAyBp5C,GAEzC,MAAM,WAAE63C,EAAF,OAAczhC,GAAWmhC,GAAgBC,EAAUxuC,GAEzDuK,EAAQM,OACRN,EAAQwC,YAAcK,EACtB7C,EAAQO,UAAY+jC,EAEpB,MAAMiD,EAAYpoC,EAAWqoC,wBAAwBvD,IACjDqD,GAAiBC,IAAchD,GAAckD,QAC/CznC,EAAQC,YAAc,KAItBd,EAAWuoC,qBACkC,SAA7CvoC,EAAWuoC,oBAAoBzD,KAE/BjkC,EAAQ2jC,YACR3jC,EAAQglC,IAAI34C,EAAGyB,EAAG,GAAI,EAAG,EAAIhX,KAAKC,IAAI,GACtCipB,EAAQmlC,UAAY,EACpBnlC,EAAQwC,YAAc,YACtBxC,EAAQ6C,SACR7C,EAAQ+jC,YAER/jC,EAAQ2jC,YACR3jC,EAAQglC,IAAI34C,EAAGyB,EAAG,GAAI,EAAG,EAAIhX,KAAKC,IAAI,GACtCipB,EAAQmlC,UAAY,EACpBnlC,EAAQwC,YAAcK,EACtB7C,EAAQ6C,SACR7C,EAAQ+jC,aAGV/jC,EAAQ2jC,YACR3jC,EAAQ4jC,OAAOv3C,EAAGyB,GAClBkS,EAAQ6jC,OAAOx3C,EAAI,EAAGyB,EAAI,IAC1BkS,EAAQ6jC,OAAOx3C,EAAI,EAAGyB,EAAI,GAC1BkS,EAAQ6jC,OAAOx3C,EAAI,EAAGyB,EAAI,IAC1BkS,EAAQ6jC,OAAOx3C,EAAGyB,GAClBkS,EAAQY,OACRZ,EAAQ6C,SAER,MAAM8kC,EAAWxoC,EAAWyoC,uBAAuB3D,GAEnD,IAAI4D,EAAY,GACZN,IAAchD,GAAckD,KAC9BI,EAAYrD,GAAkB,eAAH,YAAeD,GAAckD,KAA7B,KAClBF,IAAchD,GAAcuD,KACrCD,EAAYrD,GAAkB,eAAH,YAAeD,GAAcuD,KAA7B,KAClBP,IAAchD,GAAcwD,SACrCF,EAAYrD,GAAkB,eAAO,IAGvC,MAAMwD,EAAoB,UACxBL,EAAQ,UAAMA,EAAN,KAAoB,IADJ,OAEvBE,GAEH,IAAKP,GAAiBU,EAAsB,CAC1C,MAAM1gC,EAAUjb,EAAIE,EACdgb,EAAUzZ,EAAIrB,EACdw7C,EAAoB,EACpBC,EAAkB,EAClBC,EAAUnoC,EAAQrU,YAAYq8C,GAC9BI,EACJD,EAAQE,yBAA2BF,EAAQG,wBAG7CtoC,EAAQO,UAAYsC,EACpB7C,EAAQgB,SACNsG,EAAU,EACVC,EAAU,EACV4gC,EAAQ57C,MAAQ,EAAI07C,EAAoB,EACxCG,EAAgB,EAAIF,EAAkB,GAGxCloC,EAAQO,UAAY+jC,EACpBtkC,EAAQgB,SACNsG,EACAC,EACA4gC,EAAQ57C,MAAQ,EAAI07C,EACpBG,EAAgB,EAAIF,GAEtBloC,EAAQO,UAAY3Y,EAAGc,MAEvBsX,EAAQ8B,SACNkmC,EACA1gC,EAAU2gC,EACV1gC,EAAU2gC,EAAkBC,EAAQG,yBAIxCtoC,EAAQa,UACRb,EAAQ+jC,YAIV,IAAI/W,EA4BJ,OA3BIsY,IACFtY,EAAa3B,GACXltB,EACAynC,EACAC,EACA1mC,GAGFa,EAAQM,OACRN,EAAQO,UAAY6qB,GACpBprB,EAAQwC,YAAc,wBACtB,CAACwqB,EAAWxB,WAAYwB,EAAWvB,UAAUrtB,SAAS+uB,IAChDA,GACFuW,GACE1jC,EACAmtB,EAAU9gC,EACV8gC,EAAUr/B,EACVq/B,EAAU5gC,MACV4gC,EAAU1gC,OACV87C,MAINvoC,EAAQa,WAGVb,EAAQa,UACD,CAAE6kC,yBAA0BO,EAAgB1oD,OAAS,EAAGyvC,eAG3Dia,GAAyB,CAC7BjnC,EACAb,EACAuT,EACAnb,KAEA5R,OAAOD,KAAKgtB,GAAkBtU,SAASjhB,IACrC,MAAM0/B,EAAkBnK,EAAiBv1B,QACjBiK,IAApBy1B,IACF7c,EAAQM,OACRN,EAAQmlC,UAAY,EAAIhmC,EAAWtQ,KAAKvP,MAC5B,aAARnC,EACF4nD,GACE/kC,EACA6c,EAAgB,GAAKA,EAAgB,GAAK,EAC1CA,EAAgB,GAAKA,EAAgB,GAAK,EAC1CA,EAAgB,GAAK,GAGvBgoB,GACE7kC,EACA6c,EAAgB,GAChBA,EAAgB,GAChBA,EAAgB,GAChBA,EAAgB,GAChBA,EAAgB,GAAKA,EAAgB,GAAK,EAC1CA,EAAgB,GAAKA,EAAgB,GAAK,EAC1CtlB,GACA,GAGJyI,EAAQa,eAKRkmC,GAAwB,CAC5B/mC,EACAb,EACAqpC,KASA,MAAM,MAAEjxC,EAAF,UAASkvC,EAAT,UAAoBC,EAApB,UAA+BC,EAA/B,UAA0CC,EAA1C,gBAAqDN,GACzDkC,EACI1yB,EAAe6wB,EAAYF,EAC3B1wB,EAAgB6wB,EAAYF,EAE5BQ,EAAoB,EAAI/nC,EAAWtQ,KAAKvP,MACxCmpD,EAAY,EAAItpC,EAAWtQ,KAAKvP,MAChCopD,EAAa,EAAIvpC,EAAWtQ,KAAKvP,MAEvC0gB,EAAQM,OACRN,EAAQkG,UAAU/G,EAAWpQ,QAASoQ,EAAWnQ,SACjDgR,EAAQmlC,UAAY,EAAIhmC,EAAWtQ,KAAKvP,MAExC,MAAM+Z,EAAQitC,EAAgB/oD,OAC9B,IAAK,IAAI2J,EAAQ,EAAGA,EAAQmS,IAASnS,EACnC8Y,EAAQwC,YAAc8jC,EAAgBp/C,GACtC8Y,EAAQolC,YAAY,CAClBqD,EACAC,GAAcD,EAAYC,IAAervC,EAAQ,KAEnD2G,EAAQ2oC,gBAAkBF,EAAYC,GAAcxhD,EACpD29C,GACE7kC,EACAymC,EAAYS,EACZR,EAAYQ,EACZpxB,EAAmC,EAApBoxB,EACfnxB,EAAoC,EAApBmxB,EAChBT,EAAY3wB,EAAe,EAC3B4wB,EAAY3wB,EAAgB,EAC5Bxe,GAGJyI,EAAQa,WAGJulC,GAAyB,CAC7BpmC,EACAb,EACAgnC,KAEA,MAAMyC,EAAkB/9B,MAAM4F,QAAQ01B,GAClC0C,GACAC,GAEJ9oC,EAAQM,OACRN,EAAQkG,UAAU/G,EAAWpQ,QAASoQ,EAAWnQ,SACjD45C,EAAgB5oC,EAASmmC,GAEzBnmC,EAAQa,WAGJioC,GAA2C,CAC/C9oC,EACAzJ,KAEA,MAAOY,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBrF,GAC5ChK,EAAQ8K,EAAKF,EACb1K,EAAS6K,EAAKF,EACdwd,EAAYgB,GAAcrf,EAAShK,EAAOE,GAIhDuT,EAAQwC,YAAc,kBACtBxC,EAAQmlC,UAAYvwB,EAFC,EAGrB,MAAM9O,EAAUijC,EAAmBn0B,EAAY,EAE/C,OAAQre,EAAQtL,MACd,IAAK,YACL,IAAK,OACH45C,GACE7kC,EACA7I,EAAK2O,EACL1O,EAAK0O,EACLvZ,EAAkB,EAAVuZ,EACRrZ,EAAmB,EAAVqZ,EACT3O,EAAK5K,EAAQ,EACb6K,EAAK3K,EAAS,EACd8J,EAAQgB,OAEV,MACF,IAAK,UACH,MAAMuf,EAAOhgC,KAAK2hB,MAAMlM,EAAOE,GAxnBH,EAChCuT,EACAzT,EACAE,EACA2Q,EACAC,EACA9F,KAEAyI,EAAQM,OACRN,EAAQkG,UAAU9I,EAAIC,GACtB2C,EAAQ9I,OAAOK,GACfyI,EAAQ2jC,YACR3jC,EAAQ4jC,OAAO,EAAGn3C,EAAS,GAC3BuT,EAAQ6jC,OAAOt3C,EAAQ,EAAG,GAC1ByT,EAAQ6jC,OAAO,GAAIp3C,EAAS,GAC5BuT,EAAQ6jC,QAAQt3C,EAAQ,EAAG,GAC3ByT,EAAQ+jC,YACR/jC,EAAQ6C,SACR7C,EAAQa,WAymBJmoC,CACEhpC,EACAzT,EAAmB,GAJHuZ,EAAUgR,EAAQrqB,GAKlCA,EAAoB,GAJJqZ,EAAUgR,EAAQvqB,GAKlC4K,EAAK5K,EAAQ,EACb6K,EAAK3K,EAAS,EACd8J,EAAQgB,OAEV,MACF,IAAK,UA/mByB,EAChCyI,EACAzT,EACAE,EACA2Q,EACAC,EACA9F,KAEAyI,EAAQ2jC,YACR3jC,EAAQ+D,QAAQ3G,EAAIC,EAAI9Q,EAAQ,EAAGE,EAAS,EAAG8K,EAAO,EAAa,EAAVzgB,KAAKC,IAC9DipB,EAAQ6C,UAsmBJomC,CACEjpC,EACAzT,EAAkB,EAAVuZ,EACRrZ,EAAmB,EAAVqZ,EACT3O,EAAK5K,EAAQ,EACb6K,EAAK3K,EAAS,EACd8J,EAAQgB,SAMVsxC,GAAiD,CACrD7oC,EACAmmC,KAEA,MAAO5vC,EAASwqB,EAAYF,GAAmBslB,EAEzCvxB,EAAYgB,GAChBiL,EACAA,EAAgBt0B,MAChBs0B,EAAgBp0B,QAGlBuT,EAAQwC,YAAc,gBACtBxC,EAAQO,UAAY,mBAGH,SAAfwgB,EAAwB,CAAC,GAAI,GAAoB,UAAfA,EAAyB,CAAC,GAAK,EAAE,IACxD3iB,SAASlX,IACpB,MAAOmF,EAAGyB,GAAK2vB,GAAoBgB,iCACjCloB,EACArP,GAEF69C,GAAW/kC,EAAS3T,EAAGyB,EAAG8mB,OAIxBsxB,GAAmB,CACvB3vC,EACA2yC,EACAC,EACAC,KAQA,MAAOjyC,EAAIC,EAAIC,EAAIC,GAAM4F,GAAiB3G,GACpC8yC,EAAqB36C,GACzB,CACEC,QAASy6C,EAAoBt6C,WAC7BF,QAASw6C,EAAoBr8C,WAE/Bq8C,GAEIE,EAAyB56C,GAC7B,CACEC,QAASy6C,EAAoBt6C,WAAao6C,EAC1Ct6C,QAASw6C,EAAoBr8C,UAAYo8C,GAE3CC,GAGF,OACEC,EAAmBh9C,GAAKgL,GACxBgyC,EAAmBv7C,GAAKwJ,GACxBgyC,EAAuBj9C,GAAK8K,GAC5BmyC,EAAuBx7C,GAAKsJ,G,aCnwBhC,MAEamyC,GAAmD36B,IAM1D,IAAD,MAMH,MAAM46B,EAAS,UAAG56B,EAAK66B,kBAAR,aAAG,EAAiB3mD,QAAO,CAAC0mD,EAAWv+C,KACpDu+C,EAAUlmD,KAAKrK,IAAWgS,IAEnBu+C,IACN,IAEGC,EAAU,UAAG76B,EAAK66B,kBAAR,aAAG,EAAiB3mD,QAAO,CAACC,EAAKjF,IACnC,QAARA,EACKiF,EAAIgD,OAAO,OAAQ,SAErBhD,EAAIgD,OAAJ,WAAejI,KACrB,IAEH,OAAO4rD,aAAU,CACfC,YAAa/6B,EAAK+6B,YAClBF,aACAD,YACAI,SAAQ,UAAEh7B,EAAKg7B,gBAAP,SACRC,YAAa,CAACjqD,EAASC,EAAQiqD,KAC7B,MAAMC,EAAoB98C,GAASpN,EAjCR,KAkCrBmqD,EAAe,KACnBC,IACAtjD,SAASq1C,iBAAiBnkD,IAAMqyD,MAAOH,GACvCpjD,SAASq1C,iBAAiBnkD,IAAMsyD,WAAYJ,GAC5CA,KAEIE,EAAe,KAAO,IAAD,EAEzB,aAAIH,EAAMziC,aAAV,aAAI,EAAa9pB,OAAQ,CACvB,MAAM+P,EAAMshB,EAAKg7B,SAAW,IAAIE,EAAMziC,OAASyiC,EAAMziC,MAAM,GAC3DznB,EAAQ0N,KAGZskC,uBAAsB,KACpB93C,OAAOkiD,iBAAiBnkD,IAAMuyD,MAAOJ,MAEvC,MAAMK,EAAWvwD,OAAOwwD,aAAY,KAClCL,MAnDyB,KAqD3B,OAAQM,IACNC,cAAcH,GACdN,EAAkBn8C,SAClB9T,OAAOmiD,oBAAoBpkD,IAAMuyD,MAAOJ,GACxCrjD,SAASs1C,oBAAoBpkD,IAAMqyD,MAAOH,GAC1CpjD,SAASs1C,oBAAoBpkD,IAAMsyD,WAAYJ,GAC3CQ,IAEF1oD,QAAQw0B,KAAK,8CACbk0B,EAAc,IAAI/a,UAOfib,GAAW,CACtB3qD,EACA8uB,IAUO87B,aACL5qD,EACA,CACEkjD,SAAS,GAAD,OAAKp0B,EAAKtxB,KAAV,YAAkBsxB,EAAK+7B,WAC/BhB,YAAa/6B,EAAK+6B,YAClBF,WAAY,CAAC,IAAD,OAAK76B,EAAK+7B,aAExB/7B,EAAKpb,YC/EIo3C,GAGT,CACF9D,WAAW,EACXrlD,MAAM,EACN0hB,WAAW,EACX0nC,SAAS,EACT9mC,SAAS,EACTlY,MAAM,EACNkV,OAAO,EACPyD,OAAO,EACPsmC,UAAU,GAkBNC,GAA+B,CAInCx0C,EACAy0C,KAOO,IAAD,wBACN,MAAMC,EAAyC,CAC7ChgD,KAAM+/C,EAAM//C,MAAQsL,EAAQtL,KAG5BnJ,QAASyU,EAAQzU,SAAW,EAC5BmqB,aAAY,UAAE1V,EAAQ0V,oBAAV,QAA0B,EACtCyC,UAAS,UAAEnY,EAAQmY,iBAAV,SACTnpB,GAAIgR,EAAQhR,IAAMgmB,KAClBhL,UAAWhK,EAAQgK,WAAa,UAChChB,YAAahJ,EAAQgJ,aAAe,EACpCiD,YAAW,UAAEjM,EAAQiM,mBAAV,QAAyB,QACpCI,UAAS,UAAErM,EAAQqM,iBAAV,QAAuB,EAChC1C,QAA4B,MAAnB3J,EAAQ2J,QAAkB,IAAM3J,EAAQ2J,QACjD3I,MAAOhB,EAAQgB,OAAS,EACxBlL,EAAC,oBAAE2+C,EAAM3+C,SAAR,QAAakK,EAAQlK,SAArB,QAA0B,EAC3ByB,EAAC,oBAAEk9C,EAAMl9C,SAAR,QAAayI,EAAQzI,SAArB,QAA0B,EAC3B0S,YAAajK,EAAQiK,YACrBwC,gBAAiBzM,EAAQyM,gBACzBzW,MAAOgK,EAAQhK,OAAS,EACxBE,OAAQ8J,EAAQ9J,QAAU,EAC1B6V,KAAI,UAAE/L,EAAQ+L,YAAV,QAAkB,EACtB2K,SAAQ,UAAE1W,EAAQ0W,gBAAV,QAAsB,GAC9BrO,gBAAe,UACbrI,EAAQqI,uBADK,QAEZ9H,GAAoBP,EAAQtL,MAAQ,QAAU,QACjDujB,gBAAe,UAAEjY,EAAQiY,uBAAV,QAA6B,IAG9C,MAAO,IACFy8B,KACAp+B,GAAwBo+B,MACxBD,IAIDE,GACJ30C,IAC2B,IAAD,EA3DC40C,EA4D3B,OAAQ50C,EAAQtL,MACd,IAAK,OACH,IAAIS,EAAW6K,EAAQ7K,SACnBJ,EAAaiL,EAAQjL,WACzB,GAAI,SAAUiL,EAAS,CACrB,MAAO60C,EAAQC,GACb90C,EACA3K,KAAKrE,MAAM,KACbmE,EAAW0gC,SAASgf,EAAQ,IApEPD,EAqEYE,EAAjC//C,EApEF3F,OAAOD,KAAKvN,KAAaqZ,SAAS25C,GAC7BhzD,IACLgzD,GAGGvyD,IAiEH,OAAOmyD,GAA6Bx0C,EAAS,CAC3C7K,WACAJ,aACA7J,KAAI,UAAE8U,EAAQ9U,YAAV,QAAkB,GACtBqL,SAAUyJ,EAAQzJ,SAClB2U,UAAWlL,EAAQkL,WAAa5oB,IAChCk2B,cAAexY,EAAQwY,eAAiBj2B,MAE5C,IAAK,WACH,OAAOiyD,GAA6Bx0C,EAAS,CAC3CoC,OAAQpC,EAAQoC,OAChBoQ,mBAAoB,KACpBN,iBAAkBlS,EAAQkS,iBAC1BC,UAAWnS,EAAQmS,YAGvB,IAAK,QACH,OAAOqiC,GAA6Bx0C,EAAS,CAC3C6K,OAAQ7K,EAAQ6K,QAAU,UAC1B5K,OAAQD,EAAQC,OAChB2P,MAAO5P,EAAQ4P,OAAS,CAAC,EAAG,KAEhC,IAAK,OAGL,IAAK,OACL,IAAK,QAAS,CACZ,MAAM,eACJnC,EAAiB,KADb,aAEJC,GAAgC,UAAjB1N,EAAQtL,KAAmB,QAAU,OAClDsL,EAEJ,IAAIlK,EAAIkK,EAAQlK,EACZyB,EAAIyI,EAAQzI,EACZ6K,GACDkS,MAAM4F,QAAQla,EAAQoC,SAAWpC,EAAQoC,OAAOpb,OAAS,EACtD,CACE,CAAC,EAAG,GACJ,CAACgZ,EAAQhK,MAAOgK,EAAQ9J,SAE1B8J,EAAQoC,OAMd,OAJqB,IAAjBA,EAAO,GAAG,IAA6B,IAAjBA,EAAO,GAAG,MAC/BA,SAAQtM,IAAGyB,KAAM2vB,GAAoBkC,oBAAoBppB,IAGvDw0C,GAA6Bx0C,EAAS,CAC3CtL,KAC2D,SAAxDsL,EAAQtL,KACL,OACAsL,EAAQtL,KACd4kB,aAActZ,EAAQsZ,aACtBC,WAAYvZ,EAAQuZ,WACpB/G,mBAAoB,KACpB/E,iBACAC,eACAtL,SACAtM,IACAyB,MAIJ,IAAK,UAEL,IAAK,YAEL,IAAK,UACH,OAAOi9C,GAA6Bx0C,EAAS,MAQtC+0C,GAAkB,CAC7BntC,EAEAotC,KAEA,MAAMC,EAAmBD,EAAgB1gB,GAAc0gB,GAAiB,KACxE,OAAQptC,GAAY,IAAIrb,QAAO,CAACqb,EAAU5H,KAGxC,GAAqB,cAAjBA,EAAQtL,OAAyBohB,GAAwB9V,GAAU,CACrE,IAAIk1C,EAA4CP,GAAe30C,GAC/D,GAAIk1C,EAAiB,CACnB,MAAMC,EAAY,OAAGF,QAAH,IAAGA,OAAH,EAAGA,EAAmBj1C,EAAQhR,IAC5CmmD,GAAgBA,EAAa5pD,QAAU2pD,EAAgB3pD,UACzD2pD,EAAkBr/B,GAAYq/B,EAAiBC,EAAa5pD,UAE9Dqc,EAAS7a,KAAKmoD,IAGlB,OAAOttC,IACN,KAGQwtC,GAAkB,CAC7Bl2C,EACAm2C,KAEAn2C,EAAWA,GAAY,GAEvB,MAAMwJ,EAAkBvN,KAClB+b,EAAe,GAErB,IAAK,MAAOtwB,EAAKkiD,KAAiB15C,OAAO6F,QAAQyT,GAG5C,CACH,MAAM4sC,EAAgBp2C,EAAStY,GACzB2uD,EAAaF,EAAgBA,EAAczuD,QAAOiK,EACvDqmB,EAAqBtwB,QACFiK,IAAlBykD,EACIA,OACezkD,IAAf0kD,EACAA,EACAzM,EAGR,MAAO,IACF5xB,EACHva,YAAa03C,GAA8Bn9B,EAAava,aACpDua,EAAava,YACb,YAEJrE,KAC2B,kBAAlB4G,EAAS5G,KACZ,CACEvP,MAAOmW,EAAS5G,KAChBrH,YAAayX,EAAgBpQ,KAAKrH,aAEpCiO,EAAS5G,MAAQoQ,EAAgBpQ,OAI9BgS,GAAU,CACrB3iB,EAOA0tD,EACAL,KAEO,CACLptC,SAAUmtC,GAAe,OAACptD,QAAD,IAACA,OAAD,EAACA,EAAMigB,SAAUotC,GAC1C91C,SAAUk2C,GAAe,OAACztD,QAAD,IAACA,OAAD,EAACA,EAAMuX,SAAUm2C,GAAiB,MAC3DvkC,OAAW,OAAJnpB,QAAI,IAAJA,OAAA,EAAAA,EAAMmpB,QAAS,KC9PpB0kC,GAAoB7uD,UACxB,IAAI8uD,EAEJ,GAAIlsD,EAAKmL,OAAShS,IAAWK,IAC3B,IACE,mBACQ,sDACN2yD,kBAAkBnsD,GACpB,MAAO8B,GACP,KAAsB,YAAlBA,EAAM0tC,QACF,IAAIG,aACRhqC,EAAE,mCACF,iBAGI,IAAIgqC,aACRhqC,EAAE,iCACF,sBAkBN,GAZEumD,EADE,SAAUxtD,WACKsB,EAAK2B,aAEL,IAAI9B,SAASC,IAC5B,MAAMG,EAAS,IAAIC,WACnBD,EAAOmsD,WAAWpsD,EAAM,QACxBC,EAAOosD,UAAY,KACbpsD,EAAOqsD,aAAepsD,WAAWqsD,MACnCzsD,EAAQG,EAAOK,YAKnBN,EAAKmL,OAAShS,IAAWI,IAC3B,IACE,mBACQ,sDACNizD,kBAAkB,CAClBjzD,IAAK2yD,IAEP,MAAOpqD,GACP,KAAsB,YAAlBA,EAAM0tC,QACF,IAAIG,aACRhqC,EAAE,mCACF,iBAGI,IAAIgqC,aACRhqC,EAAE,iCACF,iBAMV,OAAOumD,GAyBIO,GAAqBn/C,IAAqC,IAAD,EACpE,OAAKA,IAIE,UAAAA,EAAO9P,KAAKkvD,MAAM,uCAAlB,eAAoD,KAHlD,MAYEC,GAAqBr/C,IAChC,MAAMnC,EAAOshD,GAAkBn/C,GAC/B,MAAgB,QAATnC,GAA2B,QAATA,GAGdyhD,GACX5sD,IAEA,MAAM,KAAEmL,GAASnL,GAAQ,GACzB,QACImL,GAASzO,IAA+CgV,SAASvG,IAI1D0hD,GAAezvD,MAC1B4C,EAEA8rD,EACAL,KAEA,MAAMS,QAAiBD,GAAkBjsD,GACzC,IACE,MAAM5B,EAAO0F,KAAKU,MAAM0nD,GACxB,IAAKY,GAAsB1uD,GACzB,MAAM,IAAImC,MAAMoF,EAAE,mCAmBpB,OAjBeob,GACb,CACE1C,SAAU+sB,GAAuBhtC,EAAKigB,UAAY,IAClD1I,SAAU,CACR1Z,MAAK,OAAE6vD,QAAF,IAAEA,OAAF,EAAEA,EAAe7vD,MACtByX,WAAY1T,EAAKsN,QAAU,QACxB2I,GAAuB7X,EAAKuX,UAAY,OACvCm2C,EACAle,GAAsBxvC,EAAKigB,UAAY,GAAIytC,GAC3C,IAENvkC,MAAOnpB,EAAKmpB,OAEdukC,EACAL,GAIF,MAAO3pD,GAEP,MADAC,QAAQD,MAAMA,EAAM0tC,SACd,IAAIjvC,MAAMoF,EAAE,qCAaTonD,GAAe3vD,SAGnB,IAAIyC,SAAQ,CAACC,EAASC,KAC3B,IACEoO,EAAO6+C,QAAQhtD,IACb,IAAKA,EACH,OAAOD,EACL,IAAIwvC,GACF5pC,EAAE,4BACF,4BAIN7F,EAAQE,MAEV,MAAO8B,GACP/B,EAAO+B,OA6BAmrD,GAAa7vD,SACjB,IAAIyC,SAAQ,CAACC,EAASC,KAC3B,MAAME,EAAS,IAAIC,WACnBD,EAAOE,OAAS,KACd,MAAM+nB,EAAUjoB,EAAOK,OACvBR,EAAQooB,IAEVjoB,EAAOitD,QAAWprD,GAAU/B,EAAO+B,GACnC7B,EAAOktD,cAAc/X,MAiBZgY,GAAkBhwD,MAC7Bg4C,EACAiY,KAGA,GAAIjY,EAAKjqC,OAAShS,IAAWI,IAC3B,OAAO67C,EAGT,MAAOkY,EAAMC,SAAyB1tD,QAAQ6F,IAAI,CAChD,mCAAeL,MAAMmoD,GAAQA,EAAIC,UAEjC,+BAA4BpoD,MAAMmoD,GAAQA,EAAIC,YAM1CzqD,EAASuqD,EAAgB,CAC7BD,KAAMA,EAAK,CAAEI,SAAU,CAAC,KAAM,YAG1BC,EAAWvY,EAAKjqC,KAEtB,IAAKyhD,GAAqBxX,GACxB,MAAM,IAAI70C,MAAMoF,EAAE,+BAGpB,OAAO,IAAIioD,KACT,OAAO5qD,EAAOgqD,OAAO5X,EAAM,CAAEr7B,IAAKszC,KAClCjY,EAAK53C,KACL,CAAE2N,KAAMwiD,KAICE,GAAkB,SAACC,GAA8C,IAA3BC,EAA0B,uDAAP,GACpE,OAAO,IAAIH,KAAK,EAAC,IAAIpvD,aAAcC,OAAOqvD,IAAaC,EAAU,CAC/D5iD,KAAMhS,IAAWI,OCvQfy0D,GAAwB,CAC5B3vC,EACAkJ,KAEA,MAAM0mC,EAAyB,GAC/B,IAAK,MAAMx3C,KAAW4H,GAEjB5H,EAAQmY,WACT,WAAYnY,GACZA,EAAQC,QACR6Q,EAAM9Q,EAAQC,UAEdu3C,EAAUx3C,EAAQC,QAAU6Q,EAAM9Q,EAAQC,SAG9C,OAAOu3C,GAGIC,GAAkB,CAC7B7vC,EACA1I,EACA4R,EACApc,KAEA,MAAM/M,EAA0B,CAC9B+M,KAAMvR,IAAkBR,WACxB4I,QAAS,EACTmsD,OAAQp0D,IACRskB,SACW,UAATlT,EACIigC,GAAuB/sB,GACvB8sB,GAAyB9sB,GAC/B1I,SACW,UAATxK,EACI8K,GAAuBN,GACvBO,GAAyBP,GAC/B4R,MACW,UAATpc,EACI6iD,GAAsB3vC,EAAUkJ,QAEhCjgB,GAGR,OAAOxD,KAAKC,UAAU3F,EAAM,KAAM,IAGvBgwD,GAAahxD,MACxBihB,EACA1I,EACA4R,KAEA,MAAM8mC,EAAaH,GAAgB7vC,EAAU1I,EAAU4R,EAAO,SACxDvnB,EAAO,IAAItB,KAAK,CAAC2vD,GAAa,CAClCljD,KAAMhS,IAAWC,aAWnB,MAAO,CAAEsa,iBARgBi3C,GAAS3qD,EAAM,CACtCxC,KAAMmY,EAASnY,KACfqtD,UAAW,aACXhB,YAAa,kBACbn2C,WAAYi5C,GAAkBh3C,EAASjC,YACnC,KACAiC,EAASjC,eAkBJo5C,GAAyB1uD,IAM9B,OAAJA,QAAI,IAAJA,OAAA,EAAAA,EAAM+M,QAASvR,IAAkBR,cAC/BgF,EAAKigB,UACJ0M,MAAM4F,QAAQvyB,EAAKigB,aAChBjgB,EAAKuX,UAAqC,kBAAlBvX,EAAKuX,WC7F1B24C,GAAwBpmC,GAC5B,IAAIroB,SAA0B,CAACC,EAASC,KAC7C,MAAMkhB,EAAQ,IAAIstC,MAClBttC,EAAM9gB,OAAS,KACbL,EAAQmhB,IAEVA,EAAMisC,QAAWprD,IACf/B,EAAO+B,IAETmf,EAAMpB,IAAMqI,KAMHsmC,GAAmBpxD,UAQzB,IARgC,QACrCqxD,EADqC,MAErClnC,EAFqC,WAGrCjI,GAKI,EACJ,MAAMovC,EAAe,IAAI58C,IACnB68C,EAAe,IAAI78C,IAoCzB,aAlCMjS,QAAQ6F,IACZ+oD,EAAQzrD,QAAO,CAAC4rD,EAAUl4C,KACxB,MAAMsR,EAAWT,EAAM7Q,GACvB,OAAIsR,IAAa0mC,EAAanvC,IAAI7I,IAChCg4C,EAAatrD,IAAIsT,GAAQ,GAClBk4C,EAAS3oD,OACd,WACE,IACE,GAAI+hB,EAAS1B,WAAantB,IAAWQ,OACnC,MAAM,IAAI4G,MAAM,0CAGlB,MAAMsuD,EAAeP,GAAqBtmC,EAASE,SAC7C9pB,EAAO,CACX6iB,MAAO4tC,EACPvoC,SAAU0B,EAAS1B,UAIrBhH,EAAWlc,IAAIsT,EAAQtY,GAEvB,MAAM6iB,QAAc4tC,EAEpBvvC,EAAWlc,IAAIsT,EAAQ,IAAKtY,EAAM6iB,UAClC,MAAOnf,GACP6sD,EAAavrD,IAAIsT,GAAQ,KAnB7B,KAwBGk4C,IACN,KAGE,CACLtvC,aAEAovC,eAEAC,iBAISG,GACXzwC,GAEAA,EAAShY,QAAQoQ,GACfD,GAA0BC,KC1EjBs4C,GAAc,uCAEdC,GAAiB5xD,eAC5BihB,EACA1I,EACA4R,EAH4B,GAsBxB,IAlBJ,iBACEjU,EADF,cAEE27C,EAAgBzyD,IAFlB,oBAGE2Y,GAeC,EATH+5C,EASG,uDANiD,CAACziD,EAAOE,KAC1D,MAAMwB,EAAStH,SAASmF,cAAc,UAGtC,OAFAmC,EAAO1B,MAAQA,EAAQkJ,EAASpC,YAChCpF,EAAOxB,OAASA,EAASgJ,EAASpC,YAC3B,CAAEpF,SAAQkY,MAAO1Q,EAASpC,cAGnC,MAAOgJ,EAAMC,EAAM/P,EAAOE,GAAUwiD,GAAc9wC,EAAU4wC,IAEtD,OAAE9gD,EAAF,MAAUkY,EAAQ,GAAM6oC,EAAaziD,EAAOE,GAE5CwS,EAAkBvN,MAElB,WAAE0N,SAAqBkvC,GAAiB,CAC5ClvC,WAAY,IAAIxN,IAChB28C,QAASK,GAA4BzwC,GAAUrZ,KAC5CyR,GAAYA,EAAQC,SAEvB6Q,UAgCF,OA7BAg+B,GACElnC,EACA1I,EACA,KACA0Q,EACA1H,KAAMxQ,OAAOA,GACbA,EACA,CACEgH,oBAAqB7B,EAAmB6B,EAAsB,KAC9DlG,SAAUsN,EAAO0yC,EACjB//C,SAAUsN,EAAOyyC,EACjBlgD,KAAMoQ,EAAgBpQ,KACtBw4C,4BAA6B,GAC7Bd,yBAA0B,GAC1B5xC,uBAAuB,EACvBizC,uBAAwB,GACxBJ,wBAAyB,GACzBzrD,MAAO0Z,EAASlC,mBAAqB,OAAS,QAC9C6L,cAEF,CACEkmC,kBAAkB,EAClBC,iBAAiB,EACjB5+B,qBAAqB,EACrB6+B,YAAY,EACZC,UAAU,IAIPx3C,GAGIihD,GAAchyD,MACzBihB,EACA1I,EAQA4R,KAEA,MAAM,cACJ0nC,EAAgBzyD,IADZ,oBAEJ2Y,EAFI,YAGJ5B,EAAc,EAHV,iBAIJC,GACEmC,EACJ,IAAIxR,EAAW,GACf,GAAIqP,EACF,IACErP,cACQ,sDACNkrD,kBAAkB,CAClB1tD,KAAMusD,GAAgB7vC,EAAU1I,EAAU4R,GAAS,GAAI,WAEzD,MAAOzlB,GACPC,QAAQD,MAAMA,GAGlB,MAAOya,EAAMC,EAAM/P,EAAOE,GAAUwiD,GAAc9wC,EAAU4wC,GAGtD3nC,EAAUzgB,SAASihB,gBAAgBlrB,IAAQ,OA4BjD,GA3BA0qB,EAAQ5F,aAAa,UAAW,OAChC4F,EAAQ5F,aAAa,QAAS9kB,KAC9B0qB,EAAQ5F,aAAa,UAArB,cAAuCjV,EAAvC,YAAgDE,IAChD2a,EAAQ5F,aAAa,QAArB,UAAiCjV,EAAQ8G,IACzC+T,EAAQ5F,aAAa,SAArB,UAAkC/U,EAAS4G,IACvCoC,EAASlC,oBACX6T,EAAQ5F,aAAa,SAAUvmB,KAGjCmsB,EAAQgoC,UAAR,cACEP,GADF,eAEE5qD,EAFF,0SAkBIwR,EAASrC,kBAAoB6B,EAAqB,CACpD,MAAMo6C,EAAOjoC,EAAQO,cAAeC,gBAAgBlrB,IAAQ,QAC5D2yD,EAAK7tC,aAAa,IAAK,KACvB6tC,EAAK7tC,aAAa,IAAK,KACvB6tC,EAAK7tC,aAAa,QAAlB,UAA8BjV,IAC9B8iD,EAAK7tC,aAAa,SAAlB,UAA+B/U,IAC/B4iD,EAAK7tC,aAAa,OAAQvM,GAC1BmS,EAAQjb,YAAYkjD,GAStB,ON0nB8B,SAC9BlxC,EACA4I,EACAK,EACAC,GAQI,IAPJ,QACEC,EAAU,EADZ,QAEEC,EAAU,GAKT,uDADC,GAECH,GAILjJ,EAASC,SAAS7H,IAChB,IAAKA,EAAQmY,UACX,IACEvH,GACE5Q,EACAwQ,EACAK,EACAC,EACA9Q,EAAQlK,EAAIib,EACZ/Q,EAAQzI,EAAIyZ,GAEd,MAAO3lB,GACPC,QAAQD,MAAMA,OM5pBpB0tD,CAAiBnxC,EADJM,KAAMplB,IAAI+tB,GACUA,EAASC,GAAS,GAAI,CACrDC,SAAUjL,EAAO0yC,EACjBxnC,SAAUjL,EAAOyyC,IAGZ3nC,GAIH6nC,GAAgB,CACpB9wC,EACA4wC,KAEA,MAAO1yC,EAAMC,EAAMC,EAAMC,GAAQ0B,GAAgBC,GAIjD,MAAO,CAAC9B,EAAMC,EAHAzO,GAASwO,EAAME,GAAwB,EAAhBwyC,EACtBlhD,GAASyO,EAAME,GAAQuyC,EAAgBA,ICpKlDQ,GAAY,GACZC,GAAU,GACVC,GAAa,IASNC,GAAkB,kBAClBC,GAAoB,oBAM3BC,GAAkBv3C,IACtB,MAAMm0C,EAAQ,iDAAiCqD,KAAKx3C,GACpD,OAAKm0C,EAGEpd,WAAWod,EAAM,GAAG9kD,QAAQ,KAAM,KAFhC,MAKLooD,GAAkB,CAACpuC,EAAmBquC,IAC1CruC,EAAMne,MAAM,GAAGq8C,OAAO/zC,GAA+C,OAAtC+jD,GAAe/jD,EAAKkkD,MAE/CC,GAAiBC,IACrB,MAAMC,EAAUD,EAAM,GAAG1yD,OAEzB,GAAI2yD,EAAU,EACZ,MAAO,CAAEjlD,KAAMykD,GAAiBS,OAAQ,uBAG1C,GAAgB,IAAZD,EAAe,CACjB,IAAKJ,GAAgBG,EAAO,GAC1B,MAAO,CAAEhlD,KAAMykD,GAAiBS,OAAQ,wBAG1C,MAAMC,EAA4C,OAAhCR,GAAeK,EAAM,GAAG,IACpChW,GAAUmW,EAAYH,EAAM1sD,MAAM,GAAK0sD,GAAOnrD,KAAK+G,GACvD+jD,GAAe/jD,EAAK,MAGtB,OAAIouC,EAAO18C,OAAS,EACX,CAAE0N,KAAMykD,GAAiBS,OAAQ,sBAGnC,CACLllD,KAAM0kD,GACNU,YAAa,CACXjf,MAAOgf,EAAYH,EAAM,GAAG,GAAK,KACjCK,OAAQ,KACRrW,OAAQA,IAKd,MAAMsW,EAAmBT,GAAgBG,EAAO,GAAK,EAAI,EAEzD,IAAKH,GAAgBG,EAAOM,GAC1B,MAAO,CAAEtlD,KAAMykD,GAAiBS,OAAQ,wBAG1C,MAAMK,GAAoBD,EAAmB,GAAK,EAC5CH,EAA2D,OAA/CR,GAAeK,EAAM,GAAGM,IACpCE,EAAOL,EAAYH,EAAM1sD,MAAM,GAAK0sD,EAE1C,OAAIQ,EAAKlzD,OAAS,EACT,CAAE0N,KAAMykD,GAAiBS,OAAQ,oBAGnC,CACLllD,KAAM0kD,GACNU,YAAa,CACXjf,MAAOgf,EAAYH,EAAM,GAAGM,GAAoB,KAChDD,OAAQG,EAAK3rD,KAAK4rD,GAAQA,EAAIF,KAC9BvW,OAAQwW,EAAK3rD,KAAK4rD,GAAQd,GAAec,EAAIH,SA2D7CI,GAAWxgD,EAAOvH,kBAAkBrF,MACxC,EACA4M,EAAOvH,kBAAkBrL,QAKrBqzD,GAAc,CAClBrwC,UAAW,UACXjV,WAAY1S,IACZ8S,SAAU/S,IACVunB,QAAS,IACT0C,UAAW,EACXpC,YAAarQ,EAAOtH,cAAc,GAClC+V,gBAAiB,QACjB4D,YAAa,QACbjD,YAAa,EACbwP,cAAe,UAGX8hC,GAAsBR,IAInB,CAAES,WAFP,GAAwBT,EAAYpW,OAAO18C,OAASiyD,GAEjCuB,YADDtB,MAIhBuB,GAAe,CACnBX,EACAhkD,EACAyB,EACAif,EACA/J,KACmB,IAAD,EAClB,OACE,UAAAqtC,EAAYC,cAAZ,eAAoBxrD,KAAI,CAACzF,EAAO6H,IACvB8nB,GAAe,CACpB/B,SAAU,CAACF,GACX/J,qBACG4tC,GACHnvD,KAAMpC,EAAM9B,OAAS,EAAf,UAAsB8B,EAAMkE,MAAM,EAAG,GAArC,OAA+ClE,EACrDgN,EAAGA,EAAS,GAALnF,EAAgCsoD,GACvC1hD,EAAGA,EAAI0hD,EACPjjD,MAAOgjD,GACPh4C,MAAO,KACP7L,SAAU,GACV+V,UAAW,SACXsN,cAAe,YAEb,IAIJkiC,GAAe,CACnBZ,EACAhkD,EACAyB,EACAif,EACA/J,KAEA,MAAMkuC,EAAYliC,GAAe,CAC/B/B,SAAU,CAACF,GACX/J,qBACG4tC,GACHvkD,EAAGA,EAAImjD,GACP1hD,EAAGA,EAAI0hD,GACP/tD,KAAM,IACNggB,UAAW,UAab,MAAO,CAACyvC,EAVUliC,GAAe,CAC/B/B,SAAU,CAACF,GACX/J,qBACG4tC,GACHvkD,EAAGA,EAAImjD,GACP1hD,EAAGA,EAAI2hD,GAAayB,EAAUzkD,OAAS,EACvChL,KAAM3K,KAAK+iB,OAAOw2C,EAAYpW,QAAQkX,iBACtC1vC,UAAW,YAMT2vC,GAAa,CACjBf,EACAhkD,EACAyB,EACAif,EACA/J,KAEA,MAAM,WAAE8tC,EAAF,YAAcC,GAAgBF,GAAmBR,GAmDvD,MAAO,CAlDOzgC,GAAiB,CAC7B5M,kBACAiK,SAAU,CAACF,MACR6jC,GACH3lD,KAAM,OACNoB,IACAyB,IACAkW,eAAgB,KAChBC,aAAc,KACd1X,MAAOukD,EACPn4C,OAAQ,CACN,CAAC,EAAG,GACJ,CAACm4C,EAAY,MAIHlhC,GAAiB,CAC7B5M,kBACAiK,SAAU,CAACF,MACR6jC,GACH3lD,KAAM,OACNoB,IACAyB,IACAkW,eAAgB,KAChBC,aAAc,KACdxX,OAAQskD,EACRp4C,OAAQ,CACN,CAAC,EAAG,GACJ,CAAC,GAAIo4C,MAIOnhC,GAAiB,CAC/B5M,kBACAiK,SAAU,CAACF,MACR6jC,GACH3lD,KAAM,OACNoB,IACAyB,EAAGA,EAAI2hD,GAAaD,GACpBxrC,eAAgB,KAChBC,aAAc,KACdzB,YAAa,SACbjW,MAAOukD,EACP5wC,QA7QiB,GA8QjBvH,OAAQ,CACN,CAAC,EAAG,GACJ,CAACm4C,EAAY,QAQbO,GAAoB,CACxBhB,EACAhkD,EACAyB,EACAif,EACA/J,EACAsuC,KAEA,MAAM,WAAER,EAAF,YAAcC,GAAgBF,GAAmBR,GAEjDjf,EAAQif,EAAYjf,MACtBpiB,GAAe,CACbhM,kBACAiK,SAAU,CAACF,MACR6jC,GACHnvD,KAAM4uD,EAAYjf,MAClB/kC,EAAGA,EAAIykD,EAAa,EACpBhjD,EAAGA,EAAI2hD,GAAaD,GAAc72D,IAClCimB,gBAAiB,QACjB4D,YAAa,QACbf,UAAW,WAEb,KAEE8vC,EAAYD,EACd3iC,GAAW,CACT3L,kBACAiK,SAAU,CAACF,MACR6jC,GACH3lD,KAAM,YACNoB,IACAyB,EAAGA,EAAIijD,EACPxkD,MAAOukD,EACPrkD,OAAQskD,EACRvwC,YAAarQ,EAAOtH,cAAc,GAClC0X,UAAW,QACXL,QAAS,IAEX,KAEJ,MAAO,IACDqxC,EAAY,CAACA,GAAa,MAC1BngB,EAAQ,CAACA,GAAS,MACnB4f,GAAaX,EAAahkD,EAAGyB,EAAGif,EAAS/J,MACzCiuC,GAAaZ,EAAahkD,EAAGyB,EAAGif,EAAS/J,MACzCouC,GAAWf,EAAahkD,EAAGyB,EAAGif,EAAS/J,KAoIjCwuC,GAAoB,CAC/BC,EACApB,EACAhkD,EACAyB,IAEkB,SAAd2jD,EAlGgB,EACpBpB,EACAhkD,EACAyB,KAEA,MAAM+L,EAAM/iB,KAAK+iB,OAAOw2C,EAAYpW,QAC9BltB,EAAUxB,KACVvI,EAAkB2tC,GAAS75D,KAAK8sB,MAAM9sB,KAAKq0B,SAAWwlC,GAASpzD,SAErE,IAAI2J,EAAQ,EACZ,MAAMyR,EAAS,GACf,IAAK,MAAMrZ,KAAS+wD,EAAYpW,OAAQ,CACtC,MAAM78B,EAAU,GAALlW,EACLmW,GAAO/d,EAAQua,EAAO41C,GAC5B92C,EAAOrV,KAAK,CAAC8Z,EAAIC,IACjBnW,IAGF,MAAMqV,EAAOzlB,KAAK+iB,OAAOlB,EAAO7T,KAAKyR,GAAYA,EAAQ,MACnDiG,EAAO1lB,KAAK+iB,OAAOlB,EAAO7T,KAAKyR,GAAYA,EAAQ,MACnD8F,EAAOvlB,KAAK2T,OAAOkO,EAAO7T,KAAKyR,GAAYA,EAAQ,MACnD+F,EAAOxlB,KAAK2T,OAAOkO,EAAO7T,KAAKyR,GAAYA,EAAQ,MAEnD1K,EAAO+jB,GAAiB,CAC5B5M,kBACAiK,SAAU,CAACF,MACR6jC,GACH3lD,KAAM,OACNoB,EAAGA,EAAImjD,GAAUD,GACjBzhD,EAAGA,EAAI0hD,GACPxrC,eAAgB,KAChBC,aAAc,KACdxX,OAAQ+P,EAAOF,EACf/P,MAAOgQ,EAAOF,EACdkD,YAAa,EACb5G,OAAQA,IAGJ+4C,EAAOrB,EAAYpW,OAAOn1C,KAAI,CAACxF,EAAO4H,KAC1C,MAAMkW,EAAU,GAALlW,EAAgCsoD,EACrCnyC,GAAO/d,EAAQua,EAAO41C,GAAaD,EACzC,OAAO7gC,GAAW,CAChB3L,kBACAiK,SAAU,CAACF,MACR6jC,GACHrwC,UAAW,QACXhB,YAAa,EACbtU,KAAM,UACNoB,EAAGA,EAAI+Q,EAAKmyC,GACZzhD,EAAGA,EAAIuP,EAAKmyC,GACZjjD,MAAOijD,GACP/iD,OAAQ+iD,QAIN9tC,EAAQ2uC,EAAYpW,OAAOn1C,KAAI,CAACxF,EAAO4H,KAC3C,MAAMkW,EAAU,GAALlW,EAAgCsoD,EACrCnyC,EAAM/d,EAAQua,EAAO41C,GAAaD,EAAcA,GACtD,OAAO5/B,GAAiB,CACtB5M,kBACAiK,SAAU,CAACF,MACR6jC,GACH3lD,KAAM,OACNoB,EAAGA,EAAI+Q,EAAKmyC,GAAgBC,EAC5B1hD,EAAGA,EAAIuP,EACP2G,eAAgB,KAChBC,aAAc,KACdxX,OAAQ4Q,EACRmF,YAAa,SACbtC,QAlbe,GAmbfvH,OAAQ,CACN,CAAC,EAAG,GACJ,CAAC,EAAG0E,SAKV,MAAO,IACFg0C,GACDhB,EACAhkD,EACAyB,EACAif,EACA/J,EACA/jB,eAAyBnH,IAAIE,aAE/B6T,KACG6V,KACAgwC,IAWIC,CAActB,EAAahkD,EAAGyB,GAvIpB,EACnBuiD,EACAhkD,EACAyB,KAEA,MAAM+L,EAAM/iB,KAAK+iB,OAAOw2C,EAAYpW,QAC9BltB,EAAUxB,KACVvI,EAAkB2tC,GAAS75D,KAAK8sB,MAAM9sB,KAAKq0B,SAAWwlC,GAASpzD,SAgBrE,MAAO,IAdM8yD,EAAYpW,OAAOn1C,KAAI,CAACxF,EAAO4H,KAC1C,MAAM0qD,EAAatyD,EAAQua,EAAO41C,GAClC,OAAO9gC,GAAW,CAChB3L,kBACAiK,SAAU,CAACF,MACR6jC,GACH3lD,KAAM,YACNoB,EAAGA,EAAS,GAALnF,EAAgCsoD,GACvC1hD,EAAGA,EAAI8jD,EAAYpC,GACnBjjD,MAAOgjD,GACP9iD,OAAQmlD,UAMPP,GACDhB,EACAhkD,EACAyB,EACAif,EACA/J,EACA/jB,eAAyBnH,IAAIE,eA0G1B65D,CAAaxB,EAAahkD,EAAGyB,GCpctC,IAAIgkD,GAAY,GACZC,IAAuB,EAEpB,MAAMC,GACX,cAAe/oD,WAAa,aAAcA,UAAU0pC,UAEzCsf,GACX,cAAehpD,WAAa,cAAeA,UAAU0pC,UAE1Cuf,GACX,cAAejpD,WACf,UAAWA,UAAU0pC,WACrB,kBAAmB74C,QACnB,WAAYq4D,kBAAkBliC,UAiBnBmiC,GAAkBl1D,MAC7BihB,EACA1I,EACA4R,KAEA,MAAMqG,EAAmBC,GAAoBxP,EAAU1I,GACjDu2C,EAA8B,CAClC/gD,KAAMvR,IAAkBC,oBACxBwkB,SAAUuP,EACVrG,MAAOqG,EAAiB5qB,QAAO,CAACC,EAAKwT,KAC/BD,GAA0BC,IAAY8Q,EAAM9Q,EAAQC,UACtDzT,EAAIwT,EAAQC,QAAU6Q,EAAM9Q,EAAQC,SAE/BzT,IACN,KAEC3J,EAAOwK,KAAKC,UAAUmoD,GAC5B8F,GAAY14D,EACZ,IACE24D,IAAuB,QACjBM,GAA0Bj5D,GAChC,MAAOwI,GACPmwD,IAAuB,EACvBlwD,QAAQD,MAAMA,KAIZ0wD,GAAkB,KACtB,IAAKR,GACH,MAAO,GAGT,IACE,OAAOluD,KAAKU,MAAMwtD,IAClB,MAAOlwD,GAEP,OADAC,QAAQD,MAAMA,GACP,KAIL2wD,GACJ9wD,IAEA,MAAMrB,EDM4BqB,KAKlC,IAAIigB,EAAQjgB,EACT+wD,OACAjrD,MAAM,MACNzC,KAAK+G,GAASA,EAAK2mD,OAAOjrD,MAAM,QAUnC,GAPIma,EAAMnkB,QAA8B,IAApBmkB,EAAM,GAAGnkB,SAC3BmkB,EAAQjgB,EACL+wD,OACAjrD,MAAM,MACNzC,KAAK+G,GAASA,EAAK2mD,OAAOjrD,MAAM,QAGhB,IAAjBma,EAAMnkB,OACR,MAAO,CAAE0N,KAAMykD,GAAiBS,OAAQ,aAG1C,MAAMsC,EAAmB/wC,EAAM,GAAGnkB,OAGlC,IAFsBmkB,EAAMk+B,OAAO/zC,GAASA,EAAKtO,SAAWk1D,IAG1D,MAAO,CACLxnD,KAAMykD,GACNS,OAAQ,8CAIZ,MAAM/vD,EAAS4vD,GAActuC,GAC7B,GAAIthB,EAAO6K,OAAS0kD,GAAmB,CACrC,MAAM+C,EAAoB1C,GA9CNC,KACtB,MAAM0C,EAAwB,GAC9B,IAAK,IAAIC,EAAM,EAAGA,EAAM3C,EAAM,GAAG1yD,OAAQq1D,IAAO,CAC9C,MAAMC,EAAwB,GAC9B,IAAK,IAAInC,EAAM,EAAGA,EAAMT,EAAM1yD,OAAQmzD,IACpCmC,EAAYvvD,KAAK2sD,EAAMS,GAAKkC,IAE9BD,EAAUrvD,KAAKuvD,GAEjB,OAAOF,GAqCmCG,CAAepxC,IACvD,GAAIgxC,EAAkBznD,OAAS0kD,GAC7B,OAAO+C,EAGX,OAAOtyD,GC7CQ2yD,CAAoBtxD,GACnC,OAAIrB,EAAO6K,OAAS0kD,GACX,CAAEU,YAAajwD,EAAOiwD,aAExB,MAyBI2C,GAAiB91D,UAG5B,MAAM+1D,OArBmB/1D,WAGzB,IAAK,IAAD,EAMF,OALagD,EAAK,UACdA,EAAMgzD,qBADQ,aACd,EAAqBC,QAAQ,cAAcX,OAC3CR,UACO/oD,UAAU0pC,UAAUygB,aAEhB,GACf,MACA,MAAO,KAUqBC,CAAmBnzD,GAKjD,IAAK+yD,GAAmBA,EAAgBzhD,SAASq9C,IAC/C,OAAOyD,KAKT,MAAMgB,EAAoBf,GAA0BU,GACpD,GAAIK,EACF,OAAOA,EAGT,MAAMC,EAAmBjB,KAEzB,IACE,MAAMkB,EAAsB5vD,KAAKU,MAAM2uD,GACvC,OA7GFjH,EA6GgCwH,EA1G9B,CACE95D,IAAkBR,WAClBQ,IAAkBC,qBAClB6X,SAHF,OAGWw6C,QAHX,IAGWA,OAHX,EAGWA,EAAU/gD,OACrB4f,MAAM4F,QAAQu7B,EAAS7tC,UAuGd,CACLA,SAAUq1C,EAAoBr1C,SAC9BkJ,MAAOmsC,EAAoBnsC,OAGxBksC,EACP,MAIA,OAAOxB,IAAwBwB,EAAiBp1C,SAC5Co1C,EACA,CAAE9xD,KAAMwxD,GA1HdjH,OAoIWqG,GAA4Bn1D,UACvC,IAAIu2D,GAAS,EACb,GAAIxB,GACF,UAGQhpD,UAAU0pC,UAAU+gB,UAAUjyD,GAAQ,IAC5CgyD,GAAS,EACT,MAAO7xD,GACPC,QAAQD,MAAMA,GAMlB,IAAK6xD,IAAWE,GAAuBlyD,GAAQ,KAC7C,MAAM,IAAIpB,MAAM,kBAKdszD,GAA0BlyD,IAC9B,MAAMiO,EAAyD,QAAjD/I,SAASC,gBAAgBw4C,aAAa,OAE9CwU,EAAWjtD,SAASmF,cAAc,YAExC8nD,EAAS5nD,MAAM6nD,OAAS,IACxBD,EAAS5nD,MAAM8Z,QAAU,IACzB8tC,EAAS5nD,MAAMi1C,OAAS,IACxB2S,EAAS5nD,MAAMC,SAAW,WAC1B2nD,EAAS5nD,MAAM0D,EAAQ,QAAU,QAAU,UAC3C,MAAMokD,EAAYh6D,OAAOi6D,aAAeptD,SAASC,gBAAgBotD,UACjEJ,EAAS5nD,MAAMmgC,IAAf,UAAwB2nB,EAAxB,MAEAF,EAAS5nD,MAAMN,SAAW,OAE1BkoD,EAASpyC,aAAa,WAAY,IAClCoyC,EAASt0D,MAAQmC,EAEjBkF,SAASoF,KAAKI,YAAYynD,GAE1B,IAAIK,GAAU,EAEd,IACEL,EAASM,SACTN,EAASO,kBAAkB,EAAGP,EAASt0D,MAAM/B,QAE7C02D,EAAUttD,SAASytD,YAAY,QAC/B,MAAOxyD,GACPC,QAAQD,MAAMA,GAKhB,OAFAgyD,EAAS7xC,SAEFkyC,GClNII,GAAen3D,MAC1B+N,EACAkT,EACA1I,EACA4R,EAJ0B,KAkBtB,IAbJ,iBACEjU,EADF,cAEE27C,EAAgBzyD,IAFlB,oBAGE2Y,EAHF,KAIE3X,EAJF,WAKEkW,EAAa,MAQZ,EACH,GAAwB,IAApB2K,EAAS5gB,OACX,MAAM,IAAI8C,MAAMoF,EAAE,mCAEpB,GAAa,QAATwF,GAA2B,kBAATA,EAA0B,CAC9C,MAAMqpD,QAAgBpF,GACpB/wC,EACA,CACE/K,mBACAG,mBAAoBkC,EAASlC,mBAC7B0B,sBACA85C,gBACA17C,YAAaoC,EAASpC,YACtBC,iBAAkBmC,EAASnC,kBAA6B,QAATrI,GAEjDoc,GAEF,GAAa,QAATpc,EACF,aAAaw/C,GACX,IAAIjsD,KAAK,CAAC81D,EAAQC,WAAY,CAAEtpD,KAAMhS,IAAWI,MACjD,CACEiE,OACAqtD,UAAW,MACXn3C,eAGC,GAAa,kBAATvI,EAET,kBADMonD,GAA0BiC,EAAQC,WAK5C,MAAMC,QAAmB1F,GAAe3wC,EAAU1I,EAAU4R,EAAO,CACjEjU,mBACA6B,sBACA85C,kBAEFyF,EAAWxoD,MAAMY,QAAU,OAC3BjG,SAASoF,KAAKI,YAAYqoD,GAC1B,IAAI10D,QAAa+sD,GAAa2H,GAG9B,GAFAA,EAAWzyC,SAEE,QAAT9W,EAUF,OATIwK,EAASnC,mBACXxT,cACQ,sDACN20D,kBAAkB,CAClB30D,OACAmE,SAAU+pD,GAAgB7vC,EAAU1I,EAAU4R,EAAO,kBAI5CojC,GAAS3qD,EAAM,CAC1BxC,OACAqtD,UAAW,MACXn3C,eAEG,GAAa,cAATvI,EACT,SD0EoC/N,iBAChC+L,UAAU0pC,UAAU+hB,MAAM,CAC9B,IAAI56D,OAAO66D,cAAc,CAAE,CAAC17D,IAAWK,KAAMwG,OC3ErC80D,CAAyB90D,GAC/B,MAAO8B,GACP,GAAmB,4BAAfA,EAAMtE,KACR,MAAMsE,EAER,MAAM,IAAIvB,MAAMoF,EAAE,qC,MC7FjB,MAAMovD,GAGR,IAAsC,IAArC,SAAEpjB,EAAF,QAAYK,EAAZ,SAAqBD,GAAe,EACxC,OACE,uBACEjC,UAAWmB,aAAK,WAAY,CAAE,aAAce,IAC5ClB,QAAU1wC,IACR2xC,GAAUC,GAEP5xC,EAAMq9C,cAAiCrsC,cACtC,iBAEFqxB,SARN,UAWE,yBAAQqN,UAAU,eAAe0C,KAAK,WAAW,eAAcR,EAA/D,SACGS,KAEH,sBAAK3C,UAAU,iBAAf,SAAiC6B,Q,MCiCxB,OA5CE,IAOE,IAPD,SAChBA,EADgB,IAEhBpX,EAFgB,MAGhBy6B,EAHgB,eAIhBC,EAJgB,UAKhBnlB,EALgB,MAMhB5jC,GACgB,EAChB,OACE,sBACE4jC,UAAWmB,aAAK,yBAA0BnB,GAC1C5jC,MAAO,CACL,QAASquB,EACT26B,WAAYF,EACZC,oBACG/oD,GANP,SASGylC,KA0BQ,GArBE,IAME,IAND,SAChBA,EADgB,IAEhBpX,EAFgB,MAGhBy6B,EAHgB,eAIhBC,EAJgB,UAKhBnlB,GACgB,EAChB,OACE,sBACEA,UAAWmB,aAAK,uBAAwBnB,GACxC5jC,MAAO,CACL,QAASquB,EACT46B,aAAcH,EACdC,kBALJ,SAQGtjB,K,MCzCA,MAAMyjB,GAAa,QAAC,SAAElS,EAAF,OAAYmS,GAAb,SACxB,gBAAC,GAAD,CAAWvlB,UAAU,aAAavV,IAAK,EAAGy6B,MAAM,SAAhD,UACE,wBAAMllB,UAAU,uBAAhB,UACGsF,GACD,gCAAO8N,OAET,eAACjT,GAAD,CACE9kC,KAAK,OACLqmC,KAAMhxB,GACN8wB,MAAO3rC,EAAE,gBACT,aAAYA,EAAE,gBACdmrC,QAASukB,EACT,cAAY,oBCkJLC,IAnJ0B/d,GAAS,CAC9C/5C,KAAM,oBACNo6C,QAAS,CAACkK,EAAWnsC,EAAUnW,KAC7BN,YAAW,SAAU,SACd,CAAEyW,SAAU,IAAKA,EAAUnY,KAAMgC,GAASq4C,iBAAiB,IAEpEI,eAAgB,QAAC,SAAEtiC,EAAF,WAAYuiC,EAAZ,SAAwBqd,GAAzB,SACd,eAAC,GAAD,CACEh2D,MAAOoG,EAAE,oBACTnG,MAAOmW,EAASnY,MAAQ,UACxBu0C,SAAWv0C,GAAiB06C,EAAW16C,GACvC6lD,eAC2B,qBAAlBkS,EAAS/3D,OAAyBmY,EAASN,qBAMnBkiC,GAAS,CAC9C/5C,KAAM,oBACNo6C,QAAS,CAACkK,EAAWnsC,EAAUnW,KACtB,CACLmW,SAAU,IAAKA,EAAUpC,YAAa/T,GACtCq4C,iBAAiB,IAGrBI,eAAgB,IAAsD,IAAnD55B,SAAUm3C,EAAZ,SAAyB7/C,EAAzB,WAAmCuiC,GAAiB,EACnE,MAAM75B,EAAWmM,GAAsBgrC,GAEjCC,EADiBloB,GAAsBlvB,EAAU1I,GAEnDkY,GAAoBxP,EAAU1I,GAC9B0I,EAEJ,OACE,qCACG9hB,IAAcyI,KAAKuT,IAClB,MAAO9L,EAAOE,GPsHK,EAC3B0R,EACA4wC,EACA5oC,KAEA,MAAO,CAAC,CAAG5Z,EAAOE,GAAUwiD,GAAc9wC,EAAU4wC,GAAejqD,KAChE+V,GAAc/jB,KAAK0+D,MAAM36C,EAAYsL,KAGxC,MAAO,CAAC5Z,EAAOE,IO/HiBgpD,CACtBF,EACAj5D,IACA+b,GAGIq9C,EAAgB,UAAMjwD,EAC1B,iBADoB,YAEjB4S,EAFiB,cAEV9L,EAFU,YAEDE,EAFC,KAItB,OACE,eAACsjC,GAAD,CAEE7uB,KAAK,QACLjW,KAAK,QACLqmC,KAAI,UAAKj5B,EAAL,KACJ/a,KAAK,sBACL8zC,MAAOskB,EACP,aAAYA,EACZnwD,GAAG,sBACHusC,QAASz5B,IAAM5C,EAASpC,YACxBw+B,SAAU,IAAMmG,EAAW3/B,IATtBA,WAkByBg/B,GAAS,CACnD/5C,KAAM,yBACNo6C,QAAS,CAACkK,EAAWnsC,EAAUnW,KACtB,CACLmW,SAAU,IAAKA,EAAUrC,iBAAkB9T,GAC3Cq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAEtiC,EAAF,WAAYuiC,GAAb,SACd,eAAC,GAAD,CACElG,QAASr8B,EAASrC,iBAClBy+B,SAAWC,GAAYkG,EAAWlG,GAFpC,SAIGrsC,EAAE,8BAKmC4xC,GAAS,CACnD/5C,KAAM,yBACNo6C,QAAS,CAACkK,EAAWnsC,EAAUnW,KACtB,CACLmW,SAAU,IAAKA,EAAUnC,iBAAkBhU,GAC3Cq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAEtiC,EAAF,WAAYuiC,GAAb,SACd,gBAAC,GAAD,CACElG,QAASr8B,EAASnC,iBAClBu+B,SAAWC,GAAYkG,EAAWlG,GAFpC,UAIGrsC,EAAE,2BACH,eAAC,GAAD,CAASpG,MAAOoG,EAAE,mCAAoC66C,MAAM,EAA5D,SACE,sBAAK1Q,UAAU,0BAAf,SAA0C2D,aAMZ8D,GAAS,CAC7C/5C,KAAM,mBACNo6C,QAASx6C,MAAOihB,EAAU1I,EAAUnW,EAAOqiD,KACzC,MAAMgU,IAAqBlgD,EAASjC,WAEpC,IACE,MAAM,WAAEA,GAAei5C,GAAkBh3C,EAASjC,iBChIlBtW,OACpCihB,EACA1I,EACA4R,KAEA,MAAM,iBAAEjU,EAAF,oBAAoB6B,EAApB,KAAyC3X,EAAzC,WAA+CkW,GAAeiC,EAE9DmgD,EAAiBrJ,GAAkB/4C,GAEzC,IAAKA,GXgGW,SAFhBvI,EW9F0C2qD,IXgGR,QAAT3qD,EW/FvB,MAAM,IAAI5K,MACR,0EX4FJ4K,MWvEA,OAlBAwK,EAAW,IACNA,EACHnC,kBAAkB,SAGd+gD,GACJuB,EACAtrC,GAAsBnM,GACtB1I,EACA4R,EACA,CACEjU,mBACA6B,sBACA3X,OACAkW,eAIG,CAAEA,eDiGKqiD,CAAuB13C,EAAU1I,EAAUksC,EAAIt6B,aAC/C6mC,GAAW/vC,EAAU1I,EAAUksC,EAAIt6B,OAE7C,MAAO,CACLswB,iBAAiB,EACjBliC,SAAU,IACLA,EACHjC,aACAwB,aAAc2gD,GACA,OAAVniD,QAAU,IAAVA,OAAA,EAAAA,EAAYlW,MACVmI,EAAE,6BAA6BiC,QAC7B,aADF,WAEM8L,EAAWlW,KAFjB,MAIAmI,EAAE,mBACJ,OAGR,MAAO7D,GAIP,MAHoB,gBAAX,OAALA,QAAK,IAALA,OAAA,EAAAA,EAAOtE,OACTuE,QAAQD,MAAMA,GAET,CAAE+1C,iBAAiB,KAG9BG,QAAU53C,GACRA,EAAM/C,MAAQkM,IAAUnJ,EAAMmJ,KAAsBnJ,EAAMwJ,SAC5DquC,eAAgB,cAAC,WAAEC,EAAF,SAAcviC,GAAf,SACd,eAAC,GAAD,CACE0/C,OAAQ,IAAMnd,EAAW,MACzBgL,SAAQ,UAAEvtC,EAASjC,kBAAX,aAAE,EAAqBlW,UAKD+5C,GAAS,CAC3C/5C,KAAM,iBACNo6C,QAASx6C,MAAOihB,EAAU1I,EAAUnW,EAAOqiD,KACzC,IACE,MAAM,WAAEnuC,SAAqB06C,GAC3B/vC,EACA,IACK1I,EACHjC,WAAY,MAEdmuC,EAAIt6B,OAEN,MAAO,CAAEswB,iBAAiB,EAAOliC,SAAU,IAAKA,EAAUjC,eAC1D,MAAO5R,GAIP,MAHoB,gBAAX,OAALA,QAAK,IAALA,OAAA,EAAAA,EAAOtE,OACTuE,QAAQD,MAAMA,GAET,CAAE+1C,iBAAiB,KAG9BG,QAAU53C,GACRA,EAAM/C,MAAQkM,IAAUnJ,EAAMwJ,UAAYxJ,EAAMmJ,GAClD0uC,eAAgB,QAAC,WAAEC,GAAH,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLqmC,KAAMmB,GACNrB,MAAO3rC,EAAE,kBACT,aAAYA,EAAE,kBACd+rC,cAAeiQ,KACfxQ,QAAS6kB,KACTllB,QAAS,IAAMoH,EAAW,MAC1B,cAAY,uBAKaX,GAAS,CACtC/5C,KAAM,YACNo6C,QAASx6C,MAAOihB,EAAU1I,EAAU0hB,EAAGwqB,KACrC,IACE,MACExjC,SAAU43C,EACVtgD,SAAUugD,EAFN,MAGJ3uC,QThIoBnqB,OAC1B0uD,EACAL,KAEA,MAAMzrD,QAAaypD,GAAS,CAC1BI,YAAa,qBAKf,OAAOgD,GAAa7sD,EAAM8rD,EAAeL,ISuH3B0K,CAAaxgD,EAAU0I,GACjC,MAAO,CACLA,SAAU43C,EACVtgD,SAAUugD,EACV3uC,QACAswB,iBAAiB,GAEnB,MAAO/1C,GACP,MAAoB,gBAAX,OAALA,QAAK,IAALA,OAAA,EAAAA,EAAOtE,OAGJ,CACL6gB,WACA1I,SAAU,IAAKA,EAAUtC,aAAcvR,EAAM0tC,SAC7CjoB,MAAOs6B,EAAIt6B,MACXswB,iBAAiB,KAIvBG,QAAU53C,GAAUA,EAAMmJ,IAAqBnJ,EAAM/C,MAAQkM,GAC7D0uC,eAAgB,QAAC,WAAEC,EAAF,SAAcviC,GAAf,SACd,eAACs6B,GAAD,CACE9kC,KAAK,SACLqmC,KAAMoB,GACNtB,MAAO3rC,EAAE,gBACT,aAAYA,EAAE,gBACd+rC,cAAeiQ,KACf7Q,QAASoH,EACT,cAAY,mBAKsBX,GAAS,CAC/C/5C,KAAM,qBACNo6C,QAAS,CAACkK,EAAWnsC,EAAUnW,KACtB,CACLmW,SAAU,IAAKA,EAAUlC,mBAAoBjU,GAC7Cq4C,iBAAiB,IAGrBI,eAAgB,QAAC,SAAEtiC,EAAF,WAAYuiC,GAAb,SACd,sBACEhsC,MAAO,CACLY,QAAS,OACTmoD,eAAgB,WAChBmB,UAAW,QACXC,aAAc,QALlB,SAQE,eAAC3W,GAAD,CACElgD,MAAOmW,EAASlC,mBAAqBhb,IAAME,KAAOF,IAAMC,MACxDq5C,SAAW91C,IACTi8C,EAAWj8C,IAAUxD,IAAME,OAE7B24C,MAAO3rC,EAAE,yCE7PV,IAAI2wD,GAAuB,KAE3B,MAAMC,GAAmBhf,GAAS,CACvC/5C,KAAM,aACNo6C,QAAS,CAACv5B,EAAU1I,KAClB,MAAMc,EAAU4H,EAASkP,MAAM0d,GAAOt1B,EAASjB,mBAAmBu2B,EAAGxlC,MAIrE,OAHIgR,IACF6/C,GAAexyD,KAAKC,UAAU0S,IAEzB,CACLd,SAAU,IACLA,EACHT,aAAcvP,EAAE,qBAElBkyC,iBAAiB,IAGrBE,iBAAkB,oBAClBC,QAAU53C,GACRA,EAAMmJ,IAAqBnJ,EAAMsJ,QAAUtJ,EAAMmF,OAAS+D,IAGjDktD,GAAoBjf,GAAS,CACxC/5C,KAAM,cACNo6C,QAAS,CAACv5B,EAAU1I,KAClB,MAAM8gD,EAAgB3yD,KAAKU,MAAM8xD,IACjC,MvEmDkB,UAAX,QAFyB7/C,EuEjDPggD,SvEmDlB,IAAPhgD,OAAA,EAAAA,EAAStL,OACS,aAAX,OAAPsL,QAAO,IAAPA,OAAA,EAAAA,EAAStL,OACS,eAAX,OAAPsL,QAAO,IAAPA,OAAA,EAAAA,EAAStL,OACS,aAAX,OAAPsL,QAAO,IAAPA,OAAA,EAAAA,EAAStL,OACS,WAAX,OAAPsL,QAAO,IAAPA,OAAA,EAAAA,EAAStL,OACS,cAAX,OAAPsL,QAAO,IAAPA,OAAA,EAAAA,EAAStL,OACS,UAAX,OAAPsL,QAAO,IAAPA,OAAA,EAAAA,EAAStL,MuExDA,CAAEkT,WAAUw5B,iBAAiB,GAE/B,CACLx5B,SAAUA,EAASrZ,KAAKyR,IACtB,GAAId,EAASjB,mBAAmB+B,EAAQhR,IAAK,CAC3C,MAAMopB,EAAaxC,GAAe5V,EAAS,CACzCyM,gBAAe,OAAEuzC,QAAF,IAAEA,OAAF,EAAEA,EAAevzC,gBAChCzD,YAAW,OAAEg3C,QAAF,IAAEA,OAAF,EAAEA,EAAeh3C,YAC5BiB,YAAW,OAAE+1C,QAAF,IAAEA,OAAF,EAAEA,EAAe/1C,YAC5BgC,YAAW,OAAE+zC,QAAF,IAAEA,OAAF,EAAEA,EAAe/zC,YAC5BjC,UAAS,OAAEg2C,QAAF,IAAEA,OAAF,EAAEA,EAAeh2C,UAC1BL,QAAO,OAAEq2C,QAAF,IAAEA,OAAF,EAAEA,EAAer2C,QACxB0C,UAAS,OAAE2zC,QAAF,IAAEA,OAAF,EAAEA,EAAe3zC,YAU5B,OARIlM,GAAciY,KAChBlD,GAAckD,EAAY,CACxBjjB,UAAuB,OAAb6qD,QAAa,IAAbA,OAAA,EAAAA,EAAe7qD,WAAY/S,IACrC2S,YAAyB,OAAbirD,QAAa,IAAbA,OAAA,EAAAA,EAAejrD,aAAc1S,IACzC6oB,WAAwB,OAAb80C,QAAa,IAAbA,OAAA,EAAAA,EAAe90C,YAAa5oB,MAEzC6xC,GAAsB/b,IAEjBA,EAET,OAAOpY,KAETohC,iBAAiB,GvEsBaphC,OuEnBlCshC,iBAAkB,qBAClBC,QAAU53C,GACRA,EAAMmJ,IAAqBnJ,EAAMsJ,QAAUtJ,EAAMmF,OAAS+D,ICjEjDotD,GAAYtmB,GACvB,yBACEN,UAAU,YACVgB,QAASV,EAAMU,QACf3lC,KAAK,SACLmmC,MAAK,UAAKlB,EAAMkB,MAAX,aACL,aAAYlB,EAAMkB,MALpB,SAOGmC,KCsBCkjB,IC9BgCpf,GAAS,CAC7C/5C,KAAM,mBACNo6C,QAAS,CAACvgB,EAAG1hB,KAAJ,CACPA,SAAU,IACLA,EACHxB,SAAgC,WAAtBwB,EAASxB,SAAwB,KAAO,UAEpD0jC,iBAAiB,IAEnBI,eAAgB,QAAC,SAAEtiC,EAAF,WAAYuiC,GAAb,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLqmC,KAAM8B,GACN,aAAY3tC,EAAE,gBACdmrC,QAASoH,EACT7G,SAAgC,WAAtB17B,EAASxB,cAKWojC,GAAS,CAC3C/5C,KAAM,iBACNo6C,QAAS,CAACkK,EAAWnsC,KAAZ,CACPA,SAAU,IACLA,EACHxB,SAAgC,UAAtBwB,EAASxB,SAAuB,KAAO,SAEnD0jC,iBAAiB,IAEnBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEiB,QAASrG,GACPl1B,EACA6U,GAAsBnM,IAExBlT,KAAK,SACLqmC,KAAMuB,GACN,aAAYptC,EAAE,gBACdmrC,QAASoH,EACT7G,SAAgC,UAAtB17B,EAASxB,cAKOojC,GAAS,CACvC/5C,KAAM,mBACNo6C,QAAS,KACFrpC,M7EmJP1H,SAASC,gBAAgB8vD,oB6EhJnBroD,M7EkJ4B1H,SAASgwD,iB6E/IlC,CACLhf,iBAAiB,IAGrBG,QAAU53C,GAAUA,EAAMmF,OAAS+D,IAAYlJ,EAAMmJ,KAGxBguC,GAAS,CACtC/5C,KAAM,kBACNo6C,QAAS,CAACkK,EAAWnsC,EAAU0hB,EAAtB,KAAiD,IAAxB,eAAEurB,GAAqB,EAIvD,OAHIjtC,EAASb,gBACX8tC,IAEK,CACLjtC,SAAU,IACLA,EACHb,gBAAiBa,EAASb,gBAE5B+iC,iBAAiB,IAGrBI,eAAgB,QAAC,WAAEC,GAAH,SACd,eAACwe,GAAD,CAAUplB,MAAO3rC,EAAE,oBAAqBmrC,QAASoH,KAEnDF,QAAU53C,GAAUA,EAAM/C,MAAQkM,KD/CV,CACxB8U,EACA1I,KAEA,MAAMiY,EAAmBC,GACvBrD,GAAsBnM,GACtB1I,GAEF,OACEiY,EAAiBnwB,QAAU,IA1BC4gB,KAC9B,GAAIA,EAAS5gB,QAAU,EAAG,CACxB,MAAM0vB,EAAW9O,EAAS,GAAG8O,SAC7B,IAAK,MAAMF,KAAWE,EACpB,GACE9O,EAASrb,QACP,CAACC,EAAKwT,IAAYxT,GAAOgrB,GAAiBxX,EAASwW,KACnD,GAGF,OAAO,EAIb,OAAO,GAY4B6pC,CAAuBlpC,KAI/CmpC,GAAcxf,GAAS,CAClC/5C,KAAM,QACNo6C,QAAS,CAACv5B,EAAU1I,KAClB,MAAMiY,EAAmBC,GACvBrD,GAAsBnM,GACtB1I,GAEF,GAAIiY,EAAiBnwB,OAAS,EAE5B,MAAO,CAAEkY,WAAU0I,WAAUw5B,iBAAiB,GAGhD,MAAMljC,EAAmB6Y,GAAoB7X,GAC7C,GAAgC,IAA5BhB,EAAiBlX,OAAc,CACjC,MAAMu5D,EAAkBriD,EAAiB,GACnCsiD,EAAoB,IAAIrtC,IAC5BsE,GAAmB7P,EAAU24C,GAAiBhyD,KAC3CyR,GAAYA,EAAQhR,MAGnBiP,EAAqB,IAAIkV,IAC7BgE,EAAiB5oB,KAAKyR,GAAYA,EAAQhR,MAM5C,GAJoB,IAAImkB,IAAI,IACvBmB,MAAMC,KAAKisC,MACXlsC,MAAMC,KAAKtW,KAEA0M,OAAS61C,EAAkB71C,KAEzC,MAAO,CAAEzL,WAAU0I,WAAUw5B,iBAAiB,GAGlD,MAAMxpB,EAAa5C,KACbyrC,EAAkB74C,EAASrZ,KAAKyR,GAC/Bd,EAASjB,mBAAmB+B,EAAQhR,IAGlC4mB,GAAe5V,EAAS,CAC7B0W,SAAUgB,GACR1X,EAAQ0W,SACRkB,EACA1Y,EAAS1C,kBANJwD,IAYLyW,EAAkBgB,GAAmBgpC,EAAiB7oC,GACtD8oC,EAAqBjqC,EAAgBA,EAAgBzvB,OAAS,GAC9D25D,EACJF,EAAgBG,YAAYF,GACxBG,EAAqBJ,EAAgBzzD,MAAM2zD,EAAwB,GAMnEG,EAAyB,IALHL,EACzBzzD,MAAM,EAAG2zD,GACT/wD,QACEmxD,IAAoBvpC,GAAiBupC,EAAgBnpC,QAIrDnB,KACAoqC,GAGL,MAAO,CACL3hD,SAAUqX,GACRqB,EACA,IAAK1Y,EAAUhB,iBAAkB,IACjC6V,GAAsB+sC,IAExBl5C,SAAUk5C,EACV1f,iBAAiB,IAGrBE,iBAAkB,eAClB0f,qBAAsB,CAACp5C,EAAU1I,IAC/BghD,GAAkBt4C,EAAU1I,GAC9BqiC,QAAU53C,IACPA,EAAMwJ,UAAYxJ,EAAMmJ,IAAqBnJ,EAAMmF,OAAS+D,EAC/D2uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAAC6D,GAAD,CAAWp5C,MAAO0Z,EAAS1Z,QACjC60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,gBAAP,mBAA4B+I,GAAe,gBAChD,aAAY/I,EAAE,gBACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKzD+hD,GAAgBngB,GAAS,CACpC/5C,KAAM,UACNo6C,QAAS,CAACv5B,EAAU1I,KAElB,GAAwB,IADP6X,GAAoB7X,GACxBlY,OACX,MAAO,CAAEkY,WAAU0I,WAAUw5B,iBAAiB,GAEhD,MAAMntB,EAAerM,EAASrZ,KAAKyR,IACjC,MAAMkhD,EhEK4B,EACtCxqC,EACAxY,IACGwY,EAAS9mB,QAAQ4mB,IAAatY,EAAiBsY,KgERzB2qC,CACnBnhD,EAAQ0W,SACRxX,EAAShB,kBAEX,OAAIgjD,EAAal6D,SAAWgZ,EAAQ0W,SAAS1vB,OACpCgZ,EAEF4V,GAAe5V,EAAS,CAC7B0W,SAAUwqC,OAGd,MAAO,CACLhiD,SAAU+X,GACR,IAAK/X,EAAUhB,iBAAkB,IACjC6V,GAAsBE,IAExBrM,SAAUqM,EACVmtB,iBAAiB,IAGrBG,QAAU53C,GACRA,EAAMwJ,UAAYxJ,EAAMmJ,IAAqBnJ,EAAMmF,OAAS+D,EAC9DyuC,iBAAkB,iBAClB0f,qBAAsB,CAACp5C,EAAU1I,IAC/B6X,GAAoB7X,GAAUlY,OAAS,EAEzCw6C,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACE9kC,KAAK,SACLgmC,OAAiD,IAAzC3jB,GAAoB7X,GAAUlY,OACtC+zC,KAAM,eAAC8D,GAAD,CAAar5C,MAAO0Z,EAAS1Z,QACnC60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,kBAAP,mBAA8B+I,GAAe,sBAClD,aAAY/I,EAAE,kBACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,Q,ME9K/D,MAAMkiD,GAAS,QAAC,SAAElmB,EAAF,MAAY1hC,EAAZ,OAAmB8jD,EAAnB,QAA2BjjB,GAA5B,SACpB,sBACEhB,UAAU,SACV5jC,MAAO,CAAEs4C,WAAYv0C,EAAO8jD,OAAO,aAAD,OAAeA,IACjDjjB,QAASA,EAHX,SAKGa,KCZQmmB,ICCyBvgB,GAAS,CAC7C/5C,KAAM,mBACNo6C,QAAS,CAACkK,EAAWnsC,EAAUnW,KAC7B,MAAMqY,EAAQrY,EACd,OAAKqY,EAIE,CACLlC,SAAU,IACLA,KACA83B,GAAe,CAChBC,WAAY71B,EACZ81B,mBAAoB,CAClBlhC,MAAOkJ,EAASlJ,MAChBE,OAAQgJ,EAAShJ,QAEnBoC,KAAM4G,EAAS5G,OAGjBoF,SAAgC,WAAtBwB,EAASxB,SAAwB,KAAOwB,EAASxB,UAE7D0jC,iBAAiB,GAjBV,CAAEliC,WAAUkiC,iBAAiB,IAoBxCI,eAAgB,IAAqC,IAApC,SAAEtiC,EAAF,WAAYuiC,EAAZ,KAAwB95C,GAAW,EAClD,MAAM+lD,EAA4B,OAAG/lD,QAAH,IAAGA,OAAH,EAAGA,EAAMqH,GAC3C,IAAK0+C,EACH,OAAO,KAGT,MAAM4T,EAAepiD,EAAS9D,cAAc+O,IAAIujC,GAEhD,IAAK4T,EACH,OAAO,KAGT,MAAM,WAAEvT,EAAF,OAAczhC,GAAWmhC,GAAgBC,EAAUxuC,GACnDqiD,EvBtBwBnQ,KAChC,IAAKA,EACH,MAAO,IAET,MAAMoQ,EAAQpQ,EAAS6K,OAAOjrD,MAAM,KAEpC,GAAIwwD,EAAMx6D,OAAS,EACjB,OAAOw6D,EAAM,GAAGC,UAAU,EAAG,GAAGntD,cAGlC,MAAMotD,EAAYF,EAAM,GAClBG,EAAWH,EAAMA,EAAMx6D,OAAS,GAEtC,OAAQ06D,EAAU,GAAKC,EAAS,IAAIrtD,euBShBstD,CAAkBN,EAAalQ,UAEjD,OACE,eAAC,GAAD,CACE53C,MAAOu0C,EACPuP,OAAQhxC,EACR+tB,QAAS,IAAMoH,EAAW6f,EAAaO,SAHzC,SAKGN,OD/CyBzgB,GAAS,CACzC/5C,KAAM,eACNo6C,QAAS,CAACv5B,EAAU1I,EAAU0hB,EAAGwqB,KAC/B,MAAMj0B,EAAmBC,GACvBrD,GAAsBnM,GACtB1I,GASF,OANAksC,EAAI0W,QAAQC,cAAcnzD,MAAMozD,IAC9B5W,EAAI0W,QAAQG,YAAY,IACnBD,EACH7qC,EAAiB5oB,IAAIirB,UAGlB,GAET8nB,iBAAkB,yBEkBP4gB,GACXt6C,IAEA,MAAMu6C,EAA2C,IAAI9mD,IAgBrD,OAXAuM,EAASC,SAAS7H,IAChB,MAAMwW,EACwB,IAA5BxW,EAAQ0W,SAAS1vB,OACbgZ,EAAQhR,GACRgR,EAAQ0W,SAAS1W,EAAQ0W,SAAS1vB,OAAS,GAE3Co7D,EAAsBD,EAAOh4C,IAAIqM,IAAY,GAEnD2rC,EAAOx1D,IAAI6pB,EAAS,IAAI4rC,EAAqBpiD,OAGxCsU,MAAMC,KAAK4tC,EAAOze,WAGrB2e,GAAuB,CAC3BlxC,EACAmxC,EAF2B,KAIG,IAD9B,KAAEC,EAAF,SAAQ7sD,GACqB,EAC7B,MAAM8sD,EAAmBC,GAAqBtxC,IAEvCjd,EAAKoP,GACD,MAATi/C,EAAe,CAAC,OAAQ,QAAU,CAAC,OAAQ,QAEvCG,EAAgB,CAAE5sD,EAAG,EAAGyB,EAAG,GACjC,MAAiB,UAAb7B,EACK,IACFgtD,EACH,CAACH,GAAOD,EAAqBpuD,GAAOsuD,EAAiBtuD,IAEjC,QAAbwB,EACF,IACFgtD,EACH,CAACH,GAAOD,EAAqBh/C,GAAOk/C,EAAiBl/C,IAGlD,IACFo/C,EACH,CAACH,IACED,EAAqBpuD,GAAOouD,EAAqBh/C,IAAQ,GACzDk/C,EAAiBtuD,GAAOsuD,EAAiBl/C,IAAQ,IAIlDm/C,GAAwB76C,IAC5B,MAAO9B,EAAMC,EAAMC,EAAMC,GAAQ0B,GAAgBC,GACjD,MAAO,CAAE9B,OAAMC,OAAMC,OAAMC,SC1EvBi6C,GAAoB,CACxBt4C,EACA1I,IACGkY,GAAoBrD,GAAsBnM,GAAW1I,GAAUlY,OAAS,EAEvE27D,GAAwB,CAC5B/6C,EACA1I,EACA0jD,KAEA,MAKMnC,EDlBqB,EAC3BtpC,EACAyrC,KAEA,MAAMT,EAAgCD,GAAiB/qC,GAEjDmrC,EAAuBG,GAAqBtrC,GAElD,OAAOgrC,EAAOl+B,SAAS9S,IACrB,MAAMlgB,EAAcoxD,GAClBlxC,EACAmxC,EACAM,GAEF,OAAOzxC,EAAM5iB,KAAKyR,GAChB4V,GAAe5V,EAAS,CACtBlK,EAAGkK,EAAQlK,EAAI7E,EAAY6E,EAC3ByB,EAAGyI,EAAQzI,EAAItG,EAAYsG,UCCTsrD,CALCzrC,GACvBrD,GAAsBnM,GACtB1I,GAGsD0jD,GAElDE,EAAqBxuB,GAAcmsB,GAEzC,OAAO74C,EAASrZ,KAAKyR,GAAY8iD,EAAmB9iD,EAAQhR,KAAOgR,KC+DxDkiD,ID5DiBphB,GAAS,CACrC/5C,KAAM,WACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAU+6C,GAAsB/6C,EAAU1I,EAAU,CAClDxJ,SAAU,QACV6sD,KAAM,MAERnhB,iBAAiB,IAGrBG,QAAU53C,GACRA,EAAMmJ,IAAqBnJ,EAAMwJ,UAAYxJ,EAAM/C,MAAQkM,EAC7D0uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAAC0C,GAAD,CAAcj4C,MAAO0Z,EAAS1Z,QACpC60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,mBAAP,mBAA+B+I,GAClC,uBAEF,aAAY/I,EAAE,mBACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKrC4hC,GAAS,CACxC/5C,KAAM,cACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAU+6C,GAAsB/6C,EAAU1I,EAAU,CAClDxJ,SAAU,MACV6sD,KAAM,MAERnhB,iBAAiB,IAGrBG,QAAU53C,GACRA,EAAMmJ,IAAqBnJ,EAAMwJ,UAAYxJ,EAAM/C,MAAQkM,EAC7D0uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAAC4C,GAAD,CAAiBn4C,MAAO0Z,EAAS1Z,QACvC60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,sBAAP,mBAAkC+I,GACrC,yBAEF,aAAY/I,EAAE,sBACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKvC4hC,GAAS,CACtC/5C,KAAM,YACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAU+6C,GAAsB/6C,EAAU1I,EAAU,CAClDxJ,SAAU,QACV6sD,KAAM,MAERnhB,iBAAiB,IAGrBG,QAAU53C,GACRA,EAAMmJ,IAAqBnJ,EAAMwJ,UAAYxJ,EAAM/C,MAAQkM,EAC7D0uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAAC6C,GAAD,CAAep4C,MAAO0Z,EAAS1Z,QACrC60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,oBAAP,mBAAgC+I,GACnC,yBAEF,aAAY/I,EAAE,oBACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKtC4hC,GAAS,CACvC/5C,KAAM,aACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAU+6C,GAAsB/6C,EAAU1I,EAAU,CAClDxJ,SAAU,MACV6sD,KAAM,MAERnhB,iBAAiB,IAGrBG,QAAU53C,GACRA,EAAMmJ,IAAqBnJ,EAAMwJ,UAAYxJ,EAAM/C,MAAQkM,EAC7D0uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAAC8C,GAAD,CAAgBr4C,MAAO0Z,EAAS1Z,QACtC60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,qBAAP,mBAAiC+I,GACpC,0BAEF,aAAY/I,EAAE,qBACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKzB4hC,GAAS,CACpD/5C,KAAM,0BACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAU+6C,GAAsB/6C,EAAU1I,EAAU,CAClDxJ,SAAU,SACV6sD,KAAM,MAERnhB,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAACiD,GAAD,CAAsBx4C,MAAO0Z,EAAS1Z,QAC5C60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAO3rC,EAAE,2BACT,aAAYA,EAAE,2BACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKvB4hC,GAAS,CACtD/5C,KAAM,4BACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAU+6C,GAAsB/6C,EAAU1I,EAAU,CAClDxJ,SAAU,SACV6sD,KAAM,MAERnhB,iBAAiB,IAGrBI,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAACmD,GAAD,CAAwB14C,MAAO0Z,EAAS1Z,QAC9C60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAO3rC,EAAE,6BACT,aAAYA,EAAE,6BACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QCpGpE0I,IAEA,MAAMu6C,EAA2C,IAAI9mD,IAgBrD,OAXAuM,EAASC,SAAS7H,IAChB,MAAMwW,EACwB,IAA5BxW,EAAQ0W,SAAS1vB,OACbgZ,EAAQhR,GACRgR,EAAQ0W,SAAS1W,EAAQ0W,SAAS1vB,OAAS,GAE3Co7D,EAAsBD,EAAOh4C,IAAIqM,IAAY,GAEnD2rC,EAAOx1D,IAAI6pB,EAAS,IAAI4rC,EAAqBpiD,OAGxCsU,MAAMC,KAAK4tC,EAAOze,YAGrB+e,GAAwB76C,IAC5B,MAAO9B,EAAMC,EAAMC,EAAMC,GAAQ0B,GAAgBC,GACjD,MAAO,CACL9B,OACAC,OACAC,OACAC,OACAjQ,MAAOgQ,EAAOF,EACd5P,OAAQ+P,EAAOF,EACfg9C,MAAOj9C,EAAOE,GAAQ,EACtBg9C,MAAOj9C,EAAOE,GAAQ,ICtHpBi6C,GAAoB,CACxBt4C,EACA1I,IACGkY,GAAoBrD,GAAsBnM,GAAW1I,GAAUlY,OAAS,EAEvEi8D,GAA6B,CACjCr7C,EACA1I,EACAgkD,KAEA,MAKMzC,EDV0B,EAChCtpC,EACA+rC,KAEA,MAAO9kB,EAAO+kB,EAAKC,EAAKC,GACA,MAAtBH,EAAaX,KACR,CAAC,OAAQ,OAAQ,OAAQ,SACzB,CAAC,OAAQ,OAAQ,OAAQ,UAE1B37C,EAAS67C,GAAqBtrC,GAC9BgrC,EAASD,GAAiB/qC,GAC7B5oB,KAAK4iB,GAAU,CAACA,EAAOsxC,GAAqBtxC,MAC5C1hB,MAAK,CAACgtB,EAAGC,IAAMD,EAAE,GAAG0mC,GAAOzmC,EAAE,GAAGymC,KAEnC,IAAI/sD,EAAO,EACX,IAAK,MAAM+a,KAASgxC,EAClB/rD,GAAQ+a,EAAM,GAAGkyC,GAGnB,MAAMna,GAAQtiC,EAAOy8C,GAAUjtD,IAAS+rD,EAAOn7D,OAAS,GAExD,GAAIkiD,EAAO,EAAG,CAKZ,MAAMoa,EAASnB,EAAO7f,WAAWihB,GAAMA,EAAE,GAAGnlB,KAAWx3B,EAAOw3B,KACxDolB,EAASrB,EAAO7f,WAAWihB,GAAMA,EAAE,GAAGH,KAASx8C,EAAOw8C,KAItDla,GACHiZ,EAAOqB,GAAQ,GAAGL,GAAOhB,EAAOmB,GAAQ,GAAGH,KAAShB,EAAOn7D,OAAS,GAEvE,IAAIy8D,EAAMtB,EAAOmB,GAAQ,GAAGH,GAE5B,OAAOhB,EAAOl+B,SAAQ,CAAC,EAActzB,KAAW,IAAxBwgB,EAAOuyC,GAAgB,EAC7C,MAAMzyD,EAAc,CAClB6E,EAAG,EACHyB,EAAG,GASL,OALI5G,IAAU2yD,GAAU3yD,IAAU6yD,IAChCC,GAAOva,EACPj4C,EAAYiyD,EAAaX,MAAQkB,EAAMC,EAAIP,IAGtChyC,EAAM5iB,KAAKyR,GAChB4V,GAAe5V,EAAS,CACtBlK,EAAGkK,EAAQlK,EAAI7E,EAAY6E,EAC3ByB,EAAGyI,EAAQzI,EAAItG,EAAYsG,SAQnC,IAAIksD,EAAM78C,EAAOw3B,GAEjB,OAAO+jB,EAAOl+B,SAAQ,IAAmB,IAAjB9S,EAAOuyC,GAAS,EACtC,MAAMzyD,EAAc,CAClB6E,EAAG,EACHyB,EAAG,GAQL,OALAtG,EAAYiyD,EAAaX,MAAQkB,EAAMC,EAAItlB,GAE3CqlB,GAAOva,EACPua,GAAOC,EAAIL,GAEJlyC,EAAM5iB,KAAKyR,GAChB4V,GAAe5V,EAAS,CACtBlK,EAAGkK,EAAQlK,EAAI7E,EAAY6E,EAC3ByB,EAAGyI,EAAQzI,EAAItG,EAAYsG,UCjETosD,CALCvsC,GACvBrD,GAAsBnM,GACtB1I,GAG2DgkD,GAEvDJ,EAAqBxuB,GAAcmsB,GAEzC,OAAO74C,EAASrZ,KAAKyR,GAAY8iD,EAAmB9iD,EAAQhR,KAAOgR,KCAxD4jD,IDGyB9iB,GAAS,CAC7C/5C,KAAM,yBACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAUq7C,GAA2Br7C,EAAU1I,EAAU,CACvD2kD,MAAO,UACPtB,KAAM,MAERnhB,iBAAiB,IAGrBG,QAAU53C,GAAUA,EAAMsJ,QAAUtJ,EAAMmF,OAAS+D,EACnD2uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAAC+C,GAAD,CAA4Bt4C,MAAO0Z,EAAS1Z,QAClD60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,iCAAP,mBAA6C+I,GAChD,UAEF,aAAY/I,EAAE,iCACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QAKlC4hC,GAAS,CAC3C/5C,KAAM,uBACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACLA,WACA0I,SAAUq7C,GAA2Br7C,EAAU1I,EAAU,CACvD2kD,MAAO,UACPtB,KAAM,MAERnhB,iBAAiB,IAGrBG,QAAU53C,GAAUA,EAAMsJ,QAAUtJ,EAAMmF,OAAS+D,EACnD2uC,eAAgB,QAAC,SAAE55B,EAAF,SAAY1I,EAAZ,WAAsBuiC,GAAvB,SACd,eAACjI,GAAD,CACEkB,QAASwlB,GAAkBt4C,EAAU1I,GACrCxK,KAAK,SACLqmC,KAAM,eAACgD,GAAD,CAA0Bv4C,MAAO0Z,EAAS1Z,QAChD60C,QAAS,IAAMoH,EAAW,MAC1B5G,MAAK,UAAK3rC,EAAE,+BAAP,mBAA2C+I,GAAe,UAC/D,aAAY/I,EAAE,+BACdurC,QAAS3D,GAAsB/iB,GAAsBnM,GAAW1I,QCpDlC4hC,GAAS,CAC3C/5C,KAAM,iBACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACL0I,SAAUk8C,GAAqBl8C,EAAU1I,EAAU,cACnDA,WACAkiC,iBAAiB,IAGrBG,QAAU53C,GAAUA,EAAMwJ,UAA2B,SAAfxJ,EAAMmF,KAC5CwyC,iBAAkB,wBAClB0f,qBAAsB,CAACp5C,EAAU1I,IAjCA,EACjC0I,EACA1I,KAEA,MAAM6kD,EAAmB3sC,GACvBrD,GAAsBnM,GACtB1I,GAEF,OAAmC,IAA5B6kD,EAAiB/8D,QAA6C,SAA7B+8D,EAAiB,GAAGrvD,MA0B1DsvD,CAA2Bp8C,EAAU1I,MAG5B+kD,GAAqBnjB,GAAS,CACzC/5C,KAAM,eACNo6C,QAAS,CAACv5B,EAAU1I,KACX,CACL0I,SAAUk8C,GAAqBl8C,EAAU1I,EAAU,YACnDA,WACAkiC,iBAAiB,IAGrBG,QAAU53C,GAAUA,EAAMwJ,UAA2B,SAAfxJ,EAAMmF,KAC5CwyC,iBAAkB,sBAClB0f,qBAAsB,CAACp5C,EAAU1I,IArCF,EAC/B0I,EACA1I,IAMmC,IAJVkY,GACvBrD,GAAsBnM,GACtB1I,GAEsBlY,OA8BtBk9D,CAAyBt8C,EAAU1I,KAGjC4kD,GAAuB,CAC3Bl8C,EACA1I,EACAilD,KAEA,MAAMhtC,EAAmBC,GACvBrD,GAAsBnM,GACtB1I,GAIF,GAAIiY,EAAiBnwB,OAAS,EAC5B,OAAO4gB,EAGT,MAAM64C,EAAkB2D,GACtBjtC,EACAjY,EACAilD,GAGIrB,EAAqBxuB,GAAcmsB,GAEzC,OAAO74C,EAASrZ,KAAKyR,GAAY8iD,EAAmB9iD,EAAQhR,KAAOgR,KAG/DokD,GAAe,CACnBx8C,EACA1I,EACAilD,KAEAv8C,EAASC,SAAS7H,IAChBqkD,GAAYrkD,EAASd,GAEC,aAAlBilD,GACFG,GAActkD,EAASzf,KAAKC,OAGzBonB,GAGHy8C,GAAc,CAClBrkD,EACAd,KAEA,MAAMqlD,EAAYvkD,EAAQlK,EACpB0uD,EAAYxkD,EAAQzI,EACpBvB,EAAQgK,EAAQhK,MAChBE,EAAS8J,EAAQ9J,OACjBuuD,EAAgB51B,GAAe7uB,EAAQgB,OAE7C,IAAI0jD,EAAe,GACfpkD,GAAgBN,IAAYI,GAAkBJ,MAChD0kD,EACsE,EAApE1kD,EAAQoC,OAAO7V,QAAO,CAAC+W,EAAKlC,IAAU7gB,KAAK+iB,IAAIA,EAAKlC,EAAM,KAAK,GAC/DpB,EAAQhK,OAIZkf,GAAclV,EAAS,CACrBgB,MAAO6tB,GAAe,KAGxB,MAAM1S,EAAmBG,GAAoBtc,EAASd,EAAS5G,MAC/D,IAAIqsD,GAAgB,EAChBC,EAAc,EACdC,EAAU1oC,EAAiBjB,GAC/B,IAAK2pC,IAEHF,GAAgB,EAChBE,EAAU1oC,EAAiBd,IACtBwpC,GAIH,YAHA3vC,GAAclV,EAAS,CACrBgB,MAAOyjD,IAMb,GAAInkD,GAAgBN,GAAU,CAC5B,IAAK,IAAI5V,EAAI,EAAGA,EAAI4V,EAAQoC,OAAOpb,OAAQoD,IACzC88B,GAAoBa,UAAU/nB,EAAS5V,EAAG,EACvC4V,EAAQoC,OAAOhY,GAAG,GACnB4V,EAAQoC,OAAOhY,GAAG,KAGtB88B,GAAoBQ,gBAAgB1nB,QAGpC4kD,EAAcD,EAAgB3kD,EAAQlK,EAAI,EAAIE,EAAQgK,EAAQlK,EAAI,EAAIE,EACtE65B,GACE7vB,GACA,EACAA,EACA2kD,EAAgB,KAAO,MACvB,EACAC,EACAC,EAAQ,IAGV3vC,GAAclV,EAAS,CACrBhK,QACAE,WAKJ,IAAI8K,EAAQ6tB,GAAe,EAAItuC,KAAKC,GAAKikE,GACrCzjD,EAAQ,IAEVA,EAAQ6tB,GAAe7tB,EAAQ,EAAIzgB,KAAKC,KAE1C00B,GAAclV,EAAS,CACrBgB,UAIFkU,GAAclV,EAAS,CACrBlK,EAAGyuD,EAAYG,EACfntD,EAAGitD,IAGLv4B,GAAoBjsB,IAGhBskD,GAAgB,CAACtkD,EAA4B8kD,KACjD,MAAMP,EAAYvkD,EAAQlK,EACpB0uD,EAAYxkD,EAAQzI,EAC1B,IAAIyJ,EAAQ6tB,GAAe7uB,EAAQgB,MAAQ8jD,GACvC9jD,EAAQ,IAEVA,EAAQ6tB,GAAe,EAAItuC,KAAKC,GAAKwgB,IAEvCkU,GAAclV,EAAS,CACrBgB,UAIFkU,GAAclV,EAAS,CACrBlK,EAAGyuD,EACHhtD,EAAGitD,KCnMMO,GAAajkB,GAAS,CACjC/5C,KAAM,OACNo6C,QAAS,CAACv5B,EAAU1I,EAAU0hB,EAAGwqB,KAC/ByQ,GAAgB9nC,GAAsBnM,GAAW1I,EAAUksC,EAAIt6B,OAExD,CACLswB,iBAAiB,IAGrBE,iBAAkB,cAElBC,aAAS1wC,IAGEm0D,GAAYlkB,GAAS,CAChC/5C,KAAM,MACNo6C,QAAS,CAACv5B,EAAU1I,EAAUvX,EAAMyjD,KAClC2Z,GAAW5jB,QAAQv5B,EAAU1I,EAAUvX,EAAMyjD,GACtClK,GAAqBC,QAAQv5B,EAAU1I,EAAUvX,EAAMyjD,IAEhE9J,iBAAkB,aAClBC,QAAU53C,GAAUA,EAAMmJ,IAAqBnJ,EAAMmF,OAAS+D,IAGnDoyD,GAAkBnkB,GAAS,CACtC/5C,KAAM,YACNo6C,QAASx6C,MAAOihB,EAAU1I,EAAUgmD,EAAO9Z,KACzC,IAAKA,EAAI1zC,OACP,MAAO,CACL0pC,iBAAiB,GAGrB,MAAMjqB,EAAmBC,GACvBrD,GAAsBnM,GACtB1I,GAEF,IAUE,aATM4+C,GACJ,gBACA3mC,EAAiBnwB,OACbmwB,EACApD,GAAsBnM,GAC1B1I,EACAksC,EAAIt6B,MACJ5R,GAEK,CACLkiC,iBAAiB,GAEnB,MAAO/1C,GAEP,OADAC,QAAQD,MAAMA,GACP,CACL6T,SAAU,IACLA,EACHtC,aAAcvR,EAAM0tC,SAEtBqI,iBAAiB,KAIvBE,iBAAkB,qBAGP6jB,GAAkBrkB,GAAS,CACtC/5C,KAAM,YACNo6C,QAASx6C,MAAOihB,EAAU1I,EAAUgmD,EAAO9Z,KACzC,IAAKA,EAAI1zC,OACP,MAAO,CACL0pC,iBAAiB,GAGrB,MAAMjqB,EAAmBC,GACvBrD,GAAsBnM,GACtB1I,GAEF,IAUE,aATM4+C,GACJ,YACA3mC,EAAiBnwB,OACbmwB,EACApD,GAAsBnM,GAC1B1I,EACAksC,EAAIt6B,MACJ5R,GAEK,CACLA,SAAU,IACLA,EACHT,aAAcvP,EAAE,6BAA8B,CAC5Ck2D,gBAAiBjuC,EAAiBnwB,OAC9BkI,EAAE,mBACFA,EAAE,gBACNm2D,kBAAmBnmD,EAASlC,mBACxB9N,EAAE,oBACFA,EAAE,wBAGVkyC,iBAAiB,GAEnB,MAAO/1C,GAEP,OADAC,QAAQD,MAAMA,GACP,CACL6T,SAAU,IACLA,EACHtC,aAAcvR,EAAM0tC,SAEtBqI,iBAAiB,KAIvBE,iBAAkB,mBAClBC,QAAU53C,GAAUA,EAAMmF,OAAS+D,GAAWlJ,EAAMsJ,QAAUtJ,EAAMwJ,WClHzDmyD,GAAuBxkB,GAAS,CAC3C/5C,KAAM,WACNo6C,QAAQv5B,EAAU1I,GAEhB,OADAzW,YAAW,OAAQ,OAAQ,QACpB,CACLyW,SAAU,IACLA,EACHhC,SAAUqW,KAAKgoB,QAASr8B,GAAY,KAAOzc,KAE7C2+C,iBAAiB,IAGrB7F,QAAUr8B,GAA6C,OAAtBA,EAAShC,SAC1CokC,iBAAkB,kBAClBC,QAAU53C,GAAUA,EAAMmJ,IAAqBnJ,EAAMmF,OAAS+D,IChBnD0yD,GAAsBzkB,GAAS,CAC1C/5C,KAAM,UACNo6C,QAAQv5B,EAAU1I,GAGhB,OAFAzW,YAAW,OAAQ,OAAQ,OAEpB,CACLyW,SAAU,IACLA,EACHP,gBAAiB4U,KAAKgoB,QAASr8B,IAEjCkiC,iBAAiB,IAGrB7F,QAAUr8B,GAAaA,EAASP,eAChC2iC,iBAAkB,kBAClBC,QAAU53C,IACPA,EAAMmJ,IAAqBnJ,EAAMsJ,QAAUtJ,EAAMmF,OAAS+D,ICjBlD2yD,GAAoB1kB,GAAS,CACxC/5C,KAAM,QACNo6C,QAAQv5B,EAAU1I,GAChB,MAAO,CACLA,SAAU,IACLA,EACHZ,WAAYiV,KAAKgoB,QAASr8B,IAE5BkiC,iBAAiB,IAGrB7F,QAAUr8B,GAAaA,EAASZ,UAChCgjC,iBAAkB,cAClBC,QAAU53C,IACPA,EAAMmJ,IAAqBnJ,EAAMsJ,QAAUtJ,EAAMmF,OAAS+D,ICLzD4yD,GAAY,CAChBC,EACAxmD,EACAymD,KAEA,MAAMvkB,GAAkB,EACxB,IACGliC,EAASzB,eACTyB,EAASnB,kBACTmB,EAAS3C,iBACT2C,EAAS5C,gBACV,CACA,MAAM3U,EAAOg+D,IACb,GAAa,OAATh+D,EACF,MAAO,CAAEy5C,mBAGX,MAAMwkB,EAAiBtxB,GAAcoxB,GAC/BzxC,EAAetsB,EAAKigB,SACpBi+C,EAAiBvxB,GAAcrgB,GAE/Bwa,EAAkBi3B,EAAa91D,QAClCk2D,IAAiBD,EAAe5rC,eAAe6rC,EAAY92D,MAExD4Y,EAAWqM,EACd1lB,KAAKg0C,GACJ3sB,GACEgwC,EAAerjB,EAAYvzC,KAAOuzC,EAClCA,KAGH/yC,OACCi/B,EAAgBlgC,KAAKu3D,GACnBlwC,GAAekwC,EAAa,CAAE3tC,WAAW,OAK/C,OAFAqW,GAAyB5mB,EAAU6mB,GAE5B,CACL7mB,WACA1I,SAAU,IAAKA,KAAavX,EAAKuX,UACjCkiC,kBACA2kB,aAAa,GAGjB,MAAO,CAAE3kB,oBC5CJ,MAAM4kB,GASXlsC,YACE6rC,EACAM,EACAvyC,EACA03B,GACC,KAbHvK,QAAU,GAaR,KAXF8kB,aAWE,OATFM,iBASE,OARFvyC,iCAQE,OAPF03B,SAOE,OA4EF8a,aAAe,CAACn/D,EAAkBY,KAChC,MAAM1C,EAAgBsuB,KAAK63B,IAAIzR,MAAMwsB,UAAUlhE,cAE/C,GACEsuB,KAAKstB,QAAQ95C,IACb,mBAAoBwsB,KAAKstB,QAAQ95C,OAChCA,KAAQ9B,IACLA,EAAc8B,IAElB,CACA,MAAMg6C,EAASxtB,KAAKstB,QAAQ95C,GACtBy6C,EAAiBT,EAAOS,eACxBC,EAAc2kB,IAClB7yC,KAAKoyC,QACH5kB,EAAOI,QACL5tB,KAAKG,8BACLH,KAAK0yC,cACLG,EACA7yC,KAAK63B,OAKX,OACE,eAAC5J,EAAD,CACE55B,SAAU2L,KAAKG,8BACfxU,SAAUqU,KAAK0yC,cACfxkB,WAAYA,EACZqd,SAAUvrC,KAAK63B,IAAIzR,MACnBhyC,KAAMA,IAKZ,OAAO,MA7GP4rB,KAAKoyC,QAAWU,IACd,IAAIA,KAAgB,SAAUA,GAK5B,OAAOV,EAAQU,GAJfA,EAAaz3D,MAAMy3D,GACVV,EAAQU,MAMrB9yC,KAAK0yC,YAAcA,EACnB1yC,KAAKG,4BAA8BA,EACnCH,KAAK63B,IAAMA,EAGbkb,eAAevlB,GACbxtB,KAAKstB,QAAQE,EAAOh6C,MAAQg6C,EAG9BwlB,YAAY1lB,GACVA,EAAQh5B,SAASk5B,GAAWxtB,KAAK+yC,eAAevlB,KAGlDylB,cAAc78D,GACZ,MAAM1E,EAAgBsuB,KAAK63B,IAAIzR,MAAMwsB,UAAUlhE,cACzC0C,EAAOyH,OAAOs0C,OAAOnwB,KAAKstB,SAC7BpxC,MAAK,CAACgtB,EAAGC,KAAOA,EAAEsnB,aAAe,IAAMvnB,EAAEunB,aAAe,KACxDp0C,QACEmxC,MACEA,EAAOh6C,QAAQ9B,IACZA,EAAc87C,EAAOh6C,QAEzBg6C,EAAOQ,SACPR,EAAOQ,QACL53C,EACA4pB,KAAK0yC,cACL1yC,KAAKG,iCAIb,GAAoB,IAAhB/rB,EAAKX,OACP,OAAO,EAET,MAAM,gBAAE4X,GAAoB2U,KAAK0yC,cACjC,QAAIrnD,IACGxP,OAAOs0C,OAAOp/C,KAAO2W,SAAStT,EAAK,GAAGZ,SAK7C4C,EAAMmR,iBACNyY,KAAKoyC,QACHh+D,EAAK,GAAGw5C,QACN5tB,KAAKG,8BACLH,KAAK0yC,cACL,KACA1yC,KAAK63B,OAGF,GAGTqb,cAAc1lB,GACZxtB,KAAKoyC,QACH5kB,EAAOI,QACL5tB,KAAKG,8BACLH,KAAK0yC,cACL,KACA1yC,KAAK63B,OCmBEsb,OA5Gf,MAIE5sC,YAAYsxB,GAAW,KAHfub,aAAoC,KAGtB,KAFdvb,SAEc,OAItBwb,aAAejgE,UAAa,IAAD,UACzB,WAAM,EAAA4sB,KAAK63B,IAAIzR,OAAMktB,uBAArB,aAAM,SAAiC,KACvCtzC,KAAKozC,aAAe,IANA,KAStBG,mBAAsBC,IACpB,MAAMn/C,EAAWmM,GAAsBghC,GAAgBgS,EAAa,OACpE,OAAOn/C,EAAS5gB,OAAS4gB,EAAW,MAXhB,KA0DtBm6C,YAAc,IACL,IAAI34D,SAAQzC,UACjB,GAAI4sB,KAAKozC,aACP,OAAOt9D,EAAQgE,KAAKU,MAAMV,KAAKC,UAAUimB,KAAKozC,gBAGhD,IACE,MAAMK,EAAezzC,KAAK63B,IAAI6b,wBAC9B,IAAKD,EACH,OAAO39D,EAAQ,IAGjB,MAAM24D,EAAQgF,EAAaz6D,QAAO,CAACC,EAAKy9C,KACjB12B,KAAKuzC,mBAAmB7c,IAE3Cz9C,EAAIO,KAAKk9C,GAEJz9C,IACN,IAGH+mB,KAAKozC,aAAet5D,KAAKU,MAAMV,KAAKC,UAAU00D,IAE9C34D,EAAQ24D,GACR,MAAO32D,GACPC,QAAQD,MAAMA,GACdhC,EAAQ,QApFQ,KAyFtB44D,YAAct7D,UACZ,MAAMugE,EAAmB3zC,KAAKozC,aAC9B,IAAK,IAAD,IACF,MAAMQ,EAAkB95D,KAAKC,UAAU00D,GAGvCzuC,KAAKozC,aAAet5D,KAAKU,MAAMo5D,SAC/B,WAAM,EAAA5zC,KAAK63B,IAAIzR,OAAMktB,uBAArB,aAAM,SAAiC7E,IACvC,MAAO32D,GAEP,MADAkoB,KAAKozC,aAAeO,EACd77D,IAlGRkoB,KAAK63B,IAAMA,EAcM,oBAAC7hD,GAClB,MAAM69D,O9B0IyBzgE,WACjC,MAAM8uD,QAAiBD,GAAkBjsD,GACnC5B,EAA4B0F,KAAKU,MAAM0nD,GAC7C,GAAI9tD,EAAK+M,OAASvR,IAAkBE,kBAClC,MAAM,IAAIyG,MAAMoF,EAAE,mCAEpB,OAAOvH,G8BhJqB0/D,CAAoB99D,GAC9C,IAAK69D,IAAgBA,EAAYtF,QAC/B,OAMF,MAqBMwF,QAA6B/zC,KAAKwuC,cAElCwF,EAAWH,EAAYtF,QAASv1D,QAAO,CAACC,EAAKu6D,KACjD,MAAMS,EAAej0C,KAAKuzC,mBAAmBC,GAI7C,OAHIS,GAzBe,EACnBF,EACAG,KAEQH,EAAqBxwC,MAAMiwC,GAC7BA,EAAY//D,SAAWygE,EAAkBzgE,QAMtC+/D,EAAY1d,OAAM,CAACqe,EAAuBnhD,IAE7CmhD,EAAsB14D,KAAOy4D,EAAkBlhD,GAAKvX,IACpD04D,EAAsBhyC,eACpB+xC,EAAkBlhD,GAAKmP,iBAUXiyC,CAAaL,EAAsBE,IACrDh7D,EAAIO,KAAKy6D,GAEJh7D,IACN,UAEG+mB,KAAK0uC,YAAY,IAAIqF,KAAyBC,MC/DjD,MAAMK,GAAaC,IACxB,MAAMC,EAAYxzC,MAAMC,KAAKszC,EAASnkB,UACtC,MAAO,CACL5tC,EAAG83C,GAAIka,GAAYrhD,GAAWA,EAAO3Q,IAAKgyD,EAAU9gE,OACpDuQ,EAAGq2C,GAAIka,GAAYrhD,GAAWA,EAAOlP,IAAKuwD,EAAU9gE,SAI3C+gE,GAAc,QAAEtrC,EAAGC,GAAL,SACzBn8B,KAAK2hB,MAAMua,EAAE3mB,EAAI4mB,EAAE5mB,EAAG2mB,EAAEllB,EAAImlB,EAAEnlB,IAE1Bq2C,GAAM,CAAIzL,EAAqB5nB,IACnC4nB,EAAM51C,QAAO,CAACC,EAAKy9C,IAASz9C,EAAM+tB,EAAO0vB,IAAO,GCM5C+d,GAAqC9oD,IAClC,CACLjB,mBAAoBiB,EAASjB,mBAC7BC,iBAAkBgB,EAAShB,iBAC3BQ,oBAAqBQ,EAASR,oBAC9BjC,qBAAsByC,EAASzC,qBAC/BD,eAAgB0C,EAAS1C,eACzBzV,KAAMmY,EAASnY,OA4OJkhE,OAxOf,MAAe,cAAD,KACJC,aAAe,IAAI7sD,IADf,KAEJ8sD,WAAqB,EAFjB,KAGJC,aAAyC,GAHrC,KAIJC,UAAsC,GAJlC,KAKJC,UAAiC,KAL7B,KAoEJC,cAAgB,CACtBrpD,EACA0I,IAEA2L,KAAKi1C,sBAAsB,CACzBtpD,SAAU8oD,GAAkC9oD,GAC5C0I,SAAUA,EAASrb,QAAO,CAACqb,EAAU5H,KACnC,GACEM,GAAgBN,IAChBd,EAASzB,cACTyB,EAASzB,aAAazO,KAAOgR,EAAQhR,GACrC,CAEA,GACEkQ,EAASzB,cACTyB,EAASzB,aAAazO,KAAOgR,EAAQhR,IACrCgR,EAAQoC,OAAOpb,OAAS,EAExB,OAAO4gB,EAGTA,EAAS7a,KAAK,IACTiT,EAEHoC,OACEpC,EAAQwS,qBACRxS,EAAQoC,OAAOpC,EAAQoC,OAAOpb,OAAS,GACnCgZ,EAAQoC,OAAOpV,MAAM,GAAI,GACzBgT,EAAQoC,cAGhBwF,EAAS7a,KAAKiT,GAEhB,OAAO4H,IACN,MA/FC6gD,oBAAoB,GAGc,IAHd,SAC1BvpD,EAD0B,SAE1B0I,GACuC,EACvC,MAAO,CACL1I,SAAU7R,KAAKU,MAAMmR,GACrB0I,SAAUA,EAASrZ,KAAKm6D,IAAiC,IAAD,EACtD,MAAM1oD,EAAO,UAAGuT,KAAK20C,aAClB/9C,IAAIu+C,EAA4B15D,WADtB,aAAG,EAEZmb,IAAIu+C,EAA4BhzC,cACpC,IAAK1V,EACH,MAAM,IAAIlW,MAAJ,6BACkB4+D,EAA4B15D,GAD9C,YACoD05D,EAA4BhzC,eAGxF,OAAO1V,MAKLwoD,sBAAsB,GAGY,IAHZ,SAC5BtpD,EAD4B,SAE5B0I,GACuC,EACvC,MAAO,CACL1I,SAAU7R,KAAKC,UAAU4R,GACzB0I,SAAUA,EAASrZ,KAAKyR,IACjBuT,KAAK20C,aAAap/C,IAAI9I,EAAQhR,KACjCukB,KAAK20C,aAAav7D,IAAIqT,EAAQhR,GAAI,IAAIqM,KAExC,MAAMstD,EAAWp1C,KAAK20C,aAAa/9C,IAAInK,EAAQhR,IAI/C,OAHK25D,EAAS7/C,IAAI9I,EAAQ0V,eACxBizC,EAASh8D,IAAIqT,EAAQ0V,aAAc8D,GAAgBxZ,IAE9C,CACLhR,GAAIgR,EAAQhR,GACZ0mB,aAAc1V,EAAQ0V,kBAM9BkzC,qBACE,MAAO,CACLT,UAAW50C,KAAK40C,UAChBC,aAAc70C,KAAK60C,aAAa75D,KAAKs6D,GACnCt1C,KAAKk1C,oBAAoBI,KAE3BR,UAAW90C,KAAK80C,UAAU95D,KAAKs6D,GAC7Bt1C,KAAKk1C,oBAAoBI,MAK/B30C,QACEX,KAAK60C,aAAaphE,OAAS,EAC3BusB,KAAK80C,UAAUrhE,OAAS,EACxBusB,KAAK+0C,UAAY,KACjB/0C,KAAK20C,aAAah0C,QAwCpB40C,kBAAkBC,GAChB,MAAM,UAAET,GAAc/0C,KAEtB,IAAK+0C,EACH,OAAO,EAGT,GAAIS,EAAUnhD,SAAS5gB,SAAWshE,EAAU1gD,SAAS5gB,OACnD,OAAO,EAIT,IAAK,IAAIoD,EAAI2+D,EAAUnhD,SAAS5gB,OAAS,EAAGoD,GAAK,EAAGA,IAAK,CACvD,MAAMwoC,EAAOm2B,EAAUnhD,SAASxd,GAC1B4Y,EAAOslD,EAAU1gD,SAASxd,GAChC,IACGwoC,IACA5vB,GACD4vB,EAAK5jC,KAAOgU,EAAKhU,IACjB4jC,EAAKld,eAAiB1S,EAAK0S,aAE3B,OAAO,EAKX,IAAI9uB,EACJ,IAAKA,KAAOmiE,EAAU7pD,SAAU,CACO,IAAD,IAApC,GAAY,yBAARtY,EACF,IACE,UAAAmiE,EAAU7pD,SAAStY,UAAnB,eAAyBugC,cAAzB,UACAmhC,EAAUppD,SAAStY,UADnB,aACA,EAAyBugC,WAEzB,SAGJ,GAAY,uBAARvgC,GAAwC,qBAARA,GAGhCmiE,EAAU7pD,SAAStY,KAAS0hE,EAAUppD,SAAStY,GACjD,OAAO,EAIX,OAAO,EAGToiE,UAAU9pD,EAAoB0I,GAC5B,MAAMqhD,EAAqB11C,KAAKg1C,cAAcrpD,EAAU0I,GAClDshD,EAAyB31C,KAAKk1C,oBAAoBQ,GAExD,GAAIC,EAAU,CACZ,IAAK31C,KAAKu1C,kBAAkBI,GAC1B,OAGF31C,KAAK60C,aAAar7D,KAAKk8D,GACvB11C,KAAK+0C,UAAYY,EAEjB31C,KAAK41C,kBAITA,iBACE51C,KAAK80C,UAAUtwC,OAAO,EAAGxE,KAAK80C,UAAUrhE,QAG1CoiE,WACE,GAA8B,IAA1B71C,KAAK80C,UAAUrhE,OACjB,OAAO,KAGT,MAAMqiE,EAAiB91C,KAAK80C,UAAUiB,MAEtC,YAAuBz4D,IAAnBw4D,GACF91C,KAAK60C,aAAar7D,KAAKs8D,GAChB91C,KAAKk1C,oBAAoBY,IAG3B,KAGTE,WACE,GAAiC,IAA7Bh2C,KAAK60C,aAAaphE,OACpB,OAAO,KAGT,MAAMwiE,EAAej2C,KAAK60C,aAAakB,MAEjCD,EAAiB91C,KAAK60C,aAAa70C,KAAK60C,aAAaphE,OAAS,GAEpE,YAAqB6J,IAAjB24D,GACFj2C,KAAK80C,UAAUt7D,KAAKy8D,GACbj2C,KAAKk1C,oBAAoBY,IAG3B,KAYTI,gBAAgBvqD,EAAoB0I,GAClC2L,KAAK+0C,UAAY/0C,KAAKk1C,oBACpBl1C,KAAKg1C,cAAcrpD,EAAU0I,IAKjC2gB,kBACEhV,KAAK40C,WAAY,EAGnBuB,OAAOC,EAAiB/hD,GAClB2L,KAAK40C,YACP50C,KAAKy1C,UAAUW,EAAO/hD,GACtB2L,KAAK40C,WAAY,KC/PhB,MAAMyB,GAAS,CACpB,CACE7uB,KAEE,sBAAKzB,QAAQ,cAAcD,UAAU,GAArC,SACE,uBAAM3X,EAAE,qSAGZ34B,MAAO,YACPnC,IAAKkM,IAEP,CACEioC,KAEE,sBAAKzB,QAAQ,cAAb,SACE,uBAAM5X,EAAE,gHAGZ34B,MAAO,YACPnC,IAAKkM,IAEP,CACEioC,KAEE,sBAAKzB,QAAQ,sBAAb,SACE,uBAAM5X,EAAE,iEAGZ34B,MAAO,UACPnC,IAAKkM,IAEP,CACEioC,KAEE,sBAAKzB,QAAQ,cAAb,SACE,uBAAM5X,EAAE,4EAGZ34B,MAAO,UACPnC,IAAKkM,IAEP,CACEioC,KAEE,sBAAKzB,QAAQ,cAAcD,UAAU,aAArC,SACE,uBAAM3X,EAAE,yOAGZ34B,MAAO,QACPnC,IAAKkM,IAEP,CACEioC,KAEE,sBAAKzB,QAAQ,UAAb,SACE,uBACE14B,GAAG,IACHC,GAAG,IACHC,GAAG,IACHC,GAAG,IACHuL,OAAO,eACPoxB,cAAc,YAIpB30C,MAAO,OACPnC,IAAK,CAACkM,GAAQA,KAEhB,CACEioC,KAEE,sBAAKzB,QAAQ,cAAb,SACE,uBACEjvB,KAAK,eACLqX,EAAE,2PAIR34B,MAAO,WACPnC,IAAKkM,IAEP,CACEioC,KAEE,sBAAKzB,QAAQ,cAAb,SACE,uBAAM5X,EAAE,+UAGZ34B,MAAO,OACPnC,IAAKkM,IAEP,CACEioC,KAEE,sBAAKzB,QAAQ,cAAb,SACE,uBACEjvB,KAAK,eACLqX,EAAE,kaAIR34B,MAAO,QACPnC,IAAK,O,MC5ET,MAAMijE,GAA8C,CAClDC,IAAK,CAAC7xD,GAAe,gBACrBqiB,KAAM,CAACriB,GAAe,gBACtB8xD,MAAO,CAAC9xD,GAAe,gBACvB+xD,WAAY,CAAC/xD,GAAe,oBAC5BgyD,YAAa,CAAChyD,GAAe,oBAC7BiyD,UAAW,CAACjyD,GAAe,gBAC3BopC,uBAAwB,CAACppC,GAAe,QACxCkyD,mBAAoB,CAClBlyD,GAAe,eACfA,GAAe,OAAD,OAAQ/I,EAAE,sBAE1Bk7D,aAAc,CAACnyD,GAAe,gBAC9BoyD,aAAc,CAACpyD,GAAe,gBAC9BqyD,WAAY,CAENryD,GADJzF,EACmB,kBACA,sBAErB+3D,aAAc,CAERtyD,GADJzF,EACmB,kBACA,sBAErBg4D,UAAW,CAACvyD,GAAe,gBAC3BwyD,UAAW,GACXt5C,MAAO,CAAClZ,GAAe,gBACvByyD,QAAS,CAACzyD,GAAe,sBACzB0yD,SAAU,CAAC1yD,GAAe,gBAC1B2yD,QAAS,CAAC3yD,GAAe,UACzB4yD,MAAO,CAAC5yD,GAAe,UACvB6yD,aAAc,GACdC,eAAgB,CAAC9yD,GAAe,YAChC+yD,aAAc,CAAC/yD,GAAe,YAC9BgzD,SAAU,CAAChzD,GAAe,WAGfizD,GAA+BnkE,IAC1C,MAAMokE,EAAYtB,GAAY9iE,GAE9B,OAAOokE,GAAaA,EAAUnkE,OAAS,EAAImkE,EAAU,GAAK,IC5CtDC,GAAc,IAOK,IAPJ,QACnBj+D,EADmB,eAEnB63C,EAFmB,IAGnBpP,EAHmB,KAInBlmC,EAJmB,cAKnB27D,EALmB,SAMnBnsD,GACsB,EACtB,OACE,eAAC,GAAD,CACE8lC,eAAgBA,EAChBpP,IAAKA,EACLlmC,KAAMA,EACNu1C,eAAe,EAJjB,SAME,qBACE5L,UAAU,eACViyB,cAAgB3hE,GAAUA,EAAMmR,iBAFlC,SAIG3N,EAAQoB,KAAI,CAACs2C,EAAQt+B,KAAS,IAAD,EAC5B,GAAe,cAAXs+B,EACF,OAAO,qBAAcxL,UAAU,iCAAf9yB,GAGlB,MAAMglD,EAAa1mB,EAAO99C,KACpB+B,EAAQ+7C,EAAOvD,iBACjBpyC,EAAE21C,EAAOvD,kBACT,GACJ,OACE,qBAAc,cAAaiqB,EAAYlxB,QAAS2K,EAAhD,SACE,0BACE3L,UAAWmB,aAAK,sBAAuB,CACrCgxB,UAA0B,2BAAfD,EACXE,UAAS,UAAE5mB,EAAOtJ,eAAT,aAAE,OAAAsJ,EAAiB3lC,KAE9Bm7B,QAAS,IAAMgxB,EAAc5E,cAAc5hB,GAL7C,UAOE,sBAAKxL,UAAU,6BAAf,SAA6CvwC,IAC7C,sBAAKuwC,UAAU,gCAAf,SACGkyB,EACGL,GAA4BK,GAC5B,SAZDhlD,WAuBfmlD,GAA6B,IAAIhgD,QAiCxB,QACb3e,KAAK4+D,GACH,MAAMx+D,EAAUmnB,MAAMs3C,KACtBD,EAAOx+D,QAAQ0a,SAASg9B,IAClBA,GACF13C,EAAQJ,KAAK83C,MAGb13C,EAAQnG,QACV6kE,iBACE,eAAC,GAAD,CACEj2B,IAAK+1B,EAAO/1B,IACZlmC,KAAMi8D,EAAOj8D,KACbvC,QAASA,EACT63C,eAAgB,IAvBL8mB,KACnB,MAAMC,EAAkBL,GAA2BvhD,IAAI2hD,GACnDC,IACFC,iCAAuBD,GACvBA,EAAgBvgD,SAChBkgD,GAA2B7/C,OAAOigD,KAkBNG,CAAYN,EAAOG,WACzCT,cAAeM,EAAON,cACtBnsD,SAAUysD,EAAOzsD,WA/CC4sD,KAC1B,IAAIC,EAAkBL,GAA2BvhD,IAAI2hD,GACrD,OAAIC,IAGJA,EAAkB37D,SAASmF,cAAc,OACzCu2D,EACGnxD,cAAc,oCACd/E,YAAYm2D,GACfL,GAA2B/+D,IAAIm/D,EAAWC,GACnCA,IAuCDG,CAAmBP,EAAOG,cC1G3B,MAAMK,GAAuB,IAU7B,IAAD,MAV+B,SACnCjtD,EADmC,SAEnC0I,EAFmC,aAGnCs+C,EAHmC,YAInCvpD,GAMI,EACJ,MAAM0mC,EAAiBtM,GACrBhjB,GAAsBnM,GACtB1I,GAEIktD,EAAY/3B,QAAQn1B,EAAS3C,gBAC7B8vD,EAAWnhB,KACX/xC,EAAyD,QAAjD/I,SAASC,gBAAgBw4C,aAAa,OAE9CyjB,EACJx0B,GAAcn7B,IACd0mC,EAAenhB,MACZliB,GACC83B,GAAc93B,EAAQtL,QAAU6E,GAAcyG,EAAQyM,mBAEtD8/C,EACJz0B,GAAcn7B,IACd0mC,EAAenhB,MAAMliB,GAAY83B,GAAc93B,EAAQtL,QAEzD,IAAI83D,GAAoC,UAAAnpB,EAAe,UAAf,eAAmB3uC,OAAQ,KAEnE,IAAK,MAAMsL,KAAWqjC,EACpB,GAAIrjC,EAAQtL,OAAS83D,EAAoB,CACvCA,EAAqB,KACrB,MAIJ,OACE,uBAAKnzB,UAAU,cAAf,WACKtB,GAAep7B,IACA,UAAhBA,GACuB,UAAvB6vD,GACAnpB,EAAenhB,MAAMliB,GAAY+3B,GAAe/3B,EAAQtL,UACxDwxD,EAAa,qBACdqG,GAA6BrG,EAAa,yBAC1CoG,GAAiBpG,EAAa,oBAE7BluB,GAAer7B,IACf0mC,EAAenhB,MAAMliB,GAAYg4B,GAAeh4B,EAAQtL,UACxDwxD,EAAa,sBAEG,aAAhBvpD,GACA0mC,EAAenhB,MAAMliB,GAA6B,aAAjBA,EAAQtL,SACzCwxD,EAAa,sBAEbjuB,GAAet7B,IACf0mC,EAAenhB,MAAMliB,GAAYi4B,GAAej4B,EAAQtL,UACxD,uCACGwxD,EAAa,qBACbA,EAAa,wBAIhBhuB,GAAmBv7B,IACnB0mC,EAAenhB,MAAMliB,GAAYk4B,GAAmBl4B,EAAQtL,UAC5D,qCAAGwxD,EAAa,sBAGhB/tB,GAAQx7B,IACR0mC,EAAenhB,MAAMliB,GAAYm4B,GAAQn4B,EAAQtL,UACjD,uCACGwxD,EAAa,kBAEbA,EAAa,oBAEbA,EAAa,uBAIhB9tB,GAAkBz7B,IAClB0mC,EAAenhB,MAAMliB,GAAYo4B,GAAkBp4B,EAAQtL,UAC3D,qCAAGwxD,EAAa,qBAGjBA,EAAa,iBAEd,sCACE,kCAASh3D,EAAE,mBACX,uBAAKmqC,UAAU,aAAf,UACG6sB,EAAa,cACbA,EAAa,gBACbA,EAAa,gBACbA,EAAa,sBAIjB7iB,EAAer8C,OAAS,GACvB,sCACE,kCAASkI,EAAE,kBACX,uBAAKmqC,UAAU,aAAf,UAKGlgC,EACC,uCACG+sD,EAAa,cACbA,EAAa,6BACbA,EAAa,gBAGhB,uCACGA,EAAa,aACbA,EAAa,6BACbA,EAAa,iBAGjB7iB,EAAer8C,OAAS,GACvBk/D,EAAa,0BACf,uBAAK7sB,UAAU,UAAf,UACG6sB,EAAa,YACbA,EAAa,2BACbA,EAAa,eACb7iB,EAAer8C,OAAS,GACvBk/D,EAAa,kCAKrBmG,IAAaD,GAAa/oB,EAAer8C,OAAS,GAClD,sCACE,kCAASkI,EAAE,oBACX,uBAAKmqC,UAAU,aAAf,UACG6sB,EAAa,sBACbA,EAAa,0BACbA,EAAa,SACbA,EAAa,qBAQbuG,GAAiB,QAAC,OAC7B/0D,EAD6B,YAE7BiF,EAF6B,YAG7B+vD,EAH6B,cAI7BC,GAJ4B,SAW5B,qCACG/C,GAAOr7D,KAAI,CAAC,EAAsBoC,KAAW,IAAjC,MAAE5H,EAAF,KAASgyC,EAAT,IAAen0C,GAAiB,EAC3C,MAAMkC,EAAQoG,EAAE,WAAD,OAAYnG,IACrB6jE,EAAShmE,IAAuB,kBAARA,EAAmBA,EAAMA,EAAI,IACrDsR,EAAW00D,EAAM,UAChBx4D,GAAiBw4D,GADD,YACY19D,EAAE,iBADd,YACkCyB,EAAQ,GAD1C,UAEhBA,EAAQ,GACf,OACE,eAAC6oC,GAAD,CACEH,UAAU,QAEV3kC,KAAK,QACLqmC,KAAMA,EACNQ,QAAS5+B,IAAgB5T,EACzBhC,KAAK,uBACL8zC,MAAK,UAAKzmC,GAAiBtL,GAAtB,mBAAkCoP,GACvC8iC,gBAAe,UAAKrqC,EAAQ,GAC5B,aAAYyD,GAAiBtL,GAC7B,oBAAmBoP,EACnB,cAAanP,EACbuyC,SAAU,IAAsB,IAArB,YAAE3f,GAAkB,EAC7B+wC,EAAY,CACV/vD,YAAa5T,EACb0U,aAAc,KACdQ,mBAAoB,KAEtBrG,GAAkBF,EAAQ3O,GACZ,UAAVA,GACF4jE,EAAc,CAAEhxC,kBAlBf5yB,SA2BF8jE,GAAc,QAAC,aAC1B3G,EAD0B,KAE1B5tD,GAFyB,SAOzB,eAAC,GAAD,CAAWwrB,IAAK,EAAhB,SACE,gBAAC,GAAD,CAAWA,IAAK,EAAGy6B,MAAM,SAAzB,UACG2H,EAAa,WACbA,EAAa,UACbA,EAAa,mBC9NP4G,GAAoC,QAAC,SAChD5tD,EADgD,YAEhDwtD,EAFgD,cAGhDrB,EAHgD,aAIhD0B,GAJ+C,SAW/C,uBAAKt3D,MAAO,CAAEY,QAAS,QAAvB,UACGg1D,EAAcnF,aAAa,6BAC3B6G,GAAgB1B,EAAcnF,aAAa,mB,MCqBjC8G,OA9BM,IAQd,IARe,gBACpBC,EADoB,kBAEpBC,EAFoB,QAGpB7yB,GAKI,EACJ,OACE,qCACE,eAACb,GAAD,CACEH,UAAWmB,aAAK,eAAgB,CAC9B,mBAAoByyB,IAEtB5yB,QAASA,EACTU,KAAMoD,GACNzpC,KAAK,SACLmmC,MAAO3rC,EAAE,4BACT,aAAYA,EAAE,4BACd+rC,cAAeiQ,KATjB,SAWGgiB,EAAoB,GACnB,sBAAK7zB,UAAU,6BAAf,SAA6C6zB,S,MCTvD,MAAMC,GACJ,WAAY/8D,SAASmF,cAAc,UAAU+Z,WAAW,MAE7C89C,GAAqB,IAE9B,iCACE,8BAAKl+D,EAAE,mCACP,6BACE,gCAAOA,EAAE,gCAEX,oCAAMA,EAAE,+BAAR,UAKAm+D,GAAgB,CACpBzyD,EACA0yD,KAEAtB,iCAAuBsB,GACvBA,EAAYzU,UAAY,GACpBj+C,aAAmBghD,kBACrB0R,EAAY13D,YAAYgF,GAExBixD,iBAAO,eAACuB,GAAD,IAAwBE,IAS7BC,GAKD,IAAqD,IAApD,SAAEryB,EAAF,MAAYL,EAAZ,QAAmBR,EAAnB,MAA4B7gC,EAA5B,MAAmCg0D,EAAQ,GAAQ,EACvD,OACE,yBACEn0B,UAAU,iCACV5jC,MAAO,CACL,iBAA2Bg4D,EAAUj0D,GAAOg0D,GAC5C,wBAAkCC,EAAUj0D,GAAOg0D,EAAQ,GAC3D,yBAAmCC,EAAUj0D,GAAOg0D,EAAQ,IAE9D3yB,MAAOA,EACP,aAAYA,EACZR,QAASA,EATX,SAWGa,KAKDwyB,GAAmB,IAmBlB,IAnBmB,SACxB9lD,EADwB,SAExB1I,EAFwB,MAGxB4R,EAHwB,cAIxB0nC,EAAgBzyD,IAJQ,cAKxBslE,EALwB,cAMxBsC,EANwB,cAOxBC,EAPwB,oBAQxBC,GAWI,EACJ,MAAMC,EAAwBh3B,GAAsBlvB,EAAU1I,IACvD6uD,EAAgBC,GAAqBnuD,mBAASiuD,GAC/CG,EAAaj0B,iBAAuB,OACpC,iBAAEn9B,EAAF,oBAAoB6B,GAAwBQ,EAE5C8/C,EAAmB+O,EACrB32C,GAAoBxP,EAAU1I,GAC9B0I,EAoCJ,OAlCA0yB,qBAAU,KACR0zB,EAAkBF,KACjB,CAACA,IAEJxzB,qBAAU,KACR,MAAMgzB,EAAcW,EAAWlrD,QAC1BuqD,GAGL/U,GAAeyG,EAAkB9/C,EAAU4R,EAAO,CAChDjU,mBACA6B,sBACA85C,kBAEC5pD,MAAM8I,GAGE4+C,GAAa5+C,GAAQ9I,MAAK,KAC/By+D,GAAc31D,EAAQ41D,QAGzBY,OAAO7iE,IACNC,QAAQD,MAAMA,GACdgiE,GAAc,IAAIv0B,GAAew0B,QAEpC,CACDpuD,EACA4R,EACAkuC,EACAniD,EACA27C,EACA95C,IAIA,uBAAK26B,UAAU,eAAf,UACE,sBAAKA,UAAU,wBAAwBO,IAAKq0B,IAC3Cd,IACC9B,EAAcnF,aAAa,sBAC7B,sBAAKzwD,MAAO,CAAEY,QAAS,OAAQ83D,oBAAqB,OAApD,SACE,uBACE14D,MAAO,CACLY,QAAS,OACT83D,oBAAqB,uCAGrB73D,SAAU,UANd,UASG+0D,EAAcnF,aAAa,0BAC3B4H,GACC,eAAC,GAAD,CACEvyB,QAASwyB,EACTzyB,SAAWC,GAAYyyB,EAAkBzyB,GAF3C,SAIGrsC,EAAE,yBAGNm8D,EAAcnF,aAAa,+BAGhC,uBAAKzwD,MAAO,CAAEY,QAAS,OAAQooD,WAAY,SAAUkB,UAAW,QAAhE,UACE,eAAC,GAAD,CAAW77B,IAAK,EAAhB,SACGunC,EAAcnF,aAAa,uBAE9B,oBAAGzwD,MAAO,CAAE+oC,WAAY,MAAO4vB,WAAY,QAA3C,sBAEF,sBACE34D,MAAO,CACLY,QAAS,OACTooD,WAAY,SACZD,eAAgB,SAChB9T,OAAQ,UALZ,UAQI6U,MACA8L,EAAcnF,aAAa,uBAE/B,gBAAC,GAAD,CAAWpiC,IAAK,EAAG06B,eAAe,SAAS/oD,MAAO,CAAEi1C,OAAQ,SAA5D,UACE,eAAC6iB,GAAD,CACE/zD,MAAM,SACNqhC,MAAO3rC,EAAE,uBACT,aAAYA,EAAE,uBACdmrC,QAAS,IAAMszB,EAAc3O,GAJ/B,iBAQA,eAACuO,GAAD,CACE/zD,MAAM,MACNqhC,MAAO3rC,EAAE,uBACT,aAAYA,EAAE,uBACdmrC,QAAS,IAAMuzB,EAAc5O,GAJ/B,iBAQCrD,IACC,eAAC4R,GAAD,CACE1yB,MAAO3rC,EAAE,8BACTmrC,QAAS,IAAMwzB,EAAoB7O,GACnCxlD,MAAM,OACNg0D,MAAO,EAJT,SAMGpxB,YAQAiyB,GAAoB,IAkB1B,IAlB2B,SAChCzmD,EADgC,SAEhC1I,EAFgC,MAGhC4R,EAHgC,cAIhC0nC,EAAgBzyD,IAJgB,cAKhCslE,EALgC,cAMhCsC,EANgC,cAOhCC,EAPgC,oBAQhCC,GAUI,EACJ,MAAOS,EAAcC,GAAmB1uD,oBAAS,GAE3CosD,EAAcxyB,IAAM35B,aAAY,KACpCyuD,GAAgB,KACf,IAEH,OACE,uCACE,eAAC/0B,GAAD,CACEa,QAAS,KACPk0B,GAAgB,IAElB,cAAY,sBACZxzB,KAAMyB,GACN9nC,KAAK,SACL,aAAYxF,EAAE,uBACd+rC,cAAeiQ,KACfrQ,MAAO3rC,EAAE,yBAEVo/D,GACC,eAAC,GAAD,CAAQtpB,eAAgBinB,EAAapxB,MAAO3rC,EAAE,uBAA9C,SACE,eAACw+D,GAAD,CACE9lD,SAAUA,EACV1I,SAAUA,EACV4R,MAAOA,EACP0nC,cAAeA,EACf6S,cAAeA,EACfsC,cAAeA,EACfC,cAAeA,EACfC,oBAAqBA,EACrB7oB,eAAgBinB,U,MC/PrB,MAAMuC,GAAqB,QAAC,SACjCtzB,EADiC,KAEjC3a,EAFiC,UAGjC8Y,GAHgC,SAKhC,sBACEA,UAAWmB,aACT,qBADa,kCAEcja,GAC3B8Y,GAJJ,SAOG6B,K,MCJL,MAmEauzB,GAAa,IAIF,IAJG,SACzBvvD,EADyB,SAEzB0I,EAFyB,SAGzBykD,GACqB,EACjBqC,EAxEW,KAAwD,IAAvD,SAAExvD,EAAF,SAAY0I,EAAZ,SAAsBykD,GAAgC,EACtE,MAAM,YAAE1vD,EAAF,WAAeW,EAAf,WAA2BC,EAA3B,oBAAuCC,GAAwB0B,EAC/DyvD,EAAsC,OAA1BzvD,EAASzB,aAE3B,GAAoB,UAAhBd,GAA2C,SAAhBA,EAC7B,OAGOzN,EAHFy/D,EAGI,2BAFE,uBAKb,GAAoB,aAAhBhyD,EACF,OAAOzN,EAAE,kBAGX,GAAoB,SAAhByN,EACF,OAAOzN,EAAE,cAGX,GAA6B,UAAzBgQ,EAASvC,aAA2BuC,EAASL,oBAC/C,OAAO3P,EAAE,oBAGX,MAAMioB,EAAmBC,GAAoBxP,EAAU1I,GAEvD,GACE5B,GACwB,UAAxBE,GAC4B,IAA5B2Z,EAAiBnwB,OACjB,CACA,MAAM4nE,EAAgBz3C,EAAiB,GACvC,OAAI7W,GAAgBsuD,IAAkD,IAAhCA,EAAcxsD,OAAOpb,OAClDkI,EAAE,mBAEJgR,GAAe0uD,GAClB1/D,EAAE,qBACFA,EAAE,gBAGR,OAAIqO,GAAsC,UAAxBC,EACTtO,EAAE,gBAGqB,IAA5BioB,EAAiBnwB,QAAgBsZ,GAAgB6W,EAAiB,IAChEjY,EAASzC,qBACJyC,EAASzC,qBAAqB2qB,iBACjCl4B,EAAE,kCACFA,EAAE,oCAEDA,EAAE,yBAGqB,IAA5BioB,EAAiBnwB,QAAgBmZ,GAAcgX,EAAiB,IAC3DjoB,EAAE,uBAGPgQ,EAAS3C,gBAAkB4D,GAAcjB,EAAS3C,gBAC7CrN,EAAE,sBAGS,cAAhByN,GAAgCwa,EAAiBnwB,QAAWqlE,EAIzD,KAHEn9D,EAAE,wBAWA2/D,CAAS,CAClB3vD,WACA0I,WACAykD,aAEF,OAAKqC,GAILA,EAAOz2D,GAAey2D,GAGpB,sBAAKr1B,UAAU,aAAf,SACE,gCAAOq1B,OAPF,M,MCrFJ,MAAMI,GAASr1B,IAAMC,YAC1B,CAAC,EAAyCE,KAA1C,IAAC,SAAEsB,EAAF,QAAY3rB,EAAZ,UAAqB8pB,EAArB,MAAgC5jC,GAAjC,SACE,sBACE4jC,UAAWmB,aAAK,SAAUnB,GAC1B5jC,MAAO,CAAE,YAAa8Z,KAAY9Z,GAClCmkC,IAAKA,EAHP,SAKGsB,O,YCPP,MAAM6zB,GACJ,sBAAKz1B,QAAQ,gBAAb,SACE,uBACEjvB,KAAK,eACLqX,EAAE,qNAKKstC,GAAc,IAYpB,IAZqB,SAC1BpnD,EAD0B,MAE1BkJ,EAF0B,gBAG1Bm+C,EAH0B,oBAI1BC,EAJ0B,QAK1B70B,GAOI,EACJ,MAAMT,EAAMI,iBAA8B,MAC1CM,qBAAU,KACR,MAAMppB,EAAO0oB,EAAI72B,QACjB,GAAKmO,EAoBL,MAhBA,WACE,MAAMi+C,EAAmBvnD,GAAYqnD,EACrC,IAAKE,EACH,OAEF,MAAMrsE,QAAY61D,GAChBwW,EACA,CACEtyD,kBAAkB,EAClB6B,oBAAqBrN,EAAGc,OAE1B2e,GAEFI,EAAK2nC,UAAY/1D,EAAIk7D,WAbvB,GAgBO,KACL9sC,EAAK2nC,UAAY,MAElB,CAACjxC,EAAUqnD,EAAiBn+C,IAE/B,MAAOs+C,EAAWC,GAAgBxvD,oBAAS,GACrCwsD,EAAWnhB,KAEXokB,GAASF,GAAa/C,IAAa4C,GACvC,sBAAK51B,UAAU,sBAAf,SAAsC01B,KAGxC,OACE,uBACE11B,UAAWmB,aAAK,eAAgB,CAC9B,uBAAwB5yB,GAAYqnD,IAEtCM,aAAc,IAAMF,GAAa,GACjCG,aAAc,IAAMH,GAAa,GALnC,UAOE,sBACEh2B,UAAWmB,aAAK,wBAAyB,CACvC,wBAAyBy0B,IAE3Br1B,IAAKA,EACL61B,YAAa7nD,EACbyyB,QAAWzyB,GAAcqnD,EAAkB50B,OAAUxpC,EACrD6+D,YAAc/lE,IACZ0lE,GAAa,GACb1lE,EAAMgmE,aAAaC,QACjBltE,IAAWE,cACXyK,KAAKC,UAAUsa,OAIpB0nD,EACA1nD,IAAawnD,GAAa/C,IACzB,yBACEhzB,UAAU,kCACV,aAAYnqC,EAAE,4BACdmrC,QAAS60B,EAHX,SAKG5wB,SCjGEuxB,GAAiB,IAG1B,sBAAKx2B,UAAU,iBAAf,SACE,gCAAOnqC,EAAE,2BCUTq6C,GAAQ,CACZumB,QACE,sBACE95D,MAAM,OACNE,OAAO,OACPojC,QAAQ,gBACRy2B,MAAM,6BAJR,SAME,uBAAMruC,EAAE,kNAGZsuC,UACE,sBACEh6D,MAAM,OACNE,OAAO,OACPojC,QAAQ,gBACRy2B,MAAM,6BACN12B,UAAU,2BALZ,SAOE,uBAAM3X,EAAE,kQAKDuuC,GAAct2B,GAEvB,yBACEN,UAAWmB,aACT,qEADa,wBA7BgB,UAgC7B,CACE,8BAA+Bb,EAAMh7B,iBAGzCk8B,MAAK,UAAKlB,EAAMkB,MAAX,aARP,UAUE,wBACExB,UAAU,yBACV3kC,KAAK,WACL3N,KAAM4yC,EAAM5yC,KACZu0C,SAAU3B,EAAM2B,SAChBC,QAAS5B,EAAM4B,QACf,aAAY5B,EAAMkB,QAEpB,sBAAKxB,UAAU,iBAAf,SACGM,EAAM4B,QAAUgO,GAAMumB,QAAUvmB,GAAMymB,eCpDlCE,GAAU,IAAoD,IAAnD,QAAEC,EAAF,SAAWj1B,KAAavB,GAA0B,EACxE,MAAM,GAAE3qC,GAAO8qC,KACTs2B,EACJ,qBAAI/2B,UAAU,kBAAkBrqC,GAAE,UAAKA,EAAL,YAAWmhE,EAAX,UAAlC,SACGjhE,EAAE,YAAD,OAAaihE,MAGnB,OACE,6BAAax2B,EAAO,4BAAoB3qC,EAApB,YAA0BmhE,EAA1B,UAApB,SACuB,oBAAbj1B,EACNA,EAASk1B,GAET,uCACGA,EACAl1B,Q,MCZJ,MAAMm1B,GAAW,IAAqD,IAApD,SAAEn1B,EAAF,UAAY7B,EAAZ,OAAuBi3B,GAA4B,EAC1E,OACE,sBAAKj3B,UAAWmB,aAAK,WAAYnB,EAAW,CAAEk3B,gBAAiBD,IAA/D,SACGp1B,KCRDs1B,GACJ,sBAAKl3B,QAAQ,cAAb,SACE,uBACEjvB,KAAK,eACLqX,EAAE,4cAKK+uC,GAGR,IAAgC,IAA/B,SAAEvxD,EAAF,YAAYwtD,GAAkB,EAClC,OACE,yBACErzB,UAAWmB,aACT,wEADa,uBAGb,CACE,8BAA+Bt7B,EAASP,iBAG5Ck8B,MAAK,UAAKzmC,GAAiBlF,EAAE,oBAAxB,aACLuG,MAAO,CAAEy2C,kBAAmB,uBAT9B,UAWE,wBACE7S,UAAU,yBACV3kC,KAAK,WACL3N,KAAK,iBACLu0C,SAAW3xC,IACT+iE,EAAY,CAAEtvD,cAAezT,EAAMC,OAAO2xC,WAE5CA,QAASr8B,EAAS9B,cAClB,aAAYhJ,GAAiBlF,EAAE,oBAC/B,oBAAkB,MAEpB,sBAAKmqC,UAAU,iBAAf,SAAiCm3B,SCA1BE,GAAa,IAiBF,IAjBG,SACzBxxD,EADyB,SAEzB0I,EAFyB,YAGzB+oD,EAHyB,cAIzBtF,EAJyB,uBAKzBuF,EALyB,wBAMzBC,EANyB,YAOzBnE,EAPyB,oBAQzBoE,EARyB,aASzBC,EATyB,OAUzBr5D,EAVyB,gBAWzBu1D,EAXyB,mBAYzB+D,EAZyB,gBAazBpyD,EAbyB,aAczBmuD,EAdyB,cAezBJ,EAfyB,iBAgBzBsE,GACqB,EA+FrB,OACE,wCACIryD,GA9FF,gBAAC,GAAD,CAAoB2hB,KAAK,MAAM8Y,UAAU,cAAzC,UACE,eAAC62B,GAAD,CAASC,QAAQ,SAAjB,SACIA,GACA,gBAAC,GAAD,CAAWrsC,IAAK,EAAGy6B,MAAM,SAAzB,UACE,gBAAC,GAAD,CAAWz6B,IAAK,EAAhB,UACE,gBAAC,GAAD,CAAQvU,QAAS,EAAjB,UACG4gD,EACD,eAAC,GAAD,CAAWrsC,IAAK,EAAhB,SACE,eAAC2oC,GAAD,CACE/0D,OAAQA,EACRiF,YAAauC,EAASvC,YACtB+vD,YAAaA,EACbC,cAAe,IAAsB,IAArB,YAAEhxC,GAAkB,EAClCgxC,EAAc,CACZuE,uBAAwC,UAAhBv1C,YAMjCs1C,GAAoBA,GAAiB,EAAM/xD,GAC5C,eAAC+wD,GAAD,CACE10B,QAASr8B,EAASxC,cAClB4+B,SAAUy1B,EACVl2B,MAAO3rC,EAAE,kBAEX,eAACuhE,GAAD,CAAevxD,SAAUA,EAAUwtD,YAAaA,OAEjDiE,OAIP,eAAC,GAAD,CAAYzxD,SAAUA,EAAU0I,SAAUA,EAAUykD,UAAU,OA+DhE,sBACEhzB,UAAU,iBACV5jC,MAAO,CACLmqD,aAAc5N,GACdxT,WAAYwT,GACZmf,YAAanf,IALjB,SAQE,gBAAC,GAAD,CAAQziC,QAAS,EAAjB,UACyB,WAAtBrQ,EAASxB,SACR,eAACwyD,GAAD,CAAS72B,UAAU,kBAAkB82B,QAAQ,gBAA7C,SACE,sBAAK92B,UAAU,cAAf,SACE,gBAAC,GAAD,CAAWvV,IAAK,EAAhB,UA/CRllB,EAEA,uCACGgyD,IACAC,OAKL,uCACGxF,EAAcnF,aAAa,eAC3BmF,EAAcnF,aAAa,aAC3B0K,IACAC,IACAC,GACC,eAAC,GAAD,CACE7D,gBAAiBA,EACjBC,kBAAmBhuD,EAAS9D,cAAcuP,KAC1C0vB,QAASy2B,IAIX,eAAChE,GAAD,CACEzB,cAAeA,EACfnsD,SAAUA,EACVwtD,YAAaA,EACbK,aAAcA,OAqBV,OAEGiE,QAFH,IAEGA,OAFH,EAEGA,GAAqB,EAAM9xD,GAC3BA,EAAS9D,cAAcuP,KAAO,GAC7B,sCACE,kCAASzb,EAAE,0BACX,eAAC,GAAD,CAAUohE,QAAM,EAAhB,SACGh8C,MAAMC,KAAKrV,EAAS9D,eAElBxL,QACC,QAAEgxB,EAAGwwC,GAAL,SAAgD,IAA/BhiE,OAAOD,KAAKiiE,GAAQpqE,UAEtCuH,KAAI,QAAEm/C,EAAU0jB,GAAZ,SACH,eAAC,IAAMC,SAAP,UACGhG,EAAcnF,aAAa,mBAAoB,CAC9Cl3D,GAAI0+C,KAFaA,kBAYb,UAAtBxuC,EAASxB,WACVkB,GACDw1B,GAAyBl1B,EAAU0I,GACnC,eAACsoD,GAAD,CAAS72B,UAAU,kBAAkB82B,QAAQ,uBAA7C,SACE,eAAChE,GAAD,CACEjtD,SAAUA,EACV0I,SAAUA,EACVs+C,aAAcmF,EAAcnF,aAC5BvpD,YAAauC,EAASvC,gBAGxB,KACJ,0BAAQ08B,UAAU,cAAlB,UA1GFz6B,EAEA,sBAAKy6B,UAAU,sBAAf,SACGgyB,EAAcnF,aAAa,sBAKhC,uBAAK7sB,UAAU,sBAAf,UACGgyB,EAAcnF,aAAa,oBAC3BmF,EAAcnF,aAAa,kBAC3BmF,EAAcnF,aAAa,QAC3BmF,EAAcnF,aAAa,QAC3BmF,EAAcnF,aACbhnD,EAASzB,aAAe,WAAa,sBAEtC4tD,EAAcnF,aAAa,6BA4FvBhnD,EAASlB,kBAAoBkB,EAASxB,UACrC,yBACE27B,UAAU,yBACVgB,QAAS,KACPqyB,EAAY,IACPv1B,GAAsBvvB,EAAU1I,MAJzC,SAQGhQ,EAAE,6C,MC5MnB,MAAMoiE,GAAmB33B,IAMvB,MAAMs0B,EAAaj0B,iBAA8B,OAC1Cu3B,EAAeC,GAAoB3xD,mBACxC,MAwCF,OArCAslC,2BAAgB,KACd,IAAKxL,EAAMmgB,YACT,OAGF,MAAMlyC,EAAWqzC,GACfthB,EAAMuhB,UACNvhB,EAAMmgB,YACN,EACA,GAGF,IAAIh3D,EADJ0uE,EAAiB5pD,GAEjB,MAAM0lD,EAAcW,EAAWlrD,QAmB/B,MAjBA,WACEjgB,QAAY61D,GACV/wC,EACA,CACE/K,kBAAkB,EAClB6B,oBAAqBrN,EAAGc,OAE1B,MAGFm7D,EAAY13D,YAAY9S,GAEpB62C,EAAMiB,UACP0yB,EAAYmE,WAA8BzlC,SAb/C,GAiBO,KACLshC,EAAY72D,YAAY3T,MAEzB,CAAC62C,EAAMmgB,YAAangB,EAAMuhB,UAAWvhB,EAAMiB,WAG5C,yBACEvB,UAAU,eACVgB,QAAS,KACHk3B,GACF53B,EAAMU,QAAQV,EAAMuhB,UAAWqW,IAJrC,SAQE,sBAAK33B,IAAKq0B,OAKHyD,GAAmB,IAUzB,IAV0B,YAC/BhF,EAD+B,SAE/BxtD,EAF+B,QAG/B8mC,EAH+B,cAI/B2rB,GAMI,EACJ,MAAM1F,EAAcxyB,IAAM35B,aAAY,KAChCkmC,GACFA,MAED,CAACA,IAEE4rB,EAAmB,CAAC1W,EAAsBtzC,KAC9C+pD,EAAc/pD,GACdnf,YAAW,QAAS,QAASyyD,GAC7BwR,EAAY,CACVpxD,iBAAkB4/C,EAClBt9C,YAAa,CACXC,OAAO,EACPlW,KAAM,SAKZ,OACE,eAAC,GAAD,CACEwjD,OAAK,EACLnG,eAAgBinB,EAChBpxB,MAAO3rC,EAAE,sBACTmqC,UAAW,mBACXw4B,WAAW,EALb,SAOE,uBAAKx4B,UAAW,YAAhB,UACE,eAACi4B,GAAD,CACEpW,UAAU,MACVpB,YAAa56C,EAAStB,YAAYjW,KAClCizC,SAAwC,QAA9B17B,EAAS5D,iBACnB++B,QAASu3B,IAEX,eAACN,GAAD,CACEpW,UAAU,OACVpB,YAAa56C,EAAStB,YAAYjW,KAClCizC,SAAwC,SAA9B17B,EAAS5D,iBACnB++B,QAASu3B,U,MCpHnB,MAAME,GAAS,IACb,uBAAKz4B,UAAU,qBAAf,UACE,oBACEA,UAAU,kBACV04B,KAAK,yDACLnoE,OAAO,SACPooE,IAAI,sBAJN,SAMG9iE,EAAE,8BAEL,oBACEmqC,UAAU,kBACV04B,KAAK,8BACLnoE,OAAO,SACPooE,IAAI,sBAJN,SAMG9iE,EAAE,qBAEL,oBACEmqC,UAAU,kBACV04B,KAAK,kDACLnoE,OAAO,SACPooE,IAAI,sBAJN,SAMG9iE,EAAE,0BAKHghE,GAAWv2B,GACf,uCACE,8BAAKA,EAAMkB,QACVlB,EAAMuB,YAIL+2B,GAAWt4B,GACf,sBACElkC,MAAO,CACLY,QAAS,OACT67D,cAAe,MACfC,SAAU,OACV3T,eAAgB,iBALpB,SAQG7kB,EAAMuB,WAILk3B,GAAUz4B,GACd,sBAAKlkC,MAAO,CAAEO,MAAO,OAArB,SAA+B2jC,EAAMuB,WAGjCm3B,GAAkB14B,GAItB,uBAAKN,UAAU,qBAAf,UACE,qBAAIA,UAAU,2BAAd,SAA0CM,EAAM24B,UAC/C34B,EAAMuB,YAILq3B,GAAY54B,GAMd,sBAAKN,UAAU,uBAAf,SACE,uBACE5jC,MAAO,CACLY,QAAS,OACTq0C,OAAQ,IACRn7B,QAAS,UACTkvC,WAAY,UALhB,UAQE,sBACEhpD,MAAO,CACL2V,WAAY,KAFhB,SAKGuuB,EAAM7wC,QAET,sBACE2M,MAAO,CACLY,QAAS,OACTm8D,KAAM,WACNhU,eAAgB,WAChBtS,kBAAmB,OACnB/B,SAAU,OANd,SASGxQ,EAAMwxB,UAAU58D,KAAI,CAAC2J,EAAUvH,IAC9B,gBAAC,IAAM0gE,SAAP,WACE,eAACoB,GAAD,UAAcv6D,IACbyhC,EAAM+4B,MACL/hE,IAAUgpC,EAAMwxB,UAAUnkE,OAAS,GACnCkI,EAAE,mBAJeyB,YAajC4hE,GAAS/2B,aAAe,CACtBk3B,MAAM,GAGR,MAAMD,GAAe94B,GACnB,sBAAKN,UAAU,qBAAsBM,IAG1Bg5B,GAAa,IAA4C,IAA3C,QAAE3sB,GAAwC,EACnE,MAAMimB,EAAcxyB,IAAM35B,aAAY,KAChCkmC,GACFA,MAED,CAACA,IAEJ,OACE,qCACE,gBAAC,GAAD,CACEhB,eAAgBinB,EAChBpxB,MAAO3rC,EAAE,oBACTmqC,UAAW,aAHb,UAKE,eAACy4B,GAAD,IACA,eAAC,GAAD,CAASj3B,MAAO3rC,EAAE,wBAAlB,SACE,gBAAC+iE,GAAD,WACE,gBAACG,GAAD,WACE,gBAACC,GAAD,CAAgBC,QAASpjE,EAAE,qBAA3B,UACE,eAACqjE,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CAAC,IAAK,OAEnB,eAACoH,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CAAC,IAAK,OAEnB,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,mBAAoBi8D,UAAW,CAAC,IAAK,OACxD,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,mBAAoBi8D,UAAW,CAAC,IAAK,OACxD,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,iBAAkBi8D,UAAW,CAAC,IAAK,OACtD,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,gBAAiBi8D,UAAW,CAAC,IAAK,OACrD,eAACoH,GAAD,CACEzpE,MAAOoG,EAAE,oBACTi8D,UAAW,CAAC,UAAW,OAEzB,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,gBAAiBi8D,UAAW,CAAC,IAAK,OACrD,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,iBAAkBi8D,UAAW,CAAC,OACjD,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,mBAAoBi8D,UAAW,CAAC,OACnD,eAACoH,GAAD,CACEzpE,MAAOoG,EAAE,gCACTi8D,UAAW,CACTlzD,GAAe,SACf/I,EAAE,6BAGN,eAACqjE,GAAD,CACEzpE,MAAOoG,EAAE,0BACTi8D,UAAW,CACTlzD,GAAe,SACfA,GAAe,kBAGnB,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,yBACTi8D,UAAW,CACTlzD,GAAe,OACfA,GAAe,sBAGnB,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,0BACTi8D,UAAW,CACT,IACAj8D,EAAE,oBACFA,EAAE,oBACFA,EAAE,qBAEJwjE,MAAM,IAER,eAACH,GAAD,CACEzpE,MAAOoG,EAAE,yBACTi8D,UAAW,CACT,IACAj8D,EAAE,oBACFA,EAAE,oBACFA,EAAE,qBAEJwjE,MAAM,IAER,eAACH,GAAD,CAAUzpE,MAAOoG,EAAE,gBAAiBi8D,UAAW,CAAC,OAChD,eAACoH,GAAD,CACEzpE,MAAOoG,EAAE,6BACTi8D,UAAW,CAAClzD,GAAe,mBAG/B,gBAACo6D,GAAD,CAAgBC,QAASpjE,EAAE,mBAA3B,UACE,eAACqjE,GAAD,CACEzpE,MAAOoG,EAAE,kBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,mBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,wBACTi8D,UAAW,CAAC,aAEd,eAACoH,GAAD,CACEzpE,MAAOoG,EAAE,8BACTi8D,UAAW,CAAC,aAEd,eAACoH,GAAD,CAAUzpE,MAAOoG,EAAE,sBAAuBi8D,UAAW,CAAC,OACtD,eAACoH,GAAD,CACEzpE,MAAOoG,EAAE,mBACTi8D,UAAW,CAAClzD,GAAe,YAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,mBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,mBACTi8D,UAAW,CAAClzD,GAAe,YAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,sBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,eACTi8D,UAAW,CAAClzD,GAAe,kBAIjC,eAACm6D,GAAD,UACE,gBAACC,GAAD,CAAgBC,QAASpjE,EAAE,qBAA3B,UACE,eAACqjE,GAAD,CACEzpE,MAAOoG,EAAE,oBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,sBACTi8D,UAAW,CAAClzD,GAAe,SAAD,OAAU/I,EAAE,yBAExC,eAACqjE,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CACTlzD,GAAe,SAAD,OAAU/I,EAAE,qBAC1B+I,GAAe,SAAD,OAAU/I,EAAE,sBAE5BwjE,MAAM,IAER,eAACH,GAAD,CACEzpE,MAAOoG,EAAE,cACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,eACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,gBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,oBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CAAClzD,GAAe,sBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,sBACTi8D,UAAW,CAAClzD,GAAe,sBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,iBACTi8D,UAAW,CAAClzD,GAAe,UAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CAELlzD,GADJzF,EACmB,kBACA,wBAGvB,eAAC+/D,GAAD,CACEzpE,MAAOoG,EAAE,uBACTi8D,UAAW,CAELlzD,GADJzF,EACmB,kBACA,wBAGvB,eAAC+/D,GAAD,CACEzpE,MAAOoG,EAAE,uBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,uBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,mBACTi8D,UAAW,CAAClzD,GAAe,yBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,sBACTi8D,UAAW,CAAClzD,GAAe,2BAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,oBACTi8D,UAAW,CAAClzD,GAAe,2BAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CAAClzD,GAAe,4BAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,6BACTi8D,UAAW,CACTlzD,GAAe,eACfA,GAAe,OAAD,OAAQ/I,EAAE,wBAG5B,eAACqjE,GAAD,CACEzpE,MAAOoG,EAAE,gBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,gBACTi8D,UACEv4D,EACI,CACEqF,GAAe,eACfA,GAAe,sBAEjB,CAACA,GAAe,wBAGxB,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,gBACTi8D,UAAW,CAAClzD,GAAe,kBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,kBACTi8D,UAAW,CAAClzD,GAAe,wBAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,yBACTi8D,UAAW,CAAClzD,GAAe,cAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,uBACTi8D,UAAW,CAAClzD,GAAe,cAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,qBACTi8D,UAAW,CAAClzD,GAAe,QAE7B,eAACs6D,GAAD,CACEzpE,MAAOoG,EAAE,yBACTi8D,UAAW,CAAClzD,GAAe,wB,MC1XtC,MAAM26D,GAER,IAA0B,IAAzB,SAAE13B,EAAF,MAAY1hC,GAAY,EAC5B,OACE,sBACE6/B,UAAU,OACV5jC,MAAO,CACL,eAAyBg4D,EAAUj0D,GAAO,GAC1C,sBAAgCi0D,EAAUj0D,GAAO,GACjD,uBAAiCi0D,EAAUj0D,GAAO,IALtD,SAQG0hC,KCID23B,GAAkB,IAejB,IAfkB,SACvBjrD,EADuB,SAEvB1I,EAFuB,MAGvB4R,EAHuB,cAIvBu6C,EAJuB,WAKvByH,EALuB,OAMvBp7D,GASI,EACJ,MAAM,kBAAEq7D,GAAsBD,EAC9B,OACE,sBAAKz5B,UAAU,kCAAf,SACE,uBAAKA,UAAU,qBAAf,UACGy5B,EAAWztE,gBACV,gBAAC,GAAD,CAAMmU,MAAM,OAAZ,UACE,sBAAK6/B,UAAU,YAAf,SAA4BoD,KAC5B,8BAAKvtC,EAAE,6BACP,uBAAKmqC,UAAU,eAAf,UACGnqC,EAAE,8BACDqwD,MACA8L,EAAcnF,aAAa,wBAE/B,eAAC1sB,GAAD,CACEH,UAAU,cACV3kC,KAAK,SACLmmC,MAAO3rC,EAAE,4BACT,aAAYA,EAAE,4BACd+rC,eAAe,EACfZ,QAAS,KACPgxB,EAAc5E,cAAc5H,UAKnCkU,GACC,gBAAC,GAAD,CAAMv5D,MAAM,OAAZ,UACE,sBAAK6/B,UAAU,YAAf,SAA4B4C,KAC5B,8BAAK/sC,EAAE,6BACP,sBAAKmqC,UAAU,eAAf,SAA+BnqC,EAAE,+BACjC,eAACsqC,GAAD,CACEH,UAAU,cACV3kC,KAAK,SACLmmC,MAAO3rC,EAAE,4BACT,aAAYA,EAAE,4BACd+rC,eAAe,EACfZ,QAAS,IACP04B,EAAkBnrD,EAAU1I,EAAU4R,EAAOpZ,QAKpDo7D,EAAWE,gBACVF,EAAWE,eAAeprD,EAAU1I,EAAU4R,EAAOpZ,SAMlDu7D,GAAmB,IAczB,IAd0B,SAC/BrrD,EAD+B,SAE/B1I,EAF+B,MAG/B4R,EAH+B,cAI/Bu6C,EAJ+B,WAK/ByH,EAL+B,OAM/Bp7D,GAQI,EACJ,MAAO42D,EAAcC,GAAmB1uD,oBAAS,GAE3CosD,EAAcxyB,IAAM35B,aAAY,KACpCyuD,GAAgB,KACf,IAEH,OACE,uCACE,eAAC/0B,GAAD,CACEa,QAAS,KACPk0B,GAAgB,IAElB,cAAY,qBACZxzB,KAAMwB,GACN7nC,KAAK,SACL,aAAYxF,EAAE,kBACd+rC,cAAeiQ,KACfrQ,MAAO3rC,EAAE,oBAEVo/D,GACC,eAAC,GAAD,CAAQtpB,eAAgBinB,EAAapxB,MAAO3rC,EAAE,kBAA9C,SACE,eAAC2jE,GAAD,CACEjrD,SAAUA,EACV1I,SAAUA,EACV4R,MAAOA,EACPu6C,cAAeA,EACfrmB,eAAgBinB,EAChB6G,WAAYA,EACZp7D,OAAQA,UCjBdw7D,GAAmB,IA4BlB,IA5BmB,aACxBlM,EADwB,oBAExBkI,EAFwB,eAGxBiE,EAHwB,cAIxBC,EAJwB,gBAKxBnE,EALwB,MAMxBzpE,EANwB,YAOxBknE,EAPwB,gBAQxB2G,EARwB,iBASxBC,EATwB,eAUxBnnB,EAVwB,QAWxB2V,EAXwB,MAYxBhxC,EAZwB,GAaxB9hB,GAeI,EACJ,MAAMq9D,EAAWnhB,KACXqoB,EAAWvM,EAAahgE,QAAUioE,EAAgBjoE,OAAS,EAAI,EAAI,GACnEwsE,EAAgBnH,EAAW,EAAI,EAC/BoH,EAAUlzE,KAAK+iB,IAAI,EAAG/iB,KAAKmvB,KAAK6jD,EAAWC,IAC3CtZ,EAAO,GACb,IAAIwZ,GAAuB,EAE3B,MAAMC,EACJL,GAAoB/vE,OAAOC,SAASC,OAASF,OAAOC,SAASowE,SAE/D1Z,EAAKntD,KACH,uBAAKssC,UAAU,2BAAf,UACE,eAACG,GAAD,CAEE9kC,KAAK,SACLmmC,MAAO3rC,EAAE,gBACT,aAAYA,EAAE,gBACd6rC,KAAMoB,GACN9B,QAAS,KrDjBoB1zC,WACnC,MAAM4C,QAAaypD,GAAS,CAC1BI,YAAa,mCAOT0O,EAAQ+R,cAActqE,IqDSpBuqE,CAAsBhS,GACnBlzD,MAAK,KAEJ89D,EAAY,CAAEtvD,eAAe,IAC7BsvD,EAAY,CAAEtvD,eAAe,OAE9B8wD,MAAM50D,IACN40D,OAAO7iE,IACNqhE,EAAY,CAAE9vD,aAAcvR,EAAM0tC,eAdpC,YAkBHiuB,EAAahgE,QACd,uCACE,eAACwyC,GAAD,CAEE9kC,KAAK,SACLmmC,MAAO3rC,EAAE,kBACT,aAAYA,EAAE,kBACd6rC,KAAMwB,GACNlC,QAAS,KrD3DY1zC,WAC/B,MAAMqgE,QAAqBlF,EAAQC,cAC7Bp6D,EAA4B,CAChC+M,KAAMvR,IAAkBE,kBACxBkI,QAAS,EACTmsD,OAAQp0D,IACRw+D,QAASkF,GAELpP,EAAavqD,KAAKC,UAAU3F,EAAM,KAAM,SACxCusD,GACJ,IAAIjsD,KAAK,CAAC2vD,GAAa,CACrBljD,KAAMhS,IAAWE,gBAEnB,CACEmE,KAAM,UACNqtD,UAAW,gBACXhB,YAAa,6BqD4CL2gB,CAAkBjS,GACfoM,MAAM50D,IACN40D,OAAO7iE,IACNqhE,EAAY,CAAE9vD,aAAcvR,EAAM0tC,eATpC,UAaN,eAACS,GAAD,CAEE9kC,KAAK,SACLmmC,MAAO3rC,EAAE,wBACT,aAAYA,EAAE,wBACd6rC,KAAMsB,GACNhC,QAAS,KACH92C,OAAOywE,QAAQ9kE,EAAE,0BACnB4yD,EAAQ8E,eACRyM,EAAgB,IAChBlnB,OATA,YAeV,oBACE4lB,KAAI,kDACFxuE,OAAOwD,MAAQ,SADb,qBAES4sE,EAFT,+BAEwC3kE,EAFxC,kBAEoDxJ,GACxDoE,OAAO,wBAJT,SAMGsF,EAAE,wBA1DuC,mBA+DhD,IAAK,IAAIirD,EAAM,EAAGA,EAAMsZ,EAAStZ,IAAO,CACtC,MAAM5iD,EAAIi8D,EAAgBrZ,EACpBjf,EAAW,GACjB,IAAK,IAAIplC,EAAI,EAAGA,EAAI09D,EAAe19D,IAAK,CACtC,MAAMm+D,EACJhF,EAAgBjoE,OAAS,IACxB0sE,GACDn8D,EAAIzB,GAAKkxD,EAAahgE,OACxB0sE,EAAuBA,GAAwBO,EAE/C/4B,EAASnuC,KACP,eAAC,GAAD,UACE,eAAC,GAAD,CACE6a,SAAUo/C,EAAazvD,EAAIzB,GAC3Bgb,MAAOA,EACPm+C,gBACEgF,EAA2BhF,OAAkBp+D,EAE/Cq+D,oBAAqBA,EAAoBgF,KAAK,KAAM38D,EAAIzB,GACxDukC,QACE45B,EACId,EAAee,KAAK,KAAMjF,GAC1BmE,EAAcc,KAAK,KAAMlN,EAAazvD,EAAIzB,OAXpCA,IAiBpBokD,EAAKntD,KACH,eAAC,GAAD,CAAWwxD,MAAM,SAASz6B,IAAK,EAA/B,SACGoX,GADoCif,IAM3C,OACE,eAAC,GAAD,CAAWoE,MAAM,QAAQz6B,IAAK,EAAGuV,UAAU,0BAA3C,SACG6gB,KAKDia,GAAc,IAwBb,IAxBc,eACnBC,EADmB,cAEnBhB,EAFmB,gBAGnBnE,EAHmB,eAInBkE,EAJmB,MAKnB3tE,EALmB,YAMnBknE,EANmB,MAOnB57C,EAPmB,iBAQnBwiD,EARmB,eASnBnnB,EATmB,QAUnB2V,EAVmB,GAWnB9yD,GAaI,EACJ,MAAM4qC,EAAMI,iBAA8B,MAtMlB,EACxBJ,EACAnlB,KAEA6lB,qBAAU,KACR,MAAM+5B,EAAY1qE,IACXiwC,EAAI72B,UAKPpZ,EAAMC,kBAAkB0qE,UACvB16B,EAAI72B,QAAQyiC,SAAS77C,EAAMC,UACzBwG,SAASoF,KAAKgwC,SAAS77C,EAAMC,UAKlC6qB,EAAG9qB,KAIL,OAFAyG,SAASq1C,iBAAiB,cAAe4uB,GAAU,GAE5C,KACLjkE,SAASs1C,oBAAoB,cAAe2uB,MAE7C,CAACz6B,EAAKnlB,KA8KT8/C,CAAkB36B,GAAMjwC,IAEjBA,EAAMC,OAAmB4qE,QAAQ,mCAGtCJ,EAAezqE,MAGjB,MAAOq9D,EAAcqM,GAAmBxzD,mBAAuB,KAExD40D,EAAct6B,GAAgBt6B,mBAEnC,cAEI60D,EAAkB16B,iBAAsB,MAE9CM,qBAAU,KACRlxC,QAAQurE,KAAK,CACX,IAAIvrE,SAASC,IACXqrE,EAAgB3xD,QAAUxf,OAAO2T,YAAW,KAC1C7N,EAAQ,aACP,QAELy4D,EAAQC,cAAcnzD,MAAMozD,IAC1BqR,EAAgBrR,GAChB7nB,EAAa,cAEdvrC,MAAMjH,IACM,YAATA,GACFwyC,EAAa,cAGV,KACLljC,aAAay9D,EAAgB3xD,YAE9B,CAAC++C,IAEJ,MAAM8S,EAAoB90D,uBACxBnZ,UACE,MAAMq7D,QAAcF,EAAQC,cACtB8S,EAAY7S,EAAMpyD,QAAO,CAACgxB,EAAGjwB,IAAUA,IAAUmkE,IACvDhT,EAAQG,YAAY4S,GAAW3G,OAAO7iE,IACpCgoE,EAAgBrR,GAChB0K,EAAY,CAAE9vD,aAAc1N,EAAE,wCAEhCmkE,EAAgBwB,KAElB,CAAC/S,EAAS4K,IAGN5B,EAAehrD,uBACnBnZ,UACE,GAAIihB,EAASsa,MAAMliB,GAA6B,UAAjBA,EAAQtL,OACrC,OAAOg4D,EAAY,CACjB9vD,aAAc,0DAIlB,MAAMolD,QAAcF,EAAQC,cACtB8S,EAAY,IAAI7S,EAAOp6C,GAC7BurD,IACArR,EAAQG,YAAY4S,GAAW3G,OAAO7iE,IACpCgoE,EAAgBrR,GAChB0K,EAAY,CAAE9vD,aAAc1N,EAAE,oCAEhCmkE,EAAgBwB,KAElB,CAAC1B,EAAgBrR,EAAS4K,IAG5B,MAAwB,eAAjB+H,EAAgC,KACrC,eAAC,GAAD,CAAQllD,QAAS,EAAGqqB,IAAKA,EAAKP,UAAU,oBAAxC,SACoB,YAAjBo7B,EACC,sBAAKp7B,UAAU,4BAAf,SACGnqC,EAAE,kCAGL,eAACgkE,GAAD,CACElM,aAAcA,EACdkI,oBAAqB0F,EACrBzB,eAAgBrI,EAChBsI,cAAeA,EACfnE,gBAAiBA,EACjBvC,YAAaA,EACb2G,gBAAiBA,EACjBC,iBAAkBA,EAClBnnB,eAAgBA,EAChB2V,QAASA,EACTt8D,MAAOA,EACPsrB,MAAOA,EACP9hB,GAAIA,OAOR+lE,GAAU,IAwBK,IAxBJ,cACf1J,EADe,SAEfnsD,EAFe,MAGf4R,EAHe,YAIf47C,EAJe,OAKfh1D,EALe,SAMfkQ,EANe,oBAOfkpD,EAPe,aAQfC,EARe,iBASfiE,EATe,eAUfr2D,EAVe,mBAWfs2D,EAXe,aAYflI,EAZe,cAafmI,EAbe,gBAcfjI,EAde,iBAefgE,EAfe,mBAgBfD,EAhBe,gBAiBfpyD,EAjBe,iBAkBf00D,EAlBe,UAmBfnN,EAnBe,eAoBfha,EApBe,QAqBf2V,EArBe,GAsBf9yD,EAtBe,cAuBf29D,GACkB,EAClB,MAAMN,EAAWnhB,KAEX0lB,EAAyB,IACxBzK,EAAUlhE,cAAcG,OAK3B,eAAC6tE,GAAD,CACErrD,SAAUA,EACV1I,SAAUA,EACV4R,MAAOA,EACPu6C,cAAeA,EACfyH,WAAY3M,EAAUlhE,cAAcG,OACpCsS,OAAQA,IAVH,KAeLm5D,EAA0B,KAC9B,IAAK1K,EAAUlhE,cAAcQ,YAC3B,OAAO,KAGT,MAAM0vE,EACHzgE,GACD/N,UACE,MAAMsW,QAAmB6gD,GACvBppD,EACAsqD,EACA9/C,EACA4R,EACA,CACEjU,iBAAkBqC,EAASrC,iBAC3B9V,KAAMmY,EAASnY,KACf2X,oBAAqBQ,EAASR,sBAG/BwvD,MAAM50D,IACN40D,OAAO7iE,IACNC,QAAQD,MAAMA,GACdqhE,EAAY,CAAE9vD,aAAcvR,EAAM0tC,aAIpC75B,EAASnC,kBACTE,GACAi5C,GAAkBj5C,IAElByvD,EAAY,CAAEzvD,gBAIpB,OACE,eAACoxD,GAAD,CACEzmD,SAAUA,EACV1I,SAAUA,EACV4R,MAAOA,EACPu6C,cAAeA,EACfsC,cAAewH,EAAe,OAC9BvH,cAAeuH,EAAe,OAC9BtH,oBAAqBsH,EAAe,gBAKpCC,EAAY,IACT,sBAAK3/D,MAAO,CAAEO,MAAO,YA4FxBq/D,EAAev1D,uBAClBnW,IACC+iE,EAAY,CAAEtvD,eAAe,MAE/B,CAACsvD,IAGG4I,EAAgBx1D,uBAAY,KAChC4sD,EAAY,CACVzuD,mBAAoB,GACpBC,iBAAkB,OAEnB,CAACwuD,IAEEiE,EAAczxD,EAAS9B,cAC3B,eAAC+2D,GAAD,CACElF,gBAAiB73C,GAAoBxP,EAAU1I,GAC/Ck1D,eAAgBiB,EAChBjC,cAAe4B,EACf7B,eAAgBmC,EAChB5I,YAAaA,EACb4G,iBAAkBA,EAClBnnB,eAAgBA,EAChB2V,QAASA,EACTt8D,MAAO0Z,EAAS1Z,MAChBsrB,MAAOA,EACP9hB,GAAIA,IAEJ,KAoKEumE,EACJ,uCACGr2D,EAAS7B,WAAa,eAACwyD,GAAD,IACtB3wD,EAAStC,cACR,eAAC44D,GAAD,CACEz8B,QAAS75B,EAAStC,aAClBopC,QAAS,IAAM0mB,EAAY,CAAE9vD,aAAc,SAG9CsC,EAASb,gBACR,eAAC,GAAD,CACE2nC,QAAS,KACP0mB,EAAY,CAAEruD,gBAAgB,OAInCa,EAAStB,YAAYC,OACpB,eAAC,GAAD,CACE6uD,YAAaA,EACbxtD,SAAUA,EACVyyD,cAAeqD,EACfhvB,QAAS,IACP0mB,EAAY,CACV9uD,YAAa,CAAEC,OAAO,EAAOlW,KAAM,aAQ/C,OAAO0kE,EACL,uCACGkJ,EACD,eAAC7E,GAAD,CACExxD,SAAUA,EACV0I,SAAUA,EACVyjD,cAAeA,EACfsF,YAAaA,EACbC,uBAAwBA,EACxBC,wBAAyBA,EACzBnE,YAAaA,EACboE,oBAAqBA,EACrBC,aAAcA,EACdr5D,OAAQA,EACRu1D,gBAAiBA,EACjB+D,mBAAoBA,EACpBpyD,gBAAiBA,EACjBmuD,aAAcA,EACdJ,cAAeA,EACfsE,iBAAkBA,OAItB,uBACE53B,UAAWmB,aAAK,oBAAqB,CACnC,wBACEt7B,EAAS5C,iBACT4C,EAASnB,iBACRmB,EAAS3C,iBAAmB4D,GAAcjB,EAAS3C,kBAL1D,UAQGg5D,EAhO4B,MAC/B,MAAME,EAAmCrhC,GACvCl1B,EACA0I,GAGF,OACE,eAAC,GAAD,CAAoB2Y,KAAK,MAAzB,SACE,uBAAK8Y,UAAU,wBAAf,UACE,gBAAC,GAAD,CACEvV,IAAK,EACLuV,UAAWmB,aAAK,CAAE,wBAAyB77B,IAF7C,UAIGC,EAlIP,eAACsxD,GAAD,CACEC,QAAQ,gBACR92B,UAAWmB,aAAK,sBAAuB,CACrC,kBAAmB77B,IAHvB,SAQE,eAAC,GAAD,CAAQ4Q,QAAS,EAAG9Z,MAAO,CAAEigE,OAAQ,GAArC,SACE,eAAC,GAAD,CAAW5xC,IAAK,EAAhB,SACE,gBAAC,GAAD,CAAWA,IAAK,EAAG06B,eAAe,gBAAlC,UACGoS,IACAC,aASX,eAACX,GAAD,CACEC,QAAQ,gBACR92B,UAAWmB,aAAK,sBAAuB,CACrC,kBAAmB77B,IAHvB,SAQE,eAAC,GAAD,CAAQ4Q,QAAS,EAAG9Z,MAAO,CAAEigE,OAAQ,GAArC,SACE,gBAAC,GAAD,CAAW5xC,IAAK,EAAhB,UACE,gBAAC,GAAD,CAAWA,IAAK,EAAG06B,eAAe,gBAAlC,UACG6M,EAAcnF,aAAa,eAC5B,eAACkP,EAAD,IACC/J,EAAcnF,aAAa,aAC3B0K,IACAC,IACD,eAACuE,EAAD,IACCtE,GACC,eAAC,GAAD,CACE7D,gBAAiBA,EACjBC,kBAAmBhuD,EAAS9D,cAAcuP,KAC1C0vB,QAASy2B,OAIf,eAAChE,GAAD,CACEzB,cAAeA,EACfnsD,SAAUA,EACVwtD,YAAaA,EACbK,aAAcA,IAEf7tD,EAASjC,YACR,qCAAGouD,EAAcnF,aAAa,6BAgF7BuP,GAxET,eAACvF,GAAD,CACEC,QAAQ,uBACR92B,UAAWmB,aAAK,sBAAuB,CACrC,kBAAmB77B,IAHvB,SAME,eAAC,GAAD,CACE06B,UAAW33C,IAAQC,mBACnB4tB,QAAS,EACT9Z,MAAO,CAILkgE,UAAU,GAAD,OAAKz2D,EAAShJ,QAAUgJ,EAASjC,WAAa,IAAM,KAApD,OAPb,SAUE,eAACkvD,GAAD,CACEjtD,SAAUA,EACV0I,SAAUA,EACVs+C,aAAcmF,EAAcnF,aAC5BvpD,YAAauC,EAASvC,sBAsDpBiC,GACA,eAACsxD,GAAD,CAASC,QAAQ,SAAjB,SACIA,GACA,gBAAC,GAAD,CAAWrsC,IAAK,EAAGy6B,MAAM,QAAzB,UACE,gBAAC,GAAD,CAAWz6B,IAAK,EAAhB,UACE,eAACmsC,GAAD,CACEtxD,eAAgBA,EAChB48B,QAASr8B,EAASxC,cAClB4+B,SAAUy1B,EACVl2B,MAAO3rC,EAAE,kBAEX,gBAAC,GAAD,CACEqgB,QAAS,EACT8pB,UAAWmB,aAAK,CAAE,WAAY77B,IAFhC,UAIE,eAAC,GAAD,CACEO,SAAUA,EACV0I,SAAUA,EACVykD,SAAUA,IAEX8D,EACD,eAAC,GAAD,CAAWrsC,IAAK,EAAhB,SACE,eAAC2oC,GAAD,CACE/0D,OAAQA,EACRiF,YAAauC,EAASvC,YACtB+vD,YAAaA,EACbC,cAAe,IAAsB,IAArB,YAAEhxC,GAAkB,EAClCgxC,EAAc,CACZuE,uBAAwC,UAAhBv1C,YAMlC,eAAC80C,GAAD,CACEvxD,SAAUA,EACVwtD,YAAaA,OAGhBiE,OAKT,uBACEt3B,UAAWmB,aACT,mDACA,CACE,mBAAoB77B,IAJ1B,UAQE,eAAC,GAAD,UACGO,EAAS9D,cAAcuP,KAAO,GAC7B2J,MAAMC,KAAKrV,EAAS9D,eAEjBxL,QAAO,QAAEgxB,EAAGwwC,GAAL,SAAgD,IAA/BhiE,OAAOD,KAAKiiE,GAAQpqE,UAC5CuH,KAAI,QAAEm/C,EAAU0jB,GAAZ,SACH,eAAC,GAAD,CACEtoE,MAAOsoE,EAAOhgB,UAAY,eAD5B,SAIGia,EAAcnF,aAAa,mBAAoB,CAC9Cl3D,GAAI0+C,KAHDA,QAhBjB,OAwBGujB,QAxBH,IAwBGA,OAxBH,EAwBGA,EAAmB5E,EAAUntD,YA2InC02D,GAlID,0BACE75B,KAAK,cACL1C,UAAU,qDAFZ,UAIE,sBACEA,UAAWmB,aACT,qDACA,CACE,kDAAmD77B,IAJzD,SAQE,eAAC,GAAD,CAAWmlB,IAAK,EAAhB,SACE,gBAACosC,GAAD,CAASC,QAAQ,gBAAjB,UACE,eAAC,GAAD,CAAQ5gD,QAAS,EAAjB,SACE,eAACs9C,GAAD,CACE3G,aAAcmF,EAAcnF,aAC5B5tD,KAAM4G,EAAS5G,UAGjBsG,GACA,uBACEy6B,UAAWmB,aAAK,wCAAyC,CACvD,oDACE77B,IAHN,UAMG0sD,EAAcnF,aAAa,OAAQ,CAAEv7C,KAAM,UAC3C0gD,EAAcnF,aAAa,OAAQ,CAAEv7C,KAAM,oBAMtD,sBACE0uB,UAAWmB,aACT,uDACA,CACE,oDACE77B,IALR,gBASGqyD,QATH,IASGA,OATH,EASGA,GAAqB,EAAO9xD,KAE/B,sBACEm6B,UAAWmB,aACT,sDACA,CACE,yCAA0C77B,IAJhD,SAQG0sD,EAAcnF,aAAa,qBAE9B,yBACE7sB,UAAWmB,aAAK,mBAAoB,CAClC,4BAA6By6B,IAE/B56B,QAAS66B,EAJX,SAMGhmE,EAAE,4BAuENgQ,EAASlB,iBACR,yBACEq7B,UAAU,yBACVgB,QAAS,KACPqyB,EAAY,IACPv1B,GAAsBvvB,EAAU1I,MAJzC,SAQGhQ,EAAE,qCAOP2mE,GAAW,CAACjjC,EAAoB5vB,KACpC,MAAM8yD,EAAmB52D,IACvB,MAAM,kBACJV,EACAD,kBAAmBmuB,KAChB31B,GACDmI,EACJ,OAAOnI,GAEHg/D,EAAeD,EAAgBljC,EAAK1zB,UACpCgY,EAAe4+C,EAAgB9yD,EAAK9D,UAEpC/P,EAAOC,OAAOD,KAAK4mE,GACzB,OACEnjC,EAAKo+B,qBAAuBhuD,EAAKguD,oBACjCp+B,EAAKojC,WAAahzD,EAAKgzD,UACvBpjC,EAAKhrB,WAAa5E,EAAK4E,UACvBgrB,EAAK9hB,QAAU9N,EAAK8N,OACpB3hB,EAAKk6C,OAAOziD,GAAQmvE,EAAanvE,KAASswB,EAAatwB,MAI5C6yC,WAAM4D,KAAK03B,GAASc,I,MC/0B5B,MAAMI,GAASt8B,IAMf,IAAD,EACJ,MAAM0yB,EAAWnhB,KAEXgrB,EAAcvuD,GAAgBgyB,EAAM/xB,UACpCuP,EAAmB4f,GAAkB4C,EAAM/xB,SAAU+xB,EAAMz6B,UAC3Di3D,EAAsBxuD,GAAgBwP,GAE5C,OAAIk1C,GAAY1yB,EAAMz6B,SAASxB,SACtB,KAIP,sBAAK27B,UAAU,QAAf,SACE,gBAAC,GAAD,CAAQ9pB,QAAS,EAAjB,UACE,sBAAK8pB,UAAU,QAAQgB,QAASV,EAAMqM,QAAtC,SACG1H,KAEH,8BAAKpvC,EAAE,iBACP,iCACE,mCACE,8BACE,qBAAIknE,QAAS,EAAb,SAAiBlnE,EAAE,mBAErB,gCACE,8BAAKA,EAAE,oBACP,8BAAKyqC,EAAM/xB,SAAS5gB,YAEtB,gCACE,8BAAKkI,EAAE,iBACP,8BAAK3O,KAAK0jB,MAAMiyD,EAAY,IAAM31E,KAAK0jB,MAAMiyD,EAAY,SAE3D,gCACE,8BAAKhnE,EAAE,kBACP,8BAAK3O,KAAK0jB,MAAMiyD,EAAY,IAAM31E,KAAK0jB,MAAMiyD,EAAY,SAG9B,IAA5B/+C,EAAiBnwB,QAChB,8BACE,qBAAIovE,QAAS,EAAb,SAAiBlnE,EAAE,qBAItBioB,EAAiBnwB,OAAS,GACzB,uCACE,8BACE,qBAAIovE,QAAS,EAAb,SAAiBlnE,EAAE,sBAErB,gCACE,8BAAKA,EAAE,oBACP,8BAAKioB,EAAiBnwB,eAI3BmwB,EAAiBnwB,OAAS,GACzB,uCACE,gCACE,8BAAK,MACL,8BAAKzG,KAAK0jB,MAAMkyD,EAAoB,SAEtC,gCACE,8BAAK,MACL,8BAAK51E,KAAK0jB,MAAMkyD,EAAoB,SAEtC,gCACE,8BAAKjnE,EAAE,iBACP,8BACG3O,KAAK0jB,MACJkyD,EAAoB,GAAKA,EAAoB,SAInD,gCACE,8BAAKjnE,EAAE,kBACP,8BACG3O,KAAK0jB,MACJkyD,EAAoB,GAAKA,EAAoB,YAM1B,IAA5Bh/C,EAAiBnwB,QAChB,gCACE,8BAAKkI,EAAE,iBACP,wCACM3O,KAAK0jB,MACsB,IAA5BkT,EAAiB,GAAGnW,MAAezgB,KAAKC,IAF7C,aAjEN,UAwEGm5C,EAAM08B,yBAxET,aAwEG,OAAA18B,EAA0BA,EAAM/xB,SAAU+xB,EAAMz6B,qB,MCxGtD,MAAMo3D,GAAQ,IAMd,IANe,QACpBv9B,EADoB,WAEpBw9B,GAII,EACJ,MAAMC,EAAWx8B,iBAAe,GAE1By8B,EAAkB32D,uBACtB,IACG02D,EAASzzD,QAAUxf,OAAO2T,YAAW,IAAMq/D,KAAcvyE,MAC5D,CAACuyE,IAQH,OALAj8B,qBAAU,KACRm8B,IACO,IAAMx/D,aAAau/D,EAASzzD,WAClC,CAAC0zD,EAAiB19B,IAGnB,sBACEM,UAAU,QACVk2B,aAAc,IAAMt4D,aAAY,OAACu/D,QAAD,IAACA,OAAD,EAACA,EAAUzzD,SAC3CysD,aAAciH,EAHhB,SAKE,oBAAGp9B,UAAU,iBAAb,SAA+BN,OC1BxB29B,GAAuB51B,GAAS,CAC3C/5C,KAAM,WACNo6C,QAAQv5B,EAAU1I,GAEhB,OADAzW,YAAW,OAAQ,OAAQ,QACpB,CACLyW,SAAU,IACLA,EACHN,iBAAkB2U,KAAKgoB,QAASr8B,IAElCkiC,iBAAiB,IAGrB7F,QAAUr8B,GAAaA,EAASN,gBAChC0iC,iBAAkB,kBAClBC,QAAU53C,IACPA,EAAMmJ,IAAqBnJ,EAAMsJ,QAAUtJ,EAAMmF,OAAS+D,I,wBCoN/D,MAAM8jE,GAAkBl9B,IAAMm9B,eAAc,GAC/B1rB,GAAc,IAAM2rB,qBAAWF,IACtCG,GAA6Br9B,IAAMm9B,cAGtC,CAAE9K,UAAW,KAAM98D,GAAI,OACb8qC,GAAyB,IACpC+8B,qBAAWC,IAEb,IAAIC,IAAuB,EACvBC,GAAmB,EACnBC,GAAU,EACVC,GAAU,EACVC,IAA0B,EAC1BC,IAAqB,EACrBC,IAA+B,EAC/BC,GAAgC,CAAEriC,WAAY,KAAMC,SAAU,MAC9DqiC,GAAe,EACfC,IAAwB,EAExBC,GAA+C,KACnD,MAAMC,GAAmB,CACvB7P,SAAU,IAAIxsD,IACds8D,WAAY,KACZC,gBAAiB,KACjBC,aAAc,MAGhB,MAAMC,WAAYr+B,IAAMs+B,UA8BtBj+C,YAAY6f,GAAkB,IAAD,EAC3BX,MAAMW,GADqB,YA7B7BjiC,OAAuC,KA6BV,KA5B7B8R,GAAyB,KA4BI,KA3B7BwuD,WAAqB,EA2BQ,KA1B7B3M,mBA0B6B,OAzB7BgB,UAAW,EAyBkB,KAxB7B4L,6BAwB6B,OAtBrBC,uBAAyBz+B,IAAM0+B,YAsBV,KAfrB7kD,WAeqB,OAdrB8kD,oBAcqB,OAbrBC,gCAaqB,OAZtBvW,aAYsB,OAXtBmF,6BAWsB,OAVrBj4D,QAUqB,OATrBm5B,aASqB,OARrBmwC,8BAQqB,OAHtBxnD,MAAqB,GAGC,KAFtBjI,WAA+C,IAAIxN,IAE7B,KA8NtB8wC,eAAuD,KACjC,IAAD,EAAtB54B,KAAKomB,MAAM4+B,YACb,UAAAhlD,KAAK2kD,uBAAuBn1D,eAA5B,SAAqCipB,UAhOZ,KAoOtBwsC,iCAAmC,IACjCjlD,KAAKD,MAAMI,8BArOS,KAwOtB+kD,iBAAmB,IACjBllD,KAAKD,MAAMK,cAzOS,KA4OrB+kD,iBAAmBz+D,IACxBosD,IACC,GAAI9yC,KAAKykD,YAA8B,IAAjB3R,EACpB,OAGF,IAAI9pD,EAAoD,KAwBxD,GAvBI8pD,EAAaz+C,WACfy+C,EAAaz+C,SAASC,SAAS7H,IAAa,IAAD,GAEvC,UAAAuT,KAAKo2C,MAAMptD,sBAAX,eAA2BvN,MAAOgR,EAAQhR,IAC1CukB,KAAKo2C,MAAMptD,iBAAmByD,GAC9B8T,GAAoB9T,KAEpBzD,EAAiByD,MAGrBuT,KAAKD,MAAMU,mBAAmBqyC,EAAaz+C,UACvCy+C,EAAajlB,iBACf7tB,KAAK4U,QAAQI,mBAIb89B,EAAav1C,QACfyC,KAAKzC,MAAQu1C,EAAasS,aACtBtS,EAAav1C,MACb,IAAKyC,KAAKzC,SAAUu1C,EAAav1C,OACrCyC,KAAKqlD,4BAGHvS,EAAannD,UAAY3C,EAAgB,CAAC,IAAD,YACvC8pD,EAAajlB,iBACf7tB,KAAK4U,QAAQI,kBAGf,IAAI3pB,GAA8B,OAAZynD,QAAY,IAAZA,GAAA,UAAAA,EAAcnnD,gBAAd,eAAwBN,mBAAmB,EAC7DD,GAA6B,OAAZ0nD,QAAY,IAAZA,GAAA,UAAAA,EAAcnnD,gBAAd,eAAwBP,kBAAkB,EAC3DzB,GAAuB,OAAZmpD,QAAY,IAAZA,GAAA,UAAAA,EAAcnnD,gBAAd,eAAwBhC,WAAY,KAC/C1X,GAAoB,OAAZ6gE,QAAY,IAAZA,GAAA,UAAAA,EAAcnnD,gBAAd,eAAwB1Z,QAASxD,IAAMC,MAC/C8E,EAAI,iBAAGs/D,QAAH,IAAGA,GAAH,UAAGA,EAAcnnD,gBAAjB,aAAG,EAAwBnY,YAA3B,QAAmCwsB,KAAKo2C,MAAM5iE,KACZ,qBAA/BwsB,KAAKomB,MAAM/6B,kBACpBA,EAAkB2U,KAAKomB,MAAM/6B,iBAGU,qBAA9B2U,KAAKomB,MAAMh7B,iBACpBA,EAAiB4U,KAAKomB,MAAMh7B,gBAGY,qBAA/B4U,KAAKomB,MAAMk/B,kBACpB37D,EAAWqW,KAAKomB,MAAMk/B,gBAAkBp2E,IAAY,MAGtB,qBAArB8wB,KAAKomB,MAAMn0C,QACpBA,EAAQ+tB,KAAKomB,MAAMn0C,OAGU,qBAApB+tB,KAAKomB,MAAM5yC,OACpBA,EAAOwsB,KAAKomB,MAAM5yC,MAEpBwsB,KAAKoU,UACFgiC,IAAW,IAAD,EAIT,OAAOv6D,OAAOsrB,OAAO2rC,EAAannD,UAAY,GAAI,CAChD3C,eACEA,IAAc,UAAI8pD,EAAannD,gBAAjB,aAAI,EAAuB3C,iBAAkB,KAC7DqC,kBACAD,iBACAzB,WACA1X,QACAuB,YAGJ,KACMs/D,EAAaN,aACfxyC,KAAK4U,QAAQshC,gBACXl2C,KAAKo2C,MACLp2C,KAAKD,MAAMI,sCA1TI,KAqUrBg0B,OAASztC,IAAmB,KAClCk9D,IAAiB,EACjB5jD,KAAKoU,SAAS,CAAExqB,kBAAkB,OAvUP,KA0UrB27D,SAAW,KACjBvlD,KAAKm0B,UA3UsB,KA8UrBqxB,aAA+BpvE,IACrCA,EAAMmR,kBA/UqB,KAkVrBk+D,aAAe,KACrBzlD,KAAKD,MAAMI,8BAA8B7L,SAAS7H,IAC5CG,GAAcH,IAChB4L,GAA0B5L,MAG9BuT,KAAK0lD,kBAxVsB,KA2VrBC,qBAAuBvyE,MAAOwyE,EAAaC,KACjD,GAAI71E,OAAOC,SAAS61E,KAAKp+D,SAASlW,IAAcD,YAAa,CAC3D,MAAMu0E,EAAO,IAAIC,gBAAgB/1E,OAAOC,SAAS61E,KAAKrsE,MAAM,IAC5DqsE,EAAKxtD,OAAO9mB,IAAcD,YAC1BvB,OAAO4kC,QAAQoxC,aAAa,GAAIv5E,IAAhC,WAA8Cq5E,EAAK1/C,kBAC9C,GAAIp2B,OAAOC,SAASg2E,OAAOv+D,SAASpW,IAAeC,YAAa,CACrE,MAAM20E,EAAQ,IAAIH,gBAAgB/1E,OAAOC,SAASg2E,QAClDC,EAAM5tD,OAAOhnB,IAAeC,YAC5BvB,OAAO4kC,QAAQoxC,aAAa,GAAIv5E,IAAhC,WAA8Cy5E,EAAM9/C,aAGtD,IACE,MAAM+/C,QAAgBC,MAAMC,mBAAmBT,IACzC5vE,QAAamwE,EAAQnwE,OACrB1G,EAAOwK,KAAKU,YAAYxE,EAAK2B,QACnC,IzD5hByBrI,IAEX,kBAATA,GACPA,GACAA,EAAK6R,OAASvR,IAAkBE,mBACf,IAAjBR,EAAK0I,QyDuhBEsuE,CAAeh3E,GAClB,MAAM,IAAIiH,OAGVsvE,IAAU7lD,KAAKvkB,IACfzL,OAAOywE,QACL9kE,EAAE,2BAA4B,CAAE4qE,UAAWj3E,EAAKi/D,QAAQ96D,mBAGpDusB,KAAKuuC,QAAQ+R,cAActqE,GAE7BgqB,KAAKo2C,MAAMvsD,eACbmW,KAAKoU,SAAS,CAAEvqB,eAAe,IAEjCmW,KAAKoU,SAAS,CAAEvqB,eAAe,KAEjC,MAAO/R,GACP9H,OAAOw2E,MAAM7qE,EAAE,+BACf5D,QAAQD,MAAMA,GAtBhB,QAwBEkoB,KAAK44B,mBA9XoB,KAkYrB6tB,aAAe,KACrBzmD,KAAK4U,QAAQjU,SAnYc,KA0YrB+lD,WAAahgE,IAClBoe,IACC9E,KAAKD,MAAMU,mBAAmB,IAC9BT,KAAKoU,UAAUgiC,IAAD,IACTxuD,KACHkC,YAAe,OAAJgb,QAAI,IAAJA,OAAA,EAAAA,EAAM6hD,oBAA4BvQ,EAAMtsD,UACnD7X,MAAO+tB,KAAKo2C,MAAMnkE,UAEpB+tB,KAAKymD,kBAlZoB,KAsZrBG,gBAAkBxzE,UAAa,IAAD,EAChC,gBAAiBpD,QAAU,iBAAkBA,QAC9CA,OAAe62E,YAAYC,aAC1B1zE,UACE,IAAK2zE,EAAaxpD,MAAM9pB,OACtB,OAEF,MAAMiW,EAAaq9D,EAAaxpD,MAAM,GAChCvnB,QAAmB0T,EAAWs9D,UACpChxE,EAAKsN,OAASoG,EACdm5C,GACE7sD,EACAgqB,KAAKo2C,MACLp2C,KAAKD,MAAMI,+BAEV9kB,MAAM0kB,IACLC,KAAKmlD,iBAAiB,IACjBplD,EACHpU,SAAU,IACJoU,EAAMpU,UAAYqU,KAAKo2C,MAC3BtsD,WAAW,GAEb+jC,iBAAiB,OAGpB8sB,OAAO7iE,IACNkoB,KAAKoU,SAAS,CAAEtqB,WAAW,EAAOT,aAAcvR,EAAM0tC,gBAM3DxlB,KAAKo2C,MAAMtsD,WACdkW,KAAKoU,SAAS,CAAEtqB,WAAW,IAE7B,IAAIm9D,EAAc,KAClB,IAAK,IAAD,EACFA,QAAqBjnD,KAAKomB,MAAM6gC,aAAgB,MAChD,UAAIA,SAAJ,aAAI,EAAaxT,gBACfzzC,KAAK0zC,wBAA0BuT,EAAYxT,cAE7C,MAAO37D,GACPC,QAAQD,MAAMA,GACdmvE,EAAc,CACZt7D,SAAU,CACRtC,aACEvR,EAAM0tC,SACN,kEAKR,MAAMzlB,EAAQhJ,GAAQkwD,EAAa,KAAM,MAEzClnD,EAAMpU,SAAW,IACZoU,EAAMpU,SACTvC,YACiC,UAA/B2W,EAAMpU,SAASvC,YACX,YACA2W,EAAMpU,SAASvC,YACrBU,WAAW,IAEb,UAAIm9D,SAAJ,aAAI,EAAaC,mBACfnnD,EAAMpU,SAAW,IACZoU,EAAMpU,YACNi4B,GACD7jB,EAAM1L,SACN,IACK0L,EAAMpU,SACTlJ,MAAOud,KAAKo2C,MAAM3zD,MAClBE,OAAQqd,KAAKo2C,MAAMzzD,OACnBM,UAAW+c,KAAKo2C,MAAMnzD,UACtB+B,WAAYgb,KAAKo2C,MAAMpxD,eAO/Bgb,KAAKymD,eACLzmD,KAAKmlD,iBAAiB,IACjBplD,EACH8tB,iBAAiB,IAGnB,MAAMs5B,EAEJ,IAAIpB,gBAAgB/1E,OAAOC,SAAS61E,KAAKrsE,MAAM,IAAImd,IACjDplB,IAAcD,aAGhB,IAAIw0E,gBAAgB/1E,OAAOC,SAASg2E,QAAQrvD,IAC1CtlB,IAAeC,YAGf41E,SACInnD,KAAK2lD,qBAAqBwB,IAtfP,KA8kBrBC,SAAW1gE,IAAmB,KACpCsZ,KAAKD,MACFI,8BACA7L,SAAS7H,GAAY4L,GAA0B5L,KAClDuT,KAAKoU,SAAS,OAllBa,KAi2BrBizC,SAAWlkE,IAAS,KAC1B,MAAM,UAAEF,EAAF,WAAa+B,GAAegb,KAAKsnD,mBACvCtnD,KAAKoU,UAAUgiC,GACTA,EAAMpxD,aAAeA,GAAcoxD,EAAMnzD,YAAcA,EAClD,KAEF,CAAEA,YAAW+B,kBAErBrU,KAz2B0B,KA62BrB42E,MAAQ7gE,IAAoBtQ,IAA2B,IAAD,GACpC,UAAG4pB,KAAK2kD,uBAAuBn1D,eAA/B,aAAG,EAAqCyiC,SAC9Dp1C,SAASm2C,kBAEgBhyC,GAAkB5K,EAAMC,UAGnD2pB,KAAKwnD,SACLpxE,EAAMmR,qBAr3BqB,KAw3BrBkgE,OAAS/gE,IAAoBtQ,IAA2B,IAAD,GACrC,UAAG4pB,KAAK2kD,uBAAuBn1D,eAA/B,aAAG,EAAqCyiC,SAC9Dp1C,SAASm2C,kBAEgBhyC,GAAkB5K,EAAMC,UAGnD2pB,KAAK0nD,UACLtxE,EAAMmR,qBAh4BqB,KAm4BrBigE,OAAS,KACfxnD,KAAK0nD,UACL1nD,KAAK83C,cAAc5E,cAAcvlB,KAr4BN,KAw4BrB+5B,QAAU,KAChBpf,GAAgBtoC,KAAKD,MAAMK,cAAeJ,KAAKo2C,MAAOp2C,KAAKzC,QAz4BhC,KAg5BrBoqD,WAAcvxE,IACpB,IAAKotE,GAOH,OANAA,IAAc,EACd9/D,aAAa+/D,SACbA,GAAmBzzE,OAAO2T,WACxB4gE,GAAIqD,cACJt3E,MAMJ,GAAIkzE,IAAwC,IAAzBptE,EAAMyxE,QAAQp0E,OAAc,CAC7C,MAAO8zB,GAASnxB,EAAMyxE,QAEtB7nD,KAAK8nD,wBAAwB,CAC3BjjE,QAAS0iB,EAAM1iB,QACfC,QAASyiB,EAAMziB,UAEjB0+D,IAAc,EACd9/D,aAAa+/D,IAEfrtE,EAAMmR,iBACuB,IAAzBnR,EAAMyxE,QAAQp0E,QAChBusB,KAAKoU,SAAS,CACZ1pB,mBAAoB,MAz6BG,KA86BrBq9D,SAAY3xE,IACdA,EAAMyxE,QAAQp0E,OAAS,GACzBusB,KAAKoU,SAAS,CACZ7pB,2BAA4B,GAC5BG,mBAAoBsV,KAAKo2C,MAAM7rD,8BAl7BR,KAu7BrBy9D,mBAAqBthE,IAC3BtT,UAAyC,IAAD,IAEtC,MAAMiD,EAASwG,SAASm2C,cAGxB,KAFwB,UACtBhzB,KAAK2kD,uBAAuBn1D,eADN,aACtB,EAAqCyiC,SAAS57C,IAE9C,OAGF,MAAM4xE,EAAqBprE,SAASqrE,iBAAiBxE,GAASC,IAC9D,GAGEvtE,MACG6xE,aAA8B5f,oBAC/BrnD,GAAkB3K,IAEpB,OAMF,IAAI+0C,EAAI,OAAGh1C,QAAH,IAAGA,GAAH,UAAGA,EAAOgzD,qBAAV,aAAG,EAAsB7rC,MAAM,GAEvC,MAAMnpB,QAAa80D,GAAe9yD,GAElC,IAAKg1C,GAAQh3C,EAAKuD,KAAM,CACtB,MAAMwwE,EAAS/zE,EAAKuD,KAAK+wD,OACrByf,EAAOnrE,WAAW,SAAWmrE,EAAOC,SAAS,YAG/Ch9B,EAAOyY,GAAgBskB,IAI3B,GAAIvlB,GAAqBxX,GAAO,CAC9B,MAAQ7oC,EAAG8C,EAAQrB,EAAGsB,GAAWV,GAC/B,CAAEC,QAAS6+D,GAAS5+D,QAAS6+D,IAC7B3jD,KAAKo2C,OAGDiS,EAAeroD,KAAKsoD,mBAAmB,CAAEjjE,SAAQC,WAKvD,OAJA0a,KAAKuoD,mBAAmBF,EAAcj9B,GACtCprB,KAAKwoD,0BAA0BH,QAC/BroD,KAAKoU,SAAS,CAAE1pB,mBAAoB,CAAE,CAAC29D,EAAa5sE,KAAK,KAK3D,GAAIukB,KAAKomB,MAAMqiC,QACb,IACE,IAAgD,UAArCzoD,KAAKomB,MAAMqiC,QAAQr0E,EAAMgC,GAClC,OAEF,MAAO0B,GACPC,QAAQD,MAAMA,GAGd1D,EAAKiV,aACP2W,KAAKoU,SAAS,CAAE/qB,aAAcjV,EAAKiV,eAC1BjV,EAAKmyD,YACdvmC,KAAKoU,SAAS,CACZ/pB,YAAa,CACXjW,KAAMA,EAAKmyD,YACXj8C,OAAO,KAGFlW,EAAKigB,SACd2L,KAAK0oD,8BAA8B,CACjCr0D,SAAUjgB,EAAKigB,SACfkJ,MAAOnpB,EAAKmpB,OAAS,KACrBpb,SAAU,WAEH/N,EAAKuD,MACdqoB,KAAK2oD,iBAAiBv0E,EAAKuD,MAE7BqoB,KAAK4oD,gBAAgB,aAChB,OAALxyE,QAAK,IAALA,KAAOmR,oBAtgCkB,KA0gCrBmhE,8BAAiC5jD,IAKvC,MAAMzQ,EAAWmtC,GAAgB18B,EAAKzQ,SAAU,OACzC9B,EAAMC,EAAMC,EAAMC,GAAQ0B,GAAgBC,GAE3Cw0D,EAAkB9kE,GAASwO,EAAME,GAAQ,EACzCq2D,EAAkB/kE,GAASyO,EAAME,GAAQ,EAEzC7N,EACqB,kBAAlBigB,EAAK3iB,SACR2iB,EAAK3iB,SAAS0C,QACI,WAAlBigB,EAAK3iB,SACLuhE,GACA1jD,KAAKo2C,MAAM3zD,MAAQ,EAAIud,KAAKo2C,MAAMpxD,WAClCF,EACqB,kBAAlBggB,EAAK3iB,SACR2iB,EAAK3iB,SAAS2C,QACI,WAAlBggB,EAAK3iB,SACLwhE,GACA3jD,KAAKo2C,MAAMzzD,OAAS,EAAIqd,KAAKo2C,MAAMnzD,WAEnC,EAAEV,EAAF,EAAKyB,GAAMY,GACf,CAAEC,UAASC,WACXkb,KAAKo2C,OAGD2S,EAAKxmE,EAAIsmE,EACTG,EAAKhlE,EAAI8kE,EACT73B,EAAa,IAAInpC,KAEhBmhE,EAAOC,GAASz4D,GAAas4D,EAAIC,EAAIhpD,KAAKo2C,MAAMzsD,UAEjD8wB,EAAsB,IAAI3yB,IAC1BopC,EAAc78B,EAASrZ,KAAKyR,IAChC,MAAMoY,EAAa+B,GACjB5G,KAAKo2C,MAAMntD,eACXgoC,EACAxkC,EACA,CACElK,EAAGkK,EAAQlK,EAAI0mE,EAAQ12D,EACvBvO,EAAGyI,EAAQzI,EAAIklE,EAAQ12D,IAI3B,OADAioB,EAAoBrhC,IAAIqT,EAAQhR,GAAIopB,EAAWppB,IACxCopB,KAEHnE,EAAe,IAChBV,KAAKD,MAAMI,iCACX+wB,GAEL5W,GAA4B5Z,EAAcrM,EAAUomB,GAEhD3V,EAAKvH,QACPyC,KAAKzC,MAAQ,IAAKyC,KAAKzC,SAAUuH,EAAKvH,QAGxCyC,KAAKD,MAAMU,mBAAmBC,GAC9BV,KAAK4U,QAAQI,kBACbhV,KAAKoU,SACH1Q,GACE,IACK1D,KAAKo2C,MACRvsD,eAAe,EACfa,mBAAoBwmC,EAAYl4C,QAAO,CAACgC,EAAKyR,KAC3CzR,EAAIyR,EAAQhR,KAAM,EACXT,IACN,IACH2P,iBAAkB,IAEpBqV,KAAKD,MAAMK,gBAEb,KACM0E,EAAKvH,OACPyC,KAAKqlD,8BAIXrlD,KAAK4oD,gBAAgB,cA1lCM,KA+nC7BzP,YAAegQ,IACbnpD,KAAKoU,SAAS+0C,IAhoCa,KAmoC7BC,cAAiBhzE,IAEW,UAAtBA,EAAMgyB,aAA2B47C,KACnCtgE,aAAasgE,IACbA,GAAe,EACfC,IAAwB,GAG1BE,GAAQ7P,SAASh8C,OAAOliB,EAAMizE,YA3oCH,KA8oC7BC,WAAa,KACXtpD,KAAKoU,UAAUm1C,IACN,CACLpgE,eAAgBogE,EAAUpgE,cAC1BC,YAAamgE,EAAUpgE,cACnB,YACAogE,EAAUngE,iBAppCS,KAypC7Bu4D,cAAgB,KACd3hD,KAAK83C,cAAc5E,cAAclB,KA1pCN,KA6pC7BwX,YAAc,KACPxpD,KAAKo2C,MAAMrrD,WACd7V,YAAW,SAAU,SAEvB8qB,KAAK83C,cAAc5E,cAAcjB,KAjqCN,KAoqC7BiV,gBAAkB,WAIZ,IAHJ7wE,EAGG,uDADgC,EAAK0pB,MAAMK,cAE9C,EAAKgU,SAAS,IACTwP,GACD7iB,MAAM4F,QAAQtwB,GAAUA,EAAS,CAACA,GAClC,EAAK+/D,MACL,EAAKjyD,WA7qCkB,KAkrC7B6+D,WAAa,KACXhjD,KAAKoU,SAAS,CAAElpB,aAAc,QAnrCH,KAsrC7Bu+D,gBAAmBv+D,IACjB8U,KAAKoU,SAAS,CAAElpB,kBAvrCW,KA0rC7Bw+D,qBAAuBt2E,UACrB,IACE,MAAMu2E,QAA4BC,OAAOC,KAAK,oBAExCz+B,QAAau+B,EAAoBjnB,MAAM,eAC7C,GAAItX,EAAM,CACR,MAAMp1C,QAAao1C,EAAKp1C,OACxBgqB,KAAK8pD,iBAAiB9zE,SAChB2zE,EAAoBrxD,OAAO,eACjCtoB,OAAO4kC,QAAQoxC,aAAa,KAAMv5E,IAAUuD,OAAOC,SAASowE,WAE9D,MAAOvoE,GACPkoB,KAAKoU,SAAS,CAAE/qB,aAAcvR,EAAM0tC,YAtsCX,KA2sCtBukC,SAAgDrjE,IACpD6W,IACC,MAAMysD,EAAWzsD,EAAMvkB,QAAO,CAACC,EAAK+kB,KAClC/kB,EAAIG,IAAI4kB,EAASviB,GAAIuiB,GACd/kB,IACN,IAAI6O,KAEPkY,KAAKzC,MAAQ,IAAKyC,KAAKzC,SAAU1hB,OAAOunB,YAAY4mD,IAKpDhqD,KAAKD,MAAMK,cAAc9L,SAAS7H,IAE9BD,GAA0BC,IAC1Bu9D,EAASz0D,IAAI9I,EAAQC,UAErBsT,KAAK1K,WAAWgD,OAAO7L,EAAQC,QAC/B2L,GAA0B5L,GAC1B6V,GAAY7V,OAGhBuT,KAAKD,MAAMc,iBAEXb,KAAKqlD,8BAnuCoB,KAuuCtB4E,YAAcvjE,IACQwjE,IAMrBA,EAAUr8B,iBACZ7tB,KAAK4U,QAAQI,kBAGXk1C,EAAUv+D,UACZqU,KAAKoU,SAAS81C,EAAUv+D,UAGtBu+D,EAAU71D,UACZ2L,KAAKD,MAAMU,mBAAmBypD,EAAU71D,UAGtC61D,EAAUriE,eACZmY,KAAKoU,SAAS,CAAEvsB,cAAeqiE,EAAUriE,mBA3vClB,KAgwCrB69D,eAAiB,KACvB1lD,KAAKoU,SAAS,KAjwCa,KAowCrB+1C,4BAA8BzjE,IACnCtQ,IACCstE,GAAUttE,EAAMyO,QAChB8+D,GAAUvtE,EAAM0O,WAvwCS,KA6wCrBiuC,UAAYrsC,IACjBtQ,IxHrgDHC,MwH8hDI,IAtBE,UAAWrG,UACRoG,EAAMwJ,UAAY,UAAUV,KAAK9I,EAAM/C,MACvC+C,EAAMwJ,UAAY,UAAUV,KAAK9I,EAAM/C,QAE1C+C,EAAQ,IAAIg0E,MAAMh0E,EAAO,CACvBwgB,IAAIyzD,EAASC,GACX,MAAM90E,EAAQ60E,EAAGC,GACjB,MAAqB,oBAAV90E,EAEFA,EAAMmrE,KAAK0J,GAEJ,QAATC,EAGHl0E,EAAMwJ,SACJyqE,EAAGh3E,IAAI0N,cACPspE,EAAGh3E,IAAI6/C,cACT19C,QAMPwL,GAAkB5K,EAAMC,SAAWD,EAAM/C,MAAQkM,IAEjDC,GAAWpJ,EAAM/C,OxHjiDxBgD,EwHiiD4CD,EAAMC,OxH1hDjDA,aAAkB4K,aAAuC,YAAxB5K,EAAO6K,QAAQC,MACjD9K,aAAkB+K,eAClB/K,aAAkBiL,kBAClBjL,aAAkBgL,qBAClBhL,aAAkBk0E,uBwH2hDVn0E,EAAM/C,MAAQkM,IAChBygB,KAAKoU,SAAS,CACZtpB,gBAAgB,KAIhBkV,KAAK83C,cAAc7E,cAAc78D,KAIjC4pB,KAAKo2C,MAAM/qD,iBAAf,CAYA,GARIjV,EAAMmJ,IAAqBygB,KAAKo2C,MAAMxsD,kBACxCoW,KAAKoU,SAAS,CAAExqB,kBAAkB,IAGhCxT,EAAMmF,OAAS+D,GACjB0gB,KAAKoU,SAAS,CAAEvqB,eAAgBmW,KAAKo2C,MAAMvsD,gBAGzCrK,GAAWpJ,EAAM/C,KAAM,CACzB,MAAMsiD,EACH31B,KAAKo2C,MAAMzsD,WACTvT,EAAMwJ,SACH/S,IACAmzB,KAAKo2C,MAAMzsD,YAChBvT,EAAMwJ,SACHhT,IACAC,KAEA+2B,EAAmB5D,KAAKD,MAC3BK,cACA/jB,QAAQoQ,GAAYuT,KAAKo2C,MAAM1rD,mBAAmB+B,EAAQhR,MAE7D,IAAI+hB,EAAU,EACVC,EAAU,EAEVrnB,EAAM/C,MAAQkM,EAChBie,GAAWm4B,EACFv/C,EAAM/C,MAAQkM,EACvBie,EAAUm4B,EACDv/C,EAAM/C,MAAQkM,EACvBke,GAAWk4B,EACFv/C,EAAM/C,MAAQkM,IACvBke,EAAUk4B,GAGZ/xB,EAAiBtP,SAAS7H,IACxBkV,GAAclV,EAAS,CACrBlK,EAAGkK,EAAQlK,EAAIib,EACfxZ,EAAGyI,EAAQzI,EAAIyZ,IAGjBib,GAAoBjsB,EAAS,CAC3BosB,sBAAuBjV,OAI3B5D,KAAKwqD,0BAA0B5mD,GAE/BxtB,EAAMmR,sBACD,GAAInR,EAAM/C,MAAQkM,GAAY,CACnC,MAAMqkB,EAAmBC,GACvB7D,KAAKD,MAAMK,cACXJ,KAAKo2C,OAGP,GAC8B,IAA5BxyC,EAAiBnwB,QACjBsZ,GAAgB6W,EAAiB,IAG9B5D,KAAKo2C,MAAMltD,sBACZ8W,KAAKo2C,MAAMltD,qBAAqB0qB,YAAchQ,EAAiB,GAAGnoB,KAElEukB,KAAK4U,QAAQI,kBACbhV,KAAKoU,SAAS,CACZlrB,qBAAsB,IAAIyqB,GACxB/P,EAAiB,GACjB5D,KAAKD,eAIN,GACuB,IAA5B6D,EAAiBnwB,SAChBsZ,GAAgB6W,EAAiB,IAClC,CACA,MAAME,EAAkBF,EAAiB,GAMzC,OALA5D,KAAKyqD,iBAAiB,CACpBplE,OAAQye,EAAgBvhB,EAAIuhB,EAAgBrhB,MAAQ,EACpD6C,OAAQwe,EAAgB9f,EAAI8f,EAAgBnhB,OAAS,SAEvDvM,EAAMmR,uBAGH,IACJnR,EAAM6+C,UACN7+C,EAAMsJ,SACNtJ,EAAM4+C,SACwB,OAA/Bh1B,KAAKo2C,MAAMrtD,gBACX,CACA,MAAMzE,EzB1kDiBjR,KAC7B,MAAMiR,EAAQ+xD,GAAO9yC,MAAK,CAACjf,EAAOlH,IAE9B/J,KAAS+J,EAAQ,GAAGgpB,YACnB9hB,EAAMjR,MACiB,kBAAdiR,EAAMjR,IACViR,EAAMjR,MAAQA,EACbiR,EAAMjR,IAA0BqU,SAASrU,MAGpD,OAAY,OAALiR,QAAK,IAALA,OAAA,EAAAA,EAAO9O,QAAS,MyBgkDHk1E,CAAet0E,EAAM/C,KAC/BiR,EACF0b,KAAK4oD,gBAAgBtkE,GACZlO,EAAM/C,MAAQkM,IACvBygB,KAAKspD,aAQT,GALIlzE,EAAM/C,MAAQkM,IAAwC,IAA1B4kE,GAAQ7P,SAASl9C,OAC/CwsD,IAAiB,EACjBx/D,GAAU4b,KAAK7b,OAAQjX,IAAYG,WAGjC+I,EAAM/C,MAAQkM,IAAUnJ,EAAM/C,MAAQkM,GAAQ,CAChD,MAAMqkB,EAAmBC,GACvB7D,KAAKD,MAAMK,cACXJ,KAAKo2C,OAEP,GAC6B,cAA3Bp2C,KAAKo2C,MAAMhtD,cACVwa,EAAiBnwB,OAElB,OAIA2C,EAAM/C,MAAQkM,KACbglC,GAAcvkB,KAAKo2C,MAAMhtD,cACxBwa,EAAiB+K,MAAMliB,GAAY83B,GAAc93B,EAAQtL,UAE3D6e,KAAKoU,SAAS,CAAEhqB,UAAW,0BAEzBhU,EAAM/C,MAAQkM,IAChBygB,KAAKoU,SAAS,CAAEhqB,UAAW,2BAt7CN,KA47CrBugE,QAAUjkE,IAAoBtQ,IAmBpC,GAlBIA,EAAM/C,MAAQkM,KACZygB,KAAKo2C,MAAM/qD,gBACbjH,GAAU4b,KAAK7b,OAAQjX,IAAYI,MACC,cAA3B0yB,KAAKo2C,MAAMhtD,YACpBlF,GAAY8b,KAAK7b,SAEjBE,GAAkB2b,KAAK7b,OAAQ6b,KAAKo2C,MAAMhtD,aAC1C4W,KAAKoU,SAAS,CACZ1pB,mBAAoB,GACpBC,iBAAkB,GAClB1B,eAAgB,QAGpB26D,IAAiB,GAEdxtE,EAAMmJ,IAAsBygB,KAAKo2C,MAAMxsD,kBAC1CoW,KAAKoU,SAAS,CAAExqB,kBAAkB,IAEhCpK,GAAWpJ,EAAM/C,KAAM,CACzB,MAAMuwB,EAAmBC,GACvB7D,KAAKD,MAAMK,cACXJ,KAAKo2C,OAEPxsD,GAAiBoW,KAAKo2C,OAClB9+B,GAA6B1T,GAC7BsU,GAAqBtU,GACzB5D,KAAKoU,SAAS,CAAEnpB,kBAAmB,SAv9CV,KAo/CrB2/D,eAAiBlkE,IAAoBtQ,IAC3CA,EAAMmR,iBACNyY,KAAKoU,SAAS,CACZ1pB,mBAAoB,KAEtBy5D,GAAQG,aAAetkD,KAAKo2C,MAAMrxD,KAAKvP,SAz/CZ,KA4/CrBq1E,gBAAkBnkE,IAAoBtQ,IAQ5C,GAPAA,EAAMmR,iBAOwB,IAA1B48D,GAAQ7P,SAASl9C,KACnB,OAGF,MAAMktD,EAAeH,GAAQG,aACzBA,GACFtkD,KAAKoU,UAAS,QAAC,KAAErvB,EAAF,WAAQC,EAAR,UAAoB/B,GAArB,QAAsC,CAClD8B,KAAMggC,GACJK,GAAkBk/B,EAAeluE,EAAMimB,OACvCtX,EACA,CAAE5I,KAAM6I,EAAYq9B,IAAKp/B,GACzB,CAAEV,EAAGmhE,GAAS1/D,EAAG2/D,YA/gDI,KAqhDrBmH,aAAepkE,IAAoBtQ,IACzCA,EAAMmR,iBACNyY,KAAKoU,SAAS,CACZ7pB,2BAA4B,GAC5BG,mBAAoBsV,KAAKo2C,MAAM7rD,6BAEjC45D,GAAQG,aAAe,QA3hDI,KAsrDrBmG,iBAAmB,IAWpB,IAXqB,OAC1BplE,EAD0B,OAE1BC,EAF0B,qBAG1BylE,GAAuB,GAQnB,EACJ,MAAMC,EAAsBhrD,KAAKirD,yBAAyB5lE,EAAQC,GAE5D4lE,EACJH,GACA/qD,KAAKmrD,sCACH9lE,EACAC,EACA0a,KAAKo2C,MACLp2C,KAAK7b,OACLnU,OAAO2X,kBAGL8E,EAAUu+D,GAEZ9lD,GAAe,CACb3iB,EAAG2oE,EACCA,EAAqBz/C,eACrBpmB,EACJrB,EAAGknE,EACCA,EAAqBx/C,eACrBpmB,EACJoR,YAAasJ,KAAKo2C,MAAM3tD,uBACxByQ,gBAAiB8G,KAAKo2C,MAAMpuD,2BAC5ByO,UAAWuJ,KAAKo2C,MAAMluD,qBACtBuN,YAAauK,KAAKo2C,MAAMxtD,uBACxB8P,YAAasH,KAAKo2C,MAAMztD,uBACxBmQ,UAAWkH,KAAKo2C,MAAM7tD,qBACtB6N,QAAS4J,KAAKo2C,MAAM9tD,mBACpBwM,gBAAiBkL,KAAKo2C,MAAM1tD,2BAC5B/Q,KAAM,GACNiK,SAAUoe,KAAKo2C,MAAMhuD,oBACrB5G,WAAYwe,KAAKo2C,MAAMjuD,sBACvBwP,UAAWuzD,EACP,SACAlrD,KAAKo2C,MAAMvtD,qBACfoc,cAAeimD,EACX,SACAl8E,MAGVgxB,KAAKoU,SAAS,CAAEprB,eAAgByD,IAE5Bu+D,EAGGE,GAA8C,WAAtBz+D,EAAQkL,WACnCgK,GAAclV,EAAS,CAAEwY,cAAej2B,OAG1CgxB,KAAKD,MAAMU,mBAAmB,IACzBT,KAAKD,MAAMI,8BACd1T,IAKGy+D,GACHvpD,GAAclV,EAAS,CACrBzI,EAAGyI,EAAQzI,EAAIyI,EAAQzJ,SAAW,KAKxCgd,KAAKoU,SAAS,CACZprB,eAAgByD,IAGlBuT,KAAKorD,kBAAkB3+D,EAAS,CAC9B4+D,oBAAqBL,KAtwDI,KA0wDrBlD,wBACN1xE,IAIA,GAAI4pB,KAAKo2C,MAAMlsD,aACb,OAGF,GAA+B,cAA3B8V,KAAKo2C,MAAMhtD,YACb,OAGF,MAAMwa,EAAmBC,GACvB7D,KAAKD,MAAMK,cACXJ,KAAKo2C,OAGP,GAAgC,IAA5BxyC,EAAiBnwB,QAAgBsZ,GAAgB6W,EAAiB,IAapE,YAXG5D,KAAKo2C,MAAMltD,sBACZ8W,KAAKo2C,MAAMltD,qBAAqB0qB,YAAchQ,EAAiB,GAAGnoB,KAElEukB,KAAK4U,QAAQI,kBACbhV,KAAKoU,SAAS,CACZlrB,qBAAsB,IAAIyqB,GACxB/P,EAAiB,GACjB5D,KAAKD,WAOb7b,GAAY8b,KAAK7b,QAEjB,MAAQ5B,EAAG8C,EAAQrB,EAAGsB,GAAWV,GAC/BxO,EACA4pB,KAAKo2C,OAKP,GAFyB5yC,GAAoBxD,KAAKo2C,OAE7B3iE,OAAS,EAAG,CAC/B,MAAMshC,EAAa/U,KAAKoY,qBAAqB/yB,EAAQC,GAE/C0nD,EACJj4B,G5Gr+DoC,EAC1CtoB,EACA9B,IACG8B,EAAQ0W,SAASI,MAAMN,GAAYtY,EAAiBsY,K4Gm+DjDqoD,CAA6Bv2C,EAAY/U,KAAKo2C,MAAMzrD,kBAEtD,GAAIqiD,EAYF,YAXAhtC,KAAKoU,UAAUm1C,GACb7lD,GACE,IACK6lD,EACHtgE,eAAgB+jD,EAChBtiD,mBAAoB,CAAE,CAACqqB,EAAYt5B,KAAK,GACxCkP,iBAAkB,IAEpBqV,KAAKD,MAAMK,iBAOnBlc,GAAY8b,KAAK7b,QACZ/N,EAAMmJ,IAAsBygB,KAAKo2C,MAAM/qD,iBAC1C2U,KAAKyqD,iBAAiB,CACpBplE,SACAC,SACAylE,sBAAuB30E,EAAMsJ,UAj1DN,KAs1DrB6rE,wBACNn1E,IAEA4pB,KAAKwrD,YAAYp1E,EAAMyO,QAASzO,EAAM0O,QAASkb,KAAKo2C,MAAMttD,cAEtDq7D,GAAQ7P,SAAS/+C,IAAInf,EAAMizE,YAC7BlF,GAAQ7P,SAASl7D,IAAIhD,EAAMizE,UAAW,CACpC9mE,EAAGnM,EAAMyO,QACTb,EAAG5N,EAAM0O,UAIb,MAAMw/D,EAAeH,GAAQG,aAC7B,GAC4B,IAA1BH,GAAQ7P,SAASl9C,MACjB+sD,GAAQC,YACRE,GACAH,GAAQE,gBACR,CACA,MAAMv2D,EAASumD,GAAU8P,GAAQ7P,UAC3Br+B,EAASnoB,EAAOvL,EAAI4hE,GAAQC,WAAW7hE,EACvC2zB,EAASpoB,EAAO9J,EAAImgE,GAAQC,WAAWpgE,EAC7CmgE,GAAQC,WAAat2D,EAErB,MACM29D,EADWjX,GAAYzzC,MAAMC,KAAKmjD,GAAQ7P,SAASnkB,WAC1Bg0B,GAAQE,gBAEvCrkD,KAAKoU,UAAS,QAAC,KAAErvB,EAAF,QAAQE,EAAR,QAAiBC,EAAjB,WAA0BF,EAA1B,UAAsC/B,GAAvC,QAAwD,CACpEgC,QAASA,EAAUgxB,EAASlxB,EAAKvP,MACjC0P,QAASA,EAAUgxB,EAASnxB,EAAKvP,MACjCuP,KAAMggC,GACJK,GAAkBk/B,EAAemH,GACjC1mE,EACA,CAAE5I,KAAM6I,EAAYq9B,IAAKp/B,GACzB6K,GAEFjD,uBAAuB,MAEzBmV,KAAK0rD,2CAELvH,GAAQC,WACND,GAAQE,gBACRF,GAAQG,aACN,KAGN,GAAIV,IAAkBC,IAAaC,GACjC,OAGF,MAKM6H,EAL0B1oC,GAC9B8gC,GACA3tE,EAAMyO,QAAUmb,KAAKo2C,MAAMpxD,WAC3B5O,EAAM0O,QAAUkb,KAAKo2C,MAAMnzD,WAEmBqgC,aAC3CtjB,KAAKo2C,MAAMrtD,iBAAoBiX,KAAKo2C,MAAMlsD,eACzCyhE,EACFznE,GAAY8b,KAAK7b,QAEjBE,GAAkB2b,KAAK7b,OAAQ6b,KAAKo2C,MAAMhtD,cAI9C,MAAMyrB,EAAejwB,GAA4BxO,EAAO4pB,KAAKo2C,QACrD7zD,EAAG0wB,EAAejvB,EAAGkvB,GAAkB2B,EAE/C,GACE7U,KAAKo2C,MAAMltD,uBACV8W,KAAKo2C,MAAMltD,qBAAqB4qB,WACjC,CACA,MAAM5qB,EAAuByqB,GAAoBi4C,kBAC/Cx1E,EACA68B,EACAC,EACAlT,KAAKo2C,MAAMltD,qBACX8W,KAAKo2C,MAAMzsD,UAETT,IAAyB8W,KAAKo2C,MAAMltD,sBACtC8W,KAAKoU,SAAS,CAAElrB,yBAE+B,MAA7CA,EAAqB6qB,qBACvB/T,KAAK6rD,4BAA4Bh3C,GAEjC7U,KAAKoU,SAAS,CAAEnpB,kBAAmB,KAIvC,GAAIiC,GAAqB8S,KAAKo2C,MAAMhtD,aAAc,CAGhD,MAAM,gBAAEL,GAAoBiX,KAAKo2C,MAC7BnpD,GAAiBlE,GACnBiX,KAAK8rD,4CACH/iE,EACA,MACA8rB,EACA7U,KAAKo2C,MAAMprD,mBAGbgV,KAAK6rD,4BAA4Bh3C,GAIrC,GAAI7U,KAAKo2C,MAAMlsD,aAAc,CAC3B,MAAM,aAAEA,GAAiB8V,KAAKo2C,OACtB7zD,EAAGirB,EAAIxpB,EAAGypB,GAAOvjB,GAEnB,OAAE2E,EAAF,mBAAUoQ,GAAuB/U,EACjCmrB,EAAYxmB,EAAOA,EAAOpb,OAAS,GAkDzC,OAhDA4Q,GAAkB2b,KAAK7b,OAAQ6b,KAAKo2C,MAAMhtD,kBAEtCisB,IAAcpW,EAIdzQ,GACEykB,EAAgBzF,EAChB0F,EAAgBzF,EAChB4H,EAAU,GACVA,EAAU,KACP1oC,IAELg1B,GAAczX,EAAc,CAC1B2E,OAAQ,IAAIA,EAAQ,CAACokB,EAAgBzF,EAAI0F,EAAgBzF,MAG3DrpB,GAAU4b,KAAK7b,OAAQjX,IAAYK,SAKrCshB,EAAOpb,OAAS,GAChBwrB,GACAzQ,GACEykB,EAAgBzF,EAChB0F,EAAgBzF,EAChBxO,EAAmB,GACnBA,EAAmB,IACjBtyB,KAEJyX,GAAU4b,KAAK7b,OAAQjX,IAAYK,SACnCo0B,GAAczX,EAAc,CAC1B2E,OAAQA,EAAOpV,MAAM,GAAI,OAGvBmV,GAAYC,EAAQmR,KAAKo2C,MAAMrxD,KAAKvP,QACtC4O,GAAU4b,KAAK7b,OAAQjX,IAAYK,SAGrCo0B,GAAczX,EAAc,CAC1B2E,OAAQ,IACHA,EAAOpV,MAAM,GAAI,GACpB,CAACw5B,EAAgBzF,EAAI0F,EAAgBzF,QAS7C,GAD4BqT,QAAQ1qC,EAAM21E,UAGZ,cAA3B/rD,KAAKo2C,MAAMhtD,aACiB,SAA3B4W,KAAKo2C,MAAMhtD,YAEb,OAGF,MAAMiL,EAAW2L,KAAKD,MAAMK,cAEtBwD,EAAmBC,GAAoBxP,EAAU2L,KAAKo2C,OAC5D,GAC8B,IAA5BxyC,EAAiBnwB,QAChBk4E,GACA3rD,KAAKo2C,MAAMltD,sBAoBP,GAAI0a,EAAiBnwB,OAAS,IAAMk4E,EAAiB,CAC1D,MAAMx4C,EAAsBG,GAC1Blf,GAAgBwP,GAChBqP,EACAC,EACAlT,KAAKo2C,MAAMrxD,KACX3O,EAAMgyB,aAER,GAAI+K,EAOF,YANA/uB,GACE4b,KAAK7b,OACLqvB,GAA4B,CAC1BL,8BA/BN,CACA,MAAM64C,EAAiCh5C,GACrC3e,EACA2L,KAAKo2C,MACLnjC,EACAC,EACAlT,KAAKo2C,MAAMrxD,KACX3O,EAAMgyB,aAER,GACE4jD,GACAA,EAA+B74C,oBAM/B,YAJA/uB,GACE4b,KAAK7b,OACLqvB,GAA4Bw4C,IAuBlC,MAAMj3C,EAAa/U,KAAKoY,qBACtBvD,EAAatyB,EACbsyB,EAAa7wB,GAEgB,SAA3Bgc,KAAKo2C,MAAMhtD,YACbhF,GACE4b,KAAK7b,OACLyI,GAAcmoB,GAAc7nC,IAAYC,KAAOD,IAAYE,WAEpD4yB,KAAKo2C,MAAM/qD,gBACpBjH,GAAU4b,KAAK7b,OAAQjX,IAAYI,MAC1Bq+E,GAIRv1E,EAAMmJ,KACNw1B,IACC/U,KAAKisD,6CACHp3C,EACAjR,GAPJxf,GAAU4b,KAAK7b,OAAQjX,IAAYO,MAUnC2W,GAAU4b,KAAK7b,OAAQjX,IAAYM,OApkEV,KA2kErB0+E,gBAAmB91E,IACzB6tE,IAAwB,GA5kEG,KA+kErBkI,wBACN/1E,IAKA,MAAM4mD,EAAYngD,SAASuvE,eAQ3B,IAPA,OAAIpvB,QAAJ,IAAIA,OAAJ,EAAIA,EAAWqvB,aACbrvB,EAAUsvB,kBAGZtsD,KAAKusD,mDAAmDn2E,GACxD4pB,KAAKwsD,kCAAkCp2E,GAEnCytE,GACF,OASF,GANA7jD,KAAKoU,SAAS,CACZnqB,oBAAqB7T,EAAMgyB,YAC3Btf,aAAc,SAEhBkX,KAAKwrD,YAAYp1E,EAAMyO,QAASzO,EAAM0O,QAAS,QAE3Ckb,KAAKysD,qCAAqCr2E,GAC5C,OAIF,GACEA,EAAMs2E,SAAWh/E,IAAeC,MAChCyI,EAAMs2E,SAAWh/E,IAAeI,MAEhC,OAMF,GAHAkyB,KAAK2sD,2BAA2Bv2E,GAG5B+tE,GAAQ7P,SAASl9C,KAAO,EAC1B,OAKF,MAAMqoB,EAAmBzf,KAAK4sD,wBAAwBx2E,GAEtD,GAAI4pB,KAAK6sD,wBAAwBz2E,EAAOqpC,GACtC,OAMF,GAHAzf,KAAK8sD,oCACL9sD,KAAK+sD,kCAAkC32E,GAEnC4pB,KAAKgtD,6BAA6B52E,EAAOqpC,GAC3C,OAGF,GAA+B,SAA3Bzf,KAAKo2C,MAAMhtD,YAEb,YADA4W,KAAKitD,wBAAwB72E,EAAOqpC,GAE/B,GACsB,UAA3Bzf,KAAKo2C,MAAMhtD,aACgB,SAA3B4W,KAAKo2C,MAAMhtD,YAEX4W,KAAKktD,iCACH92E,EACA4pB,KAAKo2C,MAAMhtD,YACXq2B,QAEG,GAA+B,UAA3Bzf,KAAKo2C,MAAMhtD,YAAyB,CAI7C,GAFAhF,GAAU4b,KAAK7b,OAAQjX,IAAYE,YAE9B4yB,KAAKo2C,MAAM9qD,oBACd,OAGF0U,KAAKoU,SAAS,CACZrrB,gBAAiBiX,KAAKo2C,MAAM9qD,oBAC5BtC,eAAgBgX,KAAKo2C,MAAM9qD,oBAC3BA,oBAAqB,KACrBpB,aAAc,OAGhB,MAAM,EAAE3H,EAAF,EAAKyB,GAAMY,GAA4BxO,EAAO4pB,KAAKo2C,OACzDz0C,GAAc3B,KAAKo2C,MAAM9qD,oBAAqB,CAC5C/I,IACAyB,UAEkC,aAA3Bgc,KAAKo2C,MAAMhtD,YACpB4W,KAAKmtD,mCACH/2E,EACA4pB,KAAKo2C,MAAMhtD,YACXq2B,GAGFzf,KAAKotD,kCACHptD,KAAKo2C,MAAMhtD,YACXq2B,GAIJ,MAAM4tC,EACJrtD,KAAKstD,oCAAoC7tC,GAErCoI,EACJ7nB,KAAKutD,kCAAkC9tC,GAEnCsT,EAAY/yB,KAAKwtD,gCAAgC/tC,GACjDkrC,EAAU3qD,KAAKytD,8BAA8BhuC,GAEnDykC,GAAgBr8B,EAEX7nB,KAAKo2C,MAAM/qD,kBACdrb,OAAOkiD,iBAAiBnkD,IAAM2/E,aAAcL,GAC5Cr9E,OAAOkiD,iBAAiBnkD,IAAMsyD,WAAYxY,GAC1C73C,OAAOkiD,iBAAiBnkD,IAAM4/E,QAAS56B,GACvC/iD,OAAOkiD,iBAAiBnkD,IAAMqyD,MAAOuqB,GACrClrC,EAAiBmuC,eAAeC,OAASR,EACzC5tC,EAAiBmuC,eAAeE,KAAOjmC,EACvCpI,EAAiBmuC,eAAejD,QAAUA,EAC1ClrC,EAAiBmuC,eAAe76B,UAAYA,IAzsEnB,KA6sErBw5B,mDACNn2E,IAG0B,UAAtBA,EAAMgyB,cACR67C,IAAwB,EAEpBD,GAIFC,IAAwB,EAIxBD,GAAeh0E,OAAO2T,YAAW,KAC/BqgE,GAAe,EACVC,IACHjkD,KAAK+tD,wBAAwB33E,KAE9B7F,OAjuEoB,KAkvErBk8E,qCACNr2E,IAEA,GAE8B,IAA1B+tE,GAAQ7P,SAASl9C,QAChBhhB,EAAMs2E,SAAWh/E,IAAeE,OAC9BwI,EAAMs2E,SAAWh/E,IAAeC,MAAQi2E,IACzC5jD,KAAKo2C,MAAM/qD,iBAGf,OAAO,EAETw4D,IAAY,EAEZ,IAAImK,GAAqB,EACzB,MAAMC,EAAU,QAAQ/uE,KAAKlP,OAAOmP,UAAUC,UAE9CgF,GAAU4b,KAAK7b,OAAQjX,IAAYG,UACnC,IAAMwX,QAASqpE,EAAOppE,QAASqpE,GAAU/3E,EACzC,MAAMi3E,EAAgB3mE,IAAoBtQ,IACxC,MAAM6/B,EAASi4C,EAAQ93E,EAAMyO,QACvBqxB,EAASi4C,EAAQ/3E,EAAM0O,QAQ7B,GAPAopE,EAAQ93E,EAAMyO,QACdspE,EAAQ/3E,EAAM0O,QAOZmpE,IACCD,IACAhhF,KAAKiX,IAAIgyB,GAAU,GAAKjpC,KAAKiX,IAAIiyB,GAAU,GAC5C,CACA83C,GAAqB,EAGrB,MAAMI,EAAoBh4E,IACxByG,SAASoF,KAAKkwC,oBAAoBpkD,IAAMsgF,MAAOD,GAC/Ch4E,EAAMi9C,mBASFi7B,EAAkB,KACtB3qE,YAAW,KACT9G,SAASoF,KAAKkwC,oBAAoBpkD,IAAMsgF,MAAOD,GAC/Cp+E,OAAOmiD,oBAAoBpkD,IAAMsyD,WAAYiuB,KAC5C,MAGLzxE,SAASoF,KAAKiwC,iBAAiBnkD,IAAMsgF,MAAOD,GAC5Cp+E,OAAOkiD,iBAAiBnkD,IAAMsyD,WAAYiuB,GAG5CtuD,KAAKoU,SAAS,CACZnvB,QAAS+a,KAAKo2C,MAAMnxD,QAAUgxB,EAASjW,KAAKo2C,MAAMrxD,KAAKvP,MACvD0P,QAAS8a,KAAKo2C,MAAMlxD,QAAUgxB,EAASlW,KAAKo2C,MAAMrxD,KAAKvP,WAGrD+4E,EAAW7nE,GACdw9D,GAAgB,KACfA,GAAgB,KAChBL,IAAY,EACPD,KACC5jD,KAAKo2C,MAAM/qD,gBACbjH,GAAU4b,KAAK7b,OAAQjX,IAAYI,MAEnC+W,GAAkB2b,KAAK7b,OAAQ6b,KAAKo2C,MAAMhtD,cAG9C4W,KAAKoU,SAAS,CACZtrB,aAAc,OAEhBkX,KAAKwrD,YAAYp1E,EAAMyO,QAASzO,EAAM0O,QAAS,MAC/C9U,OAAOmiD,oBAAoBpkD,IAAM2/E,aAAcL,GAC/Cr9E,OAAOmiD,oBAAoBpkD,IAAMsyD,WAAYkuB,GAC7Cv+E,OAAOmiD,oBAAoBpkD,IAAMygF,KAAMD,KAQ3C,OALAv+E,OAAOkiD,iBAAiBnkD,IAAMygF,KAAMD,GACpCv+E,OAAOkiD,iBAAiBnkD,IAAM2/E,aAAcL,EAAe,CACzDoB,SAAS,IAEXz+E,OAAOkiD,iBAAiBnkD,IAAMsyD,WAAYkuB,IACnC,GA50EoB,KAm8ErBzB,kCAAoC,KACX,cAA3B9sD,KAAKo2C,MAAMhtD,aACb4W,KAAKoU,SAAS,CACZ1pB,mBAAoB,GACpBC,iBAAkB,GAClB1B,eAAgB,QAx8EO,KAg9ErB+jE,6BAA+B,CACrC52E,EACAqpC,KAEA,GAA+B,cAA3Bzf,KAAKo2C,MAAMhtD,YAA6B,CAC1C,MAAMiL,EAAW2L,KAAKD,MAAMK,cACtBwD,EAAmBC,GAAoBxP,EAAU2L,KAAKo2C,OAC5D,GAAgC,IAA5BxyC,EAAiBnwB,QAAiBusB,KAAKo2C,MAAMltD,qBAiBtC0a,EAAiBnwB,OAAS,IACnCgsC,EAAiBivC,OAAOC,WAAar7C,GACnClf,GAAgBwP,GAChB6b,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,EACxBgc,KAAKo2C,MAAMrxD,KACX3O,EAAMgyB,kBAvB6D,CACrE,MAAM4jD,EACJh5C,GACE3e,EACA2L,KAAKo2C,MACL32B,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,EACxBgc,KAAKo2C,MAAMrxD,KACX3O,EAAMgyB,aAE4B,MAAlC4jD,IACFhsD,KAAKoU,SAAS,CACZ5pB,gBAAiBwhE,EAA+Bv/D,UAElDgzB,EAAiBivC,OAAOC,WACtB3C,EAA+B74C,qBAWrC,GAAIsM,EAAiBivC,OAAOC,WAC1BvqE,GACE4b,KAAK7b,OACLqvB,GAA4B,CAC1BL,oBAAqBsM,EAAiBivC,OAAOC,cAGjDlvC,EAAiBivC,OAAO3kE,YAAa,EACrC01B,EAAiBivC,OAAOh2E,OAASmN,GhG7jER,EAC/BstB,EACAvP,EACArhB,EACAyB,KAEA,MAAOqJ,EAAIC,EAAIC,EAAIC,GACW,IAA5BoW,EAAiBnwB,OACbqe,GAAyB8R,EAAiB,IAC1CxP,GAAgBwP,GAChBtQ,GAAMjG,EAAKE,GAAM,EACjBgG,GAAMjG,EAAKE,GAAM,EACjBC,EAAoC,IAA5BmW,EAAiBnwB,OAAemwB,EAAiB,GAAGnW,MAAQ,EAE1E,QADClL,EAAGyB,GAAKoJ,GAAO7K,EAAGyB,EAAGsP,EAAIC,GAAK9F,GACvB0lB,GACN,IAAK,IACH,OAAO/lB,GAAO7K,GAAK8K,EAAKE,GAAM,EAAGvJ,EAAIsJ,EAAI,EAAG,EAAGG,GACjD,IAAK,IACH,OAAOL,GAAO7K,GAAK8K,EAAKE,GAAM,EAAGvJ,EAAIwJ,EAAI,EAAG,EAAGC,GACjD,IAAK,IACH,OAAOL,GAAO7K,EAAI8K,EAAIrJ,GAAKsJ,EAAKE,GAAM,EAAG,EAAG,EAAGC,GACjD,IAAK,IACH,OAAOL,GAAO7K,EAAIgL,EAAIvJ,GAAKsJ,EAAKE,GAAM,EAAG,EAAG,EAAGC,GACjD,IAAK,KACH,OAAOL,GAAO7K,EAAI8K,EAAIrJ,EAAIsJ,EAAI,EAAG,EAAGG,GACtC,IAAK,KACH,OAAOL,GAAO7K,EAAIgL,EAAIvJ,EAAIsJ,EAAI,EAAG,EAAGG,GACtC,IAAK,KACH,OAAOL,GAAO7K,EAAI8K,EAAIrJ,EAAIwJ,EAAI,EAAG,EAAGC,GACtC,IAAK,KACH,OAAOL,GAAO7K,EAAIgL,EAAIvJ,EAAIwJ,EAAI,EAAG,EAAGC,GACtC,QACE,MAAO,CAAC,EAAG,KgG8hEPmhE,CACEnvC,EAAiBivC,OAAOC,WACxB/qD,EACA6b,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,IAIE,IAA5B4f,EAAiBnwB,QACjBsZ,GAAgB6W,EAAiB,KACK,IAAtCA,EAAiB,GAAG/U,OAAOpb,SAE3BgsC,EAAiBivC,OAAOG,ehGtiEK,EACrC17C,EACA1mB,KAEA,MAAO,EAAGqO,EAAIC,IAAOtO,EAAQoC,OAM7B,MAJ2B,OAAxBskB,IAAiCrY,EAAK,GAAKC,EAAK,IACxB,OAAxBoY,GAAgCrY,GAAM,GACd,OAAxBqY,GAAgCrY,GAAM,GACd,OAAxBqY,IAAiCrY,EAAK,GAAKC,EAAK,GAC9B,MAAQ,UgG4hEoB+zD,CACvCrvC,EAAiBivC,OAAOC,WACxB/qD,EAAiB,SAGhB,CAAC,IAAD,EACL,GAAI5D,KAAKo2C,MAAMltD,qBAAsB,CACnC,MAAM1F,EAAMmwB,GAAoBo7C,kBAC9B34E,EACA4pB,KAAKo2C,OACJzqD,GAAaqU,KAAKoU,SAASzoB,IAC5BqU,KAAK4U,QACL6K,EAAiBvvC,QAKnB,GAHIsT,EAAIuxB,aACN0K,EAAiBuvC,IAAIviE,QAAUjJ,EAAIuxB,YAEjCvxB,EAAIsxB,YACN,OAAO,EAKX2K,EAAiBuvC,IAAIviE,QAArB,UACEgzB,EAAiBuvC,IAAIviE,eADvB,QAEEuT,KAAKoY,qBACHqH,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,GAK5By7B,EAAiBuvC,IAAIC,eAAiBjvD,KAAKkvD,sBACzCzvC,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,GAG1B,MAAM+wB,EAAa0K,EAAiBuvC,IAAIviE,QAClC0iE,EACJ1vC,EAAiBuvC,IAAIC,eAAetgD,MAAMliB,GACxCuT,KAAKovD,mBAAmB3iE,KAW5B,GARkB,OAAfsoB,GAAwBo6C,GACxB/4E,EAAMwJ,UACN6/B,EAAiBuvC,IAAIK,2CAEtBrvD,KAAKsvD,eAAev6C,GAIJ,MAAdA,EAAoB,CAEtB,GAAI3+B,EAAMmJ,GASR,OARKygB,KAAKo2C,MAAM1rD,mBAAmBqqB,EAAWt5B,MAC5CgkC,EAAiBuvC,IAAIO,qBAAsB,GAE7CvvD,KAAKoU,UAAUm1C,IAAD,W5GhwFxB59D,E4GiwF2C49D,E5GhwF3C98D,E4GgwFsDsoB,E5G9vF/C,IACFppB,EACH1C,eAAgBwD,EAAQ0W,SAAS1vB,OAASgZ,EAAQ0W,SAAS,GAAK,KAChExY,iBAAkB,GAClBD,mBAAoB,CAClB,CAAC+B,EAAQhR,KAAK,K4G0vFN8O,2BAA4ByV,KAAKo2C,MAAM1rD,oB5GnwFV,IACzCiB,EACAc,M4GowFiB,EAOJuT,KAAKo2C,MAAM1rD,mBAAmBqqB,EAAWt5B,MAG1CukB,KAAKo2C,MAAMntD,iBACVgb,GAAiB8Q,EAAY/U,KAAKo2C,MAAMntD,iBAEzC+W,KAAKoU,SAAS,CACZ1pB,mBAAoB,GACpBC,iBAAkB,GAClB1B,eAAgB,OAQjBkmE,GACA1vC,EAAiBuvC,IAAIK,4CAEtBrvD,KAAKoU,UAAUm1C,GACN7lD,GACL,IACK6lD,EACH7+D,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAACqqB,EAAWt5B,KAAK,IAGrBukB,KAAKD,MAAMK,iBAGfqf,EAAiBuvC,IAAIO,qBAAsB,IAKjDvvD,KAAKoU,SAAS,CACZ7pB,2BAA4ByV,KAAKo2C,MAAM1rD,sBAI7C,OAAO,GArnFoB,KA+oFrBuiE,wBAA0B,CAChC72E,EACAqpC,KACU,IAAD,EAI+B,UAApC,UAAAzf,KAAKo2C,MAAMptD,sBAAX,eAA2B7H,QAI/B6e,KAAKyqD,iBAAiB,CACpBplE,OAAQo6B,EAAiBvvC,OAAOqS,EAChC+C,OAAQm6B,EAAiBvvC,OAAO8T,EAChC+mE,sBAAuB30E,EAAMsJ,SAG/BwE,GAAY8b,KAAK7b,QACZ6b,KAAKo2C,MAAMjtD,eACd6W,KAAKoU,SAAS,CACZhrB,YAAa,gBAnqFU,KAwqFrB+jE,mCAAqC,CAC3C/2E,EACAgT,EACAq2B,KAGA,MAAOwpC,EAAOC,GAASz4D,GACrBgvB,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,EACxB,MAGIyI,G3G5vFRqY,E2G4vFqC,CACjC3jB,KAAMiI,EACN7G,EAAG0mE,EACHjlE,EAAGklE,EACHxyD,YAAasJ,KAAKo2C,MAAM3tD,uBACxByQ,gBAAiB8G,KAAKo2C,MAAMpuD,2BAC5ByO,UAAWuJ,KAAKo2C,MAAMluD,qBACtBuN,YAAauK,KAAKo2C,MAAMxtD,uBACxB8P,YAAasH,KAAKo2C,MAAMztD,uBACxBmQ,UAAWkH,KAAKo2C,MAAM7tD,qBACtB6N,QAAS4J,KAAKo2C,MAAM9tD,mBACpBwM,gBAAiBkL,KAAKo2C,MAAM/tD,iCAC5BsW,iBAAqC,KAAnBvoB,EAAMo5E,U3GlwFrB,IACF/qD,GAA2CK,EAAK3jB,KAAM2jB,GACzDjW,OAAQiW,EAAKjW,QAAU,GACvB+P,UAAW,GACXD,iBAAkBmG,EAAKnG,iBACvBM,mBAAoB,OAXtB6F,M2G2wFE9E,KAAKoU,UAAUm1C,IAAD,CACZ7+D,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAAC+B,EAAQhR,KAAK,OAIlB,MAAMmjB,EAAYnS,EAAQkS,iBACtBlS,EAAQmS,UACR,IAAInS,EAAQmS,UAAWxoB,EAAMo5E,UAEjC7tD,GAAclV,EAAS,CACrBoC,OAAQ,CAAC,CAAC,EAAG,IACb+P,cAGF,MAAMua,EAAezE,GACnB+K,EAAiBvvC,OACjB8vB,KAAKD,OAEPC,KAAKD,MAAMU,mBAAmB,IACzBT,KAAKD,MAAMI,8BACd1T,IAEFuT,KAAKoU,SAAS,CACZrrB,gBAAiB0D,EACjBzD,eAAgByD,EAChBzB,kBAAmBmuB,EACnBluB,kBAAmB,MA/tFM,KAmuFrBq9D,mBAAqB,IAMtB,IANuB,OAC5BjjE,EAD4B,OAE5BC,GAII,EACJ,MAAO2jE,EAAOC,GAASz4D,GAAapL,EAAQC,EAAQ0a,KAAKo2C,MAAMzsD,U3G/wFjEmb,M2G+xFE,O3G/xFFA,E2GixFkC,CAC9B3jB,KAAM,QACNoB,EAAG0mE,EACHjlE,EAAGklE,EACHxyD,YAAasJ,KAAKo2C,MAAM3tD,uBACxByQ,gBAAiB8G,KAAKo2C,MAAMpuD,2BAC5ByO,UAAWuJ,KAAKo2C,MAAMluD,qBACtBuN,YAAauK,KAAKo2C,MAAMxtD,uBACxB8P,YAAasH,KAAKo2C,MAAMztD,uBACxBmQ,UAAWkH,KAAKo2C,MAAM7tD,qBACtB6N,QAAS4J,KAAKo2C,MAAM9tD,mBACpBwM,gBAAiBkL,KAAKo2C,MAAM/tD,kC3GxxFzB,IACFoc,GAAwC,QAASK,GAGpDpO,YAAa,cACbY,OAAQ,UACR5K,OAAQ,KACR2P,MAAO,CAAC,EAAG,K2G0BgB,KA6vFrB6wD,iCAAmC,CACzC92E,EACAgT,EACAq2B,KAEA,GAAIzf,KAAKo2C,MAAMlsD,aAAc,CAC3B,MAAM,aAAEA,GAAiB8V,KAAKo2C,MAG9B,GACwB,SAAtBlsD,EAAa/I,MACbyN,GAAY1E,EAAa2E,OAAQmR,KAAKo2C,MAAMrxD,KAAKvP,OAOjD,OALAmsB,GAAczX,EAAc,CAC1B+U,mBACE/U,EAAa2E,OAAO3E,EAAa2E,OAAOpb,OAAS,UAErDusB,KAAK83C,cAAc5E,cAAcxa,IAInC,MAAQn2C,EAAGirB,EAAIxpB,EAAGypB,EAAZ,mBAAgBxO,GAAuB/U,EAG7C,GACEA,EAAa2E,OAAOpb,OAAS,GAC7BwrB,GACAzQ,GACEixB,EAAiBvvC,OAAOqS,EAAIirB,EAC5BiS,EAAiBvvC,OAAO8T,EAAIypB,EAC5BxO,EAAmB,GACnBA,EAAmB,IACjBtyB,IAGJ,YADAqzB,KAAK83C,cAAc5E,cAAcxa,IAInC14B,KAAKoU,UAAUm1C,IAAD,CACZ7+D,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAACR,EAAazO,KAAK,OAKvBkmB,GAAczX,EAAc,CAC1B+U,mBAAoB/U,EAAa2E,OAAO3E,EAAa2E,OAAOpb,OAAS,KAEvE2Q,GAAU4b,KAAK7b,OAAQjX,IAAYK,aAC9B,CACL,MAAO07E,EAAOC,GAASz4D,GACrBgvB,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,EACxBgc,KAAKo2C,MAAMzsD,WAQP,0BAAEnB,EAAF,wBAA6BP,GAA4B+X,KAAKo2C,OAC7Dl8C,EAAgBC,GACL,UAAhB/Q,EACI,CAACZ,EAA2BP,GAC5B,CAAC,KAAM,MAEPwE,EAAUqZ,GAAiB,CAC/B3kB,KAAMiI,EACN7G,EAAG0mE,EACHjlE,EAAGklE,EACHxyD,YAAasJ,KAAKo2C,MAAM3tD,uBACxByQ,gBAAiB8G,KAAKo2C,MAAMpuD,2BAC5ByO,UAAWuJ,KAAKo2C,MAAMluD,qBACtBuN,YAAauK,KAAKo2C,MAAMxtD,uBACxB8P,YAAasH,KAAKo2C,MAAMztD,uBACxBmQ,UAAWkH,KAAKo2C,MAAM7tD,qBACtB6N,QAAS4J,KAAKo2C,MAAM9tD,mBACpBwM,gBAAiBkL,KAAKo2C,MAAM/tD,iCAC5B6R,iBACAC,iBAEF6F,KAAKoU,UAAUm1C,IAAD,CACZ7+D,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAAC+B,EAAQhR,KAAK,OAGlBkmB,GAAclV,EAAS,CACrBoC,OAAQ,IAAIpC,EAAQoC,OAAQ,CAAC,EAAG,MAElC,MAAMsqB,EAAezE,GACnB+K,EAAiBvvC,OACjB8vB,KAAKD,OAEPC,KAAKD,MAAMU,mBAAmB,IACzBT,KAAKD,MAAMI,8BACd1T,IAEFuT,KAAKoU,SAAS,CACZrrB,gBAAiB0D,EACjBzD,eAAgByD,EAChBzB,kBAAmBmuB,EACnBluB,kBAAmB,OAr2FI,KA02FrBmiE,kCAAoC,CAC1ChkE,EACAq2B,KAEA,MAAOwpC,EAAOC,GAASz4D,GACrBgvB,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,EACxBgc,KAAKo2C,MAAMzsD,UAEP8C,EAAUoY,GAAW,CACzB1jB,KAAMiI,EACN7G,EAAG0mE,EACHjlE,EAAGklE,EACHxyD,YAAasJ,KAAKo2C,MAAM3tD,uBACxByQ,gBAAiB8G,KAAKo2C,MAAMpuD,2BAC5ByO,UAAWuJ,KAAKo2C,MAAMluD,qBACtBuN,YAAauK,KAAKo2C,MAAMxtD,uBACxB8P,YAAasH,KAAKo2C,MAAMztD,uBACxBmQ,UAAWkH,KAAKo2C,MAAM7tD,qBACtB6N,QAAS4J,KAAKo2C,MAAM9tD,mBACpBwM,gBAAiBkL,KAAKo2C,MAAM1tD,6BAGT,cAAjB+D,EAAQtL,KACV6e,KAAKoU,SAAS,CACZxpB,iBAAkB6B,EAClB1D,gBAAiB0D,KAGnBuT,KAAKD,MAAMU,mBAAmB,IACzBT,KAAKD,MAAMI,8BACd1T,IAEFuT,KAAKoU,SAAS,CACZlqB,aAAc,KACdnB,gBAAiB0D,EACjBzD,eAAgByD,MA94FO,KA+kHrBgjE,gBAAkBr8E,UAQnB,IAAD,UAR2B,UAC/Bs8E,EACArH,aAAcsH,EAFiB,uBAG/BC,GAAyB,GAKrB,EAGJ,IAAKhtB,GAAqB8sB,GACxB,MAAM,IAAIn5E,MAAMoF,EAAE,+BAEpB,MAAM2gB,EAAWozD,EAAUvuE,KAI3B,GAFAiD,GAAU4b,KAAK7b,OAAQ,QAEnBmY,IAAantB,IAAWI,IAC1B,IACEmgF,EAAY7rB,QxDnyHQzwD,WAC1B,MAAMy8E,GAAM,IAAIC,WAAYC,gBAAgBjsB,EAAW30D,IAAWI,KAC5DA,EAAMsgF,EAAIzoE,cAAc,OAE9B,GADkByoE,EAAIzoE,cAAc,gBANI,SAA7B,QAHoBuW,EAUIpuB,SAPxB,IAAJouB,OAAA,EAAAA,EAAMlZ,SAASyuC,eAQpB,MAAM,IAAI38C,MAAMoF,EAAE,4BAMlB,OAJKpM,EAAIygF,aAAa,UACpBzgF,EAAImoB,aAAa,QAAS9kB,KAGrBrD,EAAIk7D,UAjBkB9sC,OwD0yHjBsyD,OAAmBP,EAAU/3E,QACnC+3E,EAAUl8E,MAEZ,MAAOsE,GAEP,MADAC,QAAQw0B,KAAKz0B,GACP,IAAIvB,MAAMoF,EAAE,+BAMtB,MAAM+Q,SAAgB,WAAC,EAAAsT,KAAKomB,OAAM8pC,yBAAZ,aAAC,SACrBR,K1D5sH4Bt8E,WAChC,IAAIqI,EACJ,IACE,MAAM00E,QAAmBngF,OAAOiD,OAAOK,OAAO88E,OAC5C,cACMhlC,EAAKz2C,eAEb8G,EAEEslB,MAAMC,KAAK,IAAIhuB,WAAWm9E,IAEvBn1E,KAAKq1E,GAASA,EAAKjqD,SAAS,IAAI9lB,SAAS,EAAG,OAC5CkC,KAAK,IACV,MAAO1K,GACPC,QAAQD,MAAMA,GAEd2D,EAAKimB,aAAO,IAGd,OAAOjmB,G0D0rHoB60E,CAAmBZ,IAE5C,IAAKhjE,EAIH,MAHA3U,QAAQw0B,KACN,wFAEI,IAAIh2B,MAAMoF,EAAE,4BAGpB,MAAM40E,EAAmBvwD,KAAKzC,MAAM7Q,GACpC,KAAI,OAAC6jE,QAAD,IAACA,OAAD,EAACA,EAAkBryD,SAAS,CAC9B,IACEwxD,QAAkBtsB,GAChBssB,EACAj9E,KAEF,MAAOqF,GACPC,QAAQD,MAAM,iDAAkDA,GAGlE,GAAI43E,EAAUt4D,KAAOzkB,IACnB,MAAM,IAAI4D,MACRoF,EAAE,oBAAqB,CACrB60E,QAAQ,GAAD,OAAKxjF,KAAK0+D,MAAM/4D,IAAyB,KAAO,MAAhD,SAMf,GAAIi9E,EAAwB,CAAC,IAAD,EAC1B,MAAM1xD,EAAO,UAAG8B,KAAKzC,MAAM7Q,UAAd,aAAG,EAAoBwR,QAI9BuyD,EAAcvyD,G1D7sHG,SAACA,GAAqC,IAAnB6lC,EAAkB,uDAAP,GACzD,MAAM2sB,EAAiBxyD,EAAQ8F,QAAQ,KACjCttB,EAAae,KAAKymB,EAAQzkB,MAAMi3E,EAAiB,IACjDp0D,EAAW4B,EAAQzkB,MAAM,EAAGi3E,GAAgBjzE,MAAM,KAAK,GAAGA,MAAM,KAAK,GAErEkzE,EAAK,IAAIh6E,YAAYD,EAAWjD,QAChCm9E,EAAK,IAAI59E,WAAW29E,GAC1B,IAAK,IAAI95E,EAAI,EAAGA,EAAIH,EAAWjD,OAAQoD,IACrC+5E,EAAG/5E,GAAKH,EAAWK,WAAWF,GAEhC,OAAO,IAAI+sD,KAAK,CAAC+sB,GAAK5sB,EAAU,CAAE5iD,KAAMmb,I0DmsHLu0D,CAAc3yD,GAE7C8B,KAAK8wD,sBAAsBL,GAAef,GAG5C,MAAMxxD,GACJ,UAAA8B,KAAKzC,MAAM7Q,UAAX,eAAoBwR,gBAAkB+kC,GAAWysB,GAE7CrH,EAAe1mD,GACnBguD,EACA,CACEjjE,WAEF,GAGF,OAAO,IAAI7W,SACTzC,MAAO0C,EAASC,KACd,IAAK,IAAD,IACFiqB,KAAKzC,MAAQ,IACRyC,KAAKzC,MACR,CAAC7Q,GAAS,CACR4P,WACA7gB,GAAIiR,EACJwR,UACA6yD,QAAS9wE,KAAKshB,QAGlB,MAAMyvD,EAAkBhxD,KAAK1K,WAAWsB,IAAIlK,GACvCskE,IACHhxD,KAAKqlD,iCACCrlD,KAAKwkC,iBAAiB,CAAC6jB,MAEZ,OAAf2I,QAAe,IAAfA,OAAA,EAAAA,EAAiB/5D,iBAAiBphB,eAC9Bm7E,EAAgB/5D,OAGtB,UAAA+I,KAAKo2C,MAAM9qD,2BAAX,eAAgC7P,MAAO4sE,EAAa5sE,KACpD,UAAAukB,KAAKo2C,MAAMrtD,uBAAX,eAA4BtN,MAAO4sE,EAAa5sE,IAEhDukB,KAAKwoD,0BAA0BH,GAAc,GAE/CvyE,EAAQuyE,GACR,MAAOvwE,GACPC,QAAQD,MAAMA,GACd/B,EAAO,IAAIQ,MAAMoF,EAAE,6BA3BrB,QA6BOi0E,GACH1rE,GAAY8b,KAAK7b,aAnsHE,KA6sHrBokE,mBAAqBn1E,MAC3Bi1E,EACAqH,EACAE,KAEA5vD,KAAKD,MAAMU,mBAAmB,IACzBT,KAAKD,MAAMI,8BACdkoD,IAGF,UACQroD,KAAKyvD,gBAAgB,CACzBC,YACArH,eACAuH,2BAEF,MAAO93E,GACP6pB,GAAc0mD,EAAc,CAC1BzjD,WAAW,IAEb5E,KAAK83C,cAAc5E,cAAcxa,IACjC14B,KAAKoU,SAAS,CACZ/qB,aAAcvR,EAAM0tC,SAAW7pC,EAAE,+BAnuHV,KAwuHrBm1E,sBAAwB19E,UAG9B,MAEM69E,QAAqB7tB,GAAgBssB,EAFjB,IAI1B,IAAIwB,QAAuBjuB,GAAWguB,GAItC,GAAIvB,EAAUvuE,OAAShS,IAAWI,IAAK,CACrC,MAAMynB,QAAYstC,GAAqB4sB,GAEvC,IAAIvuE,EAAS3V,KAAK2T,IAAIqW,EAAIrU,OAXF,IAYpBF,EAAQE,GAAUqU,EAAIvU,MAAQuU,EAAIrU,QAElCF,EAdoB,KAetBA,EAfsB,GAgBtBE,EAASF,GAASuU,EAAIrU,OAASqU,EAAIvU,QAGrC,MAAM0B,EAAStH,SAASmF,cAAc,UACtCmC,EAAOxB,OAASA,EAChBwB,EAAO1B,MAAQA,EACC0B,EAAO4X,WAAW,MAE1B1E,UAAUL,EAAK,EAAG,EAAGvU,EAAOE,GAEpCuuE,EAAiB/sE,EAAOgtE,UAAUhiF,IAAWI,KAG3CywB,KAAKo2C,MAAM9qD,qBACblH,GAAU4b,KAAK7b,OAAN,cAAqB+sE,EAArB,iBAzwHgB,KA6wHrB9X,cAAgBhmE,iBAElB,IADJ,uBAAEuqE,GACC,uDAD0B,CAAEA,wBAAwB,GAEvD,IACE,MAAM94D,EAAU,EAAKuxD,MAAM3zD,MAAQ,EAAI,EAAK2zD,MAAMpxD,WAC5CF,EAAU,EAAKsxD,MAAMzzD,OAAS,EAAI,EAAKyzD,MAAMnzD,WAE7C,EAAEV,EAAF,EAAKyB,GAAMY,GACf,CAAEC,UAASC,WACX,EAAKsxD,OAGDsZ,QAAkBjwB,GAAS,CAC/BI,YAAa,QACbF,WAAY,CAAC,MAAO,MAAO,MAAO,SAG9B0oB,EAAe,EAAKC,mBAAmB,CAC3CjjE,OAAQ9C,EACR+C,OAAQtB,IAGN25D,GACF,EAAK4K,mBAAmBF,EAAcqH,GACtC,EAAKlH,0BAA0BH,GAC/B,EAAKj0C,SACH,CACE1pB,mBAAoB,CAAE,CAAC29D,EAAa5sE,KAAK,KAE3C,KACE,EAAKq8D,cAAc5E,cAAcxa,QAIrC,EAAKtkB,SACH,CACE9oB,oBAAqB+8D,IAEvB,KACE,EAAKE,mBACHF,EACAqH,GAC6B,MAKrC,MAAO53E,GACY,eAAfA,EAAMtE,MACRuE,QAAQD,MAAMA,GAEhB,EAAKs8B,SACH,CACE9oB,oBAAqB,KACrBtC,eAAgB,KAChBI,YAAa,cAEf,KACE,EAAK0uD,cAAc5E,cAAcxa,SAv0HZ,KA60HrB8vB,0BAA4B,SAClCH,GAEI,IAAD,MADH+I,EACG,wDACH,MAAMn6D,EACJzK,GAA0B67D,KAA1B,UACA,EAAK/yD,WAAWsB,IAAIyxD,EAAa37D,eADjC,aACA,EAA0CuK,OAE5C,IAAKA,GAASA,aAAiBphB,SAC7B,GACEwyE,EAAa5lE,MAAQ/V,IAAqB,EAAK0pE,MAAMrxD,KAAKvP,OAC1D6yE,EAAa1lE,OAASjW,IAAqB,EAAK0pE,MAAMrxD,KAAKvP,MAC3D,CACA,MAAM67E,EAAkB,IAAM,EAAKjb,MAAMrxD,KAAKvP,MAC9CmsB,GAAc0mD,EAAc,CAC1B9lE,EAAG8lE,EAAa9lE,EAAI8uE,EAAkB,EACtCrtE,EAAGqkE,EAAarkE,EAAIqtE,EAAkB,EACtC5uE,MAAO4uE,EACP1uE,OAAQ0uE,UAOd,GACED,GAIC/I,EAAa5lE,MAAQ/V,IAAqB,EAAK0pE,MAAMrxD,KAAKvP,OACzD6yE,EAAa1lE,OAASjW,IAAqB,EAAK0pE,MAAMrxD,KAAKvP,MAC7D,CACA,MAAM87E,EAAYtkF,KAAK+iB,IAAI,EAAKqmD,MAAMzzD,OAAS,IAAK,KAE9Cy/D,EAAYp1E,KAAK2T,IACrB2wE,EACAtkF,KAAK8sB,MAA0B,GAApB,EAAKs8C,MAAMzzD,QAAgB,EAAKyzD,MAAMrxD,KAAKvP,OAGlDmN,EAAS3V,KAAK2T,IAAIsW,EAAMs6D,cAAenP,GACvC3/D,EAAQE,GAAUsU,EAAMu6D,aAAev6D,EAAMs6D,eAI7ChvE,EAAI8lE,EAAa9lE,EAAI8lE,EAAa5lE,MAAQ,EAAIA,EAAQ,EACtDuB,EAAIqkE,EAAarkE,EAAIqkE,EAAa1lE,OAAS,EAAIA,EAAS,EAE9Dgf,GAAc0mD,EAAc,CAAE9lE,IAAGyB,IAAGvB,QAAOE,aA73HlB,KAm4HrB6hD,iBAAmBpxD,eACzBihB,GAEI,IADJkJ,EACG,uDADK,EAAKA,MAEb,MAAM,aAAEmnC,EAAF,aAAgBC,SAAuB8sB,GAAkB,CAC7Dn8D,WAAY,EAAKA,WACjBmvC,QAASpwC,EAASrZ,KAAKyR,GAAYA,EAAQC,SAC3C6Q,UAEF,GAAImnC,EAAattC,MAAQutC,EAAavtC,KACpC,IAAK,MAAM3K,KAAW4H,EAChBqwC,EAAanvC,IAAI9I,EAAQC,SAC3B2L,GAA0B5L,GAoBhC,OAhBIk4C,EAAavtC,MACf,EAAK2I,MAAMU,mBACT,EAAKV,MAAMI,8BAA8BnlB,KAAKyR,GAE1CD,GAA0BC,IAC1Bk4C,EAAapvC,IAAI9I,EAAQC,QAElB2V,GAAe5V,EAAS,CAC7B6K,OAAQ,UAGL7K,KAKN,CAAEi4C,eAAcC,iBAn6HI,KAu6HrB0gB,yBAA2BjyE,iBAK7B,IAJJs+E,EAIG,uDAJkD5sB,GACnD,EAAK/kC,MAAMK,eAEb7C,EACG,uDADkB,EAAKA,MAE1B,MAAMo0D,EAAwBD,EAAcr1E,QACzCoQ,IAAaA,EAAQmY,YAAc,EAAKtP,WAAWC,IAAI9I,EAAQC,UAGlE,GAAIilE,EAAsBl+E,OAAQ,CAChC,MAAM,aAAEixD,SAAuB,EAAKF,iBAClCmtB,EACAp0D,GAEEmnC,EAAattC,MACf,EAAK2I,MAAMc,mBAv7HY,KA87HrB+wD,qBAAuBC,MAAS,KACtC7xD,KAAKqlD,6BACJh1E,KAh8H0B,KAk8HrB08E,kCACN32E,IAEA,MAAM07E,EjGlsIR17E,KAEQA,EAAMmJ,GiGgsIgBwyE,CAAmC37E,GAC3D4pB,KAAKo2C,MAAMxsD,mBAAqBkoE,GAClC9xD,KAAKoU,SAAS,CAAExqB,iBAAkBkoE,KAv8HT,KA28HrBjG,4BAA+Bj0C,IAIrC,MAAMo6C,EAAyBt9C,GAC7BkD,EACA5X,KAAKD,OAEPC,KAAKoU,SAAS,CACZnpB,kBAC4B,MAA1B+mE,EAAiC,CAACA,GAA0B,MAr9HrC,KAy9HrBlG,4CAA8C,CACpDp1C,EACAO,EACAW,EAMAq6C,KAEA,MAAMD,EAAyBt9C,GAC7BkD,EACA5X,KAAKD,OAEPC,KAAKoU,SAAS,CACZnpB,kBAC4B,MAA1B+mE,GACCh6C,GACCtB,EADmC,OAEnCu7C,QAFmC,IAEnCA,OAFmC,EAEnCA,EAA6Bx2E,GAC7Bu2E,GAGE,GADA,CAACA,MAh/HkB,KA+gIrBE,gBAAmB/tE,IAWjB,IAAD,MATQ,OAAXA,GACF6b,KAAK7b,OAASA,EACd6b,KAAK/J,GAAKtB,KAAMxQ,OAAO6b,KAAK7b,QAE5B6b,KAAK7b,OAAO+tC,iBAAiBnkD,IAAMH,MAAOoyB,KAAKmyD,YAAa,CAC1D1D,SAAS,IAEXzuD,KAAK7b,OAAO+tC,iBAAiBnkD,IAAMqkF,YAAapyD,KAAK2nD,YACrD3nD,KAAK7b,OAAO+tC,iBAAiBnkD,IAAMskF,UAAWryD,KAAK+nD,YAEnD,UAAA/nD,KAAK7b,cAAL,SAAaguC,oBAAoBpkD,IAAMH,MAAOoyB,KAAKmyD,aACnD,UAAAnyD,KAAK7b,cAAL,SAAaguC,oBAAoBpkD,IAAMqkF,YAAapyD,KAAK2nD,YACzD,UAAA3nD,KAAK7b,cAAL,SAAaguC,oBAAoBpkD,IAAMskF,UAAWryD,KAAK+nD,YA7hI9B,KAiiIrBuK,gBAAkBl/E,UAAmD,IAAD,IAC1E,IACE,MAAMg4C,EAAOh1C,EAAMgmE,aAAa7+C,MAAM,GAEtC,GAAIqlC,GAAqBxX,GAAO,CAI9B,IAAQ,OAAJA,QAAI,IAAJA,OAAA,EAAAA,EAAMjqC,QAAShS,IAAWK,MAAW,OAAJ47C,QAAI,IAAJA,OAAA,EAAAA,EAAMjqC,QAAShS,IAAWI,IAC7D,IACE,GAAIy8D,KACF,IAGE,MAAMtV,EAAOtgD,EAAMgmE,aAAa3N,MAAM,GACrCrjB,EAAa9nC,aACZozC,EACA67B,wBACF,MAAOz6E,GACPC,QAAQw0B,KAAKz0B,EAAMtE,KAAMsE,EAAM0tC,SAInC,MAAMzlB,QAAc8iC,GAClBzX,EACAprB,KAAKo2C,MACLp2C,KAAKD,MAAMI,+BAWb,YATAH,KAAKmlD,iBAAiB,IACjBplD,EACHpU,SAAU,IACJoU,EAAMpU,UAAYqU,KAAKo2C,MAC3BtsD,WAAW,GAEbs7D,cAAc,EACdv3B,iBAAiB,IAGnB,MAAO/1C,GACP,GAAmB,kBAAfA,EAAMtE,KACR,MAAMsE,EASZ,MAAQyK,EAAG8C,EAAQrB,EAAGsB,GAAWV,GAC/BxO,EACA4pB,KAAKo2C,OAGDiS,EAAeroD,KAAKsoD,mBAAmB,CAAEjjE,SAAQC,WAKvD,OAJA0a,KAAKuoD,mBAAmBF,EAAcj9B,GACtCprB,KAAKwoD,0BAA0BH,QAC/BroD,KAAKoU,SAAS,CAAE1pB,mBAAoB,CAAE,CAAC29D,EAAa5sE,KAAK,MAI3D,MAAO3D,GACP,OAAOkoB,KAAKoU,SAAS,CACnBtqB,WAAW,EACXT,aAAcvR,EAAM0tC,UAIxB,MAAMgtC,EAAgBp8E,EAAMgmE,aAAa/S,QAAQl6D,IAAWE,eAC5D,GAAsB,KAAlBmjF,EAMF,YALAxyD,KAAK0oD,8BAA8B,CACjCr0D,SAAUva,KAAKU,MAAMg4E,GACrBrwE,SAAU/L,EACVmnB,MAAO,OAKX,MAAM6tB,EAAI,UAAGh1C,EAAMgmE,oBAAT,aAAG,EAAoB7+C,MAAM,GACvC,IACM,OAAJ6tB,QAAI,IAAJA,OAAA,EAAAA,EAAMjqC,QAAShS,IAAWE,gBAA1B,OACA+7C,QADA,IACAA,GADA,UACAA,EAAM53C,YADN,aACA,EAAY40E,SAAS,mBAErBpoD,KAAKuuC,QACF+R,cAAcl1B,GACd/vC,MAAK,KAEJ2kB,KAAKoU,SAAS,CAAEvqB,eAAe,IAC/BmW,KAAKoU,SAAS,CAAEvqB,eAAe,OAEhC8wD,OAAO7iE,GACNkoB,KAAKoU,SAAS,CAAEtqB,WAAW,EAAOT,aAAcvR,EAAM0tC,gBAGrD,CAEL,GADAxlB,KAAKoU,SAAS,CAAEtqB,WAAW,IACvBkiD,KACF,IAGE,MAAMtV,EAAOtgD,EAAMgmE,aAAa3N,MAAM,GACrCrjB,EAAa9nC,aAAgBozC,EAAa67B,wBAC3C,MAAOz6E,GACPC,QAAQw0B,KAAKz0B,EAAMtE,KAAMsE,EAAM0tC,eAG7BxlB,KAAK8pD,iBAAiB1+B,KA3oIH,KA+oI7B0+B,iBAAoB1+B,IAClByX,GAAazX,EAAMprB,KAAKo2C,MAAOp2C,KAAKD,MAAMI,+BACvC9kB,MAAM0kB,IACLC,KAAKmlD,iBAAiB,IACjBplD,EACHpU,SAAU,IACJoU,EAAMpU,UAAYqU,KAAKo2C,MAC3BtsD,WAAW,GAEbs7D,cAAc,EACdv3B,iBAAiB,OAGpB8sB,OAAO7iE,IACNkoB,KAAKoU,SAAS,CAAEtqB,WAAW,EAAOT,aAAcvR,EAAM0tC,cA7pI/B,KAiqIrBuoC,wBACN33E,IAEAA,EAAMmR,iBAEN,MAAM,EAAEhF,EAAF,EAAKyB,GAAMY,GAA4BxO,EAAO4pB,KAAKo2C,OACnD3pD,EAAUuT,KAAKoY,qBAAqB71B,EAAGyB,EAAG,CAAEyuE,gBAAgB,IAE5DtxE,EAAOsL,EAAU,UAAY,SAE7B8rD,EAAYv4C,KAAK2kD,uBAAuBn1D,SACtC6yB,IAAKp/B,EAAW9G,KAAM6I,GAC5BuzD,EAAU1mB,wBACN11C,EAAO/F,EAAMyO,QAAUG,EACvBq9B,EAAMjsC,EAAM0O,QAAU7B,EAExBwJ,IAAYuT,KAAKo2C,MAAM1rD,mBAAmB+B,EAAQhR,IACpDukB,KAAKoU,SAAS,CAAE1pB,mBAAoB,CAAE,CAAC+B,EAAQhR,KAAK,KAAU,KAC5DukB,KAAK0yD,iBAAiB,CAAErwC,MAAKlmC,QAAQgF,MAGvC6e,KAAK0yD,iBAAiB,CAAErwC,MAAKlmC,QAAQgF,IAtrIZ,KA0rIrBwxE,2BAA6B,CACnClzC,EACArpC,KAEA,MAAM2S,EAAkBiX,KAAKo2C,MAAMrtD,gBAC7B6uB,EAAgB6H,EAAiBmzC,WACvC,GAAK7pE,EAGL,GAA6B,cAAzBA,EAAgB5H,KAClB8+B,GACEl3B,EACAiX,KAAKo2C,MAAMhtD,YACXq2B,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,EACxB4zB,EAAcr1B,EACdq1B,EAAc5zB,EACdD,GAAS07B,EAAiBvvC,OAAOqS,EAAGq1B,EAAcr1B,GAClDwB,GAAS07B,EAAiBvvC,OAAO8T,EAAG4zB,EAAc5zB,GAClDrE,GAA0BvJ,GAC1BqJ,GAAuBrJ,QAEpB,CAAC,IAAD,EACL,MAAO6yE,EAAOC,GAASz4D,GACrBmnB,EAAcr1B,EACdq1B,EAAc5zB,EACdgc,KAAKo2C,MAAMzsD,UAGPsN,EACJzK,GAA0BzD,KAA1B,UACAiX,KAAK1K,WAAWsB,IAAI7N,EAAgB2D,eADpC,aACA,EAA6CuK,OACzC47D,GACJ57D,GAAWA,aAAiBphB,QAExB,KADAohB,EAAMxU,MAAQwU,EAAMtU,OAG1Bs9B,GACEl3B,EACAiX,KAAKo2C,MAAMhtD,YACXq2B,EAAiBqzC,aAAavwE,EAC9Bk9B,EAAiBqzC,aAAa9uE,EAC9BilE,EACAC,EACAnlE,GAAS07B,EAAiBqzC,aAAavwE,EAAG0mE,GAC1CllE,GAAS07B,EAAiBqzC,aAAa9uE,EAAGklE,GAC1Cv8D,GAAe5D,IACVpJ,GAA0BvJ,GAC3BuJ,GAA0BvJ,GAC9BqJ,GAAuBrJ,GACvBy8E,GAGF7yD,KAAKwqD,0BAA0B,CAACzhE,MA/uIP,KAmvIrBgqE,kBAAoB,CAC1BtzC,EACArpC,KAEA,MAAMwtB,EAAmBC,GACvB7D,KAAKD,MAAMK,cACXJ,KAAKo2C,OAEDjjC,EAAsBsM,EAAiBivC,OAAOC,WACpD3uD,KAAKoU,SAAS,CAIZrqB,WAAYopB,GAA+C,aAAxBA,EACnCnpB,WAAoC,aAAxBmpB,IAEd,MAAMyE,EAAgB6H,EAAiBmzC,YAChCI,EAASC,GAAWxiE,GACzBmnB,EAAcr1B,EAAIk9B,EAAiBivC,OAAOh2E,OAAO6J,EACjDq1B,EAAc5zB,EAAIy7B,EAAiBivC,OAAOh2E,OAAOsL,EACjDgc,KAAKo2C,MAAMzsD,UAEb,QhG9/I6B,EAC/B81B,EACAtM,EACAvP,EACAgY,EACA/7B,EACAJ,EACAE,EACA67B,EACAC,EACAiE,EACAC,KAEA,GAAgC,IAA5B/b,EAAiBnwB,OAAc,CACjC,MAAOgZ,GAAWmX,EAmDlB,MAlD4B,aAAxBuP,GACFoI,GACE9uB,EACA+uB,EACAC,EACA57B,GAEF64B,GAAoBjsB,KAEpBM,GAAgBN,IACU,IAA1BA,EAAQoC,OAAOpb,QACU,OAAxB0/B,GACyB,OAAxBA,GACwB,OAAxBA,GACwB,OAAxBA,GAUFvmB,GAAcH,IACW,OAAxB0mB,GACyB,OAAxBA,GACwB,OAAxBA,GACwB,OAAxBA,EAUOA,GACTmJ,GACEmD,EAAiBK,iBAAiBlpB,IAAInK,EAAQhR,IAC9CkE,EACA8M,EACA0mB,EACA1zB,EACA+7B,EACAC,IAhBFU,GACE1vB,EACA0mB,EACA1zB,EACA+7B,EACAC,GAEF/C,GAAoBjsB,IArBpBkvB,GACElvB,EACAmvB,EACA/7B,EACA27B,EACAC,IA6BG,EACF,GAAI7X,EAAiBnwB,OAAS,EAAG,CACtC,GAA4B,aAAxB0/B,EAUF,OATAqM,GACEC,EACA7b,EACA4X,EACAC,EACA57B,EACA6/B,EACAC,IAEK,EACF,GACmB,OAAxBxM,GACwB,OAAxBA,GACwB,OAAxBA,GACwB,OAAxBA,EAQA,OANAwL,GACE/a,EACAuP,EACAqI,EACAC,IAEK,EAGX,OAAO,GgGk6IHy3C,CACEzzC,EACAtM,EACAvP,EACA6b,EAAiBivC,OAAOG,eACxBhvE,GAA8BzJ,GAC9BqJ,GAAuBrJ,GACK,IAA5BwtB,EAAiBnwB,QAAgBkZ,GAAeiX,EAAiB,KAC5DjkB,GAA0BvJ,GAC3BuJ,GAA0BvJ,GAC9B48E,EACAC,EACAxzC,EAAiBivC,OAAO5gE,OAAOvL,EAC/Bk9B,EAAiBivC,OAAO5gE,OAAO9J,KAGjCgc,KAAKwqD,0BAA0B5mD,IACxB,IA3xIkB,KAiyIrB8uD,iBAAmB,CAAC,EAQ1BvxE,KACI,IARJ,KACEhF,EADF,IAEEkmC,GAMC,EACH,MAAM8wC,EAAmBpmB,GAAYU,qBACnCztC,KAAK83C,cAAc33C,8BACnBH,KAAK83C,cAAcpF,eAGf0gB,EAAqB1lB,GAAcD,qBACvCztC,KAAK83C,cAAc33C,8BACnBH,KAAK83C,cAAcpF,eAGf2gB,EAAsBhjB,GAAqB5C,qBAC/CztC,KAAK83C,cAAc33C,8BACnBH,KAAK83C,cAAcpF,eAGf4gB,EAAoB5iB,GAAmBjD,qBAC3CztC,KAAK83C,cAAc33C,8BACnBH,KAAK83C,cAAcpF,eAGf6gB,EAAY,YAEZl/D,EAAW2L,KAAKD,MAAMK,cAEtBxmB,EAA+B,GAQrC,GAPIwuD,IAAiC/zC,EAAS5gB,OAAS,GACrDmG,EAAQJ,KAAKo4D,IAGXzJ,IAAsC9zC,EAAS5gB,OAAS,GAC1DmG,EAAQJ,KAAKk4D,IAEF,WAATvwD,EAAmB,CACrB,MAAMqyE,EAAkB,IACnB55E,EACmC,qBAA/BomB,KAAKomB,MAAMk/B,iBAChBvT,GACmC,qBAA9B/xC,KAAKomB,MAAMh7B,gBAAkC4mD,GACd,qBAA/BhyC,KAAKomB,MAAM/6B,iBAChB83D,GACFlR,IAGEjyC,KAAKo2C,MAAM/qD,gBACbwsD,GAAYr+D,KAAK,CACfI,QAAS45E,EACTnxC,MACAlmC,OACA27D,cAAe93C,KAAK83C,cACpBnsD,SAAUqU,KAAKo2C,MACfmC,UAAWv4C,KAAK2kD,uBAAuBn1D,UAGzCqoD,GAAYr+D,KAAK,CACfI,QAAS,CACPomB,KAAK84C,UACH35D,UAAU0pC,WAAa,CACrBr1C,KAAM,QACNo6C,QAAS,CAACv5B,EAAUo/D,KAClBzzD,KAAKgoD,mBAAmB,MACjB,CACLn6B,iBAAiB,IAGrBE,iBAAkB,gBAEtB/tB,KAAK84C,UAAY35D,UAAU0pC,WAAa0qC,EACxCnrB,IACE/zC,EAAS5gB,OAAS,GAClBm+D,GACFzJ,IACE9zC,EAAS5gB,OAAS,GAClBi+D,IACAtJ,IAAiC/zC,EAAS5gB,OAAS,GAClD00D,IAAsC9zC,EAAS5gB,OAAS,IACzD8/E,EACF1iC,GACA0iC,EACsC,qBAA/BvzD,KAAKomB,MAAMk/B,iBAChBvT,GACmC,qBAA9B/xC,KAAKomB,MAAMh7B,gBAChB4mD,GACoC,qBAA/BhyC,KAAKomB,MAAM/6B,iBAChB83D,GACFlR,IAEF5vB,MACAlmC,OACA27D,cAAe93C,KAAK83C,cACpBnsD,SAAUqU,KAAKo2C,MACfmC,UAAWv4C,KAAK2kD,uBAAuBn1D,cAGzB,YAATrO,IACL6e,KAAKo2C,MAAM/qD,gBACbwsD,GAAYr+D,KAAK,CACfI,QAAS,CAACuF,UAAU0pC,WAAa2oB,MAAe53D,GAChDyoC,MACAlmC,OACA27D,cAAe93C,KAAK83C,cACpBnsD,SAAUqU,KAAKo2C,MACfmC,UAAWv4C,KAAK2kD,uBAAuBn1D,UAGzCqoD,GAAYr+D,KAAK,CACfI,QAAS,CACPomB,KAAK84C,UAAYrH,GACjBzxC,KAAK84C,UAAY35D,UAAU0pC,WAAa2oB,GACxCxxC,KAAK84C,UACH35D,UAAU0pC,WAAa,CACrBr1C,KAAM,QACNo6C,QAAS,CAACv5B,EAAUo/D,KAClBzzD,KAAKgoD,mBAAmB,MACjB,CACLn6B,iBAAiB,IAGrBE,iBAAkB,gBAEtB/tB,KAAK84C,UAAYya,KACd35E,EACH25E,EACAhnB,GACAC,GACA+mB,EACAJ,GAAoBpmB,GACpBqmB,GAAsB1lB,IACrBylB,GAAoBC,IAAuBG,EAC5CzlB,GACAylB,EACA/iC,GACAE,GACAC,GACAC,GACA2iC,EACAF,GAAuBhjB,GACvBijB,GAAqB5iB,IACpB2iB,GAAuBC,IAAsBC,EAC9CziC,GACAnD,IAEFtL,MACAlmC,OACA27D,cAAe93C,KAAK83C,cACpBnsD,SAAUqU,KAAKo2C,MACfmC,UAAWv4C,KAAK2kD,uBAAuBn1D,YA57IlB,KAk8IrB2iE,YAAczrE,IAAoBtQ,IAGxC,GAFAA,EAAMmR,iBAEFs8D,GACF,OAGF,MAAM,OAAE5tC,EAAF,OAAUC,GAAW9/B,GACrB,mBAAEsU,EAAF,2BAAsBH,GAA+ByV,KAAKo2C,MAEhE,GAAIhgE,EAAM4+C,SAAW5+C,EAAM6+C,QAAS,CAClC,MAAMnyB,EAAO91B,KAAK81B,KAAKoT,GACjBw9C,EAAW,GACjB,IAAI1lD,EAAQhhC,KAAKiX,IAAIiyB,GACjBlI,EAAQ0lD,IACV1lD,EAAQ0lD,GAEV1lD,GAASlL,EAC8C,IAAnDjnB,OAAOD,KAAK2O,GAA4B9W,QAC1CkQ,YAAW,KACTqc,KAAKoU,SAAS,CACZ1pB,mBAAoBH,EACpBA,2BAA4B,OAE7B,KAGL,IAAIkuC,EAAUz4B,KAAKo2C,MAAMrxD,KAAKvP,MAAQw4B,EAAQ,IAwB9C,OAtBAyqB,GAAWzrD,KAAK2mF,MAAM3mF,KAAK+iB,IAAI,EAAGiQ,KAAKo2C,MAAMrxD,KAAKvP,SAAWstB,EAE7D21B,EAAUzrD,KAAK0jB,MAAM+nC,EAAU7nD,IAAY,MAAoB,IAAZA,KAEnDovB,KAAKoU,UAAS,QAAC,KAAErvB,EAAF,WAAQC,EAAR,UAAoB/B,GAArB,QAAsC,CAClD8B,KAAMggC,GACJK,GAAkBqT,GAClB1zC,EACA,CAAE5I,KAAM6I,EAAYq9B,IAAKp/B,GACzB,CACEV,EAAGmhE,GACH1/D,EAAG2/D,KAGPj5D,mBAAoB,GACpBH,2BAC6C,IAA3C1O,OAAOD,KAAK8O,GAAoBjX,OAC5BiX,EACAH,EACNM,uBAAuB,WAEzBmV,KAAK0rD,sCAKHt1E,EAAMwJ,SACRogB,KAAKoU,UAAS,QAAC,KAAErvB,EAAF,QAAQE,GAAT,QAAwB,CAEpCA,QAASA,GAAWixB,GAAUD,GAAUlxB,EAAKvP,UAKjDwqB,KAAKoU,UAAS,QAAC,KAAErvB,EAAF,QAAQE,EAAR,QAAiBC,GAAlB,QAAiC,CAC7CD,QAASA,EAAUgxB,EAASlxB,EAAKvP,MACjC0P,QAASA,EAAUgxB,EAASnxB,EAAKvP,aAngJR,KA0iJrBg2E,YAAc,CAACjpE,EAAWyB,EAAW0oE,KAA2B,IAAD,IACrE,IAAKnqE,IAAMyB,EACT,OAEF,MAAMsqD,EAAU1pD,GACd,CAAEC,QAAStC,EAAGuC,QAASd,GACvBgc,KAAKo2C,OAGHwd,MAAMtlB,EAAQ/rD,IAAMqxE,MAAMtlB,EAAQtqD,GAItC,aAAAgc,KAAKomB,OAAMytC,uBAAX,gBAA6B,CAC3BvlB,UACAoe,SACAoH,YAAa3P,GAAQ7P,YA1jJI,KA8jJrBoX,oCAAsCvoE,IAAS,KAChD6c,KAAKykD,WACRzkD,KAAKoU,SAAS,CAAEvpB,uBAAuB,MAExC,KAlkJ0B,KAokJrBkpE,cAAiB7yD,IAAqB,IAAD,EAC3C,aAAIlB,KAAK2kD,8BAAT,aAAI,EAA6Bn1D,QAAS,CACxC,MAAMwkE,EAAsBh0D,KAAK2kD,uBAAuBn1D,SAClD,MACJ/M,EADI,OAEJE,EACAxG,KAAM6I,EACNq9B,IAAKp/B,GACH+wE,EAAoBniC,yBAEtBpvC,MAAOwxE,EACPtxE,OAAQuxE,EACRjxE,UAAWkxE,EACXnvE,WAAYovE,GACVp0D,KAAKo2C,MAET,GACE3zD,IAAUwxE,GACVtxE,IAAWuxE,GACXlvE,IAAeovE,GACfnxE,IAAckxE,EAKd,YAHIjzD,GACFA,KAKJlB,KAAKoU,SACH,CACE3xB,QACAE,SACAqC,aACA/B,cAEF,KACEie,GAAMA,SAxmJe,KA8mJtBmzD,QAAU,KACfr0D,KAAKoU,SAAS,IAAKpU,KAAKsnD,sBA7mJxB,MAAMnyD,EAAkBvN,MAClB,cACJ0sE,EACAjpE,mBAAkB,EAClBD,kBAAiB,EAHb,gBAIJk6D,GAAkB,EAClBrzE,QAAQkjB,EAAgBljB,MACxBuB,OAAO2hB,EAAgB3hB,MACrB4yC,EAgBJ,GAfApmB,KAAKo2C,MAAQ,IACRjhD,EACHljB,QACA6X,WAAW,KACRkW,KAAKsnD,mBACRj8D,kBACAD,iBACAzB,SAAU27D,EAAkBp2E,IAAY,KACxCsE,OACAiP,MAAOzS,OAAO8hD,WACdnvC,OAAQ3S,OAAO+hD,aAGjB/xB,KAAKvkB,GAAKimB,eAEN4yD,EAAe,CAAC,IAAD,EACjB,MAAMC,EACH,YAAaD,IAAb,UAA8BA,EAAc9kE,eAA5C,aAA8B,EAAuB+kE,eACtDjuE,KAEIkuE,EAA+B,CACnCC,OAAO,EACPF,eACAtK,YAAajqD,KAAKiqD,YAClBF,SAAU/pD,KAAK+pD,SACfrD,WAAY1mD,KAAK0mD,WACjBzB,iCAAkCjlD,KAAKilD,iCACvCrwC,QAAS,CACPjU,MAAOX,KAAKymD,cAEdS,gBAAiBlnD,KAAKknD,gBACtBhC,iBAAkBllD,KAAKklD,iBACvBxS,YAAa,IAAM1yC,KAAKo2C,MACxBse,SAAU,IAAM10D,KAAKzC,MACrB82D,QAASr0D,KAAKq0D,QACd/T,cAAetgD,KAAK2lD,qBACpB8D,gBAAiBzpD,KAAKypD,gBACtBhuE,GAAIukB,KAAKvkB,IAEkB,oBAAlB64E,EACTA,EAAcE,GAEdF,EAAc9kE,QAAUglE,EAE1BD,EAAaz+E,QAAQ0+E,G9B1RqB5/C,M8B6R5C5U,KAAK+kD,yBAA2B,CAC9BxM,UAAWv4C,KAAK2kD,uBAAuBn1D,QACvC/T,GAAIukB,KAAKvkB,IAGXukB,KAAKD,MAAQ,IAAIL,GACjBM,KAAKuuC,QAAU,IAAI4E,GAAQnzC,MAC3BA,KAAK4U,QAAU,IAAI8/B,GACnB10C,KAAK83C,cAAgB,IAAIrF,GACvBzyC,KAAKmlD,kBACL,IAAMnlD,KAAKo2C,QACX,IAAMp2C,KAAKD,MAAMI,+BACjBH,MAEFA,KAAK83C,cAAc9E,YAAY1lB,IAE/BttB,KAAK83C,cAAc/E,gB9B7SyBn+B,E8B6SO5U,KAAK4U,Q9B7Sb,CAC7CphC,KAAM,OACNo6C,QAAS,CAACv5B,EAAU1I,IAClBumD,GAAU79C,EAAU1I,GAAU,IAAMipB,EAAQohC,aAC9ChoB,QAAU53C,GACRA,EAAMmJ,IACNnJ,EAAM/C,IAAI6/C,gBAAkB3zC,KAC3BnJ,EAAMwJ,SACTquC,eAAgB,QAAC,WAAEC,EAAF,KAAc95C,GAAf,SACd,eAAC6xC,GAAD,CACE9kC,KAAK,SACLqmC,KAAM+B,GACN,aAAY5tC,EAAE,gBACdmrC,QAASoH,EACT92B,MAAU,OAAJhjB,QAAI,IAAJA,OAAA,EAAAA,EAAMgjB,OAAQ,YAGxBy2B,gBAAiB,KAAM,K8B6RrB7tB,KAAK83C,cAAc/E,e9B1RyBn+B,KAAD,CAC7CphC,KAAM,OACNo6C,QAAS,CAACv5B,EAAU1I,IAClBumD,GAAU79C,EAAU1I,GAAU,IAAMipB,EAAQihC,aAC9C7nB,QAAU53C,GACPA,EAAMmJ,IACLnJ,EAAMwJ,UACNxJ,EAAM/C,IAAI6/C,gBAAkB3zC,IAC7BF,GAAajJ,EAAM6+C,UAAY7+C,EAAMwJ,UAAYxJ,EAAM/C,MAAQkM,GAClE0uC,eAAgB,QAAC,WAAEC,EAAF,KAAc95C,GAAf,SACd,eAAC6xC,GAAD,CACE9kC,KAAK,SACLqmC,KAAMgC,GACN,aAAY7tC,EAAE,gBACdmrC,QAASoH,EACT92B,MAAU,OAAJhjB,QAAI,IAAJA,OAAA,EAAAA,EAAMgjB,OAAQ,YAGxBy2B,gBAAiB,KAAM,I8BwQa8mC,CAAiB30D,KAAK4U,UAGlDggD,eACN,MAAMC,EAAc7kF,OAAO2X,kBAEzBlF,MAAOqyE,EACPnyE,OAAQoyE,EAFJ,gBAGJ1pE,GACE2U,KAAKo2C,MACHhX,EAAc01B,EAAiBD,EAC/Bx1B,EAAe01B,EAAkBF,EACvC,OAAIxpE,EAEA,yBACEy6B,UAAU,qBACV5jC,MAAO,CACLO,MAAOqyE,EACPnyE,OAAQoyE,EACR57E,OAAQjM,IAAYI,MAEtBmV,MAAO28C,EACPz8C,OAAQ08C,EACRhZ,IAAKrmB,KAAKkyD,gBACVna,cAAe/3C,KAAK+tD,wBACpBV,cAAertD,KAAKurD,wBACpB1jC,YAAa7nB,KAAKopD,cAClB4L,gBAAiBh1D,KAAKopD,cACtB6L,YAAaj1D,KAAKksD,gBAClBtkC,cAAe5nB,KAAKmsD,wBAftB,SAiBGxwE,EAAE,0BAKP,yBACEmqC,UAAU,qBACV5jC,MAAO,CACLO,MAAOqyE,EACPnyE,OAAQoyE,GAEVtyE,MAAO28C,EACPz8C,OAAQ08C,EACRhZ,IAAKrmB,KAAKkyD,gBACVna,cAAe/3C,KAAK+tD,wBACpBnmC,cAAe5nB,KAAKmsD,wBACpB+I,cAAel1D,KAAK8nD,wBACpBuF,cAAertD,KAAKurD,wBACpB1jC,YAAa7nB,KAAKopD,cAClB4L,gBAAiBh1D,KAAKopD,cACtB6L,YAAaj1D,KAAKksD,gBAfpB,SAiBGvwE,EAAE,0BAKF28D,SAAU,IAAD,IACd,MAAM,eAAEltD,EAAF,gBAAkBC,GAAoB2U,KAAKo2C,OAE3C,oBACJmH,EADI,iBAEJG,EAFI,aAGJyX,EAHI,kBAIJrS,GACE9iD,KAAKomB,MAET,OACE,sBACEN,UAAWmB,aAAK,kCAAmC,CACjD,wBAAyB57B,EACzB,qBAAsB2U,KAAK84C,WAE7BzyB,IAAKrmB,KAAK2kD,uBACVyQ,OAAQp1D,KAAKsyD,gBACbh/B,SAAU,EACVP,UACE/yB,KAAKomB,MAAMivC,4BAAyB/3E,EAAY0iB,KAAK+yB,UATzD,SAYE,eAACwwB,GAA2B+R,SAA5B,CACE9/E,MAAOwqB,KAAK+kD,yBADd,SAGE,gBAAC3B,GAAgBkS,SAAjB,CAA0B9/E,MAAOwqB,KAAK84C,SAAtC,UACE,eAAC,GAAD,CACE30D,OAAQ6b,KAAK7b,OACbwH,SAAUqU,KAAKo2C,MACf74C,MAAOyC,KAAKzC,MACZ47C,YAAan5C,KAAKm5C,YAClBrB,cAAe93C,KAAK83C,cACpBzjD,SAAU2L,KAAKD,MAAMK,cACrBm9C,oBAAqBA,EACrBC,aAAcx9C,KAAKspD,WACnB7H,iBAAmBptD,GACjB2L,KAAK0oD,8BAA8B,CACjCr0D,WACAlS,SAAU,SACVob,MAAO,OAGXnS,eAAgBA,EAChBu2D,cAAe3hD,KAAK2hD,cACpBc,SAAUxlE,IAAc1B,KACxBm+D,gBAAiB15C,KAAKomB,MAAMszB,kBAAmB,EAC/CgE,iBAAkBA,EAClBD,mBAAoB0X,EACpB9pE,gBAAiBA,EACjBq2D,mBACwC,qBAAtC,UAAO1hD,KAAKomB,aAAZ,aAAO,EAAYh7B,iBACnBA,EAEFouD,aAC+B,qBAA7B,UAAOx5C,KAAKomB,aAAZ,aAAO,EAAYn0C,QACnB+tB,KAAKomB,MAAMwsB,UAAUlhE,cAAcO,MAErC8tE,iBAAkB//C,KAAKomB,MAAM25B,iBAC7BnN,UAAW5yC,KAAKomB,MAAMwsB,UACtBha,eAAgB54B,KAAK44B,eACrB2V,QAASvuC,KAAKuuC,QACd9yD,GAAIukB,KAAKvkB,GACT29D,cAAep5C,KAAKo5C,gBAEtB,sBAAKtzB,UAAU,mCACf,sBAAKA,UAAU,oCACd9lB,KAAKo2C,MAAMrrD,WACV,eAAC,GAAD,CACEY,SAAUqU,KAAKo2C,MACf+C,YAAan5C,KAAKm5C,YAClB9kD,SAAU2L,KAAKD,MAAMK,cACrBqyB,QAASzyB,KAAKwpD,YACd1G,kBAAmBA,IAGM,OAA5B9iD,KAAKo2C,MAAMlrD,cACV,eAAC,GAAD,CACEs6B,QAASxlB,KAAKo2C,MAAMlrD,aACpB83D,WAAYhjD,KAAKgjD,aAGrB,gCAAOhjD,KAAK40D,wBAmSQ,0BAAI,IAAD,EAwCyC,EAxCzC,OAI/B,GAHA50D,KAAK+kD,yBAAyBxM,UAC5Bv4C,KAAK2kD,uBAAuBn1D,QAG5Bra,eAAyBnH,IAAIC,MAC7BkH,eAAyBnH,IAAIE,YAC7B,CACiB8xB,KAAKoU,SAASusC,KAAK3gD,MACpCnkB,OAAO05E,iBAAiBvlF,OAAOikB,EAAG,CAChCmiD,MAAO,CACLof,cAAc,EACd5+D,IAAK,IACIoJ,KAAKo2C,OAGhBhiC,SAAU,CACRohD,cAAc,EACdhgF,MAAO,WACL,OAAO,EAAK4+B,YAAY,aAG5ByjB,IAAK,CACH29B,cAAc,EACdhgF,MAAOwqB,MAET4U,QAAS,CACP4gD,cAAc,EACdhgF,MAAOwqB,KAAK4U,WAYlB,GAPA5U,KAAKD,MAAMkB,YAAYjB,KAAK0lD,gBAC5B1lD,KAAKy1D,oBAEDz1D,KAAK2kD,uBAAuBn1D,SAC9BwQ,KAAK44B,iBAGH,mBAAoB5oD,SAApB,UAA8BgwB,KAAK2kD,8BAAnC,aAA8B,EAA6Bn1D,SAC7DwQ,KAAK6kD,eAAiB,IAAI6Q,gBAAe,KAGvC,MAAM,MAAEjzE,EAAF,OAASE,GACbqd,KAAK2kD,uBAAuBn1D,QAASqiC,wBACvC7xB,KAAK84C,SACHr2D,EAAQtQ,KACPwQ,EAAStQ,KAA2BoQ,EAAQrQ,IAG/C4tB,KAAK+zD,mBAEP,UAAA/zD,KAAK6kD,sBAAL,SAAqB8Q,QAAQ31D,KAAK2kD,uBAAuBn1D,cACpD,GAAIxf,OAAO4lF,WAAY,CAC5B,MAAMC,EAAa7lF,OAAO4lF,WAAP,sBACFzjF,IADE,6BACwCE,IADxC,+BACsFD,IADtF,QAGb4/C,EAAU,IAAOhyB,KAAK84C,SAAW+c,EAAWC,QAClDD,EAAWE,YAAY/jC,GACvBhyB,KAAK0kD,wBAA0B,IAAMmR,EAAWG,eAAehkC,GAG5C,IAAI+zB,gBAAgB/1E,OAAOC,SAASg2E,OAAOxsE,MAAM,IAErD8b,IAAI,oBAEnByK,KAAK0pD,uBAEL1pD,KAAK+zD,cAAc/zD,KAAK4mD,iBAIrBqP,uBAAwB,IAAD,EAC5Bj2D,KAAKzC,MAAQ,GACbyC,KAAK1K,WAAWqL,QAChB,UAAAX,KAAK6kD,sBAAL,SAAqBqR,aACrBl2D,KAAKykD,WAAY,EACjBzkD,KAAKm2D,uBACLn2D,KAAKD,MAAMqB,UACX1d,aAAasgE,IACbA,GAAe,EAUTmS,uBAAwB,IAAD,IAC7Bt5E,SAASs1C,oBAAoBpkD,IAAMsyD,WAAYrgC,KAAKopD,eACpDvsE,SAASs1C,oBAAoBpkD,IAAMqoF,KAAMp2D,KAAKynD,QAC9C5qE,SAASs1C,oBAAoBpkD,IAAMsgF,MAAOruD,KAAKgoD,oBAC/CnrE,SAASs1C,oBAAoBpkD,IAAMsoF,IAAKr2D,KAAKunD,OAC7C,UAAAvnD,KAAK8kD,kCAAL,SAAiC3yB,oBAC/BpkD,IAAMuoF,OACNt2D,KAAKqnD,UAEPxqE,SAASs1C,oBAAoBpkD,IAAM4/E,QAAS3tD,KAAK+yB,WAAW,GAC5Dl2C,SAASs1C,oBACPpkD,IAAMwoF,WACNv2D,KAAKmqD,6BACL,GAEFttE,SAASs1C,oBAAoBpkD,IAAMqyD,MAAOpgC,KAAK2qD,SAC/C36E,OAAOmiD,oBAAoBpkD,IAAMyoF,OAAQx2D,KAAKonD,UAAU,GACxDp3E,OAAOmiD,oBAAoBpkD,IAAM0oF,OAAQz2D,KAAKulD,UAAU,GACxDv1E,OAAOmiD,oBAAoBpkD,IAAMygF,KAAMxuD,KAAKm0B,QAAQ,GACpDnkD,OAAOmiD,oBAAoBpkD,IAAM2oF,UAAW12D,KAAKwlD,cAAc,GAC/Dx1E,OAAOmiD,oBAAoBpkD,IAAM4oF,KAAM32D,KAAKwlD,cAAc,GAE1D3oE,SAASs1C,oBACPpkD,IAAM6oF,cACN52D,KAAK4qD,gBACL,GAEF/tE,SAASs1C,oBACPpkD,IAAM8oF,eACN72D,KAAK6qD,iBACL,GAEFhuE,SAASs1C,oBACPpkD,IAAM+oF,YACN92D,KAAK8qD,cACL,GAGF,UAAA9qD,KAAK0kD,+BAAL,cAAA1kD,MAGMy1D,oBAAqB,IAAD,IAC1Bz1D,KAAKm2D,uBACLt5E,SAASq1C,iBAAiBnkD,IAAMsyD,WAAYrgC,KAAKopD,eACjDvsE,SAASq1C,iBAAiBnkD,IAAMqoF,KAAMp2D,KAAKynD,QACvCznD,KAAKomB,MAAMivC,wBACbx4E,SAASq1C,iBAAiBnkD,IAAM4/E,QAAS3tD,KAAK+yB,WAAW,GAE3Dl2C,SAASq1C,iBAAiBnkD,IAAMqyD,MAAOpgC,KAAK2qD,QAAS,CAAE8D,SAAS,IAChE5xE,SAASq1C,iBACPnkD,IAAMwoF,WACNv2D,KAAKmqD,6BAGP,UAAAttE,SAASk6E,aAAT,mBAAgB7kC,wBAAhB,gBAAmC,cAAelyB,KAAKylD,cAEvD5oE,SAASq1C,iBACPnkD,IAAM6oF,cACN52D,KAAK4qD,gBACL,GAEF/tE,SAASq1C,iBACPnkD,IAAM8oF,eACN72D,KAAK6qD,iBACL,GAEFhuE,SAASq1C,iBACPnkD,IAAM+oF,YACN92D,KAAK8qD,cACL,GAEE9qD,KAAKo2C,MAAM/qD,kBAIfxO,SAASq1C,iBAAiBnkD,IAAMsgF,MAAOruD,KAAKgoD,oBAC5CnrE,SAASq1C,iBAAiBnkD,IAAMsoF,IAAKr2D,KAAKunD,OACtCvnD,KAAKomB,MAAM4wC,eACbh3D,KAAK8kD,2BxHriBTr4D,KAEA,IAAI6sC,EAAS7sC,EAAQ8sC,cACrB,KAAOD,GAAQ,CACb,GAAIA,IAAWz8C,SAASoF,KACtB,OAAOpF,SAET,MAAM,UAAEo6E,GAAcjnF,OAAOwV,iBAAiB8zC,GAE9C,GAD6BA,EAAO49B,aAAe59B,EAAO69B,eAGzC,SAAdF,GAAsC,WAAdA,GAEzB,OAAO39B,EAETA,EAASA,EAAOC,cAElB,OAAO18C,UwHohB+Bu6E,CAChCp3D,KAAK2kD,uBAAuBn1D,SAE9BwQ,KAAK8kD,2BAA2B5yB,iBAC9BnkD,IAAMuoF,OACNt2D,KAAKqnD,WAGTr3E,OAAOkiD,iBAAiBnkD,IAAMyoF,OAAQx2D,KAAKonD,UAAU,GACrDp3E,OAAOkiD,iBAAiBnkD,IAAM0oF,OAAQz2D,KAAKulD,UAAU,GACrDv1E,OAAOkiD,iBAAiBnkD,IAAMygF,KAAMxuD,KAAKm0B,QAAQ,GACjDnkD,OAAOkiD,iBAAiBnkD,IAAM2oF,UAAW12D,KAAKwlD,cAAc,GAC5Dx1E,OAAOkiD,iBAAiBnkD,IAAM4oF,KAAM32D,KAAKwlD,cAAc,IAGzD6R,mBAAmBC,EAAqB/N,GAAsB,IAAD,IACvD+N,EAAU7U,WAAaziD,KAAKomB,MAAMq8B,UACpCziD,KAAKu3D,iBAGHD,EAAUjsE,kBAAoB2U,KAAKomB,MAAM/6B,iBAC3C2U,KAAKoU,SAAS,CAAE/oB,kBAAmB2U,KAAKomB,MAAM/6B,kBAG5Ck+D,EAAUl+D,kBAAoB2U,KAAKo2C,MAAM/qD,kBAC3C2U,KAAKy1D,oBACLz1D,KAAKw3D,oBAGHF,EAAUlsE,iBAAmB4U,KAAKomB,MAAMh7B,gBAC1C4U,KAAKoU,SAAS,CAAEhpB,iBAAkB4U,KAAKomB,MAAMh7B,iBAG3CksE,EAAUrlF,QAAU+tB,KAAKomB,MAAMn0C,OAAS+tB,KAAKomB,MAAMn0C,OACrD+tB,KAAKoU,SAAS,CAAEniC,MAAO+tB,KAAKomB,MAAMn0C,QAGhCqlF,EAAUhS,kBAAoBtlD,KAAKomB,MAAMk/B,iBAC3CtlD,KAAKoU,SAAS,CACZzqB,SAAUqW,KAAKomB,MAAMk/B,gBAAkBp2E,IAAY,OAInD8wB,KAAKomB,MAAM5yC,MAAQ8jF,EAAU9jF,OAASwsB,KAAKomB,MAAM5yC,MACnDwsB,KAAKoU,SAAS,CACZ5gC,KAAMwsB,KAAKomB,MAAM5yC,OAIrB,UAAAwsB,KAAK2kD,uBAAuBn1D,eAA5B,SAAqC8mC,UAAUmhC,OAC7C,cACqB,SAArBz3D,KAAKo2C,MAAMnkE,OAIX+tB,KAAKo2C,MAAMltD,uBACV8W,KAAKo2C,MAAM1rD,mBAAmBsV,KAAKo2C,MAAMltD,qBAAqB0qB,YAG/DjwB,YAAW,KACTqc,KAAK83C,cAAc5E,cAAcxa,OAGrC,MAAM,aAAExuC,GAAiBq/D,EAEvBA,EAAUngE,cAAgB4W,KAAKo2C,MAAMhtD,aACrB,MAAhBc,GACAN,GAAiBoW,KAAKo2C,QACtBnpD,GAAiB/C,IAEjBytB,GACEztB,EACA8V,KAAKo2C,MACLp2C,KAAKD,MACLla,GACE8tB,GAAoBgB,iCAClBzqB,GACC,KAMT,MAAMpB,EAEF,GACE4uE,EAAmE,GACnEj7B,EAAmE,GACnEk7B,EAA6C,GAC7CC,EAA8C,GACpD53D,KAAKo2C,MAAMvuD,cAAcyM,SAAQ,CAACujE,EAAMn7B,KACtC,GAAIm7B,EAAKntE,mBACP,IAAK,MAAMjP,KAAMI,OAAOD,KAAKi8E,EAAKntE,oBAC1BjP,KAAMghD,IACVA,EAAyBhhD,GAAM,IAEjCghD,EAAyBhhD,GAAIjC,KAAKkjD,GAGjCm7B,EAAKvpB,UAGNupB,EAAKh6B,WACP85B,EAAiBj7B,GAAYm7B,EAAKh6B,UAEhCg6B,EAAKp6B,YACPm6B,EAAkBl7B,GAAYm7B,EAAKp6B,WAErCi6B,EAAsBh7B,GAAYt3C,GAChC,CACEC,OAAQwyE,EAAKvpB,QAAQ/rD,EACrB+C,OAAQuyE,EAAKvpB,QAAQtqD,GAEvBgc,KAAKo2C,OAEPttD,EAAa4zC,GAAYm7B,EAAKnL,WAEhC,MAAMoL,EAAoB93D,KAAKD,MAAMK,cAAc/jB,QAAQoQ,KACrDE,GAAeF,KAGfuT,KAAKo2C,MAAM9qD,qBACXmB,EAAQhR,KAAOukB,KAAKo2C,MAAM9qD,oBAAoB7P,OAQ/CukB,KAAKo2C,MAAMptD,gBACuB,SAAnCgX,KAAKo2C,MAAMptD,eAAe7H,MAC1BsL,EAAQhR,KAAOukB,KAAKo2C,MAAMptD,eAAevN,OAGvC,yBAAEmgD,EAAF,WAA4B1Y,GAAeqY,GAC/Cu8B,EACA93D,KAAKo2C,MACLp2C,KAAKo2C,MAAMxrD,iBACX5a,OAAO2X,iBACPqY,KAAK/J,GACL+J,KAAK7b,OACL,CACEc,QAAS+a,KAAKo2C,MAAMnxD,QACpBC,QAAS8a,KAAKo2C,MAAMlxD,QACpBiG,oBAAqB6U,KAAKo2C,MAAMjrD,oBAChCpG,KAAMib,KAAKo2C,MAAMrxD,KACjBw4C,4BAA6Bm6B,EAC7B95B,oBAAqB90C,EACrB2zC,2BACAqB,uBAAwB65B,EACxBj6B,wBAAyBk6B,EACzB/sE,sBAAuBmV,KAAKo2C,MAAMvrD,sBAClC5Y,MAAO+tB,KAAKo2C,MAAMnkE,MAClBqjB,WAAY0K,KAAK1K,YAEnB,CACEuH,qBAAqB,EACrB2+B,kBAAmBx7B,KAAK84C,WAGxB51B,IACF6gC,GAAoB7gC,GAEtB,MAAMz4B,EAEgC,UAApC,UAAAuV,KAAKo2C,MAAMptD,sBAAX,eAA2B7H,SAEtBy6C,GAA4Bk8B,EAAkBrkF,OAAS,GAalC,IAAD,KAZvBusB,KAAKo2C,MAAM3rD,kBAAoBA,GACjCuV,KAAKoU,SAAS,CAAE3pB,oBAGlBuV,KAAK4U,QAAQuhC,OAAOn2C,KAAKo2C,MAAOp2C,KAAKD,MAAMI,+BAE3CH,KAAK4xD,uBAMA5xD,KAAKo2C,MAAMtsD,aACd,aAAAkW,KAAKomB,OAAM2B,gBAAX,gBACE/nB,KAAKD,MAAMI,8BACXH,KAAKo2C,MACLp2C,KAAKzC,QAgDiB,uBAC1BimD,IAAc,EAgNRmF,iBAAiBhxE,GACvB,MAAM,EAAE4K,EAAF,EAAKyB,GAAMY,GACf,CAAEC,QAAS6+D,GAAS5+D,QAAS6+D,IAC7B3jD,KAAKo2C,OAGD3pD,EAAUyY,GAAe,CAC7B3iB,IACAyB,IACA0S,YAAasJ,KAAKo2C,MAAM3tD,uBACxByQ,gBAAiB8G,KAAKo2C,MAAMpuD,2BAC5ByO,UAAWuJ,KAAKo2C,MAAMluD,qBACtBuN,YAAauK,KAAKo2C,MAAMxtD,uBACxB8P,YAAasH,KAAKo2C,MAAMztD,uBACxBmQ,UAAWkH,KAAKo2C,MAAM7tD,qBACtB6N,QAAS4J,KAAKo2C,MAAM9tD,mBACpBwM,gBAAiBkL,KAAKo2C,MAAM1tD,2BAC5B/Q,OACAiK,SAAUoe,KAAKo2C,MAAMhuD,oBACrB5G,WAAYwe,KAAKo2C,MAAMjuD,sBACvBwP,UAAWqI,KAAKo2C,MAAMvtD,qBACtBoc,cAAej2B,MAGjBgxB,KAAKD,MAAMU,mBAAmB,IACzBT,KAAKD,MAAMI,8BACd1T,IAEFuT,KAAKoU,SAAS,CAAE1pB,mBAAoB,CAAE,CAAC+B,EAAQhR,KAAK,KACpDukB,KAAK4U,QAAQI,kBAiWP4zC,gBAAgBx/D,GxHvtDxB/S,MwHwtDOutE,IACHv/D,GAAkB2b,KAAK7b,OAAQiF,IxHztDnC/S,EwH2tDiBwG,SAASm2C,yBxHztDR/xC,aAAe5K,EAAOyvC,UAAUp+B,SAAS,awH0tDvDsY,KAAK44B,iBAEF5rC,GAAoB5D,IACvB4W,KAAKoU,SAAS,CAAEnpB,kBAAmB,KAEjB,UAAhB7B,GACF4W,KAAKo5C,gBAEa,cAAhBhwD,EACF4W,KAAKoU,SAAS,CACZhrB,cACAsB,mBAAoB,GACpBC,iBAAkB,GAClB1B,eAAgB,OAGlB+W,KAAKoU,SAAS,CAAEhrB,gBA8CZgiE,kBACN3+D,EADuB,GAOtB,IAAD,WALA,kBACE4+D,GAAoB,GAItB,EACA,MAAM0M,EAAgB,SAACpgF,GAAqC,IAAvBitB,EAAsB,wDACzD,EAAK7E,MAAMU,mBAAmB,IACzB,EAAKV,MAAMI,8BAA8BnlB,KAAKg9E,GAC3CA,EAASv8E,KAAOgR,EAAQhR,IAAMmR,GAAcorE,GACvCnyD,GAAkBmyD,EAAU,CACjCrgF,OACAitB,cAGGozD,O9F3yDU,KAkBpB,IAlBqB,GAC1Bv8E,EAD0B,SAE1BkQ,EAF0B,SAG1Bo8B,EAH0B,SAI1BkwC,EAJ0B,kBAK1BC,EAL0B,QAM1BzrE,EAN0B,OAO1BtI,EAP0B,oBAQ1B6vE,GAUI,EACJ,MAAMmE,EAAqB,KAAO,IAAD,EAC/B,MAAM3qB,EAAc,UAAG9tC,GAAM0C,SAAS3V,UAAlB,aAAG,EAAyB4T,WAAW5kB,GAC3D,GAAI+xD,GAAkB5gD,GAAc4gD,GAAiB,CACnD,MAAO4qB,EAAWC,GAAaH,EAC7B1qB,EAAejrD,EACfirD,EAAexpD,IAEX,UAAE2T,EAAF,MAAalK,GAAU+/C,EAE7B8qB,EAAS9iF,MAAQg4D,EAAe71D,KAEhC,MAAMigB,EAAQ41C,EAAe71D,KAAKiG,QAAQ,SAAU,MAAMH,MAAM,MAC1Doa,EAAa21C,EAAe7qD,OAASiV,EAAMnkB,OAC3CgtC,GACH90B,EAAS3G,WAAa2G,EAASlJ,MAAQ21E,EAAY,GAClDzsE,EAAS5G,KAAKvP,MAEhB4Z,OACE5J,iBAAgB,OACdwuE,QADc,IACdA,OADc,EACdA,EAAqB9V,YACrBN,YAAYnkE,MAAM,GAAI,IAG5BoC,OAAOsrB,OAAOmxD,EAASp2E,MAAO,CAC5BJ,KAAMH,GAAc6rD,GAEpB31C,WAAW,GAAD,OAAKA,EAAL,MACVpV,MAAM,GAAD,OAAK+qD,EAAe/qD,MAApB,MACLE,OAAO,GAAD,OAAK6qD,EAAe7qD,OAApB,MACNxG,KAAK,GAAD,OAAKi8E,EAAL,MACJ/1C,IAAI,GAAD,OAAKg2C,EAAL,MACH7rC,UAAWhM,GACTgtB,EAAe/qD,MACf+qD,EAAe7qD,OACf8K,EACA9B,EACA80B,GAEF9oB,YACA1R,MAAOunD,EAAe92C,YACtBN,QAASo3C,EAAep3C,QAAU,IAClC/Z,OAAQ,sBACRokC,SAAS,GAAD,OAAKA,EAAL,UAKR63C,EAAWz7E,SAASmF,cAAc,YAExCs2E,EAASv7E,IAAM,OACfu7E,EAAShlC,SAAW,EACpBglC,EAASp3E,QAAQC,KAAO,UAExBm3E,EAASC,KAAO,MAEhB18E,OAAOsrB,OAAOmxD,EAASp2E,MAAO,CAC5BC,SAAU,WACVW,QAAS,eACTwuE,UAAW,MACXkH,mBAAoB,SACpBrhC,OAAQ,EACRn7B,QAAS,EACT+tC,OAAQ,EACR0uB,QAAS,EACT/J,OAAQ,OACRl0B,WAAY,cACZz3C,SAAU,SAEVX,WAAY,MAEZ+/D,OAAQ,0BAGVgW,IAEIpwC,IACFuwC,EAASI,QAAU,KACjB3wC,EAASxH,GAAc+3C,EAAS9iF,UAIpC8iF,EAASK,UAAaviF,IAEpB,GADAA,EAAMi9C,kBACFj9C,EAAM/C,MAAQkM,GAChBnJ,EAAMmR,iBACNqxE,GAAuB,EACvBC,SACK,GAAIziF,EAAM/C,MAAQkM,IAAcnJ,EAAMmJ,GAAmB,CAE9D,GADAnJ,EAAMmR,iBACFnR,EAAMqjD,aAAiC,MAAlBrjD,EAAMsjD,QAC7B,OAEFk/B,GAAuB,EACvBC,SAEAziF,EAAM/C,MAAQkM,IACbnJ,EAAMmJ,KACJnJ,EAAMmF,OAAS+D,GACdlJ,EAAMmF,OAAS+D,MAEnBlJ,EAAMmR,iBACFnR,EAAMwJ,UAAYxJ,EAAMmF,OAAS+D,EACnCw5E,IAEAC,IAGFT,EAASU,cAAc,IAAIC,MAAM,YAIrC,MACMC,EAAM,IAAIC,OADC,GAEXC,EAAiB,IAAIzzE,OAAJ,eAFN,EAEM,MACjBozE,EAAS,KACb,MAAM,eAAEM,EAAF,aAAkBC,GAAiBhB,EACnCiB,EAAoBC,IAE1B,IAAIhkF,EAAQ8iF,EAAS9iF,MACrB+jF,EAAkBjlE,SAASmlE,IACzB,MAAMC,EAAalkF,EAAMiE,MAAM,EAAGggF,GAC5BE,EAAWnkF,EAAMiE,MAAMggF,GAE7BjkF,EAAK,UAAMkkF,GAAN,OAAmBR,GAAnB,OAAyBS,MAGhCrB,EAAS9iF,MAAQA,EAEjB8iF,EAASe,eAAiBA,EAjBX,EAkBff,EAASgB,aAAeA,EAlBT,EAkBmCC,EAAkB9lF,QAGhEqlF,EAAU,KACd,MAAM,eAAEO,EAAF,aAAkBC,GAAiBhB,EACnCiB,EAAoBC,IACpBI,EAAwB,GAE9B,IAAIpkF,EAAQ8iF,EAAS9iF,MACrB+jF,EAAkBjlE,SAASmlE,IACzB,MAAMI,EAAWrkF,EACdiE,MAAMggF,EAAYA,EA7BR,GA8BV/2B,MAAM02B,GAET,GAAIS,EAAU,CACZ,MAAMH,EAAalkF,EAAMiE,MAAM,EAAGggF,GAC5BE,EAAWnkF,EAAMiE,MAAMggF,EAAaI,EAAS,GAAGpmF,QAGtD+B,EAAK,UAAMkkF,GAAN,OAAmBC,GACxBC,EAAYpgF,KAAKigF,OAIrBnB,EAAS9iF,MAAQA,EAEbokF,EAAYnmF,SACV4lF,EAAiBO,EAAYA,EAAYnmF,OAAS,GACpD6kF,EAASe,eAAiBrsF,KAAK+iB,IAC7BspE,EA/CS,EAgDTO,EAAYA,EAAYnmF,OAAS,IAQnC6kF,EAASe,eAAiBA,EAE5Bf,EAASgB,aAAetsF,KAAK+iB,IAC3BuoE,EAASe,eACTC,EA5DW,EA4DeM,EAAYnmF,UAQtC+lF,EAA+B,KACnC,IAAI,eAAEH,EAAF,aAAkBC,EAAlB,MAAgC9jF,GAAU8iF,EAG9C,MAAMwB,EAActkF,EAAMiE,MAAM,EAAG4/E,GAAgB32B,MAAM,WAAY,GAClEjvD,OAMH,OAJA4lF,GAAkCS,EAEjBtkF,EAAMiE,MAAM4/E,EAAgBC,GAG1C77E,MAAM,MACNzE,QACC,CAAC+gF,EAAch4E,EAAMiR,EAAK4E,IACxBmiE,EAAa99E,OACX+W,EAEI+mE,EAAa/mE,EAAM,GAAK4E,EAAM5E,EAAM,GAAGvf,OAAS,EAEhD4lF,IAER,IAEDpwD,WAGC+wD,EAAa5jF,IACjBA,EAAMmR,iBACNnR,EAAMi9C,mBAKR,IAAIulC,GAAuB,EAC3B,MAAMC,EAAe,KAInBoB,IACAhC,EAAS,CACPtgF,KAAM4oC,GAAc+3C,EAAS9iF,OAC7B0kF,YAAatB,KAIXqB,EAAU,KACVE,IAGJA,GAAc,EAEd7B,EAAS8B,OAAS,KAClB9B,EAASI,QAAU,KACnBJ,EAASK,UAAY,KAEjB0B,GACFA,EAASnE,aAGXlmF,OAAOmiD,oBAAoB,SAAUgmC,GACrCnoF,OAAOmiD,oBAAoB,QAAS6nC,GAAW,GAC/ChqF,OAAOmiD,oBAAoB,cAAevK,GAC1C53C,OAAOmiD,oBAAoB,YAAamoC,GACxCtqF,OAAOmiD,oBAAoB,OAAQ0mC,GAEnC0B,IAEAjC,EAASrgE,WAGLqiE,EAAgB,KACpBtqF,OAAOmiD,oBAAoB,YAAamoC,GAKxC32E,YAAW,KACT20E,EAAS8B,OAASvB,EAElBP,EAAS7/C,YAKPmP,EAAiBxxC,KAElBA,EAAMC,kBAAkB4K,aACvB7K,EAAMC,kBAAkBmkF,aAC1BpkF,EAAMC,OAAO4qE,QAAb,WAAyB9yE,IAAQC,uBAChC4S,GAAkB5K,EAAMC,UAEzBiiF,EAAS8B,OAAS,KAClBpqF,OAAOkiD,iBAAiB,YAAaooC,GAGrCtqF,OAAOkiD,iBAAiB,OAAQ2mC,KAK9B0B,EAAe76D,GAAM0C,SAAS3V,GAAUwU,aAAY,KACxDk3D,IACAG,EAAS7/C,WAKX,IAAI0hD,GAAc,EAIlB7B,EAASluB,SACTkwB,IAIA,IAAID,EAAkC,KAClCl2E,GAAU,mBAAoBnU,QAChCqqF,EAAW,IAAIrqF,OAAO0lF,gBAAe,KACnCyC,OAEFkC,EAAS1E,QAAQxxE,IAEjBnU,OAAOkiD,iBAAiB,SAAUimC,GAGpCnoF,OAAOkiD,iBAAiB,cAAetK,GACvC53C,OAAOkiD,iBAAiB,QAAS8nC,EAAW,CAC1CvL,SAAS,EACTgM,SAAS,IAEQ,OAAnBzG,QAAmB,IAAnBA,KACI5sE,cAAc,mCACf/E,YAAYi2E,I8Fo+CboC,CAAY,CACVj/E,GAAIgR,EAAQhR,GACZkQ,SAAUqU,KAAKo2C,MACfjyD,OAAQ6b,KAAK7b,OACb+zE,kBAAmB,CAAC31E,EAAGyB,KACrB,MAAQzB,EAAG61E,EAAWp0E,EAAGq0E,GAAcjzE,GACrC,CACEC,OAAQ9C,EACR+C,OAAQtB,GAEVgc,KAAKo2C,OAEP,MAAO,CACLgiB,EAAYp4D,KAAKo2C,MAAMpxD,WACvBqzE,EAAYr4D,KAAKo2C,MAAMnzD,YAG3B8kC,SAAUrhC,IAAoB/O,IAC5BogF,EAAcpgF,GACV4oB,GAAoB9T,IACtBisB,GAAoBjsB,MAGxBwrE,SAAUvxE,IAAmB,IAA4B,IAA3B,KAAE/O,EAAF,YAAQuiF,GAAkB,EACtD,MAAMt1D,GAAajtB,EAAK+wD,OACxBqvB,EAAcpgF,EAAMitB,IAGfA,GAAas1D,GAChBl6D,KAAKoU,UAAUm1C,IAAD,CACZ7+D,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAAC+B,EAAQhR,KAAK,OAIhBmpB,GACFqW,GAAyBjb,KAAKD,MAAMK,cAAe,CAAC3T,IAEjDmY,IAAaymD,GAChBrrD,KAAK4U,QAAQI,kBAGfhV,KAAKoU,SAAS,CACZrrB,gBAAiB,KACjBC,eAAgB,OAEdgX,KAAKo2C,MAAMjtD,eACb9E,GAAkB2b,KAAK7b,OAAQ6b,KAAKo2C,MAAMhtD,aAG5C4W,KAAK44B,oBAEPnsC,UACAunE,oBAAqBh0D,KAAK2kD,uBAAuBn1D,UAGnDwQ,KAAKw3D,mBAILO,EAActrE,EAAQ9U,MAGhB6/E,mBACNx3D,KAAKoU,SAAS,CACZ1pB,mBAAoB,GACpBC,iBAAkB,GAClB1B,eAAgB,OAIZgiE,yBACN1oE,EACAyB,GAEA,MAAMyI,EAAUuT,KAAKoY,qBAAqB71B,EAAGyB,GAE7C,OAAIyI,GAAWG,GAAcH,KAAaA,EAAQmY,UACzCnY,EAEF,KAGD2rB,qBACN71B,EACAyB,EACA8gB,GAMA,MAAMmqD,EAAiBjvD,KAAKkvD,sBAAsB3sE,EAAGyB,GACrD,GAAIirE,EAAex7E,OAAS,EAAG,CAC7B,UAAIqxB,QAAJ,IAAIA,OAAJ,EAAIA,EAAM2tD,eACR,IAAK,IAAIr1E,EAAQ6xE,EAAex7E,OAAS,EAAG2J,GAAS,EAAGA,IACtD,GAAI4iB,KAAKo2C,MAAM1rD,mBAAmBukE,EAAe7xE,GAAO3B,IACtD,OAAOwzE,EAAe7xE,GAI5B,MAAMu9E,EACJ1L,EAAeA,EAAex7E,OAAS,GAGzC,OAAOo3B,GACL8vD,EACA36D,KAAKo2C,MACL7zD,EACAyB,GAEEirE,EAAeA,EAAex7E,OAAS,GACvCknF,EAEN,OAA8B,IAA1B1L,EAAex7E,OACVw7E,EAAe,GAEjB,KAGDC,sBACN3sE,EACAyB,GAEA,OvFt5DFqQ,EuFs5D+B2L,KAAKD,MAAMK,cvFr5D1C0kB,EuFq5D0Dr4B,GpG55DrC,EACrBA,EACAd,EACApJ,EACAyB,KAGA,MAAM8mB,EAAY,GAAKnf,EAAS5G,KAAKvP,MAC/BqY,EAAe,CAACtL,EAAGyB,GAEzB,OAAIwnB,GAAkB7f,EAAUc,GACvBue,GAAiCve,EAASoB,EAAOid,GAGnDC,GAA0Cte,EAASd,EAAUkC,IoG+4DhE+sE,CAAQnuE,EAASuT,KAAKo2C,MAAO7zD,EAAGyB,GvFl5D7BqQ,EAAShY,QACboQ,IAAaA,EAAQmY,WAAakgB,EAAer4B,KAPjB,IACnC4H,EACAywB,EuF08EQ0nC,kCACNp2E,GAEsB,OAAlB8tE,IAIFA,GAAc9tE,GAkGVu2E,2BACNv2E,GAEA+tE,GAAQ7P,SAASl7D,IAAIhD,EAAMizE,UAAW,CACpC9mE,EAAGnM,EAAMyO,QACTb,EAAG5N,EAAM0O,UAGmB,IAA1Bq/D,GAAQ7P,SAASl9C,OACnB+sD,GAAQC,WAAa/P,GAAU8P,GAAQ7P,UACvC6P,GAAQG,aAAetkD,KAAKo2C,MAAMrxD,KAAKvP,MACvC2uE,GAAQE,gBAAkB7P,GACxBzzC,MAAMC,KAAKmjD,GAAQ7P,SAASnkB,YAK1By8B,wBACNx2E,GAEA,MAAMlG,EAAS0U,GAA4BxO,EAAO4pB,KAAKo2C,OACjDxyC,EAAmBC,GACvB7D,KAAKD,MAAMK,cACXJ,KAAKo2C,QAEA7jD,EAAMC,EAAMC,EAAMC,GAAQ0B,GAAgBwP,GAEjD,MAAO,CACL1zB,SACA2qF,cAAezkF,EAAMmJ,GACrBuzE,aAAcjtE,GACZ4K,GAAavgB,EAAOqS,EAAGrS,EAAO8T,EAAGgc,KAAKo2C,MAAMzsD,WAE9CmxE,WAAY73C,GACV8gC,GACA3tE,EAAMyO,QAAUmb,KAAKo2C,MAAMpxD,WAC3B5O,EAAM0O,QAAUkb,KAAKo2C,MAAMnzD,WAG7B2vE,WAAY,IAAK1iF,GACjB4vC,iBAAkB9f,KAAKD,MAAMK,cAAcpnB,QAAO,CAACC,EAAKwT,KACtDxT,EAAIG,IAAIqT,EAAQhR,GAAIwqB,GAAgBxZ,IAC7BxT,IACN,IAAI6O,KACP4mE,OAAQ,CACNC,YAAY,EACZ5kE,YAAY,EACZrR,OAAQ,CAAE6J,EAAG,EAAGyB,EAAG,GACnB6qE,eAAgB,SAChB/gE,OAAQ,CAAEvL,GAAIkQ,EAAOF,GAAQ,EAAGvO,GAAI0O,EAAOF,GAAQ,IAErDw8D,IAAK,CACHviE,QAAS,KACTwiE,eAAgB,GAChBM,qBAAqB,EACrBwL,mBAAmB,EACnB1L,0CACErvD,KAAKisD,6CACH/7E,EACA0zB,IAGNo3D,KAAM,CACJC,aAAa,EACbviF,OAAQ,MAEVk1E,eAAgB,CACdC,OAAQ,KACRC,KAAM,KACNnD,QAAS,KACT53B,UAAW,OAMT85B,wBACNz2E,EACAqpC,GAEA,IACIA,EAAiBq7C,WAAWx3C,cAAiBtjB,KAAKo2C,MAAMlsD,aAE1D,OAAO,EAET45D,IAAsB,EACtBrkC,EAAiBmzC,WAAWrwE,EAAInM,EAAMyO,QACtC46B,EAAiBmzC,WAAW5uE,EAAI5N,EAAM0O,QACtC,MAAMuoE,EAAgB3mE,IAAoBtQ,IACzBA,EAAMC,kBACG4K,aAIxB+e,KAAKk7D,gCAAgC9kF,EAAOqpC,MAGxCoI,EAAcnhC,IAAmB,KACrCo9D,IAAsB,EACtBz/D,GAAkB2b,KAAK7b,OAAQ6b,KAAKo2C,MAAMhtD,aAC1C86D,GAAgB,KAChBlkD,KAAKoU,SAAS,CACZtrB,aAAc,OAEhBkX,KAAKwrD,YAAYp1E,EAAMyO,QAASzO,EAAM0O,QAAS,MAC/C9U,OAAOmiD,oBAAoBpkD,IAAM2/E,aAAcL,GAC/Cr9E,OAAOmiD,oBAAoBpkD,IAAMsyD,WAAYxY,MAO/C,OAJAq8B,GAAgBr8B,EAEhB73C,OAAOkiD,iBAAiBnkD,IAAM2/E,aAAcL,GAC5Cr9E,OAAOkiD,iBAAiBnkD,IAAMsyD,WAAYxY,IACnC,EAwLDunC,mBAAmBr6C,GACzB,OAAqB,MAAdA,GAAsB/U,KAAKo2C,MAAM1rD,mBAAmBqqB,EAAWt5B,IAGhEwwE,6CACNp+D,EACA+V,GAEA,GAAIA,EAAiBnwB,OAAS,EAC5B,OAAO,EAIT,MAAMq3B,EAAY,GAAK9K,KAAKo2C,MAAMrxD,KAAKvP,OAChC6X,EAAIC,EAAIC,EAAIC,GAAM4G,GAAgBwP,GACzC,OACE/V,EAAMtL,EAAI8K,EAAKyd,GACfjd,EAAMtL,EAAIgL,EAAKud,GACfjd,EAAM7J,EAAIsJ,EAAKwd,GACfjd,EAAM7J,EAAIwJ,EAAKsd,EAwQX0iD,gCACN/tC,GAEA,OAAO/4B,IAAoBtQ,IACrB4pB,KAAK+yD,kBAAkBtzC,EAAkBrpC,IAG7C4pB,KAAK2yD,2BAA2BlzC,EAAkBrpC,MAI9Cq3E,8BACNhuC,GAEA,OAAO/4B,IAAoBtQ,IAEzBA,EAAM/C,MAAQkM,GAAYnJ,EAAMmR,iBAC5ByY,KAAK+yD,kBAAkBtzC,EAAkBrpC,IAG7C4pB,KAAK2yD,2BAA2BlzC,EAAkBrpC,MAI9Ck3E,oCACN7tC,GAEA,OAAO/4B,IAAoBtQ,IAKY,OAAjCqpC,EAAiBu7C,KAAKtiF,SACxB+mC,EAAiBu7C,KAAKtiF,OAASmN,G/FvqGR,EAC7B+d,EACArhB,EACAyB,KAEA,MAAOqJ,EAAIC,GAAM8G,GAAgBwP,GACjC,MAAO,CAACrhB,EAAI8K,EAAIrJ,EAAIsJ,I+FkqGZ6tE,CACEt3D,GAAoB7D,KAAKD,MAAMK,cAAeJ,KAAKo2C,OACnD32B,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,KAM9B,KADe5N,EAAMC,kBACG4K,aACtB,OAGF,GAAI+e,KAAKk7D,gCAAgC9kF,EAAOqpC,GAC9C,OAGF,MAAM7H,EAAgBhzB,GAA4BxO,EAAO4pB,KAAKo2C,QACvD6S,EAAOC,GAASz4D,GACrBmnB,EAAcr1B,EACdq1B,EAAc5zB,EACdgc,KAAKo2C,MAAMzsD,UAOb,IACG81B,EAAiBu7C,KAAKC,cACK,UAA3Bj7D,KAAKo2C,MAAMhtD,aACiB,SAA3B4W,KAAKo2C,MAAMhtD,cAGXoF,GACEopB,EAAcr1B,EACdq1B,EAAc5zB,EACdy7B,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,GACtBtX,IAEJ,OAIJ,GAAI+yC,EAAiBivC,OAAO3kE,aAC1B01B,EAAiBmzC,WAAWrwE,EAAIq1B,EAAcr1B,EAC9Ck9B,EAAiBmzC,WAAW5uE,EAAI4zB,EAAc5zB,EAC1Cgc,KAAK+yD,kBAAkBtzC,EAAkBrpC,IAC3C,OAAO,EAIX,GAAI4pB,KAAKo2C,MAAMltD,qBAAsB,CAenC,GAdgByqB,GAAoBynD,oBAClCp7D,KAAKo2C,OACJzqD,GAAaqU,KAAKoU,SAASzoB,IAC5BisB,EAAcr1B,EACdq1B,EAAc5zB,GACd,CAACyI,EAASwqB,KACRjX,KAAK8rD,4CACHr/D,EACAwqB,EACAW,MAQJ,OAFA6H,EAAiBmzC,WAAWrwE,EAAIq1B,EAAcr1B,OAC9Ck9B,EAAiBmzC,WAAW5uE,EAAI4zB,EAAc5zB,GASlD,GAJ+By7B,EAAiBuvC,IAAIC,eAAetgD,MAChEliB,GAAYuT,KAAKovD,mBAAmB3iE,MAKrCgzB,EAAiBuvC,IAAIK,0CACrB,CAGA5vC,EAAiBu7C,KAAKC,aAAc,EACpC,MAAMr3D,EAAmBC,GACvB7D,KAAKD,MAAMK,cACXJ,KAAKo2C,OAIP,GAAIxyC,EAAiBnwB,OAAS,IAAMgsC,EAAiBo7C,cAAe,CAClE,MAAOQ,EAAOC,GAAS7qE,GACrBmnB,EAAcr1B,EAAIk9B,EAAiBu7C,KAAKtiF,OAAO6J,EAC/Cq1B,EAAc5zB,EAAIy7B,EAAiBu7C,KAAKtiF,OAAOsL,EAC/Cgc,KAAKo2C,MAAMzsD,WAGN4xE,EAAeC,GAAiB,CACrCxuF,KAAKiX,IAAI2zB,EAAcr1B,EAAIk9B,EAAiBvvC,OAAOqS,GACnDvV,KAAKiX,IAAI2zB,EAAc5zB,EAAIy7B,EAAiBvvC,OAAO8T,IAI/Cy3E,EAAgBrlF,EAAMwJ,SAe5B,G/Fr0G0B,SAClC6/B,EACA7b,EACA4X,EACAC,EACA1b,GAII,IAHJ07D,EAGG,wDAFHC,EAEG,uDAFiB,EACpBC,EACG,uDADiB,EAEpB,MAAOtuE,EAAIC,GAAM8G,GAAgBwP,GAC3BlrB,EAAS,CAAE6J,EAAGi5B,EAAWnuB,EAAIrJ,EAAGy3B,EAAWnuB,GACjDsW,EAAiBtP,SAAS7H,IACxB,IAAIlK,EACAyB,EACJ,GAAIy3E,EAAe,CACjB,MAAMG,EAAQH,GAAiBC,EAAYC,EACrCE,EAAQJ,GAAiBC,EAAYC,EACrCG,EAAWr8C,EAAiBK,iBAAiBlpB,IAAInK,EAAQhR,IAC/D8G,EAAIq5E,GAASE,EAAWA,EAASv5E,EAAIkK,EAAQlK,EAAI7J,EAAO6J,EACxDyB,EAAI63E,GAASC,EAAWA,EAAS93E,EAAIyI,EAAQzI,EAAItL,EAAOsL,OAExDzB,EAAIkK,EAAQlK,EAAI7J,EAAO6J,EACvByB,EAAIyI,EAAQzI,EAAItL,EAAOsL,EAGzB2d,GAAclV,EAAS,CACrBlK,IACAyB,MAGF00B,GAAoBjsB,EAAS,CAC3BosB,sBAAuBjV,O+FwxGnBm4D,CACEt8C,EACA7b,EACAy3D,EACAC,EACAt7D,KAAKD,MACL07D,EACAF,EACAC,GAEFx7D,KAAKwqD,0BAA0B5mD,GAG3BxtB,EAAMsJ,SAAW+/B,EAAiBuvC,IAAI+L,kBAAmB,CAK3Dt7C,EAAiBuvC,IAAI+L,mBAAoB,EAEzC,MAAMr6D,EAAe,GACfs7D,EAAmB,GACnB/qC,EAAa,IAAInpC,IACjB2yB,EAAsB,IAAI3yB,IAC1BitB,EAAa0K,EAAiBuvC,IAAIviE,QACxC,IAAK,MAAMA,KAAWuT,KAAKD,MAAMI,8BAC/B,GACEH,KAAKo2C,MAAM1rD,mBAAmB+B,EAAQhR,KAGrCgR,EAAQhR,MAAR,OAAes5B,QAAf,IAAeA,OAAf,EAAeA,EAAYt5B,KAC1BgkC,EAAiBuvC,IAAIO,oBACvB,CACA,MAAM0M,EAAoBr1D,GACxB5G,KAAKo2C,MAAMntD,eACXgoC,EACAxkC,IAEKyvE,EAAaC,GAAe1rE,GACjCgvB,EAAiBvvC,OAAOqS,EAAIk9B,EAAiBu7C,KAAKtiF,OAAO6J,EACzDk9B,EAAiBvvC,OAAO8T,EAAIy7B,EAAiBu7C,KAAKtiF,OAAOsL,EACzDgc,KAAKo2C,MAAMzsD,UAEbgY,GAAcs6D,EAAmB,CAC/B15E,EAAG05E,EAAkB15E,GAAK25E,EAAcb,GACxCr3E,EAAGi4E,EAAkBj4E,GAAKm4E,EAAcb,KAE1C56D,EAAalnB,KAAKyiF,GAClBD,EAAiBxiF,KAAKiT,GACtBguB,EAAoBrhC,IAAIqT,EAAQhR,GAAIwgF,EAAkBxgF,SAEtDilB,EAAalnB,KAAKiT,GAGtB,MAAM2vE,EAAoB,IAAI17D,KAAiBs7D,GAC/C1hD,GACE8hD,EACAJ,EACAvhD,EACA,wBAEFza,KAAKD,MAAMU,mBAAmB27D,GAEhC,QAMJ,MAAMrzE,EAAkBiX,KAAKo2C,MAAMrtD,gBACnC,GAAKA,EAAL,CAIA,GAA6B,aAAzBA,EAAgB5H,KAAqB,CACvC,MAAM0N,EAAS9F,EAAgB8F,OACzBk6D,EAAKnxC,EAAcr1B,EAAIwG,EAAgBxG,EACvCymE,EAAKpxC,EAAc5zB,EAAI+E,EAAgB/E,EAEvC4a,EAAY7V,EAAgB4V,iBAC9B5V,EAAgB6V,UAChB,IAAI7V,EAAgB6V,UAAWxoB,EAAMo5E,UAEzC7tD,GAAc5Y,EAAiB,CAC7B8F,OAAQ,IAAIA,EAAQ,CAACk6D,EAAIC,IACzBpqD,mBAEG,GAAI7R,GAAgBhE,GAAkB,CAC3C02B,EAAiBu7C,KAAKC,aAAc,EACpC,MAAMpsE,EAAS9F,EAAgB8F,OAC/B,IAAIk6D,EAAKE,EAAQlgE,EAAgBxG,EAC7BymE,EAAKE,EAAQngE,EAAgB/E,EAE7BnE,GAA8BzJ,IAA4B,IAAlByY,EAAOpb,UAC9CgP,MAAOsmE,EAAIpmE,OAAQqmE,GAAOxmD,GAC3BxC,KAAKo2C,MAAMhtD,YACX2/D,EACAC,IAIkB,IAAlBn6D,EAAOpb,OACTkuB,GAAc5Y,EAAiB,CAAE8F,OAAQ,IAAIA,EAAQ,CAACk6D,EAAIC,MACjDn6D,EAAOpb,OAAS,GACzBkuB,GAAc5Y,EAAiB,CAC7B8F,OAAQ,IAAIA,EAAOpV,MAAM,GAAI,GAAI,CAACsvE,EAAIC,MAItC/7D,GAAiBlE,IAEnBiX,KAAK8rD,4CACH/iE,EACA,MACA6uB,EACA5X,KAAKo2C,MAAMprD,wBAIfy0B,EAAiBmzC,WAAWrwE,EAAIq1B,EAAcr1B,EAC9Ck9B,EAAiBmzC,WAAW5uE,EAAI4zB,EAAc5zB,EAC9Cgc,KAAK2yD,2BAA2BlzC,EAAkBrpC,GAGpD,GAA+B,cAA3B4pB,KAAKo2C,MAAMhtD,YAA6B,CAC1C,MAAMiL,EAAW2L,KAAKD,MAAMK,eACvBhqB,EAAMwJ,UAAY2jC,GAAsBlvB,EAAU2L,KAAKo2C,SACtD32B,EAAiBo7C,eAAiBp7C,EAAiBuvC,IAAIviE,QACzDuT,KAAKoU,UAAUm1C,GACb7lD,GACE,IACK6lD,EACH7+D,mBAAoB,CAClB,CAAC+0B,EAAiBuvC,IAAIviE,QAAShR,KAAK,IAGxCukB,KAAKD,MAAMK,iBAIfJ,KAAKoU,SAAS,CACZ1pB,mBAAoB,GACpBC,iBAAkB,GAClB1B,eAAgB,QAItB,MAAMozE,EzF78G4B,EACxChoE,EACA2oC,KAEA,MAAOs/B,EAAaC,EAAaC,EAAaC,GAC5C3qE,GAAyBkrC,GAC3B,OAAO3oC,EAAShY,QAAQoQ,IACtB,MAAOkwC,EAAWC,EAAWC,EAAWC,GACtC1pC,GAAiB3G,GAEnB,MACmB,cAAjBA,EAAQtL,MACRm7E,GAAe3/B,GACf4/B,GAAe3/B,GACf4/B,GAAe3/B,GACf4/B,GAAe3/B,MyF87GmB4/B,CAC9BroE,EACAtL,GAEFiX,KAAKoU,UAAUm1C,GACb7lD,GACE,IACK6lD,EACH7+D,mBAAoB,IACf6+D,EAAU7+D,sBACV2xE,EAAwBrjF,QAAO,CAACgC,EAAKyR,KACtCzR,EAAIyR,EAAQhR,KAAM,EACXT,IACN,OACCykC,EAAiBuvC,IAAIviE,QACrB,CAGE,CAACgzB,EAAiBuvC,IAAIviE,QAAQhR,KAC3B4gF,EAAwB5oF,QAE7B,OAGRusB,KAAKD,MAAMK,sBAQb86D,gCACN9kF,EACAqpC,GAEA,GAAIA,EAAiBq7C,WAAW33C,iBAAkB,CAChD,MAAM5gC,EAAInM,EAAMyO,QACVkkE,EAAKxmE,EAAIk9B,EAAiBmzC,WAAWrwE,EAK3C,OAJAyd,KAAKoU,SAAS,CACZnvB,QAAS+a,KAAKo2C,MAAMnxD,QAAU8jE,EAAK/oD,KAAKo2C,MAAMrxD,KAAKvP,QAErDiqC,EAAiBmzC,WAAWrwE,EAAIA,GACzB,EAGT,GAAIk9B,EAAiBq7C,WAAW13C,eAAgB,CAC9C,MAAMp/B,EAAI5N,EAAM0O,QACVkkE,EAAKhlE,EAAIy7B,EAAiBmzC,WAAW5uE,EAK3C,OAJAgc,KAAKoU,SAAS,CACZlvB,QAAS8a,KAAKo2C,MAAMlxD,QAAU8jE,EAAKhpD,KAAKo2C,MAAMrxD,KAAKvP,QAErDiqC,EAAiBmzC,WAAW5uE,EAAIA,GACzB,EAET,OAAO,EAGDupE,kCACN9tC,GAEA,OAAO/4B,IAAoBi2E,IACzB,MAAM,gBACJ5zE,EADI,gBAEJyB,EAFI,aAGJN,EAHI,YAIJd,EAJI,cAKJD,EALI,WAMJY,EANI,WAOJC,GACEgW,KAAKo2C,MAoBT,GAlBAp2C,KAAKoU,SAAS,CACZrqB,YAAY,EACZC,YAAY,EACZQ,gBAAiB,KACjBI,iBAAkB,KAClB9B,aAAc,KAGdE,eACEkB,GAAgB0C,GAAcoT,KAAKo2C,MAAMptD,gBACrCgX,KAAKo2C,MAAMptD,eACX,OAGRgX,KAAKwrD,YAAYmR,EAAW93E,QAAS83E,EAAW73E,QAAS,MAIrDkb,KAAKo2C,MAAMltD,qBAAsB,CACnC,MAAMA,EAAuByqB,GAAoBipD,gBAC/CD,EACA38D,KAAKo2C,MAAMltD,qBACX8W,KAAKo2C,OAEHltD,IAAyB8W,KAAKo2C,MAAMltD,sBACtC8W,KAAKoU,SAAS,CACZlrB,uBACA+B,kBAAmB,KA4BzB,GAvBAi5D,GAAgB,KAEhBl0E,OAAOmiD,oBACLpkD,IAAM2/E,aACNjuC,EAAiBmuC,eAAeC,QAElC79E,OAAOmiD,oBACLpkD,IAAMsyD,WACN5gB,EAAiBmuC,eAAeE,MAElC99E,OAAOmiD,oBACLpkD,IAAM4/E,QACNluC,EAAiBmuC,eAAe76B,WAElC/iD,OAAOmiD,oBACLpkD,IAAMqyD,MACN3gB,EAAiBmuC,eAAejD,SAG9B3qD,KAAKo2C,MAAM9qD,qBACb0U,KAAKoU,SAAS,CAAE9oB,oBAAqB,OAGT,cAAX,OAAfvC,QAAe,IAAfA,OAAA,EAAAA,EAAiB5H,MAAqB,CACxC,MAAMy2B,EAAgBhzB,GACpB+3E,EACA38D,KAAKo2C,OAGDvnD,EAAS9F,EAAgB8F,OAC/B,IAAIk6D,EAAKnxC,EAAcr1B,EAAIwG,EAAgBxG,EACvCymE,EAAKpxC,EAAc5zB,EAAI+E,EAAgB/E,EAGvC+kE,IAAOl6D,EAAO,GAAG,IAAMm6D,IAAOn6D,EAAO,GAAG,KAC1Cm6D,GAAM,KACND,GAAM,MAGR,MAAMnqD,EAAY7V,EAAgB4V,iBAC9B,GACA,IAAI5V,EAAgB6V,UAAW+9D,EAAWnN,UAU9C,OARA7tD,GAAc5Y,EAAiB,CAC7B8F,OAAQ,IAAIA,EAAQ,CAACk6D,EAAIC,IACzBpqD,YACAK,mBAAoB,CAAC8pD,EAAIC,UAG3BhpD,KAAK83C,cAAc5E,cAAcxa,IAInC,GAAI/rC,GAAe5D,GAAkB,CACnC,MAAMs/D,EAAet/D,EACrB,IACEiX,KAAKwoD,0BAA0BH,GAC/BroD,KAAKoU,SACH,CAAE1pB,mBAAoB,CAAE,CAAC29D,EAAa5sE,KAAK,KAC3C,KACEukB,KAAK83C,cAAc5E,cAAcxa,OAGrC,MAAO5gD,GACPC,QAAQD,MAAMA,GACdkoB,KAAKD,MAAMU,mBACTT,KAAKD,MACFI,8BACA9jB,QAAQ4kC,GAAOA,EAAGxlC,KAAO4sE,EAAa5sE,MAE3CukB,KAAK83C,cAAc5E,cAAcxa,IAEnC,OAGF,GAAI3rC,GAAgBhE,GAAkB,CAChCA,EAAiB8F,OAAOpb,OAAS,GACnCusB,KAAK4U,QAAQI,kBAEf,MAAM4C,EAAgBhzB,GACpB+3E,EACA38D,KAAKo2C,OAsDP,YAlDG32B,EAAiBu7C,KAAKC,cACvBlyE,GACCmB,EAeQu1B,EAAiBu7C,KAAKC,cAAgB/wE,IAE7CN,GAAiBoW,KAAKo2C,QACtBnpD,GAAiBlE,IAEjB4uB,GACE5uB,EACAiX,KAAKo2C,MACLp2C,KAAKD,MACL6X,GAGJ5X,KAAKoU,SAAS,CAAEnpB,kBAAmB,GAAID,kBAAmB,OACrD7B,EAWH6W,KAAKoU,UAAUm1C,IAAD,CACZxgE,gBAAiB,KACjB2B,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAACsV,KAAKo2C,MAAMrtD,gBAAiBtN,KAAK,QAdtCyI,GAAY8b,KAAK7b,QACjB6b,KAAKoU,UAAUm1C,IAAD,CACZxgE,gBAAiB,KACjBK,YAAa,YACbsB,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAACsV,KAAKo2C,MAAMrtD,gBAAiBtN,KAAK,UAjCxCkmB,GAAc5Y,EAAiB,CAC7B8F,OAAQ,IACH9F,EAAgB8F,OACnB,CACE+oB,EAAcr1B,EAAIwG,EAAgBxG,EAClCq1B,EAAc5zB,EAAI+E,EAAgB/E,MAIxCgc,KAAKoU,SAAS,CACZlqB,aAAcnB,EACdC,eAAgBgX,KAAKo2C,MAAMrtD,oBAsCjC,GACkB,cAAhBK,GACAL,GACAwZ,GAAwBxZ,GASxB,OANAiX,KAAKD,MAAMU,mBACTT,KAAKD,MAAMI,8BAA8B1mB,MAAM,GAAI,SAErDumB,KAAKoU,SAAS,CACZrrB,gBAAiB,OAKjBA,GACF4Y,GACE5Y,EACAga,GAAwBha,IAIxByB,GACFwV,KAAK4U,QAAQI,kBAGXxqB,GAAmB+X,GAAwB/X,IAC7CwV,KAAKD,MAAMU,mBACTT,KAAKD,MACFI,8BACA9jB,QAAQ4kC,GAAOA,EAAGxlC,KAAO+O,EAAgB/O,MAMhD,MAAMs5B,EAAa0K,EAAiBuvC,IAAIviE,QACxC,GACEsoB,IACC0K,EAAiBu7C,KAAKC,cACtBx7C,EAAiBuvC,IAAIO,oBAEtB,GAAIoN,EAAW/8E,SACb,GAAIogB,KAAKo2C,MAAM1rD,mBAAmBqqB,EAAWt5B,IAC3C,GAAI4nB,GAAmBrD,KAAKo2C,MAAOrhC,GAAa,CAI9C,MAAM8nD,EAAuC9nD,EAAW5R,SACrDuN,SAASzN,GACRiB,GAAmBlE,KAAKD,MAAMK,cAAe6C,KAE9CjoB,KAAKyR,IAAD,CAAgB,CAACA,EAAQhR,KAAK,MAClCzC,QAAO,CAAC8jF,EAAQ7jF,KAAT,IAAuB6jF,KAAW7jF,KAAQ,IAEpD+mB,KAAKoU,UAAU2oD,IAAD,CACZpyE,iBAAkB,IACboyE,EAAWryE,sBACXqqB,EAAW5R,SACXnoB,KAAKgiF,IAAD,CAAY,CAACA,IAAM,MACvBhkF,QAAO,CAACqmC,EAAMpmC,KAAP,IAAqBomC,KAASpmC,KAAQ,KAElDyR,mBAAoB,IACfqyE,EAAWryE,sBACXmyE,YAMP78D,KAAKoU,UAAUm1C,GACb7lD,GACE,IACK6lD,EACH7+D,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAACqqB,EAAYt5B,KAAK,IAGtBukB,KAAKD,MAAMK,sBAOjBJ,KAAKoU,UAAU2oD,IAAD,CACZryE,mBAAoB,IACfqyE,EAAWryE,mBACd,CAACqqB,EAAYt5B,KAAK,YAKxBukB,KAAKoU,UAAUm1C,IAAD,IACT7lD,GACD,IACK6lD,EACH7+D,mBAAoB,CAAE,CAACqqB,EAAWt5B,KAAK,IAEzCukB,KAAKD,MAAMK,mBAOhBJ,KAAKo2C,MAAMltD,sBACXu2B,EAAiBu7C,KAAKC,aACtBj7D,KAAKo2C,MAAMrsD,cACVgrB,GACAlK,GACEkK,EACA/U,KAAKo2C,MACL32B,EAAiBvvC,OAAOqS,EACxBk9B,EAAiBvvC,OAAO8T,KAExB+wB,GACA0K,EAAiBuvC,IAAIK,6CAYtBlmE,GAAiC,aAAhBC,GAA8BL,GAClDiX,KAAKoU,UAAUm1C,IAAD,CACZ7+D,mBAAoB,IACf6+D,EAAU7+D,mBACb,CAAC3B,EAAgBtN,KAAK,QAMV,cAAhB2N,GACAm6B,GAAsBvjB,KAAKD,MAAMK,cAAeJ,KAAKo2C,SAErDp2C,KAAK4U,QAAQI,mBAGXyK,EAAiBu7C,KAAKC,aAAelxE,GAAcC,KACpDJ,GAAiBoW,KAAKo2C,OACnB9+B,GACAY,IACFrU,GAAoB7D,KAAKD,MAAMK,cAAeJ,KAAKo2C,QAIlDjtD,GAAiC,aAAhBC,EAQpB4W,KAAKoU,SAAS,CACZrrB,gBAAiB,KACjBkC,kBAAmB,MATrB/G,GAAY8b,KAAK7b,QACjB6b,KAAKoU,SAAS,CACZrrB,gBAAiB,KACjBkC,kBAAmB,GACnB7B,YAAa,gBAtCf4W,KAAKoU,SAAS,CACZ1pB,mBAAoB,GACpBC,iBAAkB,GAClB1B,eAAgB,UAodhBuhE,0BACN5mD,GAEA,MAAM3Y,EjGx2HRoJ,KAEA,MAAM4oE,EAAqB,IAAIr9D,IAAIvL,EAASrZ,KAAI,QAAC,GAAES,GAAH,SAAYA,MAC5D,OAAO4Y,EAASqc,SAASjkB,GACvBQ,GAAiBR,GACZutB,GACCvtB,GACApQ,QACCoQ,IAAawwE,EAAmB1nE,IAAI9I,EAAQhR,MAE/C0R,GAAkBV,GAClBgrB,GAA+ChrB,GAASpQ,QACrDo4B,IAAawoD,EAAmB1nE,IAAIkf,EAAQ,GAAGh5B,MAElD,MiG01HsByhF,CAA8Bt5D,GACxD5D,KAAKoU,SAAS,CAAEnpB,sBAGVqkE,eAAev6C,GACrB/U,KAAKoU,UAAUm1C,IAAD,CACZ7+D,mBAAoB,GACpBC,iBAAkB,GAGlB1B,eACEsgE,EAAUtgE,gBACI,MAAd8rB,GACA9Q,GAAiB8Q,EAAYw0C,EAAUtgE,gBACnCsgE,EAAUtgE,eACV,SAER+W,KAAKoU,SAAS,CACZ1pB,mBAAoB,GACpBH,2BAA4ByV,KAAKo2C,MAAM1rD,qBA4fnCygE,sCACN5oE,EACAyB,EACA2H,EACAxH,EACAkY,GAEA,MAAM8gE,EvFzuJkC,EAC1C9oE,EACA9R,EACAyB,KAEA,IAAI+wB,EAAa,KAEjB,IAAK,IAAI33B,EAAQiX,EAAS5gB,OAAS,EAAG2J,GAAS,IAAKA,EAAO,CACzD,GAAIiX,EAASjX,GAAOwnB,UAClB,SAEF,MAAOvX,EAAIC,EAAIC,EAAIC,GAAMsE,GAAyBuC,EAASjX,IAC3D,GAAIiQ,EAAK9K,GAAKA,EAAIgL,GAAMD,EAAKtJ,GAAKA,EAAIwJ,EAAI,CACxCunB,EAAa1gB,EAASjX,GACtB,OAGJ,OAAO23B,GuFwtJwBqoD,CAC3Bp9D,KAAKD,MACFI,8BACA9jB,QAAQoQ,IAAaG,GAAcH,KACtClK,EACAyB,GAEF,GAAIm5E,EAAsB,CACxB,MAAM1xD,EACJ0xD,EAAqB56E,EAAI46E,EAAqB16E,MAAQ,EAClDipB,EACJyxD,EAAqBn5E,EAAIm5E,EAAqBx6E,OAAS,EAOzD,GANyB3V,KAAK2hB,MAC5BpM,EAAIkpB,EACJznB,EAAI0nB,GAGe5+B,IACE,CACrB,MAAQyV,EAAG61E,EAAWp0E,EAAGq0E,GAAcjzE,GACrC,CAAEC,OAAQomB,EAAgBnmB,OAAQomB,GAClC/f,GAEF,MAAO,CAAEysE,YAAWC,YAAW5sD,iBAAgBC,oBA6E7C47C,mBAAgE,IAAD,EACrE,aAAItnD,KAAK2kD,8BAAT,aAAI,EAA6Bn1D,QAAS,CACxC,MAAMwkE,EAAsBh0D,KAAK2kD,uBAAuBn1D,SAClD,KAAErT,EAAF,IAAQkmC,GAAQ2xC,EAAoBniC,wBAC1C,MAAO,CACL7sC,WAAY7I,EACZ8G,UAAWo/B,GAGf,MAAO,CACLr9B,WAAY,EACZ/B,UAAW,GAIa,uBAC1B,MAAMvG,EACJX,EAAUwnB,MAAMjnB,GAASA,EAAKf,OAASykB,KAAKomB,MAAMq8B,YAClD3mE,QACIc,EAAYF,GAClBsjB,KAAKm5C,YAAY,KApqJfoL,GAUUt8B,aAAkC,CAE9C2qB,UAAWnhE,KA6qJb0D,eAAyBnH,IAAIC,MAC7BkH,eAAyBnH,IAAIE,cAE7B8B,OAAOikB,EAAIjkB,OAAOikB,GAAM,GAExBpY,OAAO05E,iBAAiBvlF,OAAOikB,EAAG,CAChCI,SAAU,CACRmhE,cAAc,EACd5+D,MACE,OAAOoJ,KAAK63B,IAAI93B,MAAMI,+BAExB/mB,IAAIib,GACF,OAAO2L,KAAK63B,IAAI93B,MAAMU,mBAAmBpM,QAKlCkwD,U,YCn8JR,MAAM8Y,GAASj3C,IAQpB,MAAM,MAAEn0C,EAAQxD,IAAMC,OAAU03C,EAC1Bk3C,EAAYC,GAAYtrF,GAE9B,IAAKqrF,EACH,OAAO,KAWT,OAAOE,uBACL,uBACE13C,UAAWmB,aAAK,QAASb,EAAMN,WAC/B0C,KAAK,SACL,aAAW,OACXuK,UAbmB38C,IACjBA,EAAM/C,MAAQkM,KAChBnJ,EAAM+8C,YAAYC,2BAClBh9C,EAAMi9C,kBACNjN,EAAMqL,mBAUN,kBAAiBrL,EAAMq3C,WALzB,UAOE,sBAAK33C,UAAU,oBAAoBgB,QAASV,EAAMqL,iBAClD,sBACE3L,UAAU,iBACV5jC,MAAO,CAAE,cAAc,GAAd,OAAkBkkC,EAAM3F,SAAxB,OACT6S,SAAU,EAHZ,SAKGlN,EAAMuB,cAGX21C,IAIEC,GAAetrF,IACnB,MAAOokD,EAAKqnC,GAAUpxE,mBAAgC,MAEhDwsD,EAAWnhB,KACXgmC,EAAcl3C,iBAAOqyB,GAC3B6kB,EAAYnuE,QAAUspD,EAEtB,MAAQP,UAAWyb,GAAwBztC,KA8B3C,OA5BAqL,2BAAgB,KACVyE,GACFA,EAAIC,UAAUmhC,OAAO,qBAAsB3e,KAE5C,CAACziB,EAAKyiB,IAETlnB,2BAAgB,KACd,MAAMgsC,KACH,OAAC5J,QAAD,IAACA,OAAD,EAACA,EAAqB19B,UAAUrE,SAAS,iBAChC,SAAVhgD,EACIokD,EAAMx5C,SAASmF,cAAc,OAanC,OAXAq0C,EAAIC,UAAUn1B,IAAI,aAAc,8BAChCk1B,EAAIC,UAAUmhC,OAAO,qBAAsBkG,EAAYnuE,SAEnDouE,IACFvnC,EAAIC,UAAUn1B,IAAI,eAClBk1B,EAAIC,UAAUn1B,IAAI,gCAEpBtkB,SAASoF,KAAKI,YAAYg0C,GAE1BqnC,EAAOrnC,GAEA,KACLx5C,SAASoF,KAAKiB,YAAYmzC,MAE3B,CAAC29B,EAAqB/hF,IAElBokD,GC/EIwnC,GAAUz3C,IASrB,MAAO03C,EAAYC,GAAiB5xE,MAC7B6xE,GAAqB1xE,mBAASzP,SAASm2C,gBACxC,GAAEv3C,GAAO8qC,KAEfQ,qBAAU,KACR,IAAK+2C,EACH,OAGF,MAAMG,EAAoBC,EAAuBJ,GAE7CG,EAAkBxqF,OAAS,IAAyB,IAApB2yC,EAAMk4B,YAEvC2f,EAAkB,IAAMA,EAAkB,IAAIxlD,QAGjD,MAAMw6B,EAAiB78D,IACrB,GAAIA,EAAM/C,MAAQkM,GAAU,CAC1B,MAAM0+E,EAAoBC,EAAuBJ,IAC3C,cAAE9qC,GAAkBn2C,SACpBshF,EAAeF,EAAkBlvC,WACpCtiC,GAAYA,IAAYumC,IAGN,IAAjBmrC,GAAsB/nF,EAAMwJ,UAC9Bq+E,EAAkBA,EAAkBxqF,OAAS,GAAGglC,QAChDriC,EAAMmR,kBAEN42E,IAAiBF,EAAkBxqF,OAAS,GAC3C2C,EAAMwJ,WAEPq+E,EAAkB,GAAGxlD,QACrBriC,EAAMmR,oBAOZ,OAFAu2E,EAAW5rC,iBAAiB,UAAW+gB,GAEhC,IAAM6qB,EAAW3rC,oBAAoB,UAAW8gB,KACtD,CAAC6qB,EAAY13C,EAAMk4B,YAEtB,MAAM4f,EAA0BvgE,IAC9B,MAAMsgE,EAAoBtgE,EAAKygE,iBAC7B,qDAGF,OAAOH,EAAoBl9D,MAAMC,KAAKi9D,GAAqB,IAGvDxrC,EAAU,KACburC,EAAkCvlD,QACnC2N,EAAMqL,kBAGR,OACE,eAAC,GAAD,CACE3L,UAAWmB,aAAK,SAAUb,EAAMN,WAChC23C,WAAW,eACXh9C,SAAU2F,EAAMwR,MAAQ,IAAM,IAC9BnG,eAAgBgB,EAChBxgD,MAAOm0C,EAAMn0C,MALf,SAOE,gBAAC,GAAD,CAAQo0C,IAAK03C,EAAb,UACE,sBAAItiF,GAAE,UAAKA,EAAL,iBAAwBqqC,UAAU,gBAAxC,UACE,uBAAMA,UAAU,uBAAhB,SAAwCM,EAAMkB,QAC9C,yBACExB,UAAU,eACVgB,QAAS2L,EACT,aAAY92C,EAAE,iBAHhB,SAKGg8C,KAAgB3M,GAAOD,QAG5B,sBAAKjF,UAAU,kBAAf,SAAkCM,EAAMuB,iBCzFnCs6B,GAAc,IAMpB,IANqB,QAC1Bz8B,EAD0B,QAE1BiN,GAII,EACJ,MAAOsoB,EAAcC,GAAmB1uD,qBAAWk5B,IAC3C+yB,UAAWyb,GAAwBztC,KAErCmyB,EAAcxyB,IAAM35B,aAAY,KACpCyuD,GAAgB,GAEZvoB,GACFA,IAGiB,OAAnBuhC,QAAmB,IAAnBA,KAAqBv7C,UACpB,CAACga,EAASuhC,IAEb,OACE,qCACGjZ,GACC,eAAC,GAAD,CACEnjB,OAAK,EACLnG,eAAgBinB,EAChBpxB,MAAO3rC,EAAE,qBAHX,SAKE,sBAAKuG,MAAO,CAAEE,WAAY,YAA1B,SAAyCojC,S,aCxB5C,MAAM64C,WAAyBn4C,IAAMs+B,UAGzC,cAAD,yBACApO,MAA+B,CAC7BkoB,UAAU,EACVC,cAAe,GACfC,aAAc,IAGhBlmB,SACE,OAAOt4C,KAAKo2C,MAAMkoB,SAAWt+D,KAAKy+D,cAAgBz+D,KAAKomB,MAAMuB,SAG/D+2C,kBAAkB5mF,EAAc6mF,GAC9B,MAAMC,EAAqB,GAC3B,IAAK,MAAOvrF,EAAKmC,KAAUqG,OAAO6F,QAAQ,IAAK88E,eAC7C,IACEI,EAAcvrF,GAAOyG,KAAKU,MAAMhF,GAChC,MAAOsC,GACP8mF,EAAcvrF,GAAOmC,EAIzBqpF,MAAkBC,IAChBA,EAAMC,UAAUJ,GAChB,MAAMK,EAAUH,KAAwB/mF,GAExCkoB,KAAKoU,UAAUgiC,IAAD,CACZkoB,UAAU,EACVC,cAAeS,EACfR,aAAc1kF,KAAKC,UAAU6kF,UAK3BK,eAAe7oF,GACjBA,EAAMC,SAAWwG,SAASm2C,gBAC5B58C,EAAMmR,iBACLnR,EAAMC,OAA+B+zD,UAIX,0BAC7B,IAAInoD,EAAO,GACX,IACE,MAAMi9E,SACE,+BAGNz7B,QACFxhD,EAAO6T,mBAAmBopE,EAAcl/D,KAAKo2C,MAAMmoB,gBACnD,MAAOzmF,GACPC,QAAQD,MAAMA,GAGhB9H,OAAO65E,KAAP,mEAC8D5nE,IAIxDw8E,cACN,OACE,sBAAK34C,UAAU,yBAAf,SACE,uBAAKA,UAAU,+BAAf,UACE,uBAAKA,UAAU,4CAAf,UACGnqC,EAAE,+BACH,yBAAQmrC,QAAS,IAAM92C,OAAOC,SAASkvF,SAAvC,SACGxjF,EAAE,uCAGP,uBAAKmqC,UAAU,qCAAf,UACGnqC,EAAE,kCACH,yBACEmrC,QAAS,KACP,IACE03C,aAAa79D,QACb3wB,OAAOC,SAASkvF,SAChB,MAAOrnF,GACPC,QAAQD,MAAMA,KANpB,SAUG6D,EAAE,2CAEL,wBACA,uBAAKmqC,UAAU,UAAf,UACE,uBAAM0C,KAAK,MAAM,aAAW,UAA5B,0BAGC7sC,EAAE,iCACH,uBAAM6sC,KAAK,MAAM,cAAY,OAA7B,gCAKJ,iCACE,uBAAK1C,UAAU,wBAAf,UACGnqC,EAAE,mCACFqkB,KAAKo2C,MAAMmoB,cACX5iF,EAAE,uCAEL,uBAAKmqC,UAAU,wBAAf,UACGnqC,EAAE,oCACH,yBAAQmrC,QAAS,IAAM9mB,KAAKo/D,oBAA5B,SACGzjF,EAAE,yCAEJA,EAAE,wCAEL,sBAAKmqC,UAAU,wBAAf,SACE,uBAAKA,UAAU,sBAAf,UACE,iCAAQnqC,EAAE,8BACV,2BACEgrD,KAAM,EACN/e,cAAe5nB,KAAKi/D,eACpBI,UAAU,EACV7pF,MAAOwqB,KAAKo2C,MAAMooB,6B,aC5HhCrpF,eAAyBnH,IAAIC,OAG/BqxF,IACEtvF,OAAOuvF,uBAAP,4BACqBC,GAAIhsF,KADzB,YACiCgsF,GAAIxnF,QADrC,WCIG,MAAMynF,GAAiBr5C,IAC5B,MAAOs5C,EAASC,GAAcrzE,oBAAS,GAYvC,OAVAy6B,qBAAU,KACR,MAGMrqC,EACJX,EAAUwnB,MAAMjnB,GAASA,EAAKf,OAAS6qC,EAAMq8B,YAAa3mE,EAJzC1I,iBACXwJ,EAAYF,IAIpBkjF,GACAD,GAAW,KACV,CAACv5C,EAAMq8B,WAEHid,EAAU,eAACpjB,GAAD,IAAqBl2B,EAAMuB,U,YCFvC,MCRDk4C,GAAcz5C,IAA4B,IAAD,EAC7C,MAAM,SACJ2B,EADI,YAEJk/B,EAFI,cAGJqN,EAHI,oBAIJ/W,EAJI,gBAKJ7D,EALI,gBAMJma,EANI,iBAOJnW,EAPI,aAQJyX,EARI,SASJ1S,EAAW3mE,EAAYP,KATnB,gBAUJ8P,EAVI,eAWJD,EAXI,gBAYJk6D,EAZI,iBAaJvF,EAbI,MAcJ9tE,EAdI,KAeJuB,EAfI,kBAgBJsvE,EAhBI,QAiBJ2F,EAjBI,aAkBJuO,GAAe,EAlBX,uBAmBJ3B,GAAyB,EAnBrB,gBAoBJ/hB,EApBI,UAqBJ0R,GAAY,EArBR,kBAsBJkL,GACE9pC,EAEE10C,EAAa,UAAG00C,EAAMwsB,iBAAT,aAAG,EAAiBlhE,cAEjCkhE,EAAmC,CACvClhE,cAAe,IACVD,IAAmBC,iBACnBA,IAIqB,IAAD,KAA3B,OAAIA,QAAJ,IAAIA,OAAJ,EAAIA,EAAeG,UACjB+gE,EAAUlhE,cAAcG,OAAOC,eAA/B,oBACEJ,EAAcG,cADhB,aACE,EAAsBC,sBADxB,QAEEL,IAAmBC,cAAcG,OAAOC,gBAqB5C,OAlBAi1C,qBAAU,KAER,MAAMmlC,EAAmB91E,IAEI,kBAAhBA,EAAMimB,OAAsC,IAAhBjmB,EAAMimB,OAC3CjmB,EAAMmR,kBAQV,OAJA1K,SAASq1C,iBAAiB,YAAag6B,EAAiB,CACtDuC,SAAS,IAGJ,KACL5xE,SAASs1C,oBAAoB,YAAa+5B,MAE3C,IAGD,eAACuT,GAAD,CAAehd,SAAUA,EAAzB,SACE,eAAC,GAAD,CACE16B,SAAUA,EACVk/B,YAAaA,EACbqN,cAAeA,EACf/W,oBAAqBA,EACrB7D,gBAAiBA,EACjBma,gBAAiBA,EACjBnW,iBAAkBA,EAClByX,aAAcA,EACd1S,SAAUA,EACVp3D,gBAAiBA,EACjBD,eAAgBA,EAChBk6D,gBAAiBA,EACjBvF,iBAAkBA,EAClB9tE,MAAOA,EACPuB,KAAMA,EACNsvE,kBAAmBA,EACnBlQ,UAAWA,EACX6V,QAASA,EACTuO,aAAcA,EACd3B,uBAAwBA,EACxB/hB,gBAAiBA,EACjB0R,UAAWA,EACXkL,kBAAmBA,OAQrB5N,GAAW,CACfgV,EACAwI,KAEA,MACE7Y,YAAa8Y,EACbntB,UAAWotB,EAAgB,MACxB3gD,GACDi4C,GAEFrQ,YAAagZ,EACbrtB,UAAWstB,EAAgB,MACxBzwE,GACDqwE,EAGEK,EAAoBtkF,OAAOD,KAAKokF,GAGhCI,EAAoBvkF,OAAOD,KAAKskF,GAItC,GAAIC,EAAkB1sF,SAAW2sF,EAAkB3sF,OACjD,OAAO,EAGT,MAAM4sF,EAAkBF,EAAkBrqC,OAAOziD,IAC/C,GAAY,kBAARA,EAAyB,CACFwI,OAAOD,KAC9BokF,EAActuF,eAECokD,OAAOziD,IAAS,IAAD,QAC9B,MACU,WAARA,IAAA,OACA2sF,QADA,IACAA,GADA,UACAA,EAAetuF,qBADf,aACA,EAA8BG,UAD9B,OAEAquF,QAFA,IAEAA,GAFA,UAEAA,EAAexuF,qBAFf,aAEA,EAA8BG,QAG5BmuF,EAActuF,cAAcG,OAAOC,iBACnCouF,EAAcxuF,cAAcG,OAAOC,gBAIxB,OAAbkuF,QAAa,IAAbA,GAAA,UAAAA,EAAetuF,qBAAf,eAA+B2B,OAA/B,OACA6sF,QADA,IACAA,GADA,UACAA,EAAexuF,qBADf,aACA,EAA+B2B,OAIrC,OAAO,KAGHitF,EAAWzkF,OAAOD,KAAK07E,GACvBiJ,EAAW1kF,OAAOD,KAAKkkF,GAC7B,OACEO,GACAC,EAAS7sF,SAAW8sF,EAAS9sF,QAC7B6sF,EAASxqC,OAAOziD,GAAQgsC,EAAKhsC,KAASoc,EAAKpc,MAIzCmtF,GAAmBr6C,sBAGvB,CAACC,EAAOC,IAAQ,eAACw5C,GAAD,IAAgBz5C,EAAOkuC,cAAejuC,MACzCH,WAAM4D,KAAK02C,GAAkBle,ICzKrC,MAMMme,GAAwB,QAIxBC,GACM,4BADNA,GAEH,mBAGH,IAAKC,I,SAAAA,K,kBAAAA,E,uBAAAA,Q,KAKL,MAAMC,GACI,oBADJA,GAEC,e,qBCNP,MAAMC,GAYXt6D,YAAY,GAYR,IAZQ,SACVmuD,EADU,UAEVoM,GAUC,OAtBKC,cAAgB,IAAIj5E,IAsBzB,KApBKk5E,YAAc,IAAIl5E,IAoBvB,KAlBKm5E,WAAa,IAAIn5E,IAkBtB,KAjBK68C,aAAe,IAAI78C,IAiBxB,KAfKo5E,eAeL,OAdKC,gBAcL,OAQHC,cAAiB3lF,GAEbukB,KAAKihE,WAAW1rE,IAAI9Z,IACpBukB,KAAK+gE,cAAcxrE,IAAI9Z,IACvBukB,KAAKghE,YAAYzrE,IAAI9Z,IACrBukB,KAAK2kC,aAAapvC,IAAI9Z,GAbvB,KAiBH4lF,YAAe5lF,GACNukB,KAAKihE,WAAW1rE,IAAI9Z,GAlB1B,KAqBHqlF,UAAY1tF,UAML,IANY,SACjBihB,EADiB,MAEjBkJ,GAII,EACJ,MAAM+jE,EAA0C,IAAIx5E,IAEpD,IAAK,MAAM2E,KAAW4H,EAElB7H,GAA0BC,IAC1B8Q,EAAM9Q,EAAQC,UACbsT,KAAKohE,cAAc30E,EAAQC,UAE5B40E,EAAWloF,IAAIqT,EAAQC,OAAQ6Q,EAAM9Q,EAAQC,SAC7CsT,KAAKghE,YAAY5nF,IAAIqT,EAAQC,QAAQ,IAIzC,IACE,MAAM,WAAEu0E,EAAF,aAAct8B,SAAuB3kC,KAAKmhE,WAAW,CACzDG,eAGF,IAAK,MAAO50E,KAAWu0E,EACrBjhE,KAAKihE,WAAW7nF,IAAIsT,GAAQ,GAG9B,MAAO,CACLu0E,aACAt8B,gBAXJ,QAcE,IAAK,MAAOj4C,KAAW40E,EACrBthE,KAAKghE,YAAY1oE,OAAO5L,KAxD3B,KA6DHgoE,SAAWthF,UAMT,IAAKoI,EAAI/H,OACP,MAAO,CACL8tF,YAAa,GACb58B,aAAc,IAAI78C,KAGtB,IAAK,MAAMrM,KAAMD,EACfwkB,KAAK+gE,cAAc3nF,IAAIqC,GAAI,GAG7B,IACE,MAAM,YAAE8lF,EAAF,aAAe58B,SAAuB3kC,KAAKkhE,UAAU1lF,GAE3D,IAAK,MAAM4vC,KAAQm2C,EACjBvhE,KAAKihE,WAAW7nF,IAAIgyC,EAAK3vC,IAAI,GAE/B,IAAK,MAAOiR,KAAWi4C,EACrB3kC,KAAK2kC,aAAavrD,IAAIsT,GAAQ,GAGhC,MAAO,CAAE60E,cAAa58B,gBAVxB,QAYE,IAAK,MAAMlpD,KAAMD,EACfwkB,KAAK+gE,cAAczoE,OAAO7c,KA1F7B,KAsGH+lF,oBAAuBntE,GACdA,EAASsa,MAAMliB,GAElBD,GAA0BC,KACzBA,EAAQmY,WACT5E,KAAKghE,YAAYzrE,IAAI9I,EAAQC,UA3GhC,KAmHH+0E,+BACEh1E,GAGED,GAA0BC,IAC1BuT,KAAKqhE,YAAY50E,EAAQC,SACN,YAAnBD,EAAQ6K,OAxHV0I,KAAKkhE,UAAYxM,EACjB10D,KAAKmhE,WAAaL,EA2HpBY,QACE1hE,KAAK+gE,cAAcpgE,QACnBX,KAAKghE,YAAYrgE,QACjBX,KAAKihE,WAAWtgE,QAChBX,KAAK2kC,aAAahkC,SAIf,MAAMghE,GAAuBvuF,UAQ7B,IARoC,MACzCmqB,EADyC,SAEzCqkE,EAFyC,cAGzCxnF,GAKI,EACJ,MAAMynF,EAGA,GAEN,IAAK,MAAOpmF,EAAIuiB,KAAaT,EAAO,CAClC,MAAMhpB,GAAS,IAAIC,aAAcC,OAAOupB,EAASE,SAE3C4jE,QAAoBpoF,aAAiCnF,EAAQ,CACjE6F,gBACAD,SAAU,CACRsB,KACA6gB,SAAU0B,EAAS1B,SACnBy0D,QAAS9wE,KAAKshB,SAIlB,GAAIhtB,EAAO2E,WAAa0oF,EACtB,MAAM,IAAIrrF,MACRoF,EAAE,oBAAqB,CACrB60E,QAAQ,GAAD,OAAKxjF,KAAK0+D,MAAMk2B,EAAW,KAAO,MAAlC,SAKbC,EAAeroF,KAAK,CAClBiC,KACAlH,OAAQutF,IAIZ,OAAOD,GAGIE,GAA4B3pB,IAKlCA,EAAOzT,aAAavtC,MAGzBghD,EAAO4pB,cAAc/X,YAAY,CAC/B51D,SAAU+jD,EAAO4pB,cACd/c,mCACAjqE,KAAKyR,GAEFD,GAA0BC,IAC1B2rD,EAAOzT,aAAapvC,IAAI9I,EAAQC,QAEzB2V,GAAe5V,EAAS,CAC7B6K,OAAQ,UAGL7K,OChOTw1E,GAAkBnoF,KAAKU,MAAMrF,iXAEnC,IAAI+sF,GACF,KACEC,GAA+C,KAC/CC,GAAqD,KAErDC,IAAwB,EAE5B,MAuBMC,GAAelvF,UAGd8uF,KACHA,GA3BkB9uF,WACpB,MAAMmvF,SACE,qDACN9+B,QAEF,IAAK4+B,GAAuB,CAC1B,IACEE,EAASC,cAAcP,IACvB,MAAOnqF,GAGP,GAAmB,sBAAfA,EAAMyD,KAGR,MAAMzD,EAFNC,QAAQw0B,KAAKz0B,EAAMtE,KAAMsE,EAAMyD,MAKnC8mF,IAAwB,EAG1B,OAAOE,GAOaE,IAEbP,IAKHQ,GAAgBtvF,UACpB,MAAMmvF,QAAiBD,KAUvB,OATKH,KACHA,GAAmB,uDAII,IAArBA,WACIA,GACNA,IAAmB,GAEdI,GAGII,GAAsBvvF,UACjC,MAAMmvF,QAAiBD,KAUvB,OATKF,KACHA,GAAyB,uDAII,IAA3BA,WACIA,GACNA,IAAyB,GAEpBG,GAkDHK,GAA4B,IAAIzqE,QAEzB0qE,GAAoB,CAC/BC,EACAzuE,KAEA,GAAIyuE,EAAOC,QAAUD,EAAOE,QAAUF,EAAOG,QAAS,CACpD,MAAMC,EAAeliD,GAAgB3sB,GAErC,OAAOuuE,GAA0BhsE,IAAIksE,EAAOC,UAAYG,EAI1D,OAAO,GAGIC,GAAsB/vF,UAM5B,IANmC,OACxCgwF,EADwC,MAExC7lE,GAII,EACJ,MAAMglE,QAAiBI,KAEjBh+B,EAAe,IAAI78C,IACnBm5E,EAAa,IAAIn5E,IAuBvB,aArBMjS,QAAQ6F,IACZ6hB,EAAMviB,KAAI5H,UAA2B,IAApB,GAAEqI,EAAF,OAAMlH,GAAa,EAClC,UACQguF,EACHc,UACAh9C,IAFG,UAEI+8C,EAFJ,YAEc3nF,IACjB6nF,IACC,IAAI5uF,KAAK,CAACH,GAAS,CACjB4M,KAAMhS,IAAWQ,SAEnB,CACE4zF,aAAa,mBAAD,OFjKY,WEoK9BtC,EAAW7nF,IAAIqC,GAAI,GACnB,MAAO3D,GACP6sD,EAAavrD,IAAIqC,GAAI,QAKpB,CAAEwlF,aAAYt8B,iBAGV6+B,GAAiBpwF,MAC5B0vF,EACAzuE,KAEA,MAAM,OAAE2uE,EAAF,QAAUC,EAAV,OAAmBF,GAAWD,EACpC,IAGGE,IACAC,IACAF,GACDF,GAAkBC,EAAQzuE,GAE1B,OAAO,EAGT,MAAMkuE,QAAiBG,KACjBQ,EAAeliD,GAAgB3sB,IAC/B,WAAEovE,EAAF,GAAcnvF,QA/GElB,OACtBC,EACAghB,KAEA,MAAMhgB,QAAoBT,aAAeP,EAAK,WACxCiB,EAAKxB,eACLxD,EAAOwK,KAAKC,UAAUsa,GACtBlc,GAAU,IAAI3D,aAAcC,OAAOnF,GAUzC,MAAO,CAAEm0F,iBATgBzzF,OAAOiD,OAAOK,OAAOuB,QAC5C,CACErB,KAAM,UACNc,MAEFD,EACA8D,GAGmB7D,OA8FYovF,CAAgBT,EAAS5uE,GAEpDsvE,EAAc,CAClBT,eACAO,WAAYlB,EAASqB,UAAUlvF,KAAKmvF,eAClC,IAAI7wF,WAAWywF,IAEjBnvF,GAAIiuF,EAASqB,UAAUlvF,KAAKmvF,eAAevvF,IAGvC+5B,EAAKk0D,EAASqB,YACdE,EAASz1D,EAAG01D,WAAW,UAAUlU,IAAImT,GACrCgB,QAAkB31D,EAAG41D,gBAAe7wF,UACxC,MAAMy8E,QAAYqU,EAAYttE,IAAIktE,GAClC,IAAKjU,EAAIsU,OAEP,OADAD,EAAY9qF,IAAI0qF,EAAQH,IACjB,EAIT,QADoB9T,EAAIz7E,OACR8uF,cAAgBS,EAAYT,gBAI5CgB,EAAYE,OAAON,EAAQH,IACpB,MAOT,OAJIK,GACFpB,GAA0BxpF,IAAI2pF,EAAQG,GAGjCc,GAGIK,GAAmBjxF,MAC9B4vF,EACAC,EACAF,KAEA,MAGMe,SAHiBpB,MACHkB,YAEFG,WAAW,UAAUlU,IAAImT,GACrCnT,QAAYiU,EAAOltE,MACzB,IAAKi5D,EAAIsU,OACP,OAAO,KAET,MAAMG,EAAczU,EAAIz7E,OAClBqvF,EAAaa,EAAYb,WAAWc,eACpCjwF,EAAKgwF,EAAYhwF,GAAGiwF,eAEpBlwE,OA/IgBjhB,OACtBC,EACAiB,EACAmvF,KAEA,MAAMpvF,QAAoBT,aAAeP,EAAK,WACxCmxF,QAAkBx0F,OAAOiD,OAAOK,OAAO2B,QAC3C,CACEzB,KAAM,UACNc,MAEFD,EACAovF,GAGIgB,EAAc,IAAIxtF,YAAY,SAASC,OAC3C,IAAIlE,WAAWwxF,IAEjB,OAAO1qF,KAAKU,MAAMiqF,IA6HKC,CAAgBzB,EAAS3uF,EAAImvF,GAMpD,OAJIV,GACFH,GAA0BxpF,IAAI2pF,EAAQ/hD,GAAgB3sB,IAGjDmtC,GAAgBntC,EAAU,OAGtBswE,GAAwBvxF,MACnCgwF,EACAzoF,EACAiqF,KAEA,MAAMrD,EAAgC,GAChC58B,EAAe,IAAI78C,IAqCzB,aAnCMjS,QAAQ6F,IACZ,IAAI,IAAIkkB,IAAIglE,IAAW5pF,KAAI5H,UACzB,IACE,MAAMwyE,EAAG,sDACPqc,GAAgB4C,cADT,cAEH/uE,mBAAmBstE,EAAOxlF,QAAQ,MAAO,KAFtC,cAEgDnC,GACnDqpF,QAAiB1e,MAAM,GAAD,OAAIR,EAAJ,eAC5B,GAAIkf,EAASxtE,OAAS,IAAK,CACzB,MAAM3iB,QAAoBmwF,EAASnwF,eAE7B,KAAEP,EAAF,SAAQ+F,SAAmBG,aAC/B,IAAItH,WAAW2B,GACf,CACEgG,kBAIEujB,GAAU,IAAIjnB,aAAcC,OAAO9C,GAEzCmtF,EAAY/nF,KAAK,CACf8iB,SAAUniB,EAASmiB,UAAYntB,IAAWQ,OAC1C8L,KACAyiB,UACA6yD,SAAiB,OAAR52E,QAAQ,IAARA,OAAA,EAAAA,EAAU42E,UAAW9wE,KAAKshB,aAGrCojC,EAAavrD,IAAIqC,GAAI,GAEvB,MAAO3D,GACP6sD,EAAavrD,IAAIqC,GAAI,GACrB1D,QAAQD,MAAMA,QAKb,CAAEypF,cAAa58B,iBC3RlBogC,GAAa1U,GAAyB,WAAIA,EAAKjqD,SAAS,KAAM3sB,OAAO,GAwH9DurF,GAAgC5xF,UAC3C,MAAM4vF,OApHiB5vF,WACvB,MAAML,EAAM,IAAIC,WAAW,IAE3B,OADAhD,OAAOiD,OAAOC,gBAAgBH,GACvBguB,MAAMC,KAAKjuB,EAAKgyF,IAAWviF,KAAK,KAiHlByiF,GACfhC,QAAgB9vF,eAEtB,IAAK8vF,EACH,MAAM,IAAI1sF,MAAM,8BAGlB,MAAO,CAAEysF,SAAQC,YAUNiC,GAAkB9xF,MAC7BkB,EACAS,EACAC,KAEA,MAAM3B,QAAYO,aAAeoB,EAAY,WAC7C,OAAOhF,OAAOiD,OAAOK,OAAO2B,QAC1B,CACEzB,KAAM,UACNc,MAEFjB,EACA0B,IA8CShD,GAAYqB,MACvBqI,EACAzG,EAIAmwF,KAEA,IAAI/wF,EAaJ,OATEA,EAHQ,MAANqH,GAA4B,MAAdzG,EAGT+hB,QAtDe3jB,OACxBqI,EACAzG,KAEA,IACE,MAAM8vF,QAAiB1e,MAAM,GAAD,OA7JTjxE,uCA6JS,OAAqBsG,IAEjD,IAAKqpF,EAASM,GAEZ,OADAp1F,OAAOw2E,MAAM7qE,EAAE,+BACR,GAET,MAAMpH,QAAeuwF,EAASnwF,cAE9B,IAAI6vF,EACJ,IAEE,MAAMlwF,EAAKC,EAAOkF,MAAM,EAAG5G,MACrBkC,EAAYR,EAAOkF,MAAM5G,KAAiB0B,EAAO2E,YACvDsrF,QAAkBU,GAAgB5wF,EAAIS,EAAWC,GACjD,MAAO8C,GAEP,MAAMutF,EAAU,IAAIryF,WAAWH,MAC/B2xF,QAAkBU,GAAgBG,EAAS9wF,EAAQS,GAIrD,MAAMmzE,EAAS,IAAIn4E,OAAOiH,YAAY,SAASC,OAC7C,IAAIlE,WAAWwxF,IAEXpwF,EAA0B0F,KAAKU,MAAM2tE,GAE3C,MAAO,CACL9zD,SAAUjgB,EAAKigB,UAAY,KAC3B1I,SAAUvX,EAAKuX,UAAY,MAE7B,MAAO7T,GAGP,OAFA9H,OAAOw2E,MAAM7qE,EAAE,+BACf5D,QAAQD,MAAMA,GACP,KAiBCwtF,CAAkB7pF,EAAIzG,GADhB,OAEZmwF,QAFY,IAEZA,OAFY,EAEZA,EAAgBx5E,SAFJ,OAGZw5E,QAHY,IAGZA,OAHY,EAGZA,EAAgB9wE,UAGX0C,GAAQouE,GAAkB,KAAM,KAAM,MAGxC,CACL9wE,SAAUjgB,EAAKigB,SACf1I,SAAUvX,EAAKuX,SAIf4R,MAAOnpB,EAAKmpB,MACZswB,iBAAiB,IC7OR19C,GACa,aADbA,GAEc,mBAFdA,GAGW,oBAHXA,GAI0B,0BAe1Bo1F,GAAiC,KAC5C,IACE,MAAMnxF,EAAOoqF,aAAagH,QAAQr1F,IAClC,GAAIiE,EACF,OAAO0F,KAAKU,MAAMpG,GAAMypD,SAE1B,MAAO/lD,GAEPC,QAAQD,MAAMA,GAGhB,OAAO,MA6DI2tF,GAAyB,KACpC,IACE,MAAMpxE,EAAWmqE,aAAagH,QAAQr1F,IAEtC,OAD6B,OAARkkB,QAAQ,IAARA,OAAA,EAAAA,EAAU5gB,SAAU,EAEzC,MAAOqE,GAEP,OADAC,QAAQD,MAAMA,GACP,IAIE4tF,GAAsB,KACjC,IACE,MAAM/5E,EAAW6yE,aAAagH,QAAQr1F,IAChCw1F,EAASnH,aAAagH,QAAQr1F,IAC9Bo+D,EAAUiwB,aAAagH,QAC3BI,IAAiBx1F,uBAGby1F,GAAuB,OAARl6E,QAAQ,IAARA,OAAA,EAAAA,EAAUlY,SAAU,EACnCqyF,GAAmB,OAANH,QAAM,IAANA,OAAA,EAAAA,EAAQlyF,SAAU,EAGrC,OAAOoyF,EAAeC,IAFK,OAAPv3B,QAAO,IAAPA,OAAA,EAAAA,EAAS96D,SAAU,GAEUgyF,KACjD,MAAO3tF,GAEP,OADAC,QAAQD,MAAMA,GACP,I,aCmGIiuF,OAjNf,MAQEx/D,YAAYo/D,GAAwB,KAPpCA,YAOmC,OANnC5C,OAAuC,KAMJ,KALnCiD,mBAA6B,EAKM,KAJnChD,OAAwB,KAIW,KAHnCC,QAAyB,KAGU,KAFnCgD,2BAAkD,IAAIn+E,IAEnB,KAmEnCo+E,gBAAkBrU,qBAASz+E,UACzB,UACQ4sB,KAAK2lE,OAAOQ,YAAYrF,UAAU,CACtCzsE,SAAU2L,KAAK2lE,OAAO3D,cAAc/c,mCACpC1nD,MAAOyC,KAAK2lE,OAAO3D,cAActN,aAEnC,MAAO58E,GACY,eAAfA,EAAMtE,MACRwsB,KAAK2lE,OAAO3D,cAAc/X,YAAY,CACpCt+D,SAAU,CACRtC,aAAcvR,EAAM0tC,WAM5BxlB,KAAK2lE,OAAO3D,cAAc/X,YAAY,CACpC51D,SAAU2L,KAAK2lE,OAAO3D,cACnB/c,mCACAjqE,KAAKyR,GACAuT,KAAK2lE,OAAOQ,YAAY1E,+BAA+Bh1E,GAIlD4V,GAAe5V,EAAS,CAAE6K,OAAQ,UAEpC7K,QLlHkB,KKqBE,KAkGnC25E,eAAiBhzF,MACfizF,EACA76B,EACA86B,KAEA,GAAID,IAAc1F,GAAM4F,OAASD,EAC/B,MAAM,IAAI/vF,MAAM,gDAMlB,MAAMiwF,EAAmBh7B,EAAYxyD,QACnC,CAACC,EAAKwT,EAAuCuG,EAAKqB,KAO7C,IAAD,GALCiyE,IACEtmE,KAAKimE,2BAA2B1wE,IAAI9I,EAAQhR,KAC7CgR,EAAQzU,QACNgoB,KAAKimE,2BAA2BrvE,IAAInK,EAAQhR,MAChDukB,KAAK2lE,OAAOc,kBAAkBh6E,IAE9BxT,EAAIO,KAAK,IACJiT,EAEH6sC,OAAgB,IAARtmC,EAAY,IAAZ,UAAkBqB,EAASrB,EAAM,UAAjC,aAAkB,EAAmBvX,KAGjD,OAAOxC,IAET,IAGI7E,EAAiD,CACrD+M,KAAMklF,EACNK,QAAS,CACPryE,SAAUmyE,IAId,IAAK,MAAMG,KAAmBH,EAC5BxmE,KAAKimE,2BAA2B7sF,IAC9ButF,EAAgBlrF,GAChBkrF,EAAgB3uF,SAIpB,MAAM4uF,EAAmB5mE,KAAK6mE,qBAC5BzyF,GAGF4rB,KAAKkmE,kBAEDI,GAAWtmE,KAAK2lE,OAAOjsB,sBACnB7jE,QAAQ6F,IAAI,CAChBkrF,EACA5mE,KAAK2lE,OAAOmB,yBAAyBN,WAGjCI,GA5JyB,KAgKnCG,oBAAuBtpC,IAA8B,IAAD,EAClD,aAAIz9B,KAAK+iE,cAAT,aAAI,EAAatnF,GAAI,CACnB,MAAMrH,EAA8C,CAClD+M,KAAM,cACNulF,QAAS,CACPhqC,SAAU18B,KAAK+iE,OAAOtnF,GACtBgiD,YACAI,SAAU79B,KAAK2lE,OAAOvvB,MAAMvY,WAGhC,OAAO79B,KAAK6mE,qBACVzyF,GACA,KA5K6B,KAiLnC4yF,uBAA0BN,IAGnB,IAAD,EACJ,aAAI1mE,KAAK+iE,cAAT,aAAI,EAAatnF,GAAI,CACnB,MAAMrH,EAAiD,CACrD+M,KAAM,iBACNulF,QAAS,CACPhqC,SAAU18B,KAAK+iE,OAAOtnF,GACtB6yD,QAASo4B,EAAQp4B,QACjBoe,OAAQga,EAAQha,QAAU,KAC1BhiE,mBACEsV,KAAK2lE,OAAO3D,cAActvB,cAAchoD,mBAC1CmzC,SAAU79B,KAAK2lE,OAAOvvB,MAAMvY,WAGhC,OAAO79B,KAAK6mE,qBACVzyF,GACA,KAlMJ4rB,KAAK2lE,OAASA,EAGhB9b,KAAKkZ,EAA+BtnF,EAAYpI,GAC9C2sB,KAAK+iE,OAASA,EACd/iE,KAAKgjE,OAASvnF,EACdukB,KAAKijE,QAAU5vF,EAGf2sB,KAAK+iE,OAAOkE,GAAG,aAAa,KACtBjnE,KAAK+iE,SACP/iE,KAAK+iE,OAAOmE,KAAK,YAAalnE,KAAKgjE,QACnC9tF,YAAW,QAAS,mBAGxB8qB,KAAK+iE,OAAOkE,GAAG,YAAY7zF,UACzB4sB,KAAKomE,eACHzF,GAAM4F,KACNvmE,KAAK2lE,OAAO1gB,oCACE,MAGlBjlD,KAAK+iE,OAAOkE,GAAG,oBAAqBE,IAClCnnE,KAAK2lE,OAAOyB,iBAAiBD,MAIjCp8C,QACO/qB,KAAK+iE,SAGV/iE,KAAKkmE,gBAAgBtiF,QACrBoc,KAAK+iE,OAAOh4C,QACZ/qB,KAAK+iE,OAAS,KACd/iE,KAAKgjE,OAAS,KACdhjE,KAAKijE,QAAU,KACfjjE,KAAKgmE,mBAAoB,EACzBhmE,KAAKimE,2BAA6B,IAAIn+E,KAGxCu/E,SACE,SACErnE,KAAKgmE,mBACLhmE,KAAK+iE,QACL/iE,KAAKgjE,QACLhjE,KAAKijE,SAIiB,2BACxB7uF,GAEC,IADDkzF,EACA,wDACA,GAAItnE,KAAKqnE,SAAU,CAAC,IAAD,EACjB,MAAM/3F,EAAOwK,KAAKC,UAAU3F,GACtB+D,GAAU,IAAI3D,aAAcC,OAAOnF,GACnCyF,OFGiB3B,OAC3BgB,EACAf,KAEA,MAAMgB,QAAoBT,aAAeP,EAAK,WACxCiB,EAAKxB,eACX,MAAO,CACLsB,WAAYpE,OAAOiD,OAAOK,OAAOuB,QAC/B,CACErB,KAAM,UACNc,MAEFD,EACAD,GAEFE,OElB0BizF,CAAcpvF,EAAS6nB,KAAKijE,SACpD,UAAAjjE,KAAK+iE,cAAL,SAAamE,KACXI,EAAW5G,GAA4BA,GACvC1gE,KAAKgjE,OACLjuF,EAAUX,KACVW,EAAUT,O,MCrElB,MAAMkzF,GAAe,KACnB,MAAMroF,EAAYnP,OAAOmP,UACnBsoF,EAAiB,QAAQvoF,KAAKC,EAAUuoF,QACxCC,GAA4D,IAAzCxoF,EAAUyoF,WAAW5jE,QAAQ,OAEtD,OAAIyjE,EACK99C,GACEg+C,EACF/9C,GAGFF,IAwJMm+C,OArJI,IAkBZ,IAlBa,YAClBnvB,EADkB,eAElBovB,EAFkB,SAGlBjqC,EAHkB,iBAIlBkqC,EAJkB,aAKlBC,EALkB,cAMlBC,EANkB,gBAOlBC,EAPkB,MAQlBj2F,GAUI,EACJ,MAAMk2F,EAAgB1hD,iBAAyB,MAEzC2hD,EAAeh1F,UACnB,UACQm1D,GAA0Bu/B,GAChC,MAAOhwF,GACPowF,EAAgBpwF,EAAM0tC,SAEpB2iD,EAAc34E,SAChB24E,EAAc34E,QAAQ46C,UAIpBi+B,EAAgBj1F,UACpB,UACQ+L,UAAUuqC,MAAM,CACpBpC,MAAO3rC,EAAE,yBACThE,KAAMgE,EAAE,yBACRiqE,IAAKkiB,IAEP,MAAOhwF,MAKLwwF,EAAelyF,IACfA,EAAMC,SAAWwG,SAASm2C,gBAC5B58C,EAAMmR,iBACLnR,EAAMC,OAA4B+zD,WA0FvC,OACE,eAAC,GAAD,CACExS,OAAK,EACLnG,eAAgBinB,EAChBpxB,MAAO3rC,EAAE,4BACT1J,MAAOA,EAJT,SArFE,uBAAK6zC,UAAU,mBAAf,WACIgiD,GACA,uCACE,6BAAInsF,EAAE,2BACN,oDAAUA,EAAE,8BACZ,sBAAKmqC,UAAU,yCAAf,SACE,eAACG,GAAD,CACEH,UAAU,0BACV3kC,KAAK,SACLqmC,KAAMqD,GACNvD,MAAO3rC,EAAE,kCACT,aAAYA,EAAE,kCACd+rC,eAAe,EACfZ,QAASkhD,SAKhBF,GACC,uCACE,6BAAInsF,EAAE,qCACN,6BAAIA,EAAE,+BACN,uBAAKmqC,UAAU,2BAAf,UACE,gBAAC,GAAD,CAAWvV,IAAK,EAAhB,UACG,UAAWpxB,UACV,eAAC8mC,GAAD,CACE9kC,KAAK,SACLqmC,KAAMggD,KACNlgD,MAAO3rC,EAAE,gBACT,aAAYA,EAAE,gBACdmrC,QAASuhD,IAET,KACJ,eAACpiD,GAAD,CACE9kC,KAAK,SACLqmC,KAAMqB,GACNvB,MAAO3rC,EAAE,eACT,aAAYA,EAAE,eACdmrC,QAASshD,OAGb,wBACE5yF,MAAOsyF,EACPzI,UAAU,EACVv5C,UAAU,kBACVO,IAAK8hD,EACLvgD,cAAe0gD,OAGnB,uBAAKxiD,UAAU,+BAAf,UACE,wBAAOA,UAAU,2BAA2BsT,QAAQ,WAApD,SACGz9C,EAAE,qBAEL,wBACEF,GAAG,WACHjG,MAAOqoD,GAAY,GACnB/X,UAAU,gCACViC,SAAW3xC,GAAU2xF,EAAiB3xF,EAAMC,OAAOb,OACnD+yF,WAAanyF,GAAwB,UAAdA,EAAM/C,KAAmBqlE,SAGpD,+BACE,uBAAMlwB,KAAK,MAAM,cAAY,OAAO1C,UAAU,mBAA9C,SACG,iBACK,IACPnqC,EAAE,8BAEL,6BAAIA,EAAE,iCACN,sBAAKmqC,UAAU,yCAAf,SACE,eAACG,GAAD,CACEH,UAAU,yBACV3kC,KAAK,SACLqmC,KAAMsD,GACNxD,MAAO3rC,EAAE,iCACT,aAAYA,EAAE,iCACd+rC,eAAe,EACfZ,QAASmhD,eC9JlB,MCSDO,GAA6B,CACjC1mC,EACA2mC,EACAC,KACa,IAAD,MACZ,SACED,KAECA,EAAMhtF,MAAN,UAAaqmD,EAAc94C,sBAA3B,aAAa,EAA8BvN,KAC1CgtF,EAAMhtF,MAAN,UAAaqmD,EAAct3C,uBAA3B,aAAa,EAA+B/O,KAC5CgtF,EAAMhtF,MAAN,UAAaqmD,EAAc/4C,uBAA3B,aAAa,EAA+BtN,KAE5CgtF,EAAMzwF,QAAU0wF,EAAO1wF,SAGtBywF,EAAMzwF,UAAY0wF,EAAO1wF,SACxBywF,EAAMtmE,aAAeumE,EAAOvmE,iBCqElCwmE,QAASC,GACTC,SAAUC,GACVxT,SAAUyT,IF/FVC,KAEA,MAAML,EAAUziD,IAAMm9B,cAAc2lB,GAIpC,MAAMC,UAAwB/iD,IAAMs+B,UAElCj+C,YAAY6f,GACVX,MAAMW,GADgB,KADxBgwB,MAAQ,CAAE5gE,MAAOwzF,GAGfL,EAAQO,qBAAwB1zF,GAAawqB,KAAKoU,SAAS,CAAE5+B,UAE/D8iE,SACE,OACE,eAACqwB,EAAQrT,SAAT,CAAkB9/E,MAAOwqB,KAAKo2C,MAAM5gE,MAApC,SACGwqB,KAAKomB,MAAMuB,YAMpB,MAAMwhD,UAAwBjjD,IAAMs+B,UAClC4kB,oBAAqB,IAAD,EAClB,UAAAT,EAAQO,4BAAR,cAAAP,EAA+B3oE,KAAKomB,MAAM5wC,OAE5C6hF,qBAAsB,IAAD,EACnB,UAAAsR,EAAQO,4BAAR,cAAAP,EAA+B3oE,KAAKomB,MAAM5wC,OAE5C8iE,SACE,OAAO,eAACqwB,EAAQE,SAAT,UAAmB,IAAM7oE,KAAKomB,MAAMuB,YAI/C,MAAO,CACLghD,UACAE,SAAUI,EACV3T,SAAU6T,IE4DVE,CAAgD,CAAE7U,IAAK,OAI3D,MAAM8U,WAAsBC,gBAY1BhjE,YAAY6f,GAAe,IAAD,EACxBX,MAAMW,GADkB,YAX1B08C,YAW0B,OAV1BqD,iBAU0B,OAT1BnE,mBAS0B,OAR1BtoB,iBAA2B,EAQD,KAP1B8vB,sBAO0B,OAN1BC,mBAM0B,OAJlBC,+BAIkB,OAHlBC,uCAAiD,EAG/B,KAFlB9hF,cAAgB,IAAIC,IAEF,KA4ElBy9D,SAAW,KACjBvlD,KAAK4pE,oBAAoB,CAAEC,UAAU,KA7Eb,KAgFlBC,aAAepjF,IAAoBtQ,IACzC,MAAMowF,EAAmBxmE,KAAK+pE,oBAC5B/pE,KAAKilD,oCAeP,IAXEjlD,KAAK05C,kBACJ15C,KAAKmmE,YAAY3E,oBAAoBgF,IACnC3D,GAAkB7iE,KAAK8iE,OAAQ0D,KAIlCxmE,KAAK8mE,yBAAyBN,GAE9Bl/E,GAAclR,IAGZ4pB,KAAK05C,iBAAmB15C,KAAK8iE,OAAOE,OACtC,IAAK,IAAD,EACU,QAAZ,EAAAxE,oBAAA,SAAcwL,QACZ75F,GACA2J,KAAKC,UAAU,CACbkwF,UAAWhqF,KAAKshB,MAChB2oE,KAAMlqE,KAAK8iE,OAAOE,UAGtB,WA1GoB,KA8G1B8D,yBAA2B1zF,iBAIrB,IAHJozF,EAGG,uDAH8C,EAAKuD,oBACpD,EAAK/H,cAAc/c,oCAGrB,UACQue,GAAe,EAAKV,OAAQ0D,GAClC,MAAO1uF,GACPC,QAAQD,MAAMA,KAtHQ,KA0H1BqyF,WAAa/2F,UACX8B,YAAW,QAAS,iBACb8qB,KAAKoqE,uBAAuB,OA5HX,KA+H1BC,YAAc,KAKZ,GAJArqE,KAAKsqE,0BAA0BxmF,SAC/Bkc,KAAKuqE,eAAezmF,SAEpBkc,KAAK8mE,2BACD92F,OAAOywE,QAAQ9kE,EAAE,oCAAqC,CAAC,IAAD,IACxD3L,OAAO4kC,QAAQ41D,UAAU,GAAI/9F,IAAUuD,OAAOC,SAASC,QACvD8vB,KAAK4pE,sBACL10F,YAAW,QAAS,eAEpB,aAAA8qB,KAAKomB,OAAMqkD,mBAAX,iBAEA,MAAMp2E,EAAW2L,KAAKgiE,cACnB/c,mCACAjqE,KAAKyR,GACAE,GAAeF,IAA+B,UAAnBA,EAAQ6K,OAC9B+K,GAAe5V,EAAS,CAAE6K,OAAQ,YAEpC7K,IAGXuT,KAAKgiE,cAAc/X,YAAY,CAC7B51D,WACAw5B,iBAAiB,MAtJG,KA2JlB+7C,oBAAuB9kE,KACzB,OAACA,QAAD,IAACA,OAAD,EAACA,EAAM+kE,YACT7pE,KAAKnY,cAAgB,IAAIC,IACzBkY,KAAKgiE,cAAc/X,YAAY,CAC7BpiE,cAAemY,KAAKnY,gBAEtBmY,KAAKoU,SAAS,CACZ0zD,eAAgB,KAElB9nE,KAAK05C,iBAAkB,GAEzB15C,KAAK2pE,uCAAyC,EAC9C3pE,KAAK8iE,OAAO/3C,QACZ/qB,KAAKmmE,YAAYzE,SAxKO,KA2KlBgJ,4BAA8Bt3F,UAGpC,MAAMu3F,EAAkB5qE,EAAM1L,SAC3BhY,QAAQoQ,GAELD,GAA0BC,KACzBuT,KAAKmmE,YAAY/E,cAAc30E,EAAQC,UACvCD,EAAQmY,WACU,UAAnBnY,EAAQ6K,SAGXtc,KAAKyR,GAAaA,EAA8CC,SAEnE,aAAasT,KAAKmmE,YAAYzR,SAASiW,IAzLf,KA4LlBP,uBAAyBh3F,UAG/B,GAAI4sB,KAAK8iE,OAAOC,OACd,OAAO,KAGT,IAAIC,EACAC,EN9J6B7uF,MMgK7Bw2F,IACC5H,SAAQC,WAAY2H,MAEpB5H,SAAQC,iBAAkB+B,MAC7Bh1F,OAAO4kC,QAAQ41D,UACb,GACA/9F,KNtK6B2H,EMuKR,CAAE4uF,SAAQC,WNnK/B,GAAN,OAAUjzF,OAAOC,SAASC,QAA1B,OAAmCF,OAAOC,SAASowE,SAAnD,iBAAoEjsE,EAAK4uF,OAAzE,YAAmF5uF,EAAK6uF,YMuKtF,MAAM4H,EAAevkF,KAErB0Z,KAAK05C,iBAAkB,EAEvB,MAAQjW,QAASqnC,SAA8B,iEAM/C,GAFA9qE,KAAK8iE,OAAOjZ,KAAKihB,EN3SQ31F,yCM2SuB6tF,EAAQC,GAEpD2H,EAAsB,CACxB5qE,KAAKgiE,cAActb,aAEnB,IACE,MAAMryD,QAAiBgwE,GACrBrB,EACAC,EACAjjE,KAAK8iE,OAAOC,QAEV1uE,GACFw2E,EAAa/0F,QAAQ,CACnBue,WACA6yD,iBAAiB,IAGrB,MAAOpvE,GAEPC,QAAQD,MAAMA,QAEX,CACL,MAAMuc,EAAW2L,KAAKgiE,cAAc9c,mBAAmBlqE,KAAKyR,GACtDE,GAAeF,IAA+B,UAAnBA,EAAQ6K,OAC9B+K,GAAe5V,EAAS,CAAE6K,OAAQ,YAEpC7K,IAMTuT,KAAKgiE,cAAcptD,QAAQjU,QAC3BX,KAAKgiE,cAAc/X,YAAY,CAC7B51D,WACAw5B,iBAAiB,IAGnB7tB,KAAK+qE,kBAAkB12E,GAEvB,MAAMmyE,EAAmBxmE,KAAK+pE,oBAAoB11E,GAClD2L,KAAK8mE,yBAAyBN,GAgGhC,OA3FAxmE,KAAK0pE,0BAA4B15F,OAAO2T,YAAW,KACjDqc,KAAKgrE,mBACLH,EAAa/0F,QAAQ,QT1XiB,KS8XxCkqB,KAAK8iE,OAAOC,OAAQkE,GAClB,oBACA7zF,MAAO63F,EAA4B32F,KACjC,IAAK0rB,KAAK8iE,OAAOG,QACf,OAEF,MAAMiI,ON/Re93F,OAC3BgB,EACAf,EACAiB,KAEA,IACE,MAAMD,QAAoBT,aAAeP,EAAK,WACxCmxF,QAAkBx0F,OAAOiD,OAAOK,OAAO2B,QAC3C,CACEzB,KAAM,UACNc,MAEFD,EACAD,GAGIqwF,EAAc,IAAIxtF,YAAY,SAASC,OAC3C,IAAIlE,WAAWwxF,IAEjB,OAAO1qF,KAAKU,MAAMiqF,GAClB,MAAO3sF,GACP9H,OAAOw2E,MAAM7qE,EAAE,yBACf5D,QAAQD,MAAMA,GAEhB,MAAO,CACLqJ,KAAM,qBMsQ0BgqF,CAC1BF,EACAjrE,KAAK8iE,OAAOG,QACZ3uF,GAGF,OAAQ42F,EAAc/pF,MACpB,IAAK,mBACH,OACF,KAAKw/E,GAAM4F,KACT,IAAKvmE,KAAK8iE,OAAOkD,kBAAmB,CAClChmE,KAAKgrE,mBACL,MAAMI,EAAiBF,EAAcxE,QAAQryE,SACvCg3E,EAAqBrrE,KAAKsrE,kBAAkBF,GAClDprE,KAAKurE,wBAAwBF,EAAoB,CAC/CG,MAAM,IAGRX,EAAa/0F,QAAQ,CACnBue,SAAUg3E,EACVnkB,iBAAiB,IAGrB,MAEF,KAAKyZ,GAAM8K,OACTzrE,KAAKurE,wBACHvrE,KAAKsrE,kBAAkBJ,EAAcxE,QAAQryE,WAE/C,MACF,IAAK,iBAAkB,CACrB,MAAM,QAAEi6C,EAAF,OAAWoe,EAAX,SAAmB7uB,EAAnB,mBAA6BnzC,GACjCwgF,EAAcxE,QACVhqC,EACJwuC,EAAcxE,QAAQhqC,UAEtBwuC,EAAcxE,QAAQgF,SAElB7jF,EAAgB,IAAIC,IAAIkY,KAAKnY,eAC7BgwE,EAAOhwE,EAAc+O,IAAI8lC,IAAa,GAC5Cm7B,EAAKvpB,QAAUA,EACfupB,EAAKnL,OAASA,EACdmL,EAAKntE,mBAAqBA,EAC1BmtE,EAAKh6B,SAAWA,EAChBh2C,EAAczO,IAAIsjD,EAAUm7B,GAC5B73D,KAAKgiE,cAAc/X,YAAY,CAC7BpiE,kBAEF,MAEF,IAAK,cAAe,CAClB,MAAM,UAAE41C,EAAF,SAAaf,EAAb,SAAuBmB,GAAaqtC,EAAcxE,QAClD7+E,EAAgB,IAAIC,IAAIkY,KAAKnY,eAC7BgwE,EAAOhwE,EAAc+O,IAAI8lC,IAAa,GAC5Cm7B,EAAKp6B,UAAYA,EACjBo6B,EAAKh6B,SAAWA,EAChB79B,KAAKgiE,cAAc/X,YAAY,CAC7BpiE,kBAEF,WAMRmY,KAAK8iE,OAAOC,OAAQkE,GAAG,iBAAiB,KAClCjnE,KAAK8iE,OAAOC,QACd/iE,KAAK8iE,OAAOC,OAAO4I,IAAI,iBAEzB3rE,KAAKgrE,mBACLH,EAAa/0F,QAAQ,SAGvBkqB,KAAK4rE,yBAEL5rE,KAAKoU,SAAS,CACZ0zD,eAAgB93F,OAAOC,SAASuuE,OAG3BqsB,GAlWiB,KAqWlBG,iBAAmB,KACzBhrE,KAAK8iE,OAAOkD,mBAAoB,EAChCtiF,aAAasc,KAAK0pE,4BAvWM,KA0WlB4B,kBACNF,IAEA,MAGMC,EDhbuB,EAC/B5pC,EACA2pC,EACAtpC,KAEA,MAAM+pC,EACuCpqC,EApBpCzoD,QACP,CACEC,EAGAwT,EACAuG,KAEA/Z,EAAIwT,EAAQhR,IAAM,CAACgR,EAASuG,GACrB/Z,IAET,IAWIoyF,EAA0C5pC,EAAchoD,QAExDqyF,EAAa,IAAI3zE,QAEvB,IAAIhf,EAAS,EACTT,EAAS,EAETqzF,GAAoB,EACxB,IAAK,MAAMC,KAAiBZ,EAAgB,CAAC,IAAD,EAC1CW,IAEA,MAAMtD,EAAQoD,EAAkBG,EAAcvwF,IAE9C,GAAI+sF,GAA2B1mC,EAAD,OAAgB2mC,QAAhB,IAAgBA,OAAhB,EAAgBA,EAAQ,GAAIuD,GAAgB,CACpEA,EAAc1yC,eACT0yC,EAAc1yC,OAGvB,SAGEmvC,GAEFqD,EAAW1yF,IAAIqvF,EAAM,IAAI,GAK3B,MAAMnvC,EACJ0yC,EAAc1yC,SAAd,UAAwB8xC,EAAeW,EAAmB,UAA1D,aAAwB,EAAsCtwF,KAAM,KAEtE,GAAc,MAAV69C,EAIF,UAHO0yC,EAAc1yC,OAGN,MAAXA,EACF5gD,IACe,IAAXS,GACFkyF,EAAmB5uF,QAAQuvF,GAC3BH,EAAkBG,EAAcvwF,IAAM,CACpCuwF,EACA7yF,EAAST,KAGX2yF,EAAmB7mE,OAAOrrB,EAAS,EAAG,EAAG6yF,GACzCH,EAAkBG,EAAcvwF,IAAM,CACpCuwF,EACA7yF,EAAS,EAAIT,GAEfS,SAEG,CACL,IAAI6Z,EAAM64E,EAAkBvyC,GACxBuyC,EAAkBvyC,GAAS,GAC3B,KACO,MAAPtmC,IACFA,GAAOta,GAEE,MAAPsa,GAAeA,GAAO7Z,GACxBkyF,EAAmB7mE,OAAOxR,EAAM,EAAG,EAAGg5E,GACtCtzF,IACAmzF,EAAkBG,EAAcvwF,IAAM,CACpCuwF,EACAh5E,EAAM,EAAIta,GAEZS,EAAS6Z,EAAM,GACC,MAAPA,GACTq4E,EAAmB7mE,OAAOrrB,EAAS,EAAG,EAAG6yF,GACzCtzF,IACAmzF,EAAkBG,EAAcvwF,IAAM,CACpCuwF,EACA7yF,EAAS,EAAIT,GAEfS,MAEAkyF,EAAmB7xF,KAAKwyF,GACxBH,EAAkBG,EAAcvwF,IAAM,CACpCuwF,EACAX,EAAmB53F,OAAS,EAAIiF,SAK7B+vF,GACT4C,EAAmB5C,EAAM,IAAMuD,EAC/BH,EAAkBG,EAAcvwF,IAAM,CAACuwF,EAAevD,EAAM,MAG5D4C,EAAmB7xF,KAAKwyF,GACxBH,EAAkBG,EAAcvwF,IAAM,CACpCuwF,EACAX,EAAmB53F,OAAS,EAAIiF,IAStC,OAJ0C2yF,EAAmBhvF,QAC1DoQ,IAAaq/E,EAAWv2E,IAAI9I,MCuUFw/E,CAHLjsE,KAAKilD,mCAKzBmmB,EAJeprE,KAAKgiE,cAActvB,eAgBpC,OAJA1yC,KAAKksE,yCACHlrD,GAAgBqqD,IAGXA,GA9XiB,KAiYlBd,eAAiB1Y,MAASz+E,UAChC,MAAM,YAAEmuF,EAAF,aAAe58B,SACb3kC,KAAK0qE,4BAA4B,CACrCr2E,SAAU2L,KAAKgiE,cAAc/c,qCAGjCjlD,KAAKgiE,cAAcjY,SAASwX,GAE5BQ,GAAyB,CACvBC,cAAehiE,KAAKgiE,cACpBr9B,eACAtwC,SAAU2L,KAAKgiE,cAAc/c,uCT3fA,KS+GP,KAgZlBsmB,wBAA0B,SAChCl3E,GAEI,IADJ,KAAEm3E,GAAO,GACN,uDADoC,GAEvC,EAAKxJ,cAAc/X,YAAY,CAC7B51D,WACAw5B,kBAAmB29C,IAOrB,EAAKxJ,cAAcptD,QAAQjU,QAE3B,EAAK4pE,kBA/ZmB,KAkalBld,cAAgB,KAClBrtD,KAAKypE,gBACPz5F,OAAO0T,aAAasc,KAAKypE,eACzBzpE,KAAKypE,cAAgB,MAEvBzpE,KAAKypE,cAAgBz5F,OAAO2T,WAAWqc,KAAKmsE,WAAYt7F,KACnDmvB,KAAKwpE,mBACRxpE,KAAKwpE,iBAAmBx5F,OAAOwwD,YAC7BxgC,KAAKosE,aACLt7F,OA3aoB,KAgblBu7F,mBAAqB,KACvBxvF,SAASsqC,QACPnnB,KAAKypE,gBACPz5F,OAAO0T,aAAasc,KAAKypE,eACzBzpE,KAAKypE,cAAgB,MAEnBzpE,KAAKwpE,mBACPx5F,OAAO0wD,cAAc1gC,KAAKwpE,kBAC1BxpE,KAAKwpE,iBAAmB,MAE1BxpE,KAAKssE,kBAAkB7xC,GAAckD,QAErC39B,KAAKypE,cAAgBz5F,OAAO2T,WAAWqc,KAAKmsE,WAAYt7F,KACxDmvB,KAAKwpE,iBAAmBx5F,OAAOwwD,YAC7BxgC,KAAKosE,aACLt7F,KAEFkvB,KAAKssE,kBAAkB7xC,GAAcwD,UAjcf,KAqclBkuC,WAAa,KACnBnsE,KAAKssE,kBAAkB7xC,GAAcuD,MACjCh+B,KAAKwpE,mBACPx5F,OAAO0wD,cAAc1gC,KAAKwpE,kBAC1BxpE,KAAKwpE,iBAAmB,OAzcF,KA6clB4C,aAAe,KACrBpsE,KAAKssE,kBAAkB7xC,GAAcwD,SA9cb,KAidlB2tC,uBAAyB,KAC/B/uF,SAASq1C,iBAAiBnkD,IAAM2/E,aAAc1tD,KAAKqtD,eACnDxwE,SAASq1C,iBAAiBnkD,IAAMw+F,kBAAmBvsE,KAAKqsE,qBAndhC,KAsenBH,yCAA4Cl0F,IACjDgoB,KAAK2pE,sCAAwC3xF,GAverB,KA0enBw0F,yCAA2C,IACzCxsE,KAAK2pE,sCA3eY,KA8enB1kB,iCAAmC,IACjCjlD,KAAKgiE,cAAc/c,mCA/eF,KAkf1B4O,gBAAmB6S,IAKjBA,EAAQ5S,YAAY18D,KAAO,GACzB4I,KAAK8iE,OAAOC,QACZ/iE,KAAK8iE,OAAOkE,uBAAuBN,IAzfb,KA4f1B4F,kBAAqB7uC,IACnBz9B,KAAKoU,SAAS,CAAEqpB,cAChBz9B,KAAK8iE,OAAOiE,oBAAoBtpC,IA9fR,KAigB1BstC,kBAAqB12E,IAEjB2sB,GAAgB3sB,GAChB2L,KAAKwsE,6CAELxsE,KAAK8iE,OAAOsD,eAAezF,GAAM8K,OAAQp3E,GAAU,GACnD2L,KAAK2pE,sCAAwC3oD,GAAgB3sB,GAC7D2L,KAAKsqE,8BAxgBiB,KA4gB1BA,0BAA4BzY,MAAS,KACnC7xD,KAAK8iE,OAAOsD,eACVzF,GAAM8K,OACNzrE,KAAKgiE,cAAc/c,oCACnB,GAEF,MAAMwnB,EAAiBzsE,KAAKwsE,2CACtBE,EAAa1/F,KAAK+iB,IACtB08E,EACAzrD,GAAgBhhB,KAAKilD,qCAEvBjlD,KAAKksE,yCAAyCQ,KTroBP,KS8Gf,KA0hB1Bh0B,YAAc,KACZ14C,KAAKoU,SAAS,CAAE2mC,cAAc,KA3hBN,KA8hB1BgtB,iBAAoBlqC,IAClB79B,KAAKoU,SAAS,CAAEypB,aLloBuBA,KACzC,IACE2gC,aAAawL,QACX75F,GACA2J,KAAKC,UAAU,CAAE8jD,cAEnB,MAAO/lD,GAEPC,QAAQD,MAAMA,KK2nBd60F,CAA2B9uC,IAhiBH,KAmiB1B0f,oBAAsB,KACpBv9C,KAAKoU,SAAS,CACZ2mC,cAAc,KAriBQ,KAyiB1B0rB,kBAAqBh6E,GACZA,EAAQmY,YAAcrC,GAAwB9V,GA1iB7B,KA6iB1Bs9E,oBAAuB11E,GACrBA,EAAShY,QAAQoQ,GAAYuT,KAAKymE,kBAAkBh6E,KA9iB5B,KAijBlBmgF,aAAiC,KAjjBf,KAojB1BC,gBAAkB,KACX7sE,KAAK4sE,eACR5sE,KAAK4sE,aAAe,IAGtB5sE,KAAK4sE,aAAalzB,gBAAkB,IAAM15C,KAAK05C,gBAC/C15C,KAAK4sE,aAAa/uC,SAAW79B,KAAKo2C,MAAMvY,SACxC79B,KAAK4sE,aAAa/Y,gBAAkB7zD,KAAK6zD,gBACzC7zD,KAAK4sE,aAAaxC,uBAAyBpqE,KAAKoqE,uBAChDpqE,KAAK4sE,aAAarvB,oBAAsBv9C,KAAKu9C,oBAC7Cv9C,KAAK4sE,aAAa7B,kBAAoB/qE,KAAK+qE,kBAC3C/qE,KAAK4sE,aAAalC,4BAChB1qE,KAAK0qE,4BACA1qE,KAAK4sE,cA/jBZ5sE,KAAKo2C,MAAQ,CACX2E,cAAc,EACd1xD,aAAc,GACdw0C,SAAU0nC,MAAoC,GAC9C9nC,UAAWhD,GAAcwD,OACzB6pC,eAAgB,IAElB9nE,KAAK8iE,OAAS,IAAIiD,GAAO/lE,MACzBA,KAAKmmE,YAAc,IAAItF,GAAY,CACjCnM,SAAUthF,UACR,MAAM,OAAE4vF,EAAF,QAAUC,GAAYjjE,KAAK8iE,OACjC,IAAKE,IAAWC,EACd,MAAM,IAAIv9C,GAGZ,OAAOi/C,GAAsB,eAAD,OAAgB3B,GAAUC,EAASx+B,IAEjEq8B,UAAW1tF,UAA2B,IAApB,WAAEkuF,GAAiB,EACnC,MAAM,OAAE0B,EAAF,QAAUC,GAAYjjE,KAAK8iE,OACjC,IAAKE,IAAWC,EACd,MAAM,IAAIv9C,GAGZ,OAAOy9C,GAAoB,CACzBC,OAAO,GAAD,OAAKxC,GAAL,YAA8CoC,GACpDzlE,YAAaokE,GAAqB,CAChCpkE,MAAO+jE,EACPlnF,cAAe6oF,EACfrB,SAAUnB,UAKlBzgE,KAAKgiE,cAAgB57C,EAAM47C,cAC3BhiE,KAAKwpE,iBAAmB,KACxBxpE,KAAKypE,cAAgB,KAGvBL,oBACEp5F,OAAOkiD,iBAAiBnkD,IAAM++F,cAAe9sE,KAAK8pE,cAClD95F,OAAOkiD,iBAAiBnkD,IAAM0oF,OAAQz2D,KAAKulD,UAGzCpwE,eAAyBnH,IAAIC,MAC7BkH,eAAyBnH,IAAIE,cAE7B8B,OAAO21F,OAAS31F,OAAO21F,QAAW,GAClC9pF,OAAO05E,iBAAiBvlF,OAAQ,CAC9B21F,OAAQ,CACNnQ,cAAc,EACdhgF,MAAOwqB,SAMfi2D,uBACEjmF,OAAOmiD,oBAAoBpkD,IAAM++F,cAAe9sE,KAAK8pE,cACrD95F,OAAOmiD,oBAAoBpkD,IAAM0oF,OAAQz2D,KAAKulD,UAC9Cv1E,OAAOmiD,oBAAoBpkD,IAAM2/E,aAAc1tD,KAAKqtD,eACpDr9E,OAAOmiD,oBACLpkD,IAAMw+F,kBACNvsE,KAAKqsE,oBAEHrsE,KAAKwpE,mBACPx5F,OAAO0wD,cAAc1gC,KAAKwpE,kBAC1BxpE,KAAKwpE,iBAAmB,MAEtBxpE,KAAKypE,gBACPz5F,OAAO0T,aAAasc,KAAKypE,eACzBzpE,KAAKypE,cAAgB,MA8YzBrC,iBAAiB2F,GACf/sE,KAAKoU,UAAUgiC,IACb,MAAMvuD,EACJ,IAAIC,IACN,IAAK,MAAM40C,KAAYqwC,EACjB/sE,KAAKnY,cAAc0N,IAAImnC,GACzB70C,EAAczO,IAAIsjD,EAAU18B,KAAKnY,cAAc+O,IAAI8lC,IAEnD70C,EAAczO,IAAIsjD,EAAU,IAGhC18B,KAAKnY,cAAgBA,EACrBmY,KAAKgiE,cAAc/X,YAAY,CAAEpiE,qBAkGrCywD,SACE,MAAM,aAAEyC,EAAF,SAAgBld,EAAhB,aAA0Bx0C,EAA1B,eAAwCy+E,GAAmB9nE,KAAKo2C,MAEtE,OACE,uCACG2E,GACC,eAAC,GAAD,CACErC,YAAa14C,KAAK04C,YAClBovB,eAAgBA,EAChBjqC,SAAUA,EACVkqC,iBAAkB/nE,KAAK+nE,iBACvBC,aAAchoE,KAAKmqE,WACnBlC,cAAejoE,KAAKqqE,YACpBnC,gBAAkB7+E,IAChB2W,KAAKoU,SAAS,CAAE/qB,kBAElBpX,MAAO+tB,KAAKgiE,cAActvB,cAAczgE,QAG3CoX,GACC,eAAC44D,GAAD,CACEz8B,QAASn8B,EACTopC,QAAS,IAAMzyB,KAAKoU,SAAS,CAAE/qB,aAAc,OAGjD,eAAC0/E,GAAD,CACEvzF,MAAO,CACLg/E,IAAKx0D,KAAK6sE,yBAepB13F,eAAyBnH,IAAIC,MAC7BkH,eAAyBnH,IAAIE,cAE7B8B,OAAO21F,OAAS31F,OAAO21F,QAAW,IAGrB2D,UCpuBR,MAAM0D,GAAe,QAAC,SAC3BjlD,EAD2B,UAE3BhsC,EAAYkxF,EAFe,gBAG3BC,EAAkBD,IAAmB1xF,MAHX,SAS1B,eAAC,IAAMuiE,SAAP,UACE,0BACEh4B,UAAU,4CACViC,SAAU,QAAC,OAAE1xC,GAAH,SAAgB0xC,EAAS1xC,EAAOb,QAC1CA,MAAO03F,EACP,aAAYD,EAAO,0BAJrB,UAME,yBAAoCz3F,MAAOy3F,EAAiB1xF,KAA5D,SACG0xF,EAAiB13F,OADP03F,EAAiB1xF,MAG7BQ,EAAUf,KAAKsB,GACd,yBAAwB9G,MAAO8G,EAAKf,KAApC,SACGe,EAAK/G,OADK+G,EAAKf,cCVpB4xF,GAAkBhqF,IAAU+d,IAChCA,EAAG,CACDnB,MAAO0lE,KACP2H,MAAO1H,SALkB,KAyEd2H,OA7DMjnD,IACnB,MAAOknD,EAAcC,GAAmBjhF,mBAAuB,CAC7DyT,MAAO,EACPqtE,MAAO,IAGTrmD,qBAAU,KACRomD,IAAiBK,IACfD,EAAgBC,SAGpBzmD,qBAAU,IAAM,IAAMomD,GAAgBrpF,UAAU,IAEhD,MAAM9L,EAAUmP,KAChB,IAAI2+D,EACAmkB,EASJ,OAPIjyF,IAAY/I,KACdg7F,EAAYjyF,EAAQyB,MAAM,EAAG,IAAImE,QAAQ,IAAK,KAC9CkoE,EAAO9tE,EAAQyB,MAAM,KAErBwwF,EAAYtuF,EAAE,6BAId,uCACE,8BACE,qBAAIknE,QAAS,EAAb,SAAiBlnE,EAAE,qBAErB,gCACE,8BAAKA,EAAE,iBACP,8BAAKkL,GAAWymF,EAAavtE,MAAO,QAEtC,gCACE,8BAAKpkB,EAAE,iBACP,8BAAKkL,GAAWymF,EAAaF,MAAO,QAEtC,8BACE,qBAAIvqB,QAAS,EAAb,SAAiBlnE,EAAE,qBAErB,8BACE,sBACEknE,QAAS,EACT3gE,MAAO,CAAEyV,UAAW,SAAUxe,OAAQ,WACtC2tC,QAAS1zC,UACP,UACQm1D,GAA0BphD,MAChCi/B,EAAMqjC,gBAAgB9tE,EAAE,0BACxB,SAEJ2rC,MAAO3rC,EAAE,qBATX,UAWGsuF,EACD,wBACCnkB,W,OC3EJ,MAAM2nB,GAAqBplD,GAChC,uCACE,uBACEla,EAAE,ggCACFrX,KAAK,iBAEP,uBACEqX,EAAE,+vFACFrX,KAAK,iBAEP,uBACEqX,EAAE,48JACFrX,KAAK,oBAGT,CAAErU,MAAO,GAAIE,OAAQ,IAAKT,MAAO,CAAEsqC,UAAW,qBCwDnCkhD,GAKR,IAA6C,IAA5C,SAAEr5E,EAAF,SAAY1I,EAAZ,MAAsB4R,EAAtB,QAA6BowE,GAAc,EAC/C,OACE,gBAAC,GAAD,CAAM1nF,MAAM,SAAZ,UACE,sBAAK6/B,UAAU,YAAf,SAA4B2nD,KAC5B,8CACA,sBAAK3nD,UAAU,eAAf,SACGnqC,EAAE,6CAEL,eAACsqC,GAAD,CACEH,UAAU,cACV3kC,KAAK,SACLmmC,MAAO3rC,EAAE,sCACT,aAAYA,EAAE,sCACd+rC,eAAe,EACfZ,QAAS1zC,UACP,SA7EqBA,OAC7BihB,EACA1I,EACA4R,KAEA,MAAMglE,QAAiBI,KAEjBlnF,EAAE,UAAMimB,aAAO,KAEftnB,QAAuBjH,eACvB83F,QAAsB92F,aAC1BiG,EACA8pD,GAAgB7vC,EAAU1I,EAAU4R,EAAO,aAGvCvnB,EAAO,IAAItB,KACf,CAACu2F,EAAc32F,GAAI,IAAItB,WAAWi4F,EAAcr2F,kBAChD,CACEuM,KAAMhS,IAAWQ,eAIf4yF,EACHc,UACAh9C,IAFG,6BAEuB5qC,IAC1B6nF,IAAIttF,EAAM,CACT43F,eAAgB,CACdx5F,KAAM0F,KAAKC,UAAU,CAAE/B,QAAS,EAAGxE,KAAMmY,EAASnY,OAClDu9E,QAAS9wE,KAAKshB,MAAM6E,cAI1B,MAAM4jD,EAAW,IAAIliE,IACrB,IAAK,MAAM2E,KAAW4H,EAChB7H,GAA0BC,IAAY8Q,EAAM9Q,EAAQC,SACtDs9D,EAAS5wE,IAAIqT,EAAQC,OAAQ6Q,EAAM9Q,EAAQC,SAI/C,GAAIs9D,EAAS5yD,KAAM,CACjB,MAAMy2E,QAAsBlM,GAAqB,CAC/CpkE,MAAOysD,EACP5vE,gBACAwnF,SAAUnB,WAGN0C,GAAoB,CACxBC,OAAO,4BAAD,OAA8B3nF,GACpC8hB,MAAOswE,IAIX79F,OAAO65E,KAAP,wDACmDpuE,EADnD,YACyDrB,KAyBzC0zF,CAAuBz5E,EAAU1I,EAAU4R,GACjD,MAAOzlB,GACPC,QAAQD,MAAMA,GACK,eAAfA,EAAMtE,MACRm6F,EAAQ,IAAIp3F,MAAMoF,EAAE,qD,aC5BlC,MAAMoyF,GAAaC,aAAY,WAAY,eAErCC,GAAkC76F,UAGtC,MAAM86F,QAAetyF,aAAKmyF,IAC1B,IAAK,MAAMtyF,KAAMyyF,EACVppE,EAAKqpE,eAAezmF,SAASjM,IAChC2yF,aAAI3yF,EAAIsyF,KAKRM,GAAmB,IAAIxN,GAAY,CACvCnM,SAASl5E,GACA8yF,aAAQ9yF,EAAKuyF,IAAY1yF,MAC7BkzF,IACC,MAAMhN,EAAgC,GAChC58B,EAAe,IAAI78C,IAUzB,OATAymF,EAAUj6E,SAAQ,CAAClgB,EAAMgJ,KACvB,MAAM3B,EAAKD,EAAI4B,GACXhJ,EACFmtF,EAAY/nF,KAAKpF,GAEjBuwD,EAAavrD,IAAIqC,GAAI,MAIlB,CAAE8lF,cAAa58B,mBAI5BvxD,gBAAA,GAAiC,IAAjB,WAAEkuF,GAAc,EAC9B,MAAML,EAAa,IAAIn5E,IACjB68C,EAAe,IAAI78C,IAczB,aAZMjS,QAAQ6F,IACZ,IAAI4lF,GAAYtmF,KAAI5H,UAA2B,IAAnBqI,EAAIuiB,GAAc,EAC5C,UACQ5kB,aAAIqC,EAAIuiB,EAAU+vE,IACxB9M,EAAW7nF,IAAIqC,GAAI,GACnB,MAAO3D,GACPC,QAAQD,MAAMA,GACd6sD,EAAavrD,IAAIqC,GAAI,QAKpB,CAAEwlF,aAAYt8B,mBAInB6pC,GAAmB,IAAIC,IAC7BD,GAAiBhD,KAAK,CACpBkD,cAAe,CACbC,mBAAqBlsB,GAA+BA,EACpDmsB,cAAe,KAAM,GAEvBC,gBAAgB,IAGlB,MAAMC,GAAgB3rF,IACpB/P,MACEihB,EACA1I,EACA4R,EACAwxE,KV9F8B,EAChC16E,EACA1I,KAEA,IACE6yE,aAAawL,QACX75F,GACA2J,KAAKC,UAAUsnC,GAA6BhtB,KAE9CmqE,aAAawL,QACX75F,GACA2J,KAAKC,UAAUiS,GAA6BL,KAE9C,MAAO7T,GAEPC,QAAQD,MAAMA,KUiFdk3F,CAAmB36E,EAAU1I,SAEvB0iF,GAAiBvN,UAAU,CAC/BzsE,WACAkJ,UAGFwxE,MdhJyC,KcqJvC56C,GAAS,KACb26C,GAAclrF,SAGVgjE,GAAkBxzE,UAQtB,MACMqI,EADe,IAAIsqE,gBAAgB/1E,OAAOC,SAASg2E,QACjCrvD,IAAI,MACtBq4E,EAAmBj/F,OAAOC,SAAS61E,KAAKpjB,MAC5C,qCAEIwsC,EAAmBl/F,OAAOC,SAAS61E,KAAKpjB,MAAM,eAE9CyiC,EV5G8B,MACpC,IAAIgK,EAAgB,KAChBC,EAAa,KAEjB,IACED,EAAgB3Q,aAAagH,QAAQr1F,IACrCi/F,EAAa5Q,aAAagH,QAAQr1F,IAClC,MAAO2H,GAEPC,QAAQD,MAAMA,GAGhB,IAAIuc,EAAgC,GACpC,GAAI86E,EACF,IACE96E,EAAWgtB,GAA6BvnC,KAAKU,MAAM20F,IACnD,MAAOr3F,GACPC,QAAQD,MAAMA,GAKlB,IAAI6T,EAAW,KACf,GAAIyjF,EACF,IACEzjF,EAAW,IACN/D,QACAoE,GACDlS,KAAKU,MAAM40F,KAGf,MAAOt3F,GACPC,QAAQD,MAAMA,GAIlB,MAAO,CAAEuc,WAAU1I,aUwEI0jF,GAEvB,IAAItvE,QAEMhuB,GAAU,KAAM,KAAMozF,GAE5BmK,EX3CmC5mD,KACvC,MACMga,EADO,IAAI6sC,IAAI7mD,GAAMo9B,KACRpjB,MAAM,6CACzB,OAAIA,GAA6B,KAApBA,EAAM,GAAGjvD,QACpBzD,OAAOw2E,MAAM7qE,EAAE,gCACR,MAEF+mD,EAAQ,CAAEsgC,OAAQtgC,EAAM,GAAIugC,QAASvgC,EAAM,IAAO,MWoCtC8sC,CAAyBx/F,OAAOC,SAASuuE,MAC5D,MAAMixB,KAAqBh0F,GAAMwzF,GAAoBK,GACrD,GAAIG,EACF,IAEG1vE,EAAM1L,SAAS5gB,QAEhB67F,GAEAt/F,OAAOywE,QAAQ9kE,EAAE,mCAEbszF,IACFlvE,QAAchuB,GACZk9F,EAAiB,GACjBA,EAAiB,GACjB9J,IAGJplE,EAAMmnD,iBAAkB,EACnBooB,GACHt/F,OAAO4kC,QAAQoxC,aAAa,GAAIv5E,IAAUuD,OAAOC,SAASC,YAEvD,CAEL,GAAI2M,SAASsqC,OACX,OAAO,IAAItxC,SAAQ,CAACC,EAASC,KAC3B/F,OAAOkiD,iBACL,SACA,IAAM00B,GAAgB9hD,GAAMzpB,KAAKvF,GAAS6kE,MAAM5kE,IAChD,CACE25F,MAAM,OAMdJ,EAAe,KACft/F,OAAO4kC,QAAQoxC,aAAa,GAAIv5E,IAAUuD,OAAOC,SAASC,aAEvD,GAAIg/F,EAAkB,CAC3Bl/F,OAAO4kC,QAAQoxC,aAAa,GAAIv5E,IAAUuD,OAAOC,SAASC,QAE1D,MAAM01E,EAAMspB,EAAiB,GAC7B,IACE,MAAM/oB,QAAgBC,MAAMp2E,OAAOq2E,mBAAmBT,IAChDxxE,QAAayuD,SAAmBsjB,EAAQnwE,OAAQ,KAAM,MAC5D,IACG+pB,EAAM1L,SAAS5gB,QAChBzD,OAAOywE,QAAQ9kE,EAAE,mCAEjB,MAAO,CAAEokB,MAAO3rB,EAAMq7F,mBAExB,MAAO33F,GACP,MAAO,CACLioB,MAAO,CACLpU,SAAU,CACRtC,aAAc1N,EAAE,4BAGpB8zF,oBAKN,OAAIH,EACK,CACLvvE,YAAa+E,EAAK6qE,UAAUvF,uBAAuBkF,GACnDG,iBAAiB,EACjBh0F,GAAI6zF,EAAatM,OACjB3vF,IAAKi8F,EAAarM,SAEXljE,EACF0vE,GAAmBR,EACtB,CACElvE,QACA0vE,kBACAh0F,GAAIwzF,EAAiB,GACrB57F,IAAK47F,EAAiB,IAExB,CAAElvE,QAAO0vE,iBAAiB,GAEzB,CAAE1vE,MAAO,KAAM0vE,iBAAiB,IAGnCG,GACJ,qBAAG1tF,MAAO,CAAEmc,UAAW,MAAOwxE,YAAa,SAA3C,oCAEE,wBACA,oBACErxB,KAAK,2FACLnoE,OAAO,SACPooE,IAAI,aAHN,6BAUEqxB,GAAoB,KAAO,IAAD,EAC9B,MAAOzmF,EAAc6+E,GAAmB57E,mBAAS,IACjD,IAAI4gF,EAAkBsB,GAAiBuB,UAAYj0F,EAAYP,KAC3DwlB,MAAM4F,QAAQumE,KAChBA,EAAkBA,EAAgB,IAEpC,MAAOzqB,EAAUutB,GAAe1jF,mBAAS4gF,GAKnC+C,EAAyBxpD,iBAE5B,CAAElgC,QAAS,OACT0pF,EAAuBzgF,QAAQjJ,UAClC0pF,EAAuBzgF,QAAQjJ,QAC7BD,MAGJygC,qBAAU,KAERpjC,YAAW,KACTzO,YAAW,OAAQ,UAAWiS,QAC7BzW,OACF,IAEH,MAAOsxF,EAAekO,GACpB/jF,KAEIwjF,EAAS,UAAGrsB,qBAAWslB,WAAd,aAAG,EAA2BpU,IAE7CztC,qBAAU,KACR,IAAK4oD,IAAc3N,EACjB,OAGF,MAAMmO,EAAa,SACjB/7F,GAEI,IADJg8F,EACG,wDACH,GAAKh8F,EAAK2rB,MAAV,CAGA,GAAI4vE,EAAUj2B,kBACRtlE,EAAK2rB,MAAM1L,UACbs7E,EACGjF,4BAA4B,CAC3Br2E,SAAUjgB,EAAK2rB,MAAM1L,WAEtBhZ,MAAK,IAAoC,IAAnC,YAAEkmF,EAAF,aAAe58B,GAAmB,EACvCq9B,EAAcjY,SAASwX,GACvBQ,GAAyB,CACvBC,gBACAr9B,eACAtwC,SAAU2tE,EAAc/c,4CAI3B,CAAC,IAAD,EACL,MAAMxgB,GACJ,UAAArwD,EAAK2rB,MAAM1L,gBAAX,eAAqBrb,QAAO,CAACC,EAAKwT,IAC5BD,GAA0BC,GACrBxT,EAAIgD,OAAOwQ,EAAQC,QAErBzT,GACN,MAAmB,GAEpB7E,EAAKq7F,gBACP9K,GAAsB,GAAD,OAChB/D,GADgB,YAC4BxsF,EAAKqH,IACpDrH,EAAKf,IACLoxD,GACAppD,MAAK,IAAoC,IAAnC,YAAEkmF,EAAF,aAAe58B,GAAmB,EACxCq9B,EAAcjY,SAASwX,GACvBQ,GAAyB,CACvBC,gBACAr9B,eACAtwC,SAAU2tE,EAAc/c,wCAGnBmrB,IACL3rC,EAAQhxD,QACV46F,GACG3Z,SAASjwB,GACTppD,MAAK,IAAoC,IAAnC,YAAEkmF,EAAF,aAAe58B,GAAmB,EACnC48B,EAAY9tF,QACduuF,EAAcjY,SAASwX,GAEzBQ,GAAyB,CACvBC,gBACAr9B,eACAtwC,SAAU2tE,EAAc/c,wCAMhCgpB,GAAgC,CAAEE,eAAgB1pC,KAItD,IACErwD,EAAK2rB,MAAM0zC,aACT35D,KAAKU,MACHgkF,aAAagH,QAAQr1F,IAAaC,yBAC/B,GACP,MAAO0H,GACPC,QAAQD,MAAMA,MAIlB8uE,GAAgB,CAAE+oB,cAAat0F,MAAMjH,IACnC+7F,EAAW/7F,GAA0B,GACrC67F,EAAuBzgF,QAAQjJ,QAAQzQ,QAAQ1B,EAAK2rB,UAGtD,MAAMswE,EAAgBj6F,IACpBA,EAAMmR,iBACN,MAAMu+D,EAAO,IAAIC,gBAAgB/1E,OAAOC,SAAS61E,KAAKrsE,MAAM,IACtD0tE,EAAarB,EAAKlvD,IAAIplB,IAAcD,YACtC41E,GAKFn3E,OAAO4kC,QAAQoxC,aAAa,GAAI,GAAI5vE,EAAMk6F,QAC1CtO,EAAc1hB,cAAc6G,EAAYrB,EAAKlvD,IAAI,WAEjDgwD,GAAgB,CAAE+oB,cAAat0F,MAAMjH,IACnC+7F,EAAW/7F,GACPA,EAAK2rB,OACPiiE,EAAc/X,YAAY,IACrB71E,EAAK2rB,MACRpU,SAAUk2C,GAAgBztD,EAAK2rB,MAAMpU,SAAU,YAOnD4kF,EAAe5sF,YACnB,IAAO9G,SAASyqC,MAAQ76C,KACxB+D,KAKF,OAHAR,OAAOkiD,iBAAiBnkD,IAAMyiG,WAAYH,GAAc,GACxDrgG,OAAOkiD,iBAAiBnkD,IAAM0oF,OAAQtiC,IAAQ,GAC9CnkD,OAAOkiD,iBAAiBnkD,IAAMygF,KAAMr6B,IAAQ,GACrC,KACLnkD,OAAOmiD,oBAAoBpkD,IAAMyiG,WAAYH,GAAc,GAC3DrgG,OAAOmiD,oBAAoBpkD,IAAM0oF,OAAQtiC,IAAQ,GACjDnkD,OAAOmiD,oBAAoBpkD,IAAMygF,KAAMr6B,IAAQ,GAC/CzwC,aAAa6sF,MAEd,CAACZ,EAAW3N,IAEfj7C,qBAAU,KACR,MAAM0pD,EAAiBr6F,IACrB04F,GAAclrF,QAGZo+E,GACAqM,GAAiB7M,oBAAoBQ,EAAc9c,qBAEnD59D,GAAclR,IAIlB,OADApG,OAAOkiD,iBAAiBnkD,IAAM++F,cAAe2D,GACtC,KACLzgG,OAAOmiD,oBAAoBpkD,IAAM++F,cAAe2D,MAEjD,CAACzO,IAEJj7C,qBAAU,KACRynD,GAAiBkC,kBAAkBjuB,KAClC,CAACA,IAEJ,MAuEM/E,EAAmBnxD,uBACvB,CAACusD,EAAmBntD,IACdmtD,EACK,KAGP,sBACE52D,MAAO,CACLO,MAAO,OACPb,SAAU,QACV+V,UAAW,UAJf,SASGi4E,MAIP,IAGIza,EAAe5oE,uBAClBusD,IACC,MAcM63B,EAAqB,IACzB,eAAC3D,GAAD,CACEjlD,SAAW06B,GAAautB,EAAYvtB,GACpC1mE,UAAWA,EACXmxF,gBAAiBzqB,IAGrB,GAAI3J,EAAU,CACZ,MAAM83B,EAAe5gG,OAAO8hD,WAAa,IACzC,OACE,uBACE5vC,MAAO,CACLY,QAAS,OACT67D,cAAeiyB,EAAe,SAAW,OAH7C,UAME,sCACE,kCAASj1F,EAAE,qBACVg1F,OAGH,sBACEzuF,MAAO,CACLO,MAAO,OACPb,SAAU,QACV+V,UAAW,SACXy0C,UAAWwkC,EAAe,QAAKtzF,EAC/B2tC,WAAY,OACZ2yB,YAAagzB,EAAe,YAAStzF,EACrC0e,QAAS,UACT+tC,OAAQ,kBACR8mC,aAAc,IAVlB,SAaGjB,QAKT,OACE,uCArDA,oBACE9pD,UAAU,yBACV04B,KAAK,qDACLnoE,OAAO,SACPooE,IAAI,sBACJ,aAAY9iE,EAAE,kBALhB,SAOE,eAAC,GAAD,CAASpG,MAAOoG,EAAE,qBAAsB66C,MAAM,EAA9C,SACGrL,OA+CFwlD,SAIP,CAACluB,IAoBGgoB,EAAcl+E,uBAAY,KAC9B8hF,GAAiB3M,UAChB,IAEH,OACE,uCACE,eAAC,GAAD,CACEr7C,IAAK6pD,EACLnoD,SAvLW,CACf1zB,EACA1I,EACA4R,MAEA,OAAIoyE,QAAJ,IAAIA,OAAJ,EAAIA,EAAWj2B,mBACbi2B,EAAU5E,kBAAkB12E,GAE5By6E,GAAcz6E,EAAU1I,EAAU4R,GAAO,KACvC,GAAIykE,EAAe,CACjB,IAAIngE,GAAY,EAEZvW,EAAsBK,EAASL,oBACnC,MAAM+I,EAAW2tE,EACd/c,mCACAjqE,KAAKyR,IACJ,GAAI4hF,GAAiB5M,+BAA+Bh1E,GAAU,CAC5DoV,GAAY,EACZ,MAAMivE,EAAQzuE,GAAe5V,EAAS,CAAE6K,OAAQ,UAIhD,OAHIhM,IAAwBmB,IAC1BnB,EAAsBwlF,GAEjBA,EAET,OAAOrkF,KAGPoV,GACFmgE,EAAc/X,YAAY,CACxB51D,WACA1I,SAAU,CACRL,8BAyJR27D,YAAagpB,EAAuBzgF,QAAQjJ,QAC5Cg3D,oBAAmB,OAAEoyB,QAAF,IAAEA,OAAF,EAAEA,EAAWpyB,oBAChC7D,gBAAe,OAAEi2B,QAAF,IAAEA,OAAF,EAAEA,EAAWj2B,kBAC5Bma,gBAAe,OAAE8b,QAAF,IAAEA,OAAF,EAAEA,EAAW9b,gBAC5BjhB,UAAW,CACTlhE,cAAe,CACbG,OAAQ,CACN2tE,kBAvJcpsE,MACxBq4D,EACA9/C,EACA4R,EACApZ,KAEA,GAAgC,IAA5BsnD,EAAiBh4D,OACnB,OAAOzD,OAAOw2E,MAAM7qE,EAAE,mCAExB,GAAIwI,EACF,SXzPyB/Q,OAC7BihB,EACA1I,EACA4R,KAEA,MAAMjuB,EAAO40D,GAAgB7vC,EAAU1I,EAAU4R,EAAO,YAClDplB,GAAU,IAAI3D,aAAcC,OAAOnF,GAEnCyhG,QAAkB/gG,OAAOiD,OAAOK,OAAOC,YAC3C,CACEC,KAAM,UACNC,OAAQ,MAEV,EACA,CAAC,UAAW,YAGRa,EAAKxB,eAGLiC,QAAkB/E,OAAOiD,OAAOK,OAAOuB,QAC3C,CACErB,KAAM,UACNc,MAEFy8F,EACA54F,GAII64F,EAAc,IAAIt8F,KAAK,CAACJ,EAAGC,OAAQQ,IACnC2xF,QAAgB,IAAIuK,SAASD,GAAar8F,cAI1Cu8F,QAAoBlhG,OAAOiD,OAAOK,OAAOI,UAAU,MAAOq9F,GAEhE,IACE,MAAM/mB,EAAW,IAAIliE,IACrB,IAAK,MAAM2E,KAAW4H,EAChB7H,GAA0BC,IAAY8Q,EAAM9Q,EAAQC,SACtDs9D,EAAS5wE,IAAIqT,EAAQC,OAAQ6Q,EAAM9Q,EAAQC,SAI/C,MAAMtS,EAAgB82F,EAAYv9F,EAE5Bk6F,QAAsBlM,GAAqB,CAC/CpkE,MAAOysD,EACP5vE,gBACAwnF,SAAUnB,KAGNqE,QAAiB1e,MAtRHjxE,2CAsR0B,CAC5CyD,OAAQ,OACRqJ,KAAMykF,IAEFp3F,QAAaw1F,EAASx1F,OAC5B,GAAIA,EAAKmM,GAAI,CACX,MAAMmqE,EAAM,IAAI2pB,IAAIv/F,OAAOC,SAASuuE,MAGpCoH,EAAIE,KAAJ,eAAmBx2E,EAAKmM,GAAxB,YAA8BrB,GAC9B,MAAM+2F,EAAYvrB,EAAIx/C,iBAEhB+8D,GAAoB,CACxBC,OAAO,qBAAD,OAAuB9zF,EAAKmM,IAClC8hB,MAAOswE,IAGT79F,OAAOohG,OAAP,sBAAmBz1F,EAAE,2BAA6Bw1F,OACpB,yBAArB7hG,EAAK+hG,YACdrhG,OAAOw2E,MAAM7qE,EAAE,6CAEf3L,OAAOw2E,MAAM7qE,EAAE,uCAEjB,MAAO7D,GACPC,QAAQD,MAAMA,GACd9H,OAAOw2E,MAAM7qE,EAAE,yCW4KL21F,CACJ7lC,EACA,IACK9/C,EACHR,oBAAqBQ,EAASrC,iBAC1BqC,EAASR,oBACTvD,KAAqBuD,qBAE3BoS,GAEF,MAAOzlB,GACP,GAAmB,eAAfA,EAAMtE,KAAuB,CAC/B,MAAM,MAAEiP,EAAF,OAASE,GAAWwB,EAC1BpM,QAAQD,MAAMA,EAAO,CAAE2K,QAAOE,WAC9BulF,EAAgBpwF,EAAM0tC,YA+HlBi6B,eAAgB,CAACprD,EAAU1I,EAAU4R,IAEjC,eAACmwE,GAAD,CACEr5E,SAAUA,EACV1I,SAAUA,EACV4R,MAAOA,EACPowE,QAAU71F,IACK,OAAbkqF,QAAa,IAAbA,KAAe/X,YAAY,CACzBt+D,SAAU,CACRtC,aAAcvR,EAAM0tC,iBAUtCk4B,iBAAkBA,EAClByX,aAAcA,EACd1S,SAAUA,EACVK,kBAxDoB,IAEtB,eAAC,GAAD,CACE2G,gBAAkBjkC,GAAYw8C,EAAevY,gBAAgBjkC,KAsD7DwxC,cAAc,EACd3B,wBAAwB,EACxB/hB,gBAnDkBlgE,UACtB,IAAKq7D,EAAMh7D,OAET,YADA+qF,aAAa+S,WAAWphG,IAAaC,uBAGvC,MAAMwjE,EAAkB95D,KAAKC,UAAU00D,GACvC+vB,aAAawL,QAAQ75F,IAAaC,sBAAuBwjE,IA8CrDoR,WAAW,IAEZgd,GACC,eAAC,GAAD,CACEA,cAAeA,EACfyI,YAAaA,IAGhBphF,GACC,eAAC44D,GAAD,CACEz8B,QAASn8B,EACTopC,QAAS,IAAMy1C,EAAgB,UAiB1BsJ,OAVO,IAElB,eAAC,GAAD,UACE,eAAC1I,GAAD,UACE,eAACgH,GAAD,QCrqBR,MAAM2B,GAAc3wD,QACW,cAA7B9wC,OAAOC,SAASyhG,UAEe,UAA7B1hG,OAAOC,SAASyhG,UAEhB1hG,OAAOC,SAASyhG,SAAShvC,MACvB,2DAkDAivC,GAAkB,CAACC,EAAeC,KACtC1yF,UAAU2yF,cACPvkD,SAASqkD,GACTv2F,MAAM02F,IACLA,EAAaC,cAAgB,KAC3B,MAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,KACA,cAA3BF,EAAiB77B,QACfj3D,UAAU2yF,cAAcM,YAK1Br6F,QAAQs6F,KACN,qFAIER,GAAUA,EAAOS,UACnBT,EAAOS,SAASP,KAOlBh6F,QAAQs6F,KAAK,sCAGTR,GAAUA,EAAOU,WACnBV,EAAOU,UAAUR,WAO5Bp3B,OAAO7iE,IACNC,QAAQD,MAAM,4CAA6CA,OAI3D06F,GAA0B,CAACZ,EAAeC,KAE9CzrB,MAAMwrB,EAAO,CACXa,QAAS,CAAE,iBAAkB,YAE5Bp3F,MAAMypF,IAEL,MAAM4N,EAAc5N,EAAS2N,QAAQ77E,IAAI,gBAEnB,MAApBkuE,EAASxtE,QACO,MAAfo7E,IAA8D,IAAvCA,EAAY1uE,QAAQ,cAG5C7kB,UAAU2yF,cAAcrd,MAAMp5E,MAAM02F,IAClCA,EAAaY,aAAat3F,MAAK,KAC7BrL,OAAOC,SAASkvF,eAKpBwS,GAAgBC,EAAOC,MAG1Bl3B,OAAO7iE,IACNC,QAAQs6F,KACN,gEACAv6F,EAAM0tC,aAKDmtD,GAAc7xE,IACrB,kBAAmB3hB,WACrBA,UAAU2yF,cAAcrd,MACrBp5E,MAAM02F,GACEA,EAAaY,eAErBt3F,MAAK,KACI,OAARylB,QAAQ,IAARA,UAED65C,OAAO7iE,IACNC,QAAQD,MAAMA,EAAM0tC,aCnJ1B,gCAAgCtmC,KAAKC,UAAUyzF,aAC9Chd,WAAW,8BAA8BE,SAE1C,mCDiBuB+b,KACvB,GAA6C,kBAAmB1yF,UAAW,CAGzE,GADkB,IAAIowF,IAAIp6F,IAAwBnF,OAAOC,SAASuuE,MACpDtuE,SAAWF,OAAOC,SAASC,OAIvC,OAGFF,OAAOkiD,iBAAiB,QAAQ,KAE9B,GADkBliD,OAAOC,SAASowE,SAASrjE,WAAW,UAKpD,OAHA21F,IAAW,KACT3iG,OAAOC,SAASkvF,aAEX,EAET,MAAMyS,EAAK,UAAMz8F,IAAN,sBAEPs8F,IAEFe,GAAwBZ,EAAOC,GAI/B1yF,UAAU2yF,cAAcrd,MAAMp5E,MAAK,KACjCtD,QAAQs6F,KACN,iHAMJV,GAAgBC,EAAOC,QCjD/BgB,CAAsB,CACpBP,SAAWP,IACT,MAAMe,EAAuBf,EAAagB,QACtCD,IACFA,EAAqB5gD,iBACnBnkD,IAAMilG,cACL58F,IAGe,cAFCA,EAAMC,OACA+/D,OAEnBpmE,OAAOC,SAASkvF,YAItB2T,EAAqBG,YAAY,CAAE9xF,KAAM,qB,wBCxB/C,MAAM+xF,GAAkD,CACtD,iBAAkB,aAClB,aAAc,WAOVC,KAHqC,SAAzCh+F,gyBAAYi+F,2BAKZv3F,OAAOD,KAAKs3F,IAAsB3vE,MAC/BmzB,GAAS1mD,OAAOC,SAASyhG,SAAS1tE,QAAQ0yB,IAAS,IAGxDmoC,KAAY,CACVwU,IAAKF,GACD,kEACA71F,EACJg2F,YAAaH,GAAYD,GAAqBC,SAAa71F,EAC3Di2F,QAASp+F,GACTq+F,aAAc,CACZ,sEAEFC,aAAc,CACZ,IAAIC,KAAkC,CACpCC,OAAQ,CAAC,YAGbC,WAAWx9F,GAAQ,IAAD,EAIhB,OAHA,UAAIA,EAAM+vE,eAAV,aAAI,EAAeP,OACjBxvE,EAAM+vE,QAAQP,IAAMxvE,EAAM+vE,QAAQP,IAAIhoE,QAAQ,OAAQ,KAEjDxH,KC/BXpG,OAAO6jG,mBAAqB1+F,GAE5B2+F,IAASx7B,OAAO,eAAC,GAAD,IAAmBz7D,SAASk3F,eAAe,W","file":"static/js/main.1f46de7f.chunk.js","sourcesContent":["import cssVariables from \"./css/variables.module.scss\";\nimport { AppProps } from \"./types\";\nimport { FontFamilyValues } from \"./element/types\";\n\nexport const APP_NAME = \"Excalidraw\";\n\nexport const DRAGGING_THRESHOLD = 10; // px\nexport const LINE_CONFIRM_THRESHOLD = 8; // px\nexport const ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nexport const ELEMENT_TRANSLATE_AMOUNT = 1;\nexport const TEXT_TO_CENTER_SNAP_THRESHOLD = 30;\nexport const SHIFT_LOCKING_ANGLE = Math.PI / 12;\nexport const CURSOR_TYPE = {\n  TEXT: \"text\",\n  CROSSHAIR: \"crosshair\",\n  GRABBING: \"grabbing\",\n  GRAB: \"grab\",\n  POINTER: \"pointer\",\n  MOVE: \"move\",\n  AUTO: \"\",\n};\nexport const POINTER_BUTTON = {\n  MAIN: 0,\n  WHEEL: 1,\n  SECONDARY: 2,\n  TOUCH: -1,\n};\n\nexport enum EVENT {\n  COPY = \"copy\",\n  PASTE = \"paste\",\n  CUT = \"cut\",\n  KEYDOWN = \"keydown\",\n  KEYUP = \"keyup\",\n  MOUSE_MOVE = \"mousemove\",\n  RESIZE = \"resize\",\n  UNLOAD = \"unload\",\n  FOCUS = \"focus\",\n  BLUR = \"blur\",\n  DRAG_OVER = \"dragover\",\n  DROP = \"drop\",\n  GESTURE_END = \"gestureend\",\n  BEFORE_UNLOAD = \"beforeunload\",\n  GESTURE_START = \"gesturestart\",\n  GESTURE_CHANGE = \"gesturechange\",\n  POINTER_MOVE = \"pointermove\",\n  POINTER_UP = \"pointerup\",\n  STATE_CHANGE = \"statechange\",\n  WHEEL = \"wheel\",\n  TOUCH_START = \"touchstart\",\n  TOUCH_END = \"touchend\",\n  HASHCHANGE = \"hashchange\",\n  VISIBILITY_CHANGE = \"visibilitychange\",\n  SCROLL = \"scroll\",\n}\n\nexport const ENV = {\n  TEST: \"test\",\n  DEVELOPMENT: \"development\",\n};\n\nexport const CLASSES = {\n  SHAPE_ACTIONS_MENU: \"App-menu__left\",\n};\n\n// 1-based in case we ever do `if(element.fontFamily)`\nexport const FONT_FAMILY = {\n  Virgil: 1,\n  Helvetica: 2,\n  Cascadia: 3,\n};\n\nexport const THEME = {\n  LIGHT: \"light\",\n  DARK: \"dark\",\n};\n\nexport const WINDOWS_EMOJI_FALLBACK_FONT = \"Segoe UI Emoji\";\n\nexport const DEFAULT_FONT_SIZE = 20;\nexport const DEFAULT_FONT_FAMILY: FontFamilyValues = FONT_FAMILY.Virgil;\nexport const DEFAULT_TEXT_ALIGN = \"left\";\nexport const DEFAULT_VERTICAL_ALIGN = \"top\";\nexport const DEFAULT_VERSION = \"{version}\";\n\nexport const CANVAS_ONLY_ACTIONS = [\"selectAll\"];\n\nexport const GRID_SIZE = 20; // TODO make it configurable?\n\nexport const MIME_TYPES = {\n  excalidraw: \"application/vnd.excalidraw+json\",\n  excalidrawlib: \"application/vnd.excalidrawlib+json\",\n  json: \"application/json\",\n  svg: \"image/svg+xml\",\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  gif: \"image/gif\",\n  binary: \"application/octet-stream\",\n} as const;\n\nexport const EXPORT_DATA_TYPES = {\n  excalidraw: \"excalidraw\",\n  excalidrawClipboard: \"excalidraw/clipboard\",\n  excalidrawLibrary: \"excalidrawlib\",\n} as const;\n\nexport const EXPORT_SOURCE = window.location.origin;\n\nexport const STORAGE_KEYS = {\n  LOCAL_STORAGE_LIBRARY: \"excalidraw-library\",\n} as const;\n\n// time in milliseconds\nexport const IMAGE_RENDER_TIMEOUT = 500;\nexport const TAP_TWICE_TIMEOUT = 300;\nexport const TOUCH_CTX_MENU_TIMEOUT = 500;\nexport const TITLE_TIMEOUT = 10000;\nexport const TOAST_TIMEOUT = 5000;\nexport const VERSION_TIMEOUT = 30000;\nexport const SCROLL_TIMEOUT = 100;\nexport const ZOOM_STEP = 0.1;\n\n// Report a user inactive after IDLE_THRESHOLD milliseconds\nexport const IDLE_THRESHOLD = 60_000;\n// Report a user active each ACTIVE_THRESHOLD milliseconds\nexport const ACTIVE_THRESHOLD = 3_000;\n\nexport const MODES = {\n  VIEW: \"viewMode\",\n  ZEN: \"zenMode\",\n  GRID: \"gridMode\",\n};\n\nexport const THEME_FILTER = cssVariables.themeFilter;\n\nexport const URL_QUERY_KEYS = {\n  addLibrary: \"addLibrary\",\n} as const;\n\nexport const URL_HASH_KEYS = {\n  addLibrary: \"addLibrary\",\n} as const;\n\nexport const DEFAULT_UI_OPTIONS: AppProps[\"UIOptions\"] = {\n  canvasActions: {\n    changeViewBackgroundColor: true,\n    clearCanvas: true,\n    export: { saveFileToDisk: true },\n    loadScene: true,\n    saveToActiveFile: true,\n    theme: true,\n    saveAsImage: true,\n  },\n};\n\nexport const MQ_MAX_WIDTH_PORTRAIT = 730;\nexport const MQ_MAX_WIDTH_LANDSCAPE = 1000;\nexport const MQ_MAX_HEIGHT_LANDSCAPE = 500;\n\nexport const MAX_DECIMALS_FOR_SVG_EXPORT = 2;\n\nexport const EXPORT_SCALES = [1, 2, 3];\nexport const DEFAULT_EXPORT_PADDING = 10; // px\n\nexport const DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT = 1440;\n\nexport const ALLOWED_IMAGE_MIME_TYPES = [\n  MIME_TYPES.png,\n  MIME_TYPES.jpg,\n  MIME_TYPES.svg,\n  MIME_TYPES.gif,\n] as const;\n\nexport const MAX_ALLOWED_FILE_BYTES = 2 * 1024 * 1024;\n\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n","export const IV_LENGTH_BYTES = 12;\n\nexport const createIV = () => {\n  const arr = new Uint8Array(IV_LENGTH_BYTES);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nexport const getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n\nexport const encryptData = async (\n  key: string,\n  data: Uint8Array | ArrayBuffer | Blob | File | string,\n): Promise<{ encryptedBuffer: ArrayBuffer; iv: Uint8Array }> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  const buffer: ArrayBuffer | Uint8Array =\n    typeof data === \"string\"\n      ? new TextEncoder().encode(data)\n      : data instanceof Uint8Array\n      ? data\n      : data instanceof Blob\n      ? await data.arrayBuffer()\n      : data;\n\n  const encryptedBuffer = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    buffer as ArrayBuffer | Uint8Array,\n  );\n\n  return { encryptedBuffer, iv };\n};\n\nexport const decryptData = async (\n  iv: Uint8Array,\n  encrypted: Uint8Array | ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getImportedKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n","export const trackEvent =\n  typeof process !== \"undefined\" &&\n  process.env?.REACT_APP_GOOGLE_ANALYTICS_ID &&\n  typeof window !== \"undefined\" &&\n  window.gtag\n    ? (category: string, name: string, label?: string, value?: number) => {\n        window.gtag(\"event\", name, {\n          event_category: category,\n          event_label: label,\n          value,\n        });\n      }\n    : typeof process !== \"undefined\" && process.env?.JEST_WORKER_ID\n    ? (category: string, name: string, label?: string, value?: number) => {}\n    : (category: string, name: string, label?: string, value?: number) => {\n        // Uncomment the next line to track locally\n        // console.info(\"Track Event\", category, name, label, value);\n      };\n","import { deflate, inflate } from \"pako\";\nimport { encryptData, decryptData } from \"./encryption\";\n\n// -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n\n// fast, Buffer-compatible implem\nexport const toByteString = (\n  data: string | Uint8Array | ArrayBuffer,\n): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const blob =\n      typeof data === \"string\"\n        ? new Blob([new TextEncoder().encode(data)])\n        : new Blob([data instanceof Uint8Array ? data : new Uint8Array(data)]);\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target || typeof event.target.result !== \"string\") {\n        return reject(new Error(\"couldn't convert to byte string\"));\n      }\n      resolve(event.target.result);\n    };\n    reader.readAsBinaryString(blob);\n  });\n};\n\nconst byteStringToArrayBuffer = (byteString: string) => {\n  const buffer = new ArrayBuffer(byteString.length);\n  const bufferView = new Uint8Array(buffer);\n  for (let i = 0, len = byteString.length; i < len; i++) {\n    bufferView[i] = byteString.charCodeAt(i);\n  }\n  return buffer;\n};\n\nconst byteStringToString = (byteString: string) => {\n  return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));\n};\n\n// -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */\nexport const stringToBase64 = async (str: string, isByteString = false) => {\n  return isByteString ? window.btoa(str) : window.btoa(await toByteString(str));\n};\n\n// async to align with stringToBase64\nexport const base64ToString = async (base64: string, isByteString = false) => {\n  return isByteString\n    ? window.atob(base64)\n    : byteStringToString(window.atob(base64));\n};\n\n// -----------------------------------------------------------------------------\n// text encoding\n// -----------------------------------------------------------------------------\n\ntype EncodedData = {\n  encoded: string;\n  encoding: \"bstring\";\n  /** whether text is compressed (zlib) */\n  compressed: boolean;\n  /** version for potential migration purposes */\n  version?: string;\n};\n\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */\nexport const encode = async ({\n  text,\n  compress,\n}: {\n  text: string;\n  /** defaults to `true`. If compression fails, falls back to bstring alone. */\n  compress?: boolean;\n}): Promise<EncodedData> => {\n  let deflated!: string;\n  if (compress !== false) {\n    try {\n      deflated = await toByteString(deflate(text));\n    } catch (error: any) {\n      console.error(\"encode: cannot deflate\", error);\n    }\n  }\n  return {\n    version: \"1\",\n    encoding: \"bstring\",\n    compressed: !!deflated,\n    encoded: deflated || (await toByteString(text)),\n  };\n};\n\nexport const decode = async (data: EncodedData): Promise<string> => {\n  let decoded: string;\n\n  switch (data.encoding) {\n    case \"bstring\":\n      // if compressed, do not double decode the bstring\n      decoded = data.compressed\n        ? data.encoded\n        : await byteStringToString(data.encoded);\n      break;\n    default:\n      throw new Error(`decode: unknown encoding \"${data.encoding}\"`);\n  }\n\n  if (data.compressed) {\n    return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {\n      to: \"string\",\n    });\n  }\n\n  return decoded;\n};\n\n// -----------------------------------------------------------------------------\n// binary encoding\n// -----------------------------------------------------------------------------\n\ntype FileEncodingInfo = {\n  /* version 2 is the version we're shipping the initial image support with.\n    version 1 was a PR version that a lot of people were using anyway.\n    Thus, if there are issues we can check whether they're not using the\n    unoffic version */\n  version: 1 | 2;\n  compression: \"pako@1\" | null;\n  encryption: \"AES-GCM\" | null;\n};\n\n// -----------------------------------------------------------------------------\nconst CONCAT_BUFFERS_VERSION = 1;\n/** how many bytes we use to encode how many bytes the next chunk has.\n * Corresponds to DataView setter methods (setUint32, setUint16, etc).\n *\n * NOTE ! values must not be changed, which would be backwards incompatible !\n */\nconst VERSION_DATAVIEW_BYTES = 4;\nconst NEXT_CHUNK_SIZE_DATAVIEW_BYTES = 4;\n// -----------------------------------------------------------------------------\n\nconst DATA_VIEW_BITS_MAP = { 1: 8, 2: 16, 4: 32 } as const;\n\n// getter\nfunction dataView(buffer: Uint8Array, bytes: 1 | 2 | 4, offset: number): number;\n// setter\nfunction dataView(\n  buffer: Uint8Array,\n  bytes: 1 | 2 | 4,\n  offset: number,\n  value: number,\n): Uint8Array;\n/**\n * abstraction over DataView that serves as a typed getter/setter in case\n * you're using constants for the byte size and want to ensure there's no\n * discrepenancy in the encoding across refactors.\n *\n * DataView serves for an endian-agnostic handling of numbers in ArrayBuffers.\n */\nfunction dataView(\n  buffer: Uint8Array,\n  bytes: 1 | 2 | 4,\n  offset: number,\n  value?: number,\n): Uint8Array | number {\n  if (value != null) {\n    if (value > Math.pow(2, DATA_VIEW_BITS_MAP[bytes]) - 1) {\n      throw new Error(\n        `attempting to set value higher than the allocated bytes (value: ${value}, bytes: ${bytes})`,\n      );\n    }\n    const method = `setUint${DATA_VIEW_BITS_MAP[bytes]}` as const;\n    new DataView(buffer.buffer)[method](offset, value);\n    return buffer;\n  }\n  const method = `getUint${DATA_VIEW_BITS_MAP[bytes]}` as const;\n  return new DataView(buffer.buffer)[method](offset);\n}\n\n// -----------------------------------------------------------------------------\n\n/**\n * Resulting concatenated buffer has this format:\n *\n * [\n *   VERSION chunk (4 bytes)\n *   LENGTH chunk 1 (4 bytes)\n *   DATA chunk 1 (up to 2^32 bits)\n *   LENGTH chunk 2 (4 bytes)\n *   DATA chunk 2 (up to 2^32 bits)\n *   ...\n * ]\n *\n * @param buffers each buffer (chunk) must be at most 2^32 bits large (~4GB)\n */\nconst concatBuffers = (...buffers: Uint8Array[]) => {\n  const bufferView = new Uint8Array(\n    VERSION_DATAVIEW_BYTES +\n      NEXT_CHUNK_SIZE_DATAVIEW_BYTES * buffers.length +\n      buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0),\n  );\n\n  let cursor = 0;\n\n  // as the first chunk we'll encode the version for backwards compatibility\n  dataView(bufferView, VERSION_DATAVIEW_BYTES, cursor, CONCAT_BUFFERS_VERSION);\n  cursor += VERSION_DATAVIEW_BYTES;\n\n  for (const buffer of buffers) {\n    dataView(\n      bufferView,\n      NEXT_CHUNK_SIZE_DATAVIEW_BYTES,\n      cursor,\n      buffer.byteLength,\n    );\n    cursor += NEXT_CHUNK_SIZE_DATAVIEW_BYTES;\n\n    bufferView.set(buffer, cursor);\n    cursor += buffer.byteLength;\n  }\n\n  return bufferView;\n};\n\n/** can only be used on buffers created via `concatBuffers()` */\nconst splitBuffers = (concatenatedBuffer: Uint8Array) => {\n  const buffers = [];\n\n  let cursor = 0;\n\n  // first chunk is the version (ignored for now)\n  cursor += VERSION_DATAVIEW_BYTES;\n\n  while (true) {\n    const chunkSize = dataView(\n      concatenatedBuffer,\n      NEXT_CHUNK_SIZE_DATAVIEW_BYTES,\n      cursor,\n    );\n    cursor += NEXT_CHUNK_SIZE_DATAVIEW_BYTES;\n\n    buffers.push(concatenatedBuffer.slice(cursor, cursor + chunkSize));\n    cursor += chunkSize;\n    if (cursor >= concatenatedBuffer.byteLength) {\n      break;\n    }\n  }\n\n  return buffers;\n};\n\n// helpers for (de)compressing data with JSON metadata including encryption\n// -----------------------------------------------------------------------------\n\n/** @private */\nconst _encryptAndCompress = async (\n  data: Uint8Array | string,\n  encryptionKey: string,\n) => {\n  const { encryptedBuffer, iv } = await encryptData(\n    encryptionKey,\n    deflate(data),\n  );\n\n  return { iv, buffer: new Uint8Array(encryptedBuffer) };\n};\n\n/**\n * The returned buffer has following format:\n * `[]` refers to a buffers wrapper (see `concatBuffers`)\n *\n * [\n *   encodingMetadataBuffer,\n *   iv,\n *   [\n *      contentsMetadataBuffer\n *      contentsBuffer\n *   ]\n * ]\n */\nexport const compressData = async <T extends Record<string, any> = never>(\n  dataBuffer: Uint8Array,\n  options: {\n    encryptionKey: string;\n  } & ([T] extends [never]\n    ? {\n        metadata?: T;\n      }\n    : {\n        metadata: T;\n      }),\n): Promise<Uint8Array> => {\n  const fileInfo: FileEncodingInfo = {\n    version: 2,\n    compression: \"pako@1\",\n    encryption: \"AES-GCM\",\n  };\n\n  const encodingMetadataBuffer = new TextEncoder().encode(\n    JSON.stringify(fileInfo),\n  );\n\n  const contentsMetadataBuffer = new TextEncoder().encode(\n    JSON.stringify(options.metadata || null),\n  );\n\n  const { iv, buffer } = await _encryptAndCompress(\n    concatBuffers(contentsMetadataBuffer, dataBuffer),\n    options.encryptionKey,\n  );\n\n  return concatBuffers(encodingMetadataBuffer, iv, buffer);\n};\n\n/** @private */\nconst _decryptAndDecompress = async (\n  iv: Uint8Array,\n  decryptedBuffer: Uint8Array,\n  decryptionKey: string,\n  isCompressed: boolean,\n) => {\n  decryptedBuffer = new Uint8Array(\n    await decryptData(iv, decryptedBuffer, decryptionKey),\n  );\n\n  if (isCompressed) {\n    return inflate(decryptedBuffer);\n  }\n\n  return decryptedBuffer;\n};\n\nexport const decompressData = async <T extends Record<string, any>>(\n  bufferView: Uint8Array,\n  options: { decryptionKey: string },\n) => {\n  // first chunk is encoding metadata (ignored for now)\n  const [encodingMetadataBuffer, iv, buffer] = splitBuffers(bufferView);\n\n  const encodingMetadata: FileEncodingInfo = JSON.parse(\n    new TextDecoder().decode(encodingMetadataBuffer),\n  );\n\n  try {\n    const [contentsMetadataBuffer, contentsBuffer] = splitBuffers(\n      await _decryptAndDecompress(\n        iv,\n        buffer,\n        options.decryptionKey,\n        !!encodingMetadata.compression,\n      ),\n    );\n\n    const metadata = JSON.parse(\n      new TextDecoder().decode(contentsMetadataBuffer),\n    ) as T;\n\n    return {\n      /** metadata source is always JSON so we can decode it here */\n      metadata,\n      /** data can be anything so the caller must decode it */\n      data: contentsBuffer,\n    };\n  } catch (error: any) {\n    console.error(\n      `Error during decompressing and decrypting the file.`,\n      encodingMetadata,\n    );\n    throw error;\n  }\n};\n\n// -----------------------------------------------------------------------------\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"themeFilter\":\"invert(93%) hue-rotate(180deg)\"};","var map = {\n\t\"./ar-SA.json\": [\n\t\t105,\n\t\t4\n\t],\n\t\"./bg-BG.json\": [\n\t\t106,\n\t\t5\n\t],\n\t\"./bn-BD.json\": [\n\t\t107,\n\t\t6\n\t],\n\t\"./ca-ES.json\": [\n\t\t108,\n\t\t7\n\t],\n\t\"./cs-CZ.json\": [\n\t\t109,\n\t\t8\n\t],\n\t\"./da-DK.json\": [\n\t\t110,\n\t\t9\n\t],\n\t\"./de-DE.json\": [\n\t\t111,\n\t\t10\n\t],\n\t\"./el-GR.json\": [\n\t\t112,\n\t\t11\n\t],\n\t\"./en.json\": [\n\t\t36\n\t],\n\t\"./es-ES.json\": [\n\t\t113,\n\t\t12\n\t],\n\t\"./fa-IR.json\": [\n\t\t114,\n\t\t13\n\t],\n\t\"./fi-FI.json\": [\n\t\t115,\n\t\t14\n\t],\n\t\"./fr-FR.json\": [\n\t\t116,\n\t\t15\n\t],\n\t\"./he-IL.json\": [\n\t\t117,\n\t\t16\n\t],\n\t\"./hi-IN.json\": [\n\t\t118,\n\t\t17\n\t],\n\t\"./hu-HU.json\": [\n\t\t119,\n\t\t18\n\t],\n\t\"./id-ID.json\": [\n\t\t120,\n\t\t19\n\t],\n\t\"./it-IT.json\": [\n\t\t121,\n\t\t20\n\t],\n\t\"./ja-JP.json\": [\n\t\t122,\n\t\t21\n\t],\n\t\"./kab-KAB.json\": [\n\t\t123,\n\t\t22\n\t],\n\t\"./kk-KZ.json\": [\n\t\t124,\n\t\t23\n\t],\n\t\"./ko-KR.json\": [\n\t\t125,\n\t\t24\n\t],\n\t\"./lv-LV.json\": [\n\t\t126,\n\t\t25\n\t],\n\t\"./my-MM.json\": [\n\t\t127,\n\t\t26\n\t],\n\t\"./nb-NO.json\": [\n\t\t128,\n\t\t27\n\t],\n\t\"./nl-NL.json\": [\n\t\t129,\n\t\t28\n\t],\n\t\"./nn-NO.json\": [\n\t\t130,\n\t\t29\n\t],\n\t\"./oc-FR.json\": [\n\t\t131,\n\t\t30\n\t],\n\t\"./pa-IN.json\": [\n\t\t132,\n\t\t31\n\t],\n\t\"./percentages.json\": [\n\t\t37\n\t],\n\t\"./pl-PL.json\": [\n\t\t133,\n\t\t32\n\t],\n\t\"./pt-BR.json\": [\n\t\t134,\n\t\t33\n\t],\n\t\"./pt-PT.json\": [\n\t\t135,\n\t\t34\n\t],\n\t\"./ro-RO.json\": [\n\t\t136,\n\t\t35\n\t],\n\t\"./ru-RU.json\": [\n\t\t137,\n\t\t36\n\t],\n\t\"./si-LK.json\": [\n\t\t138,\n\t\t37\n\t],\n\t\"./sk-SK.json\": [\n\t\t139,\n\t\t38\n\t],\n\t\"./sv-SE.json\": [\n\t\t140,\n\t\t39\n\t],\n\t\"./ta-IN.json\": [\n\t\t141,\n\t\t40\n\t],\n\t\"./tr-TR.json\": [\n\t\t142,\n\t\t41\n\t],\n\t\"./uk-UA.json\": [\n\t\t143,\n\t\t42\n\t],\n\t\"./zh-CN.json\": [\n\t\t144,\n\t\t43\n\t],\n\t\"./zh-HK.json\": [\n\t\t145,\n\t\t44\n\t],\n\t\"./zh-TW.json\": [\n\t\t146,\n\t\t45\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, 3);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 58;\nmodule.exports = webpackAsyncContext;","import fallbackLangData from \"./locales/en.json\";\nimport percentages from \"./locales/percentages.json\";\nimport { ENV } from \"./constants\";\n\nconst COMPLETION_THRESHOLD = 85;\n\nexport interface Language {\n  code: string;\n  label: string;\n  rtl?: boolean;\n}\n\nexport const defaultLang = { code: \"en\", label: \"English\" };\n\nconst allLanguages: Language[] = [\n  { code: \"ar-SA\", label: \"\", rtl: true },\n  { code: \"bg-BG\", label: \"\" },\n  { code: \"ca-ES\", label: \"Catal\" },\n  { code: \"de-DE\", label: \"Deutsch\" },\n  { code: \"el-GR\", label: \"\" },\n  { code: \"es-ES\", label: \"Espaol\" },\n  { code: \"fa-IR\", label: \"\", rtl: true },\n  { code: \"fi-FI\", label: \"Suomi\" },\n  { code: \"fr-FR\", label: \"Franais\" },\n  { code: \"he-IL\", label: \"\", rtl: true },\n  { code: \"hi-IN\", label: \"\" },\n  { code: \"hu-HU\", label: \"Magyar\" },\n  { code: \"id-ID\", label: \"Bahasa Indonesia\" },\n  { code: \"it-IT\", label: \"Italiano\" },\n  { code: \"ja-JP\", label: \"\" },\n  { code: \"kab-KAB\", label: \"Taqbaylit\" },\n  { code: \"ko-KR\", label: \"\" },\n  { code: \"my-MM\", label: \"Burmese\" },\n  { code: \"nb-NO\", label: \"Norsk bokml\" },\n  { code: \"nl-NL\", label: \"Nederlands\" },\n  { code: \"nn-NO\", label: \"Norsk nynorsk\" },\n  { code: \"oc-FR\", label: \"Occitan\" },\n  { code: \"pa-IN\", label: \"\" },\n  { code: \"pl-PL\", label: \"Polski\" },\n  { code: \"pt-BR\", label: \"Portugus Brasileiro\" },\n  { code: \"pt-PT\", label: \"Portugus\" },\n  { code: \"ro-RO\", label: \"Romn\" },\n  { code: \"ru-RU\", label: \"\" },\n  { code: \"sk-SK\", label: \"Slovenina\" },\n  { code: \"sv-SE\", label: \"Svenska\" },\n  { code: \"tr-TR\", label: \"Trke\" },\n  { code: \"uk-UA\", label: \"\" },\n  { code: \"zh-CN\", label: \"\" },\n  { code: \"zh-TW\", label: \"\" },\n  { code: \"lv-LV\", label: \"Latvieu\" },\n  { code: \"cs-CZ\", label: \"esky\" },\n  { code: \"kk-KZ\", label: \" \" },\n].concat([defaultLang]);\n\nexport const languages: Language[] = allLanguages\n  .sort((left, right) => (left.label > right.label ? 1 : -1))\n  .filter(\n    (lang) =>\n      (percentages as Record<string, number>)[lang.code] >=\n      COMPLETION_THRESHOLD,\n  );\n\nconst TEST_LANG_CODE = \"__test__\";\nif (process.env.NODE_ENV === ENV.DEVELOPMENT) {\n  languages.unshift(\n    { code: TEST_LANG_CODE, label: \"test language\" },\n    {\n      code: `${TEST_LANG_CODE}.rtl`,\n      label: \"\\u{202a}test language (rtl)\\u{202c}\",\n      rtl: true,\n    },\n  );\n}\n\nlet currentLang: Language = defaultLang;\nlet currentLangData = {};\n\nexport const setLanguage = async (lang: Language) => {\n  currentLang = lang;\n  document.documentElement.dir = currentLang.rtl ? \"rtl\" : \"ltr\";\n  document.documentElement.lang = currentLang.code;\n\n  if (lang.code.startsWith(TEST_LANG_CODE)) {\n    currentLangData = {};\n  } else {\n    currentLangData = await import(\n      /* webpackChunkName: \"i18n-[request]\" */ `./locales/${currentLang.code}.json`\n    );\n  }\n};\n\nexport const getLanguage = () => currentLang;\n\nconst findPartsForData = (data: any, parts: string[]) => {\n  for (let index = 0; index < parts.length; ++index) {\n    const part = parts[index];\n    if (data[part] === undefined) {\n      return undefined;\n    }\n    data = data[part];\n  }\n  if (typeof data !== \"string\") {\n    return undefined;\n  }\n  return data;\n};\n\nexport const t = (path: string, replacement?: { [key: string]: string }) => {\n  if (currentLang.code.startsWith(TEST_LANG_CODE)) {\n    const name = replacement\n      ? `${path}(${JSON.stringify(replacement).slice(1, -1)})`\n      : path;\n    return `\\u{202a}[[${name}]]\\u{202c}`;\n  }\n\n  const parts = path.split(\".\");\n  let translation =\n    findPartsForData(currentLangData, parts) ||\n    findPartsForData(fallbackLangData, parts);\n  if (translation === undefined) {\n    throw new Error(`Can't find translation for ${path}`);\n  }\n\n  if (replacement) {\n    for (const key in replacement) {\n      translation = translation.replace(`{{${key}}}`, replacement[key]);\n    }\n  }\n  return translation;\n};\n","import oc from \"open-color\";\n\nconst shades = (index: number) => [\n  oc.red[index],\n  oc.pink[index],\n  oc.grape[index],\n  oc.violet[index],\n  oc.indigo[index],\n  oc.blue[index],\n  oc.cyan[index],\n  oc.teal[index],\n  oc.green[index],\n  oc.lime[index],\n  oc.yellow[index],\n  oc.orange[index],\n];\n\nexport default {\n  canvasBackground: [oc.white, oc.gray[0], oc.gray[1], ...shades(0)],\n  elementBackground: [\"transparent\", oc.gray[4], oc.gray[6], ...shades(6)],\n  elementStroke: [oc.black, oc.gray[8], oc.gray[7], ...shades(9)],\n};\n","export const isDarwin = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\nexport const isWindows = /^Win/.test(window.navigator.platform);\n\nexport const CODES = {\n  EQUAL: \"Equal\",\n  MINUS: \"Minus\",\n  NUM_ADD: \"NumpadAdd\",\n  NUM_SUBTRACT: \"NumpadSubtract\",\n  NUM_ZERO: \"Numpad0\",\n  BRACKET_RIGHT: \"BracketRight\",\n  BRACKET_LEFT: \"BracketLeft\",\n  ONE: \"Digit1\",\n  TWO: \"Digit2\",\n  NINE: \"Digit9\",\n  QUOTE: \"Quote\",\n  ZERO: \"Digit0\",\n  SLASH: \"Slash\",\n  C: \"KeyC\",\n  D: \"KeyD\",\n  G: \"KeyG\",\n  F: \"KeyF\",\n  H: \"KeyH\",\n  V: \"KeyV\",\n  X: \"KeyX\",\n  Z: \"KeyZ\",\n  R: \"KeyR\",\n} as const;\n\nexport const KEYS = {\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_UP: \"ArrowUp\",\n  BACKSPACE: \"Backspace\",\n  ALT: \"Alt\",\n  CTRL_OR_CMD: isDarwin ? \"metaKey\" : \"ctrlKey\",\n  DELETE: \"Delete\",\n  ENTER: \"Enter\",\n  ESCAPE: \"Escape\",\n  QUESTION_MARK: \"?\",\n  SPACE: \" \",\n  TAB: \"Tab\",\n\n  A: \"a\",\n  D: \"d\",\n  E: \"e\",\n  G: \"g\",\n  I: \"i\",\n  L: \"l\",\n  O: \"o\",\n  P: \"p\",\n  Q: \"q\",\n  R: \"r\",\n  S: \"s\",\n  T: \"t\",\n  V: \"v\",\n  X: \"x\",\n  Y: \"y\",\n  Z: \"z\",\n} as const;\n\nexport type Key = keyof typeof KEYS;\n\nexport const isArrowKey = (key: string) =>\n  key === KEYS.ARROW_LEFT ||\n  key === KEYS.ARROW_RIGHT ||\n  key === KEYS.ARROW_DOWN ||\n  key === KEYS.ARROW_UP;\n\nexport const shouldResizeFromCenter = (event: MouseEvent | KeyboardEvent) =>\n  event.altKey;\n\nexport const shouldMaintainAspectRatio = (event: MouseEvent | KeyboardEvent) =>\n  event.shiftKey;\n\nexport const shouldRotateWithDiscreteAngle = (\n  event: MouseEvent | KeyboardEvent,\n) => event.shiftKey;\n","import colors from \"./colors\";\nimport {\n  CURSOR_TYPE,\n  DEFAULT_VERSION,\n  FONT_FAMILY,\n  WINDOWS_EMOJI_FALLBACK_FONT,\n} from \"./constants\";\nimport { FontFamilyValues, FontString } from \"./element/types\";\nimport { Zoom } from \"./types\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { isDarwin } from \"./keys\";\n\nlet mockDateTime: string | null = null;\n\nexport const setDateTimeForTests = (dateTime: string) => {\n  mockDateTime = dateTime;\n};\n\nexport const getDateTime = () => {\n  if (mockDateTime) {\n    return mockDateTime;\n  }\n\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = `${date.getMonth() + 1}`.padStart(2, \"0\");\n  const day = `${date.getDate()}`.padStart(2, \"0\");\n  const hr = `${date.getHours()}`.padStart(2, \"0\");\n  const min = `${date.getMinutes()}`.padStart(2, \"0\");\n\n  return `${year}-${month}-${day}-${hr}${min}`;\n};\n\nexport const capitalizeString = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\nexport const isToolIcon = (\n  target: Element | EventTarget | null,\n): target is HTMLElement =>\n  target instanceof HTMLElement && target.className.includes(\"ToolIcon\");\n\nexport const isInputLike = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLSelectElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLInputElement ||\n  target instanceof HTMLTextAreaElement ||\n  target instanceof HTMLSelectElement;\n\nexport const isWritableElement = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLTextAreaElement ||\n  (target instanceof HTMLInputElement &&\n    (target.type === \"text\" || target.type === \"number\"));\n\nexport const getFontFamilyString = ({\n  fontFamily,\n}: {\n  fontFamily: FontFamilyValues;\n}) => {\n  for (const [fontFamilyString, id] of Object.entries(FONT_FAMILY)) {\n    if (id === fontFamily) {\n      return `${fontFamilyString}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;\n    }\n  }\n  return WINDOWS_EMOJI_FALLBACK_FONT;\n};\n\n/** returns fontSize+fontFamily string for assignment to DOM elements */\nexport const getFontString = ({\n  fontSize,\n  fontFamily,\n}: {\n  fontSize: number;\n  fontFamily: FontFamilyValues;\n}) => {\n  return `${fontSize}px ${getFontFamilyString({ fontFamily })}` as FontString;\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport const measureText = (text: string, font: FontString) => {\n  const line = document.createElement(\"div\");\n  const body = document.body;\n  line.style.position = \"absolute\";\n  line.style.whiteSpace = \"pre\";\n  line.style.font = font;\n  body.appendChild(line);\n  line.innerText = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const width = line.offsetWidth;\n  const height = line.offsetHeight;\n  // Now creating 1px sized item that will be aligned to baseline\n  // to calculate baseline shift\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  line.appendChild(span);\n  // Baseline is important for positioning text on canvas\n  const baseline = span.offsetTop + span.offsetHeight;\n  document.body.removeChild(line);\n\n  return { width, height, baseline };\n};\n\nexport const debounce = <T extends any[]>(\n  fn: (...args: T) => void,\n  timeout: number,\n) => {\n  let handle = 0;\n  let lastArgs: T | null = null;\n  const ret = (...args: T) => {\n    lastArgs = args;\n    clearTimeout(handle);\n    handle = window.setTimeout(() => {\n      lastArgs = null;\n      fn(...args);\n    }, timeout);\n  };\n  ret.flush = () => {\n    clearTimeout(handle);\n    if (lastArgs) {\n      const _lastArgs = lastArgs;\n      lastArgs = null;\n      fn(..._lastArgs);\n    }\n  };\n  ret.cancel = () => {\n    lastArgs = null;\n    clearTimeout(handle);\n  };\n  return ret;\n};\n\nexport const selectNode = (node: Element) => {\n  const selection = window.getSelection();\n  if (selection) {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n};\n\nexport const removeSelection = () => {\n  const selection = window.getSelection();\n  if (selection) {\n    selection.removeAllRanges();\n  }\n};\n\nexport const distance = (x: number, y: number) => Math.abs(x - y);\n\nexport const resetCursor = (canvas: HTMLCanvasElement | null) => {\n  if (canvas) {\n    canvas.style.cursor = \"\";\n  }\n};\n\nexport const setCursor = (canvas: HTMLCanvasElement | null, cursor: string) => {\n  if (canvas) {\n    canvas.style.cursor = cursor;\n  }\n};\n\nexport const setCursorForShape = (\n  canvas: HTMLCanvasElement | null,\n  shape: string,\n) => {\n  if (!canvas) {\n    return;\n  }\n  if (shape === \"selection\") {\n    resetCursor(canvas);\n    // do nothing if image tool is selected which suggests there's\n    // a image-preview set as the cursor\n  } else if (shape !== \"image\") {\n    canvas.style.cursor = CURSOR_TYPE.CROSSHAIR;\n  }\n};\n\nexport const isFullScreen = () =>\n  document.fullscreenElement?.nodeName === \"HTML\";\n\nexport const allowFullScreen = () =>\n  document.documentElement.requestFullscreen();\n\nexport const exitFullScreen = () => document.exitFullscreen();\n\nexport const getShortcutKey = (shortcut: string): string => {\n  shortcut = shortcut\n    .replace(/\\bAlt\\b/i, \"Alt\")\n    .replace(/\\bShift\\b/i, \"Shift\")\n    .replace(/\\b(Enter|Return)\\b/i, \"Enter\")\n    .replace(/\\bDel\\b/i, \"Delete\");\n\n  if (isDarwin) {\n    return shortcut\n      .replace(/\\bCtrlOrCmd\\b/i, \"Cmd\")\n      .replace(/\\bAlt\\b/i, \"Option\");\n  }\n  return shortcut.replace(/\\bCtrlOrCmd\\b/i, \"Ctrl\");\n};\n\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY }: { clientX: number; clientY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const invScale = 1 / zoom.value;\n  const x = (clientX - zoom.translation.x - offsetLeft) * invScale - scrollX;\n  const y = (clientY - zoom.translation.y - offsetTop) * invScale - scrollY;\n  return { x, y };\n};\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY }: { sceneX: number; sceneY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const x = (sceneX + scrollX + offsetLeft) * zoom.value + zoom.translation.x;\n  const y = (sceneY + scrollY + offsetTop) * zoom.value + zoom.translation.y;\n  return { x, y };\n};\n\nexport const getGlobalCSSVariable = (name: string) =>\n  getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);\n\nconst RS_LTR_CHARS =\n  \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\" +\n  \"\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF\";\nconst RS_RTL_CHARS = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);\n/**\n * Checks whether first directional character is RTL. Meaning whether it starts\n *  with RTL characters, or indeterminate (numbers etc.) characters followed by\n *  RTL.\n * See https://github.com/excalidraw/excalidraw/pull/1722#discussion_r436340171\n */\nexport const isRTL = (text: string) => RE_RTL_CHECK.test(text);\n\nexport const tupleToCoors = (\n  xyTuple: readonly [number, number],\n): { x: number; y: number } => {\n  const [x, y] = xyTuple;\n  return { x, y };\n};\n\n/** use as a rejectionHandler to mute filesystem Abort errors */\nexport const muteFSAbortError = (error?: Error) => {\n  if (error?.name === \"AbortError\") {\n    return;\n  }\n  throw error;\n};\n\nexport const findIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = 0,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length, Math.max(fromIndex, 0));\n  let index = fromIndex - 1;\n  while (++index < array.length) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const findLastIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = array.length - 1,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));\n  let index = fromIndex + 1;\n  while (--index > -1) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const isTransparent = (color: string) => {\n  const isRGBTransparent = color.length === 5 && color.substr(4, 1) === \"0\";\n  const isRRGGBBTransparent = color.length === 9 && color.substr(7, 2) === \"00\";\n  return (\n    isRGBTransparent ||\n    isRRGGBBTransparent ||\n    color === colors.elementBackground[0]\n  );\n};\n\nexport type ResolvablePromise<T> = Promise<T> & {\n  resolve: [T] extends [undefined] ? (value?: T) => void : (value: T) => void;\n  reject: (error: Error) => void;\n};\nexport const resolvablePromise = <T>() => {\n  let resolve!: any;\n  let reject!: any;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  (promise as any).resolve = resolve;\n  (promise as any).reject = reject;\n  return promise as ResolvablePromise<T>;\n};\n\n/**\n * @param func handler taking at most single parameter (event).\n */\nexport const withBatchedUpdates = <\n  TFunction extends ((event: any) => void) | (() => void),\n>(\n  func: Parameters<TFunction>[\"length\"] extends 0 | 1 ? TFunction : never,\n) =>\n  ((event) => {\n    unstable_batchedUpdates(func as TFunction, event);\n  }) as TFunction;\n\n//https://stackoverflow.com/a/9462382/8418\nexport const nFormatter = (num: number, digits: number): string => {\n  const si = [\n    { value: 1, symbol: \"b\" },\n    { value: 1e3, symbol: \"k\" },\n    { value: 1e6, symbol: \"M\" },\n    { value: 1e9, symbol: \"G\" },\n  ];\n  const rx = /\\.0+$|(\\.[0-9]*[1-9])0+$/;\n  let index;\n  for (index = si.length - 1; index > 0; index--) {\n    if (num >= si[index].value) {\n      break;\n    }\n  }\n  return (\n    (num / si[index].value).toFixed(digits).replace(rx, \"$1\") + si[index].symbol\n  );\n};\n\nexport const getVersion = () => {\n  return (\n    document.querySelector<HTMLMetaElement>('meta[name=\"version\"]')?.content ||\n    DEFAULT_VERSION\n  );\n};\n\n// Adapted from https://github.com/Modernizr/Modernizr/blob/master/feature-detects/emoji.js\nexport const supportsEmoji = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return false;\n  }\n  const offset = 12;\n  ctx.fillStyle = \"#f00\";\n  ctx.textBaseline = \"top\";\n  ctx.font = \"32px Arial\";\n  // Modernizr used , but it is sort of supported on Windows 7.\n  // Luckily  isn't supported.\n  ctx.fillText(\"\", 0, 0);\n  return ctx.getImageData(offset, offset, 1, 1).data[0] !== 0;\n};\n\nexport const getNearestScrollableContainer = (\n  element: HTMLElement,\n): HTMLElement | Document => {\n  let parent = element.parentElement;\n  while (parent) {\n    if (parent === document.body) {\n      return document;\n    }\n    const { overflowY } = window.getComputedStyle(parent);\n    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;\n    if (\n      hasScrollableContent &&\n      (overflowY === \"auto\" || overflowY === \"scroll\")\n    ) {\n      return parent;\n    }\n    parent = parent.parentElement;\n  }\n  return document;\n};\n\nexport const focusNearestParent = (element: HTMLInputElement) => {\n  let parent = element.parentElement;\n  while (parent) {\n    if (parent.tabIndex > -1) {\n      parent.focus();\n      return;\n    }\n    parent = parent.parentElement;\n  }\n};\n\nexport const preventUnload = (event: BeforeUnloadEvent) => {\n  event.preventDefault();\n  // NOTE: modern browsers no longer allow showing a custom message here\n  event.returnValue = \"\";\n};\n","import oc from \"open-color\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_TEXT_ALIGN,\n  EXPORT_SCALES,\n  THEME,\n} from \"./constants\";\nimport { t } from \"./i18n\";\nimport { AppState, NormalizedZoomValue } from \"./types\";\nimport { getDateTime } from \"./utils\";\n\nconst defaultExportScale = EXPORT_SCALES.includes(devicePixelRatio)\n  ? devicePixelRatio\n  : 1;\n\nexport const getDefaultAppState = (): Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n> => {\n  return {\n    theme: THEME.LIGHT,\n    collaborators: new Map(),\n    currentChartType: \"bar\",\n    currentItemBackgroundColor: \"transparent\",\n    currentItemEndArrowhead: \"arrow\",\n    currentItemFillStyle: \"hachure\",\n    currentItemFontFamily: DEFAULT_FONT_FAMILY,\n    currentItemFontSize: DEFAULT_FONT_SIZE,\n    currentItemLinearStrokeSharpness: \"round\",\n    currentItemOpacity: 100,\n    currentItemRoughness: 1,\n    currentItemStartArrowhead: null,\n    currentItemStrokeColor: oc.black,\n    currentItemStrokeSharpness: \"sharp\",\n    currentItemStrokeStyle: \"solid\",\n    currentItemStrokeWidth: 1,\n    currentItemTextAlign: DEFAULT_TEXT_ALIGN,\n    cursorButton: \"up\",\n    draggingElement: null,\n    editingElement: null,\n    editingGroupId: null,\n    editingLinearElement: null,\n    elementLocked: false,\n    elementType: \"selection\",\n    errorMessage: null,\n    exportBackground: true,\n    exportScale: defaultExportScale,\n    exportEmbedScene: false,\n    exportWithDarkMode: false,\n    fileHandle: null,\n    gridSize: null,\n    isBindingEnabled: true,\n    isLibraryOpen: false,\n    isLoading: false,\n    isResizing: false,\n    isRotating: false,\n    lastPointerDownWith: \"mouse\",\n    multiElement: null,\n    name: `${t(\"labels.untitled\")}-${getDateTime()}`,\n    openMenu: null,\n    openPopup: null,\n    pasteDialog: { shown: false, data: null },\n    previousSelectedElementIds: {},\n    resizingElement: null,\n    scrolledOutside: false,\n    scrollX: 0,\n    scrollY: 0,\n    selectedElementIds: {},\n    selectedGroupIds: {},\n    selectionElement: null,\n    shouldCacheIgnoreZoom: false,\n    showHelpDialog: false,\n    showStats: false,\n    startBoundElement: null,\n    suggestedBindings: [],\n    toastMessage: null,\n    viewBackgroundColor: oc.white,\n    zenModeEnabled: false,\n    zoom: { value: 1 as NormalizedZoomValue, translation: { x: 0, y: 0 } },\n    viewModeEnabled: false,\n    pendingImageElement: null,\n  };\n};\n\n/**\n * Config containing all AppState keys. Used to determine whether given state\n *  prop should be stripped when exporting to given storage type.\n */\nconst APP_STATE_STORAGE_CONF = (<\n  Values extends {\n    /** whether to keep when storing to browser storage (localStorage/IDB) */\n    browser: boolean;\n    /** whether to keep when exporting to file/database */\n    export: boolean;\n    /** server (shareLink/collab/...) */\n    server: boolean;\n  },\n  T extends Record<keyof AppState, Values>,\n>(config: { [K in keyof T]: K extends keyof AppState ? T[K] : never }) =>\n  config)({\n  theme: { browser: true, export: false, server: false },\n  collaborators: { browser: false, export: false, server: false },\n  currentChartType: { browser: true, export: false, server: false },\n  currentItemBackgroundColor: { browser: true, export: false, server: false },\n  currentItemEndArrowhead: { browser: true, export: false, server: false },\n  currentItemFillStyle: { browser: true, export: false, server: false },\n  currentItemFontFamily: { browser: true, export: false, server: false },\n  currentItemFontSize: { browser: true, export: false, server: false },\n  currentItemLinearStrokeSharpness: {\n    browser: true,\n    export: false,\n    server: false,\n  },\n  currentItemOpacity: { browser: true, export: false, server: false },\n  currentItemRoughness: { browser: true, export: false, server: false },\n  currentItemStartArrowhead: { browser: true, export: false, server: false },\n  currentItemStrokeColor: { browser: true, export: false, server: false },\n  currentItemStrokeSharpness: { browser: true, export: false, server: false },\n  currentItemStrokeStyle: { browser: true, export: false, server: false },\n  currentItemStrokeWidth: { browser: true, export: false, server: false },\n  currentItemTextAlign: { browser: true, export: false, server: false },\n  cursorButton: { browser: true, export: false, server: false },\n  draggingElement: { browser: false, export: false, server: false },\n  editingElement: { browser: false, export: false, server: false },\n  editingGroupId: { browser: true, export: false, server: false },\n  editingLinearElement: { browser: false, export: false, server: false },\n  elementLocked: { browser: true, export: false, server: false },\n  elementType: { browser: true, export: false, server: false },\n  errorMessage: { browser: false, export: false, server: false },\n  exportBackground: { browser: true, export: false, server: false },\n  exportEmbedScene: { browser: true, export: false, server: false },\n  exportScale: { browser: true, export: false, server: false },\n  exportWithDarkMode: { browser: true, export: false, server: false },\n  fileHandle: { browser: false, export: false, server: false },\n  gridSize: { browser: true, export: true, server: true },\n  height: { browser: false, export: false, server: false },\n  isBindingEnabled: { browser: false, export: false, server: false },\n  isLibraryOpen: { browser: false, export: false, server: false },\n  isLoading: { browser: false, export: false, server: false },\n  isResizing: { browser: false, export: false, server: false },\n  isRotating: { browser: false, export: false, server: false },\n  lastPointerDownWith: { browser: true, export: false, server: false },\n  multiElement: { browser: false, export: false, server: false },\n  name: { browser: true, export: false, server: false },\n  offsetLeft: { browser: false, export: false, server: false },\n  offsetTop: { browser: false, export: false, server: false },\n  openMenu: { browser: true, export: false, server: false },\n  openPopup: { browser: false, export: false, server: false },\n  pasteDialog: { browser: false, export: false, server: false },\n  previousSelectedElementIds: { browser: true, export: false, server: false },\n  resizingElement: { browser: false, export: false, server: false },\n  scrolledOutside: { browser: true, export: false, server: false },\n  scrollX: { browser: true, export: false, server: false },\n  scrollY: { browser: true, export: false, server: false },\n  selectedElementIds: { browser: true, export: false, server: false },\n  selectedGroupIds: { browser: true, export: false, server: false },\n  selectionElement: { browser: false, export: false, server: false },\n  shouldCacheIgnoreZoom: { browser: true, export: false, server: false },\n  showHelpDialog: { browser: false, export: false, server: false },\n  showStats: { browser: true, export: false, server: false },\n  startBoundElement: { browser: false, export: false, server: false },\n  suggestedBindings: { browser: false, export: false, server: false },\n  toastMessage: { browser: false, export: false, server: false },\n  viewBackgroundColor: { browser: true, export: true, server: true },\n  width: { browser: false, export: false, server: false },\n  zenModeEnabled: { browser: true, export: false, server: false },\n  zoom: { browser: true, export: false, server: false },\n  viewModeEnabled: { browser: false, export: false, server: false },\n  pendingImageElement: { browser: false, export: false, server: false },\n});\n\nconst _clearAppStateForStorage = <\n  ExportType extends \"export\" | \"browser\" | \"server\",\n>(\n  appState: Partial<AppState>,\n  exportType: ExportType,\n) => {\n  type ExportableKeys = {\n    [K in keyof typeof APP_STATE_STORAGE_CONF]: typeof APP_STATE_STORAGE_CONF[K][ExportType] extends true\n      ? K\n      : never;\n  }[keyof typeof APP_STATE_STORAGE_CONF];\n  const stateForExport = {} as { [K in ExportableKeys]?: typeof appState[K] };\n  for (const key of Object.keys(appState) as (keyof typeof appState)[]) {\n    const propConfig = APP_STATE_STORAGE_CONF[key];\n    if (propConfig?.[exportType]) {\n      const nextValue = appState[key];\n\n      // https://github.com/microsoft/TypeScript/issues/31445\n      (stateForExport as any)[key] = nextValue;\n    }\n  }\n  return stateForExport;\n};\n\nexport const clearAppStateForLocalStorage = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"browser\");\n};\n\nexport const cleanAppStateForExport = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"export\");\n};\n\nexport const clearAppStateForDatabase = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"server\");\n};\n","import { useCallback, useState } from \"react\";\n\nexport const useCallbackRefState = <T>() => {\n  const [refValue, setRefValue] = useState<T | null>(null);\n  const refCallback = useCallback((value: T | null) => setRefValue(value), []);\n  return [refValue, refCallback] as const;\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  ExcalidrawGenericElement,\n  ExcalidrawFreeDrawElement,\n  InitializedExcalidrawImageElement,\n  ExcalidrawImageElement,\n} from \"./types\";\n\nexport const isGenericElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawGenericElement => {\n  return (\n    element != null &&\n    (element.type === \"selection\" ||\n      element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\")\n  );\n};\n\nexport const isInitializedImageElement = (\n  element: ExcalidrawElement | null,\n): element is InitializedExcalidrawImageElement => {\n  return !!element && element.type === \"image\" && !!element.fileId;\n};\n\nexport const isImageElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawImageElement => {\n  return !!element && element.type === \"image\";\n};\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isFreeDrawElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawFreeDrawElement => {\n  return element != null && isFreeDrawElementType(element.type);\n};\n\nexport const isFreeDrawElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return elementType === \"freedraw\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isLinearElementType(element.type);\n};\n\nexport const isLinearElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return (\n    elementType === \"arrow\" || elementType === \"line\" // || elementType === \"freedraw\"\n  );\n};\n\nexport const isBindingElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isBindingElementType(element.type);\n};\n\nexport const isBindingElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return elementType === \"arrow\";\n};\n\nexport const isBindableElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      element.type === \"text\")\n  );\n};\n\nexport const isExcalidrawElement = (element: any): boolean => {\n  return (\n    element?.type === \"text\" ||\n    element?.type === \"diamond\" ||\n    element?.type === \"rectangle\" ||\n    element?.type === \"ellipse\" ||\n    element?.type === \"arrow\" ||\n    element?.type === \"freedraw\" ||\n    element?.type === \"line\"\n  );\n};\n","import { NormalizedZoomValue, Point, Zoom } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nimport { ExcalidrawLinearElement } from \"./element/types\";\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // =()cos()sin+\n  // =()sin+()cos+.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const rotatePoint = (\n  point: Point,\n  center: Point,\n  angle: number,\n): [number, number] => rotate(point[0], point[1], center[0], center[1], angle);\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\nexport const centerPoint = (a: Point, b: Point): Point => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = distance2d(first[0], first[1], last[0], last[1]);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nconst isPointWithinBounds = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\n// TODO: Rounding this point causes some shake when free drawing\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n","import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] => {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor =\n    prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map(\n    (prevPoint) =>\n      prevPoint.map((value, currentDimension) => {\n        if (currentDimension !== dimension) {\n          return value;\n        }\n        const scaledValue = value * dimensionScaleFactor;\n        nextMinDimension = Math.min(scaledValue, nextMinDimension);\n        return scaledValue;\n      }) as [number, number],\n  );\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n} from \"./types\";\nimport { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\n\n// x and y position of top left corner, x and y position of bottom right corner\nexport type Bounds = readonly [number, number, number, number];\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n): Bounds => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n};\n\nexport const pointRelativeTo = (\n  element: ExcalidrawElement,\n  absoluteCoords: Point,\n): Point => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = data as unknown as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          if (transformXY) {\n            [x, y] = transformXY(x, y);\n          }\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): [number, number, number, number] => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nconst getLinearElementAbsoluteCoords = (\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] => {\n  let coords: [number, number, number, number];\n\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    coords = [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else {\n    const shape = getShapeForElement(element) as Drawable[];\n\n    // first element is always the curve\n    const ops = getCurvePathOps(shape[0]);\n\n    const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n\n    coords = [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  return coords;\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data as unknown as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n    triangle: 15,\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  let length = 0;\n\n  if (arrowhead === \"arrow\") {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] = element.points[element.points.length - 1];\n    const [px, py] =\n      element.points.length > 1\n        ? element.points[element.points.length - 2]\n        : [0, 0];\n\n    length = Math.hypot(cx - px, cy - py);\n  } else {\n    // Length for other arrowhead types is based on the total length of the line\n    for (let i = 0; i < element.points.length; i++) {\n      const [px, py] = element.points[i - 1] || [0, 0];\n      const [cx, cy] = element.points[i];\n      length += Math.hypot(cx - px, cy - py);\n    }\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2) + element.strokeWidth;\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90,\n    triangle: 25,\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\n// We could cache this stuff\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  let bounds: [number, number, number, number];\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isFreeDrawElement(element)) {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n      element.points.map(([x, y]) =>\n        rotate(x, y, cx - element.x, cy - element.y, element.angle),\n      ),\n    );\n\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else if (isLinearElement(element)) {\n    bounds = getLinearElementRotatedBounds(element, cx, cy);\n  } else if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  } else if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n  } else {\n    const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  }\n\n  return bounds;\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n): [number, number, number, number] => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points),\n  );\n\n  let bounds: [number, number, number, number];\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve =\n      element.strokeSharpness === \"sharp\"\n        ? gen.linearPath(\n            points as [number, number][],\n            generateRoughOptions(element),\n          )\n        : gen.curve(\n            points as [number, number][],\n            generateRoughOptions(element),\n          );\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    sharpness === \"sharp\"\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  Arrowhead,\n  NonDeletedExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n} from \"../element/types\";\nimport {\n  isTextElement,\n  isLinearElement,\n  isFreeDrawElement,\n  isInitializedImageElement,\n} from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getArrowheadPoints,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport { distance, getFontString, getFontFamilyString, isRTL } from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { AppState, BinaryFiles, Zoom } from \"../types\";\nimport { getDefaultAppState } from \"../appState\";\nimport { MAX_DECIMALS_FOR_SVG_EXPORT, MIME_TYPES, SVG_NS } from \"../constants\";\nimport { getStroke, StrokeOptions } from \"perfect-freehand\";\n\nconst defaultAppState = getDefaultAppState();\n\nconst isPendingImageElement = (\n  element: ExcalidrawElement,\n  sceneState: SceneState,\n) =>\n  isInitializedImageElement(element) &&\n  !sceneState.imageCache.has(element.fileId);\n\nconst getDashArrayDashed = (strokeWidth: number) => [8, 8 + strokeWidth];\n\nconst getDashArrayDotted = (strokeWidth: number) => [1.5, 6 + strokeWidth];\n\nconst getCanvasPadding = (element: ExcalidrawElement) =>\n  element.type === \"freedraw\" ? element.strokeWidth * 12 : 20;\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  theme: SceneState[\"theme\"];\n  canvasZoom: Zoom[\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: Zoom,\n  sceneState: SceneState,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n  const padding = getCanvasPadding(element);\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n  }\n\n  context.save();\n  context.translate(padding * zoom.value, padding * zoom.value);\n  context.scale(\n    window.devicePixelRatio * zoom.value,\n    window.devicePixelRatio * zoom.value,\n  );\n\n  const rc = rough.canvas(canvas);\n\n  if (\n    sceneState.theme === \"dark\" &&\n    isInitializedImageElement(element) &&\n    !isPendingImageElement(element, sceneState) &&\n    sceneState.imageCache.get(element.fileId)?.mimeType !== MIME_TYPES.svg\n  ) {\n    // using a stronger invert (100% vs our regular 93%) and saturate\n    // as a temp hack to make images in dark theme look closer to original\n    // color scheme (it's still not quite there and the clors look slightly\n    // desaturing/black is not as black, but...)\n    context.filter = \"invert(100%) hue-rotate(180deg) saturate(1.25)\";\n  }\n\n  drawElementOnCanvas(element, rc, context, sceneState);\n  context.restore();\n\n  return {\n    element,\n    canvas,\n    theme: sceneState.theme,\n    canvasZoom: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n  };\n};\n\nconst IMAGE_PLACEHOLDER_IMG = document.createElement(\"img\");\nIMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"image\" class=\"svg-inline--fa fa-image fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"#888\" d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z\"></path></svg>`,\n)}`;\n\nconst IMAGE_ERROR_PLACEHOLDER_IMG = document.createElement(\"img\");\nIMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg viewBox=\"0 0 668 668\" xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2\"><path d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.81709 0 0 .81709 124.825 145.825)\"/><path d=\"M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.30366 0 0 .30366 506.822 60.065)\"/></svg>`,\n)}`;\n\nconst drawImagePlaceholder = (\n  element: ExcalidrawImageElement,\n  context: CanvasRenderingContext2D,\n  zoomValue: AppState[\"zoom\"][\"value\"],\n) => {\n  context.fillStyle = \"#E7E7E7\";\n  context.fillRect(0, 0, element.width, element.height);\n\n  const imageMinWidthOrHeight = Math.min(element.width, element.height);\n\n  const size = Math.min(\n    imageMinWidthOrHeight,\n    Math.min(imageMinWidthOrHeight * 0.4, 100),\n  );\n\n  context.drawImage(\n    element.status === \"error\"\n      ? IMAGE_ERROR_PLACEHOLDER_IMG\n      : IMAGE_PLACEHOLDER_IMG,\n    element.width / 2 - size / 2,\n    element.height / 2 - size / 2,\n    size,\n    size,\n  );\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    case \"freedraw\": {\n      // Draw directly to canvas\n      context.save();\n      context.fillStyle = element.strokeColor;\n\n      const path = getFreeDrawPath2D(element) as Path2D;\n\n      context.fillStyle = element.strokeColor;\n      context.fill(path);\n\n      context.restore();\n      break;\n    }\n    case \"image\": {\n      const img = isInitializedImageElement(element)\n        ? sceneState.imageCache.get(element.fileId)?.image\n        : undefined;\n      if (img != null && !(img instanceof Promise)) {\n        context.drawImage(\n          img,\n          0 /* hardcoded for the selection box*/,\n          0,\n          element.width,\n          element.height,\n        );\n      } else {\n        drawImagePlaceholder(element, context, sceneState.zoom.value);\n      }\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        context.save();\n        context.font = getFontString(element);\n        context.fillStyle = element.strokeColor;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            (index + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.restore();\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport const getShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.get(element);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (\n  element: ExcalidrawElement,\n  continuousPath = false,\n): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? getDashArrayDashed(element.strokeWidth)\n        : element.strokeStyle === \"dotted\"\n        ? getDashArrayDotted(element.strokeWidth)\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n    preserveVertices: continuousPath,\n    // disable decimals to fix Skia rendering issues #4046\n    fixedDecimalPlaceDigits: 0,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\": {\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"freedraw\":\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\n/**\n * Generates the element's shape and puts it into the cache.\n * @param element\n * @param generator\n */\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element) || null;\n\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        if (element.strokeSharpness === \"round\") {\n          const w = element.width;\n          const h = element.height;\n          const r = Math.min(w, h) * 0.25;\n          shape = generator.path(\n            `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n              h - r\n            } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n              h - r\n            } L 0 ${r} Q 0 0, ${r} 0`,\n            generateRoughOptions(element, true),\n          );\n        } else {\n          shape = generator.rectangle(\n            0,\n            0,\n            element.width,\n            element.height,\n            generateRoughOptions(element),\n          );\n        }\n        break;\n      case \"diamond\": {\n        const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n          getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        break;\n      case \"line\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (element.strokeSharpness === \"sharp\") {\n          if (options.fill) {\n            shape = [generator.polygon(points as [number, number][], options)];\n          } else {\n            shape = [\n              generator.linearPath(points as [number, number][], options),\n            ];\n          }\n        } else {\n          shape = [generator.curve(points as [number, number][], options)];\n        }\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n          const getArrowheadShapes = (\n            element: ExcalidrawLinearElement,\n            shape: Drawable[],\n            position: \"start\" | \"end\",\n            arrowhead: Arrowhead,\n          ) => {\n            const arrowheadPoints = getArrowheadPoints(\n              element,\n              shape,\n              position,\n              arrowhead,\n            );\n\n            if (arrowheadPoints === null) {\n              return [];\n            }\n\n            // Other arrowheads here...\n            if (arrowhead === \"dot\") {\n              const [x, y, r] = arrowheadPoints;\n\n              return [\n                generator.circle(x, y, r, {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\",\n                  stroke: \"none\",\n                }),\n              ];\n            }\n\n            if (arrowhead === \"triangle\") {\n              const [x, y, x2, y2, x3, y3] = arrowheadPoints;\n\n              // always use solid stroke for triangle arrowhead\n              delete options.strokeLineDash;\n\n              return [\n                generator.polygon(\n                  [\n                    [x, y],\n                    [x2, y2],\n                    [x3, y3],\n                    [x, y],\n                  ],\n                  {\n                    ...options,\n                    fill: element.strokeColor,\n                    fillStyle: \"solid\",\n                  },\n                ),\n              ];\n            }\n\n            // Arrow arrowheads\n            const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n            if (element.strokeStyle === \"dotted\") {\n              // for dotted arrows caps, reduce gap to make it more legible\n              const dash = getDashArrayDotted(element.strokeWidth - 1);\n              options.strokeLineDash = [dash[0], dash[1] - 1];\n            } else {\n              // for solid/dashed, keep solid arrow cap\n              delete options.strokeLineDash;\n            }\n            return [\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ];\n          };\n\n          if (startArrowhead !== null) {\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"start\",\n              startArrowhead,\n            );\n            shape.push(...shapes);\n          }\n\n          if (endArrowhead !== null) {\n            if (endArrowhead === undefined) {\n              // Hey, we have an old arrow here!\n            }\n\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"end\",\n              endArrowhead,\n            );\n            shape.push(...shapes);\n          }\n        }\n\n        break;\n      }\n      case \"freedraw\": {\n        generateFreeDrawShape(element);\n        shape = [];\n        break;\n      }\n      case \"text\":\n      case \"image\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  sceneState: SceneState,\n) => {\n  const zoom: Zoom = sceneState ? sceneState.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom.value &&\n    !sceneState?.shouldCacheIgnoreZoom;\n\n  if (\n    !prevElementWithCanvas ||\n    shouldRegenerateBecauseZoom ||\n    prevElementWithCanvas.theme !== sceneState.theme\n  ) {\n    const elementWithCanvas = generateElementCanvas(element, zoom, sceneState);\n\n    elementWithCanvasCache.set(element, elementWithCanvas);\n\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n  // Free draw elements will otherwise \"shuffle\" as the min x and y change\n  if (isFreeDrawElement(element)) {\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n  }\n\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n\n  const _isPendingImageElement = isPendingImageElement(element, sceneState);\n\n  const scaleXFactor =\n    \"scale\" in elementWithCanvas.element && !_isPendingImageElement\n      ? elementWithCanvas.element.scale[0]\n      : 1;\n  const scaleYFactor =\n    \"scale\" in elementWithCanvas.element && !_isPendingImageElement\n      ? elementWithCanvas.element.scale[1]\n      : 1;\n\n  context.save();\n  context.scale(\n    (1 / window.devicePixelRatio) * scaleXFactor,\n    (1 / window.devicePixelRatio) * scaleYFactor,\n  );\n  context.translate(cx * scaleXFactor, cy * scaleYFactor);\n  context.rotate(element.angle * scaleXFactor * scaleYFactor);\n\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      (padding * elementWithCanvas.canvasZoom) / elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      (padding * elementWithCanvas.canvasZoom) / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.restore();\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.save();\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.restore();\n      break;\n    }\n    case \"freedraw\": {\n      generateElementShape(element, generator);\n\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.save();\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context, sceneState);\n        context.restore();\n      }\n\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"image\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.save();\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context, sceneState);\n        context.restore();\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst roughSVGDrawWithPrecision = (\n  rsvg: RoughSVG,\n  drawable: Drawable,\n  precision?: number,\n) => {\n  if (typeof precision === \"undefined\") {\n    return rsvg.draw(drawable);\n  }\n  const pshape: Drawable = {\n    sets: drawable.sets,\n    shape: drawable.shape,\n    options: { ...drawable.options, fixedDecimalPlaceDigits: precision },\n  };\n  return rsvg.draw(pshape);\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  files: BinaryFiles,\n  offsetX?: number,\n  offsetY?: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = roughSVGDrawWithPrecision(\n        rsvg,\n        getShapeForElement(element) as Drawable,\n        MAX_DECIMALS_FOR_SVG_EXPORT,\n      );\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\"stroke-linecap\", \"round\");\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"arrow\": {\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      group.setAttribute(\"stroke-linecap\", \"round\");\n\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = roughSVGDrawWithPrecision(\n          rsvg,\n          shape,\n          MAX_DECIMALS_FOR_SVG_EXPORT,\n        );\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          element.type === \"line\" &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    case \"freedraw\": {\n      generateFreeDrawShape(element);\n      const opacity = element.opacity / 100;\n      const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      const path = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"path\");\n      node.setAttribute(\"stroke\", \"none\");\n      node.setAttribute(\"fill\", element.strokeColor);\n      path.setAttribute(\"d\", getFreeDrawSvgPath(element));\n      node.appendChild(path);\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"image\": {\n      const fileData =\n        isInitializedImageElement(element) && files[element.fileId];\n      if (fileData) {\n        const symbolId = `image-${fileData.id}`;\n        let symbol = svgRoot.querySelector(`#${symbolId}`);\n        if (!symbol) {\n          symbol = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"symbol\");\n          symbol.id = symbolId;\n\n          const image = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"image\");\n\n          image.setAttribute(\"width\", \"100%\");\n          image.setAttribute(\"height\", \"100%\");\n          image.setAttribute(\"href\", fileData.dataURL);\n\n          symbol.appendChild(image);\n\n          svgRoot.prepend(symbol);\n        }\n\n        const use = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"use\");\n        use.setAttribute(\"href\", `#${symbolId}`);\n\n        use.setAttribute(\"width\", `${Math.round(element.width)}`);\n        use.setAttribute(\"height\", `${Math.round(element.height)}`);\n\n        use.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n\n        svgRoot.appendChild(use);\n      }\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n\nexport const pathsCache = new WeakMap<ExcalidrawFreeDrawElement, Path2D>([]);\n\nexport function generateFreeDrawShape(element: ExcalidrawFreeDrawElement) {\n  const svgPathData = getFreeDrawSvgPath(element);\n  const path = new Path2D(svgPathData);\n  pathsCache.set(element, path);\n  return path;\n}\n\nexport function getFreeDrawPath2D(element: ExcalidrawFreeDrawElement) {\n  return pathsCache.get(element);\n}\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  // If input points are empty (should they ever be?) return a dot\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0.5]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options: StrokeOptions = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 4.25,\n    thinning: 0.6,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t) => Math.sin((t * Math.PI) / 2), // https://easings.net/#easeOutSine\n    last: !!element.lastCommittedPoint, // LastCommittedPoint is added on pointerup\n  };\n\n  return getSvgPathFromStroke(getStroke(inputPoints as number[][], options));\n}\n\nfunction med(A: number[], B: number[]) {\n  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];\n}\n\n// Trim SVG path data so number are each two decimal points. This\n// improves SVG exports, and prevents rendering errors on points\n// with long decimals.\nconst TO_FIXED_PRECISION = /(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g;\n\nfunction getSvgPathFromStroke(points: number[][]): string {\n  if (!points.length) {\n    return \"\";\n  }\n\n  const max = points.length - 1;\n\n  return points\n    .reduce(\n      (acc, point, i, arr) => {\n        if (i === max) {\n          acc.push(point, med(point, arr[0]), \"L\", arr[0], \"Z\");\n        } else {\n          acc.push(point, med(point, arr[i + 1]));\n        }\n        return acc;\n      },\n      [\"M\", points[0], \"Q\"],\n    )\n    .join(\" \")\n    .replace(TO_FIXED_PRECISION, \"$1\");\n}\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getNonDeletedElements, isNonDeletedElement } from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n\n  // TODO: getAllElementsIncludingDeleted\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  // TODO: getAllNonDeletedElements\n  getElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id: ExcalidrawElement[\"id\"]): ExcalidrawElement | null {\n    return this.elementsMap.get(id) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  // TODO: Rename methods here, this is confusing\n  getNonDeletedElements(\n    ids: readonly ExcalidrawElement[\"id\"][],\n  ): NonDeleted<ExcalidrawElement>[] {\n    const result: NonDeleted<ExcalidrawElement>[] = [];\n    ids.forEach((id) => {\n      const element = this.getNonDeletedElement(id);\n      if (element != null) {\n        result.push(element);\n      }\n    });\n    return result;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n}\n\nexport default Scene;\n","import { Random } from \"roughjs/bin/math\";\nimport { nanoid } from \"nanoid\";\n\nlet random = new Random(Date.now());\nlet testIdBase = 0;\n\nexport const randomInteger = () => Math.floor(random.next() * 2 ** 31);\n\nexport const reseed = (seed: number) => {\n  random = new Random(seed);\n  testIdBase = 0;\n};\n\nexport const randomId = () =>\n  process.env.NODE_ENV === \"test\" ? `id${testIdBase++}` : nanoid();\n","import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n  informMutation = true,\n): TElement => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points, fileId } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        // (except for specific keys we handle below)\n        (typeof value !== \"object\" ||\n          value === null ||\n          key === \"groupIds\" ||\n          key === \"scale\")\n      ) {\n        continue;\n      }\n\n      if (key === \"scale\") {\n        const prevScale = (element as any)[key];\n        const nextScale = value;\n        if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {\n          continue;\n        }\n      } else if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint: Point = prevPoints[index];\n            const nextPoint: Point = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n  if (!didChange) {\n    return element;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof fileId != \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n\n  if (informMutation) {\n    Scene.getScene(element)?.informMutation();\n  }\n\n  return element;\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        (typeof value !== \"object\" || value === null)\n      ) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return element;\n  }\n\n  return {\n    ...element,\n    ...updates,\n    version: element.version + 1,\n    versionNonce: randomInteger(),\n  };\n};\n\n/**\n * Mutates element and updates `version` & `versionNonce`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = (\n  element: Mutable<ExcalidrawElement>,\n  version?: ExcalidrawElement[\"version\"],\n) => {\n  element.version = (version ?? element.version) + 1;\n  element.versionNonce = randomInteger();\n  return element;\n};\n","import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"freedraw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n","import { GroupId, ExcalidrawElement, NonDeleted } from \"./element/types\";\nimport { AppState } from \"./types\";\nimport { getSelectedElements } from \"./scene\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  const elementsInGroup = elements.filter((element) =>\n    element.groupIds.includes(groupId),\n  );\n\n  if (elementsInGroup.length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        ...appState,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    ...appState,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...Object.fromEntries(\n        elementsInGroup.map((element) => [element.id, true]),\n      ),\n    },\n  };\n};\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (appState: AppState): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\nexport const selectGroupsForSelectedElements = (\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  let nextAppState: AppState = { ...appState, selectedGroupIds: {} };\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  if (!selectedElements.length) {\n    return { ...nextAppState, editingGroupId: null };\n  }\n\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  return nextAppState;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: readonly ExcalidrawElement[],\n  groupId: string,\n) => elements.filter((element) => isElementInGroup(element, groupId));\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n","import {\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  GroupId,\n  VerticalAlign,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  FontFamilyValues,\n} from \"../element/types\";\nimport { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"boundElementIds\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    strokeSharpness,\n    boundElementIds = null,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => ({\n  id: rest.id || randomId(),\n  type,\n  x,\n  y,\n  width,\n  height,\n  angle,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  groupIds,\n  strokeSharpness,\n  seed: rest.seed ?? randomInteger(),\n  version: rest.version || 1,\n  versionNonce: rest.versionNonce ?? 0,\n  isDeleted: false as false,\n  boundElementIds,\n});\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize: number;\n    fontFamily: FontFamilyValues;\n    textAlign: TextAlign;\n    verticalAlign: VerticalAlign;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text: opts.text,\n      fontSize: opts.fontSize,\n      fontFamily: opts.fontFamily,\n      textAlign: opts.textAlign,\n      verticalAlign: opts.verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n    },\n    {},\n  );\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element));\n  const { textAlign, verticalAlign } = element;\n\n  let x: number;\n  let y: number;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline,\n  };\n};\n\nexport const updateTextElement = (\n  element: ExcalidrawTextElement,\n  { text, isDeleted }: { text: string; isDeleted?: boolean },\n): ExcalidrawTextElement => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted ?? element.isDeleted,\n    ...getAdjustedDimensions(element, text),\n  });\n};\n\nexport const newFreeDrawElement = (\n  opts: {\n    type: \"freedraw\";\n    points?: ExcalidrawFreeDrawElement[\"points\"];\n    simulatePressure: boolean;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFreeDrawElement> => {\n  return {\n    ..._newElementBase<ExcalidrawFreeDrawElement>(opts.type, opts),\n    points: opts.points || [],\n    pressures: [],\n    simulatePressure: opts.simulatePressure,\n    lastCommittedPoint: null,\n  };\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points?: ExcalidrawLinearElement[\"points\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead,\n  };\n};\n\nexport const newImageElement = (\n  opts: {\n    type: ExcalidrawImageElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawImageElement> => {\n  return {\n    ..._newElementBase<ExcalidrawImageElement>(\"image\", opts),\n    // in the future we'll support changing stroke color for some SVG elements,\n    // and `transparent` will likely mean \"use original colors of the image\"\n    strokeColor: \"transparent\",\n    status: \"pending\",\n    fileId: null,\n    scale: [1, 1],\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement only\n// (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\nexport const deepCopyElement = (val: any, depth: number = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): TElement => {\n  let copy: TElement = deepCopyElement(element);\n  if (process.env.NODE_ENV === \"test\") {\n    copy.id = `${copy.id}_copy`;\n    // `window.h` may not be defined in some unit tests\n    if (\n      window.h?.app\n        ?.getSceneElementsIncludingDeleted()\n        .find((el) => el.id === copy.id)\n    ) {\n      copy.id += \"_copy\";\n    }\n  } else {\n    copy.id = randomId();\n  }\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n","import { ExcalidrawElement, PointerType } from \"./types\";\n\nimport { getElementAbsoluteCoords, Bounds } from \"./bounds\";\nimport { rotate } from \"../math\";\nimport { Zoom } from \"../types\";\n\nexport type TransformHandleDirection =\n  | \"n\"\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"nw\"\n  | \"ne\"\n  | \"sw\"\n  | \"se\";\n\nexport type TransformHandleType = TransformHandleDirection | \"rotation\";\n\nexport type TransformHandle = [number, number, number, number];\nexport type TransformHandles = Partial<{\n  [T in TransformHandleType]: TransformHandle;\n}>;\nexport type MaybeTransformHandleType = TransformHandleType | false;\n\nconst transformHandleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  ne: true,\n  sw: true,\n};\n\nconst generateTransformHandle = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n): TransformHandle => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const getTransformHandlesFromCoords = (\n  [x1, y1, x2, y2]: Bounds,\n  angle: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  omitSides: { [T in TransformHandleType]?: boolean } = {},\n): TransformHandles => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  const dashedLineMargin = 4 / zoom.value;\n\n  const centeringOffset = (size - 8) / (2 * zoom.value);\n\n  const transformHandles: TransformHandles = {\n    nw: omitSides.nw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides.ne\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides.sw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides.se\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides.rotation\n      ? undefined\n      : generateTransformHandle(\n          x1 + width / 2 - handleWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handleMarginY +\n            centeringOffset -\n            ROTATION_RESIZE_HANDLE_GAP / zoom.value,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles =\n    (5 * transformHandleSizes.mouse) / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y1 - dashedLineMargin - handleMarginY + centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(\n        x1 - dashedLineMargin - handleMarginX + centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return transformHandles;\n};\n\nexport const getTransformHandles = (\n  element: ExcalidrawElement,\n  zoom: Zoom,\n  pointerType: PointerType = \"mouse\",\n): TransformHandles => {\n  let omitSides: { [T in TransformHandleType]?: boolean } = {};\n  if (\n    element.type === \"arrow\" ||\n    element.type === \"line\" ||\n    element.type === \"freedraw\"\n  ) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (element.type === \"text\") {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  }\n\n  return getTransformHandlesFromCoords(\n    getElementAbsoluteCoords(element),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n  );\n};\n","/**\n * This is a 2D Projective Geometric Algebra implementation.\n *\n * For wider context on geometric algebra visit see https://bivector.net.\n *\n * For this specific algebra see cheatsheet https://bivector.net/2DPGA.pdf.\n *\n * Converted from generator written by enki, with a ton of added on top.\n *\n * This library uses 8-vectors to represent points, directions and lines\n * in 2D space.\n *\n * An array `[a, b, c, d, e, f, g, h]` represents a n(8)vector:\n *   a + b*e0 + c*e1 + d*e2 + e*e01 + f*e20 + g*e12 + h*e012\n *\n * See GAPoint, GALine, GADirection and GATransform modules for common\n * operations.\n */\n\nexport type Point = NVector;\nexport type Direction = NVector;\nexport type Line = NVector;\nexport type Transform = NVector;\n\nexport const point = (x: number, y: number): Point => [0, 0, 0, 0, y, x, 1, 0];\n\nexport const origin = (): Point => [0, 0, 0, 0, 0, 0, 1, 0];\n\nexport const direction = (x: number, y: number): Direction => {\n  const norm = Math.hypot(x, y); // same as `inorm(direction(x, y))`\n  return [0, 0, 0, 0, y / norm, x / norm, 0, 0];\n};\n\nexport const offset = (x: number, y: number): Direction => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  0,\n  0,\n];\n\n/// This is the \"implementation\" part of the library\n\ntype NVector = readonly [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n];\n\n// These are labels for what each number in an nvector represents\nconst NVECTOR_BASE = [\"1\", \"e0\", \"e1\", \"e2\", \"e01\", \"e20\", \"e12\", \"e012\"];\n\n// Used to represent points, lines and transformations\nexport const nvector = (value: number = 0, index: number = 0): NVector => {\n  const result = [0, 0, 0, 0, 0, 0, 0, 0];\n  if (index < 0 || index > 7) {\n    throw new Error(`Expected \\`index\\` betwen 0 and 7, got \\`${index}\\``);\n  }\n  if (value !== 0) {\n    result[index] = value;\n  }\n  return result as unknown as NVector;\n};\n\nconst STRING_EPSILON = 0.000001;\nexport const toString = (nvector: NVector): string => {\n  const result = nvector\n    .map((value, index) =>\n      Math.abs(value) > STRING_EPSILON\n        ? value.toFixed(7).replace(/(\\.|0+)$/, \"\") +\n          (index > 0 ? NVECTOR_BASE[index] : \"\")\n        : null,\n    )\n    .filter((representation) => representation != null)\n    .join(\" + \");\n  return result === \"\" ? \"0\" : result;\n};\n\n// Reverse the order of the basis blades.\nexport const reverse = (nvector: NVector): NVector => [\n  nvector[0],\n  nvector[1],\n  nvector[2],\n  nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  -nvector[7],\n];\n\n// Poincare duality operator.\nexport const dual = (nvector: NVector): NVector => [\n  nvector[7],\n  nvector[6],\n  nvector[5],\n  nvector[4],\n  nvector[3],\n  nvector[2],\n  nvector[1],\n  nvector[0],\n];\n\n// Clifford Conjugation\nexport const conjugate = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  nvector[7],\n];\n\n// Main involution\nexport const involute = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  nvector[4],\n  nvector[5],\n  nvector[6],\n  -nvector[7],\n];\n\n// Multivector addition\nexport const add = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] + b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] + b[0],\n    a[1] + b[1],\n    a[2] + b[2],\n    a[3] + b[3],\n    a[4] + b[4],\n    a[5] + b[5],\n    a[6] + b[6],\n    a[7] + b[7],\n  ];\n};\n\n// Multivector subtraction\nexport const sub = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] - b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] - b[0],\n    a[1] - b[1],\n    a[2] - b[2],\n    a[3] - b[3],\n    a[4] - b[4],\n    a[5] - b[5],\n    a[6] - b[6],\n    a[7] - b[7],\n  ];\n};\n\n// The geometric product.\nexport const mul = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [\n      a[0] * b,\n      a[1] * b,\n      a[2] * b,\n      a[3] * b,\n      a[4] * b,\n      a[5] * b,\n      a[6] * b,\n      a[7] * b,\n    ];\n  }\n  return [\n    mulScalar(a, b),\n    b[1] * a[0] +\n      b[0] * a[1] -\n      b[4] * a[2] +\n      b[5] * a[3] +\n      b[2] * a[4] -\n      b[3] * a[5] -\n      b[7] * a[6] -\n      b[6] * a[7],\n    b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n    b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n    b[4] * a[0] +\n      b[2] * a[1] -\n      b[1] * a[2] +\n      b[7] * a[3] +\n      b[0] * a[4] +\n      b[6] * a[5] -\n      b[5] * a[6] +\n      b[3] * a[7],\n    b[5] * a[0] -\n      b[3] * a[1] +\n      b[7] * a[2] +\n      b[1] * a[3] -\n      b[6] * a[4] +\n      b[0] * a[5] +\n      b[4] * a[6] +\n      b[2] * a[7],\n    b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n    b[7] * a[0] +\n      b[6] * a[1] +\n      b[5] * a[2] +\n      b[4] * a[3] +\n      b[3] * a[4] +\n      b[2] * a[5] +\n      b[1] * a[6] +\n      b[0] * a[7],\n  ];\n};\n\nexport const mulScalar = (a: NVector, b: NVector): number =>\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6];\n\n// The outer/exterior/wedge product.\nexport const meet = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0],\n  b[1] * a[0] + b[0] * a[1],\n  b[2] * a[0] + b[0] * a[2],\n  b[3] * a[0] + b[0] * a[3],\n  b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[0] * a[4],\n  b[5] * a[0] - b[3] * a[1] + b[1] * a[3] + b[0] * a[5],\n  b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n  b[7] * a[0] +\n    b[6] * a[1] +\n    b[5] * a[2] +\n    b[4] * a[3] +\n    b[3] * a[4] +\n    b[2] * a[5] +\n    b[1] * a[6],\n];\n\n// The regressive product.\nexport const join = (a: NVector, b: NVector): NVector => [\n  joinScalar(a, b),\n  a[1] * b[7] + a[4] * b[5] - a[5] * b[4] + a[7] * b[1],\n  a[2] * b[7] - a[4] * b[6] + a[6] * b[4] + a[7] * b[2],\n  a[3] * b[7] + a[5] * b[6] - a[6] * b[5] + a[7] * b[3],\n  a[4] * b[7] + a[7] * b[4],\n  a[5] * b[7] + a[7] * b[5],\n  a[6] * b[7] + a[7] * b[6],\n  a[7] * b[7],\n];\n\nexport const joinScalar = (a: NVector, b: NVector): number =>\n  a[0] * b[7] +\n  a[1] * b[6] +\n  a[2] * b[5] +\n  a[3] * b[4] +\n  a[4] * b[3] +\n  a[5] * b[2] +\n  a[6] * b[1] +\n  a[7] * b[0];\n\n// The inner product.\nexport const dot = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6],\n  b[1] * a[0] +\n    b[0] * a[1] -\n    b[4] * a[2] +\n    b[5] * a[3] +\n    b[2] * a[4] -\n    b[3] * a[5] -\n    b[7] * a[6] -\n    b[6] * a[7],\n  b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n  b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n  b[4] * a[0] + b[7] * a[3] + b[0] * a[4] + b[3] * a[7],\n  b[5] * a[0] + b[7] * a[2] + b[0] * a[5] + b[2] * a[7],\n  b[6] * a[0] + b[0] * a[6],\n  b[7] * a[0] + b[0] * a[7],\n];\n\nexport const norm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[0] * a[0] - a[2] * a[2] - a[3] * a[3] + a[6] * a[6]));\n\nexport const inorm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[7] * a[7] - a[5] * a[5] - a[4] * a[4] + a[1] * a[1]));\n\nexport const normalized = (a: NVector): NVector => {\n  const n = norm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  const sign = a[6] < 0 ? -1 : 1;\n  return mul(a, sign / n);\n};\n\nexport const inormalized = (a: NVector): NVector => {\n  const n = inorm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  return mul(a, 1 / n);\n};\n\nconst isNumber = (a: any): a is number => typeof a === \"number\";\n\nexport const E0: NVector = nvector(1, 1);\nexport const E1: NVector = nvector(1, 2);\nexport const E2: NVector = nvector(1, 3);\nexport const E01: NVector = nvector(1, 4);\nexport const E20: NVector = nvector(1, 5);\nexport const E12: NVector = nvector(1, 6);\nexport const E012: NVector = nvector(1, 7);\nexport const I = E012;\n","import * as GA from \"./ga\";\nimport { Line, Point } from \"./ga\";\n\n/**\n * A line is stored as an array `[0, c, a, b, 0, 0, 0, 0]` representing:\n *   c * e0 + a * e1 + b*e2\n *\n * This maps to a standard formula `a * x + b * y + c`.\n *\n * `(-b, a)` correponds to a 2D vector parallel to the line. The lines\n * have a natural orientation, corresponding to that vector.\n *\n * The magnitude (\"norm\") of the line is `sqrt(a ^ 2 + b ^ 2)`.\n * `c / norm(line)` is the oriented distance from line to origin.\n */\n\n// Returns line with direction (x, y) through origin\nexport const vector = (x: number, y: number): Line =>\n  GA.normalized([0, 0, -y, x, 0, 0, 0, 0]);\n\n// For equation ax + by + c = 0.\nexport const equation = (a: number, b: number, c: number): Line =>\n  GA.normalized([0, c, a, b, 0, 0, 0, 0]);\n\nexport const through = (from: Point, to: Point): Line =>\n  GA.normalized(GA.join(to, from));\n\nexport const orthogonal = (line: Line, point: Point): Line =>\n  GA.dot(line, point);\n\n// Returns a line perpendicular to the line through `against` and `intersection`\n// going through `intersection`.\nexport const orthogonalThrough = (against: Point, intersection: Point): Line =>\n  orthogonal(through(against, intersection), intersection);\n\nexport const parallel = (line: Line, distance: number): Line => {\n  const result = line.slice();\n  result[1] -= distance;\n  return result as unknown as Line;\n};\n\nexport const parallelThrough = (line: Line, point: Point): Line =>\n  orthogonal(orthogonal(point, line), point);\n\nexport const distance = (line1: Line, line2: Line): number =>\n  GA.inorm(GA.meet(line1, line2));\n\nexport const angle = (line1: Line, line2: Line): number =>\n  Math.acos(GA.dot(line1, line2)[0]);\n\n// The orientation of the line\nexport const sign = (line: Line): number => Math.sign(line[1]);\n","import * as GA from \"./ga\";\nimport * as GALine from \"./galines\";\nimport { Point, Line, join } from \"./ga\";\n\nexport const from = ([x, y]: readonly [number, number]): Point => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  1,\n  0,\n];\n\nexport const toTuple = (point: Point): [number, number] => [point[5], point[4]];\n\nexport const abs = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  Math.abs(point[4]),\n  Math.abs(point[5]),\n  1,\n  0,\n];\n\nexport const intersect = (line1: Line, line2: Line): Point =>\n  GA.normalized(GA.meet(line1, line2));\n\n// Projects `point` onto the `line`.\n// The returned point is the closest point on the `line` to the `point`.\nexport const project = (point: Point, line: Line): Point =>\n  intersect(GALine.orthogonal(line, point), line);\n\nexport const distance = (point1: Point, point2: Point): number =>\n  GA.norm(join(point1, point2));\n\nexport const distanceToLine = (point: Point, line: Line): number =>\n  GA.joinScalar(point, line);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point } from \"./ga\";\n\n/**\n * A direction is stored as an array `[0, 0, 0, 0, y, x, 0, 0]` representing\n * vector `(x, y)`.\n */\n\nexport const from = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  point[4],\n  point[5],\n  0,\n  0,\n];\n\nexport const fromTo = (from: Point, to: Point): Direction =>\n  GA.inormalized([0, 0, 0, 0, to[4] - from[4], to[5] - from[5], 0, 0]);\n\nexport const orthogonal = (direction: Direction): Direction =>\n  GA.inormalized([0, 0, 0, 0, -direction[5], direction[4], 0, 0]);\n\nexport const orthogonalToLine = (line: Line): Direction => GA.mul(line, GA.I);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point, Transform } from \"./ga\";\nimport * as GADirection from \"./gadirections\";\n\n/**\n * TODO: docs\n */\n\nexport const rotation = (pivot: Point, angle: number): Transform =>\n  GA.add(GA.mul(pivot, Math.sin(angle / 2)), Math.cos(angle / 2));\n\nexport const translation = (direction: Direction): Transform => [\n  1,\n  0,\n  0,\n  0,\n  -(0.5 * direction[5]),\n  0.5 * direction[4],\n  0,\n  0,\n];\n\nexport const translationOrthogonal = (\n  direction: Direction,\n  distance: number,\n): Transform => {\n  const scale = 0.5 * distance;\n  return [1, 0, 0, 0, scale * direction[4], scale * direction[5], 0, 0];\n};\n\nexport const translationAlong = (line: Line, distance: number): Transform =>\n  GA.add(GA.mul(GADirection.orthogonalToLine(line), 0.5 * distance), 1);\n\nexport const compose = (motor1: Transform, motor2: Transform): Transform =>\n  GA.mul(motor2, motor1);\n\nexport const apply = (\n  motor: Transform,\n  nvector: Point | Direction | Line,\n): Point | Direction | Line =>\n  GA.normalized(GA.mul(GA.mul(motor, nvector), GA.reverse(motor)));\n","import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\n\nimport {\n  distance2d,\n  rotatePoint,\n  isPathALoop,\n  isPointInPolygon,\n  rotate,\n} from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport {\n  NonDeletedExcalidrawElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawTextElement,\n  ExcalidrawEllipseElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n} from \"./types\";\n\nimport { getElementAbsoluteCoords, getCurvePathOps, Bounds } from \"./bounds\";\nimport { Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { isImageElement } from \"./typeChecks\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  if (element.type === \"freedraw\") {\n    return true;\n  }\n\n  const isDraggableFromInside = element.backgroundColor !== \"transparent\";\n\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n  return isDraggableFromInside || isImageElement(element);\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point: Point = [x, y];\n\n  if (isElementSelected(appState, element)) {\n    return isPointHittingElementBoundingBox(element, point, threshold);\n  }\n\n  return isHittingElementNotConsideringBoundingBox(element, appState, point);\n};\n\nexport const isHittingElementBoundingBoxWithoutHittingElement = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  return (\n    !isHittingElementNotConsideringBoundingBox(element, appState, [x, y]) &&\n    isPointHittingElementBoundingBox(element, [x, y], threshold)\n  );\n};\n\nconst isHittingElementNotConsideringBoundingBox = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  point: Point,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  const check =\n    element.type === \"text\"\n      ? isStrictlyInside\n      : isElementDraggableFromInside(element)\n      ? isInsideCheck\n      : isNearCheck;\n\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nconst isElementSelected = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n) => appState.selectedElementIds[element.id];\n\nconst isPointHittingElementBoundingBox = (\n  element: NonDeleted<ExcalidrawElement>,\n  [x, y]: Point,\n  threshold: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(\n    x,\n    y,\n    elementCenterX,\n    elementCenterY,\n    -element.angle,\n  );\n\n  return (\n    rotatedX > x1 - threshold &&\n    rotatedX < x2 + threshold &&\n    rotatedY > y1 - threshold &&\n    rotatedY < y2 + threshold\n  );\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n): boolean => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point: Point = [x, y];\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n): number => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\ntype HitTestArgs = {\n  element: NonDeletedExcalidrawElement;\n  point: Point;\n  threshold: number;\n  check: (distance: number, threshold: number) => boolean;\n};\n\nconst hitTestPointAgainstElement = (args: HitTestArgs): boolean => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"freedraw\": {\n      if (\n        !args.check(\n          distanceToRectangle(args.element, args.point),\n          args.threshold,\n        )\n      ) {\n        return false;\n      }\n\n      return hitTestFreeDrawElement(args.element, args.point, args.threshold);\n    }\n    case \"arrow\":\n    case \"line\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\n        \"This should not happen, we need to investigate why it does.\",\n      );\n      return false;\n  }\n};\n\nexport const distanceToBindableElement = (\n  element: ExcalidrawBindableElement,\n  point: Point,\n): number => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance: number, threshold: number): boolean => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance: number, threshold: number): boolean => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance: number, threshold: number): boolean => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance: number, threshold: number): boolean => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawTextElement\n    | ExcalidrawFreeDrawElement\n    | ExcalidrawImageElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToDiamond = (\n  element: ExcalidrawDiamondElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): number => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): [GA.Point, GA.Line] => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach((_) => {\n    const xx = a * tx;\n    const yy = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = xx - ex;\n    const ry = yy - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n\n  const closestPoint = GA.point(a * tx, b * ty);\n\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestFreeDrawElement = (\n  element: ExcalidrawFreeDrawElement,\n  point: Point,\n  threshold: number,\n): boolean => {\n  // Check point-distance-to-line-segment for every segment in the\n  // element's points (its input points, not its outline points).\n  // This is... okay? It's plenty fast, but the GA library may\n  // have a faster option.\n\n  let x: number;\n  let y: number;\n\n  if (element.angle === 0) {\n    x = point[0] - element.x;\n    y = point[1] - element.y;\n  } else {\n    // Counter-rotate the point around center before testing\n    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(element);\n    const rotatedPoint = rotatePoint(\n      point,\n      [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2],\n      -element.angle,\n    );\n    x = rotatedPoint[0] - element.x;\n    y = rotatedPoint[1] - element.y;\n  }\n\n  let [A, B] = element.points;\n  let P: readonly [number, number];\n\n  // For freedraw dots\n  if (\n    distance2d(A[0], A[1], x, y) < threshold ||\n    distance2d(B[0], B[1], x, y) < threshold\n  ) {\n    return true;\n  }\n\n  // For freedraw lines\n  for (let i = 0; i < element.points.length; i++) {\n    const delta = [B[0] - A[0], B[1] - A[1]];\n    const length = Math.hypot(delta[1], delta[0]);\n\n    const U = [delta[0] / length, delta[1] / length];\n    const C = [x - A[0], y - A[1]];\n    const d = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);\n    P = [A[0] + U[0] * d, A[1] + U[1] * d];\n\n    const da = distance2d(P[0], P[1], A[0], A[1]);\n    const db = distance2d(P[0], P[1], B[0], B[1]);\n\n    P = db < da && da > length ? B : da < db && db > length ? A : P;\n\n    if (Math.hypot(y - P[1], x - P[0]) < threshold) {\n      return true;\n    }\n\n    A = B;\n    B = element.points[i + 1];\n  }\n\n  return false;\n};\n\nconst hitTestLinear = (args: HitTestArgs): boolean => {\n  const { element, threshold } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(\n    args.element,\n    args.point,\n  );\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) ||\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)\n  ) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some((subshape) =>\n      hitTestCurveInside(subshape, relX, relY, element.strokeSharpness),\n    );\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some((subshape) =>\n    hitTestRoughShape(subshape, relX, relY, threshold),\n  );\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (\n  element: ExcalidrawElement,\n  pointTuple: Point,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const [ax, ay, bx, by] = elementCoords;\n  const halfWidth = (bx - ax) / 2;\n  const halfHeight = (by - ay) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (\n  element: ExcalidrawElement,\n  // Point relative to the element position\n  point: Point,\n): Point => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = (\n  element: ExcalidrawElement,\n): GA.Transform => {\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(\n    GATransform.translation(GADirection.from(center)),\n  );\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = ([ax, ay, bx, by]: Bounds): GA.Point => {\n  return GA.point((ax + bx) / 2, (ay + by) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: Point,\n): number => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\n\nexport const determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjecentPoint: Point,\n): Point => {\n  if (focus === 0) {\n    const elementCoords = getElementAbsoluteCoords(element);\n    const center = coordsCenter(elementCoords);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(\n    relateToCenter,\n    GAPoint.from(adjecentPoint),\n  );\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates\n  b: Point,\n  // If given, the element is inflated by this value\n  gap: number = 0,\n): Point[] => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(\n    element,\n    line,\n    aRel,\n    gap,\n  );\n  return intersections.map((point) =>\n    GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)),\n  );\n};\n\nconst getSortedElementLineIntersections = (\n  element: ExcalidrawBindableElement,\n  // Relative to element center\n  line: GA.Line,\n  // Relative to element center\n  nearPoint: GA.Point,\n  gap: number = 0,\n): GA.Point[] => {\n  let intersections: GA.Point[];\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"diamond\":\n      const corners = getCorners(element);\n      intersections = corners\n        .flatMap((point, i) => {\n          const edge: [GA.Point, GA.Point] = [point, corners[(i + 1) % 4]];\n          return intersectSegment(line, offsetSegment(edge, gap));\n        })\n        .concat(\n          corners.flatMap((point) => getCircleIntersections(point, gap, line)),\n        );\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort(\n    (i1, i2) =>\n      GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint),\n  );\n  return [\n    sortedIntersections[0],\n    sortedIntersections[sortedIntersections.length - 1],\n  ];\n};\n\nconst getCorners = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawImageElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  scale: number = 1,\n): GA.Point[] => {\n  const hx = (scale * element.width) / 2;\n  const hy = (scale * element.height) / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n      return [\n        GA.point(hx, hy),\n        GA.point(hx, -hy),\n        GA.point(-hx, -hy),\n        GA.point(-hx, hy),\n      ];\n    case \"diamond\":\n      return [\n        GA.point(0, hy),\n        GA.point(hx, 0),\n        GA.point(0, -hy),\n        GA.point(-hx, 0),\n      ];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection conincides with second segment point returns empty array.\nconst intersectSegment = (\n  line: GA.Line,\n  segment: [GA.Point, GA.Point],\n): GA.Point[] => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (\n  segment: [GA.Point, GA.Point],\n  distance: number,\n): [GA.Point, GA.Point] => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(\n    GADirection.fromTo(a, b),\n    distance,\n  );\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (\n  element: ExcalidrawEllipseElement,\n  gap: number,\n  line: GA.Line,\n): GA.Point[] => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [\n    GA.point(\n      (xn + a * b * n * discrRoot) / squares,\n      (yn - a * b * m * discrRoot) / squares,\n    ),\n    GA.point(\n      (xn - a * b * n * discrRoot) / squares,\n      (yn + a * b * m * discrRoot) / squares,\n    ),\n  ];\n};\n\nexport const getCircleIntersections = (\n  center: GA.Point,\n  radius: number,\n  line: GA.Line,\n): GA.Point[] => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n\n  return [\n    GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),\n    GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares),\n  ];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n  // Between -1 and 1 (not 0) the relative size of the \"focus image\" of\n  // the element on which the focus point lies\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the ellipse center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = (ellipse.width * relativeDistanceAbs) / 2;\n  const b = (ellipse.height * relativeDistanceAbs) / 2;\n\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m =\n    (-px * b ** 2 +\n      orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) /\n    squares;\n\n  const n = (-m * px - 1) / py;\n\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\n\nexport const findFocusPointForRectangulars = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawImageElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  // Between -1 and 1 for how far away should the focus point be relative\n  // to the size of the element. Sign determines orientation.\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the element center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n\n  let maxDistance = 0;\n  let tangentPoint: null | GA.Point = null;\n  corners.forEach((corner) => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint!;\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Point[] = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (sharpness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points as any, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data as unknown as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n","import {\n  ExcalidrawElement,\n  PointerType,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\nimport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  TransformHandleType,\n  TransformHandle,\n  MaybeTransformHandleType,\n} from \"./transformHandles\";\nimport { AppState, Zoom } from \"../types\";\n\nconst isInsideTransformHandle = (\n  transformHandle: TransformHandle,\n  x: number,\n  y: number,\n) =>\n  x >= transformHandle[0] &&\n  x <= transformHandle[0] + transformHandle[2] &&\n  y >= transformHandle[1] &&\n  y <= transformHandle[1] + transformHandle[3];\n\nexport const resizeTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n): MaybeTransformHandleType => {\n  if (!appState.selectedElementIds[element.id]) {\n    return false;\n  }\n\n  const { rotation: rotationTransformHandle, ...transformHandles } =\n    getTransformHandles(element, zoom, pointerType);\n\n  if (\n    rotationTransformHandle &&\n    isInsideTransformHandle(rotationTransformHandle, x, y)\n  ) {\n    return \"rotation\" as TransformHandleType;\n  }\n\n  const filter = Object.keys(transformHandles).filter((key) => {\n    const transformHandle =\n      transformHandles[key as Exclude<TransformHandleType, \"rotation\">]!;\n    if (!transformHandle) {\n      return false;\n    }\n    return isInsideTransformHandle(transformHandle, x, y);\n  });\n\n  if (filter.length > 0) {\n    return filter[0] as TransformHandleType;\n  }\n\n  return false;\n};\n\nexport const getElementWithTransformHandleType = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n) => {\n  return elements.reduce((result, element) => {\n    if (result) {\n      return result;\n    }\n    const transformHandleType = resizeTest(\n      element,\n      appState,\n      scenePointerX,\n      scenePointerY,\n      zoom,\n      pointerType,\n    );\n    return transformHandleType ? { element, transformHandleType } : null;\n  }, null as { element: NonDeletedExcalidrawElement; transformHandleType: MaybeTransformHandleType } | null);\n};\n\nexport const getTransformHandleTypeFromCoords = (\n  [x1, y1, x2, y2]: readonly [number, number, number, number],\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n): MaybeTransformHandleType => {\n  const transformHandles = getTransformHandlesFromCoords(\n    [x1, y1, x2, y2],\n    0,\n    zoom,\n    pointerType,\n    OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  );\n\n  const found = Object.keys(transformHandles).find((key) => {\n    const transformHandle =\n      transformHandles[key as Exclude<TransformHandleType, \"rotation\">]!;\n    return (\n      transformHandle &&\n      isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY)\n    );\n  });\n  return (found || false) as MaybeTransformHandleType;\n};\n\nconst RESIZE_CURSORS = [\"ns\", \"nesw\", \"ew\", \"nwse\"];\nconst rotateResizeCursor = (cursor: string, angle: number) => {\n  const index = RESIZE_CURSORS.indexOf(cursor);\n  if (index >= 0) {\n    const a = Math.round(angle / (Math.PI / 4));\n    cursor = RESIZE_CURSORS[(index + a) % RESIZE_CURSORS.length];\n  }\n  return cursor;\n};\n\n/*\n * Returns bi-directional cursor for the element being resized\n */\nexport const getCursorForResizingElement = (resizingElement: {\n  element?: ExcalidrawElement;\n  transformHandleType: MaybeTransformHandleType;\n}): string => {\n  const { element, transformHandleType } = resizingElement;\n  const shouldSwapCursors =\n    element && Math.sign(element.height) * Math.sign(element.width) === -1;\n  let cursor = null;\n\n  switch (transformHandleType) {\n    case \"n\":\n    case \"s\":\n      cursor = \"ns\";\n      break;\n    case \"w\":\n    case \"e\":\n      cursor = \"ew\";\n      break;\n    case \"nw\":\n    case \"se\":\n      if (shouldSwapCursors) {\n        cursor = \"nesw\";\n      } else {\n        cursor = \"nwse\";\n      }\n      break;\n    case \"ne\":\n    case \"sw\":\n      if (shouldSwapCursors) {\n        cursor = \"nwse\";\n      } else {\n        cursor = \"nesw\";\n      }\n      break;\n    case \"rotation\":\n      return \"grab\";\n  }\n\n  if (cursor && element) {\n    cursor = rotateResizeCursor(cursor, element.angle);\n  }\n\n  return cursor ? `${cursor}-resize` : \"\";\n};\n","import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n} from \"./types\";\nimport { distance2d, rotate, isPathALoop, getGridPoint } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { Point, AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport History from \"../history\";\n\nimport Scene from \"../scene/Scene\";\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n} from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\n\nexport class LinearElementEditor {\n  public elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  public activePointIndex: number | null;\n  /** whether you're dragging a point */\n  public isDragging: boolean;\n  public lastUncommittedPoint: Point | null;\n  public pointerOffset: { x: number; y: number };\n  public startBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 20;\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    scenePointerX: number,\n    scenePointerY: number,\n    maybeSuggestBinding: (\n      element: NonDeleted<ExcalidrawLinearElement>,\n      startOrEnd: \"start\" | \"end\",\n    ) => void,\n  ): boolean {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { activePointIndex, elementId, isDragging } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    if (activePointIndex != null && activePointIndex > -1) {\n      if (isDragging === false) {\n        setState({\n          editingLinearElement: {\n            ...editingLinearElement,\n            isDragging: true,\n          },\n        });\n      }\n\n      const newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - editingLinearElement.pointerOffset.x,\n        scenePointerY - editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n      LinearElementEditor.movePoint(element, activePointIndex, newPoint);\n      if (isBindingElement(element)) {\n        maybeSuggestBinding(element, activePointIndex === 0 ? \"start\" : \"end\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n  ): LinearElementEditor {\n    const { elementId, activePointIndex, isDragging } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    let binding = {};\n    if (\n      isDragging &&\n      (activePointIndex === 0 || activePointIndex === element.points.length - 1)\n    ) {\n      if (isPathALoop(element.points, appState.zoom.value)) {\n        LinearElementEditor.movePoint(\n          element,\n          activePointIndex,\n          activePointIndex === 0\n            ? element.points[element.points.length - 1]\n            : element.points[0],\n        );\n      }\n      const bindingElement = isBindingEnabled(appState)\n        ? getHoveredElementForBinding(\n            tupleToCoors(\n              LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                element,\n                activePointIndex!,\n              ),\n            ),\n            Scene.getScene(element)!,\n          )\n        : null;\n      binding = {\n        [activePointIndex === 0 ? \"startBindingElement\" : \"endBindingElement\"]:\n          bindingElement,\n      };\n    }\n    return {\n      ...editingLinearElement,\n      ...binding,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    history: History,\n    scenePointer: { x: number; y: number },\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const { elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (appState.editingLinearElement.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointer.x,\n              scenePointer.y,\n              appState.gridSize,\n            ),\n          ],\n        });\n      }\n      history.resumeRecording();\n      setState({\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n          endBindingElement: getHoveredElementForBinding(\n            scenePointer,\n            Scene.getScene(element)!,\n          ),\n        },\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, insted of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const { startBindingElement, endBindingElement } =\n        appState.editingLinearElement;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    setState({\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n        pointerOffset: targetPoint\n          ? {\n              x: scenePointer.x - targetPoint[0],\n              y: scenePointer.y - targetPoint[1],\n            }\n          : { x: 0, y: 0 },\n      },\n    });\n    return ret;\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    editingLinearElement: LinearElementEditor,\n    gridSize: number | null,\n  ): LinearElementEditor {\n    const { elementId, lastUncommittedPoint } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n      return { ...editingLinearElement, lastUncommittedPoint: null };\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(\n      element,\n      scenePointerX - editingLinearElement.pointerOffset.x,\n      scenePointerY - editingLinearElement.pointerOffset.y,\n      gridSize,\n    );\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(\n        element,\n        element.points.length - 1,\n        newPoint,\n      );\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return {\n      ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n  ): Point {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const point = element.points[index];\n    const { x, y } = element;\n    return rotate(x + point[0], y + point[1], cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: Point,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(\n      absoluteCoords[0],\n      absoluteCoords[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom.value <\n        // +1px to account for outline stroke\n        this.POINT_HANDLE_SIZE / 2 + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase. Also returns new x/y to account\n   * for the potential normalization.\n   */\n  static getNormalizedPoints(element: ExcalidrawLinearElement) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    return {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    mutateElement(element, LinearElementEditor.getNormalizedPoints(element));\n  }\n\n  static movePointByOffset(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number,\n    offset: { x: number; y: number },\n  ) {\n    const [x, y] = element.points[pointIndex];\n    LinearElementEditor.movePoint(element, pointIndex, [\n      x + offset.x,\n      y + offset.y,\n    ]);\n  }\n\n  static movePoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number | \"new\",\n    targetPosition: Point | \"delete\",\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    let nextPoints: (readonly [number, number])[];\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        // positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n          offsetX = 0;\n          offsetY = 0;\n\n          return [point[0] + deltaX, point[1] + deltaY] as const;\n        }\n        return offsetX || offsetY\n          ? ([point[0] - offsetX, point[1] - offsetY] as const)\n          : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(\n      element,\n      nextPoints,\n      element.strokeSharpness || \"round\",\n    );\n    const prevCoords = getElementPointsCoords(\n      element,\n      points,\n      element.strokeSharpness || \"round\",\n    );\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n}\n","import {\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  PointBinding,\n  ExcalidrawElement,\n} from \"./types\";\nimport { getElementAtPosition } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { isBindableElement, isBindingElement } from \"./typeChecks\";\nimport {\n  bindingBorderTest,\n  distanceToBindableElement,\n  maxBindingGap,\n  determineFocusDistance,\n  intersectElementWithLine,\n  determineFocusPoint,\n} from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLCanvasElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n): void => {\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n  Scene.getScene(linearElement)!\n    .getNonDeletedElements(onlyUnbound)\n    .forEach((element) => {\n      mutateElement(element, {\n        boundElementIds: element.boundElementIds?.filter(\n          (id) => id !== linearElement.id,\n        ),\n      });\n    });\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n): void => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (\n        otherEdgeBindableElement == null ||\n        (otherEdgeBindableElement === \"keep\"\n          ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n              linearElement,\n              bindableElement,\n              startOrEnd,\n            )\n          : startOrEnd === \"start\" ||\n            otherEdgeBindableElement.id !== bindableElement.id)\n      ) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(\n        element,\n        getElligibleElementForBindingElement(element, \"start\"),\n        getElligibleElementForBindingElement(element, \"end\"),\n      );\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): void => {\n  getElligibleElementsForBindableElementAndWhere(bindableElement).forEach(\n    ([linearElement, where]) =>\n      bindOrUnbindLinearElement(\n        linearElement,\n        where === \"end\" ? \"keep\" : bindableElement,\n        where === \"start\" ? \"keep\" : bindableElement,\n      ),\n  );\n};\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  scene: Scene,\n  pointerCoords: { x: number; y: number },\n): void => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (\n    hoveredElement != null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      hoveredElement,\n      \"end\",\n    )\n  ) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): void => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd),\n    } as PointBinding,\n  });\n  mutateElement(hoveredElement, {\n    boundElementIds: Array.from(\n      new Set([...(hoveredElement.boundElementIds ?? []), linearElement.id]),\n    ),\n  });\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id && linearElement.points.length < 3\n  );\n};\n\nexport const unbindLinearElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  scene: Scene,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const hoveredElement = getElementAtPosition(\n    scene.getElements(),\n    (element) =>\n      isBindableElement(element) && bindingBorderTest(element, pointerCoords),\n  );\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  const boundElementIds = changedElement.boundElementIds ?? [];\n  if (boundElementIds.length === 0) {\n    return;\n  }\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n  (\n    Scene.getScene(changedElement)!.getNonDeletedElements(\n      boundElementIds,\n    ) as NonDeleted<ExcalidrawLinearElement>[]\n  ).forEach((linearElement) => {\n    const bindableElement = changedElement as ExcalidrawBindableElement;\n    // In case the boundElementIds are stale\n    if (!doesNeedUpdate(linearElement, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.startBinding,\n      newSize,\n    );\n    const endBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.endBinding,\n      newSize,\n    );\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(linearElement.id)) {\n      mutateElement(linearElement, { startBinding, endBinding });\n      return;\n    }\n    updateBoundPoint(\n      linearElement,\n      \"start\",\n      startBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    updateBoundPoint(\n      linearElement,\n      \"end\",\n      endBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n  });\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  binding: PointBinding | null | undefined,\n  changedElement: ExcalidrawBindableElement,\n): void => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== changedElement.id && linearElement.points.length > 2)\n  ) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement)!.getElement(\n    binding.elementId,\n  ) as ExcalidrawBindableElement | null;\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindingElement,\n    binding.focus,\n    adjacentPoint,\n  );\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(\n      bindingElement,\n      adjacentPoint,\n      focusPointAbsolute,\n      binding.gap,\n    );\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoint(\n    linearElement,\n    edgePointIndex,\n    LinearElementEditor.pointFromAbsoluteCoords(linearElement, newEdgePoint),\n    { [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding },\n  );\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { gap, focus, elementId } = currentBinding;\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      gap * (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n  return { elementId, gap: newGap, focus };\n};\n\nexport const getEligibleElementsForBinding = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): SuggestedBinding[] => {\n  const includedElementIds = new Set(elements.map(({ id }) => id));\n  return elements.flatMap((element) =>\n    isBindingElement(element)\n      ? (getElligibleElementsForBindingElement(\n          element as NonDeleted<ExcalidrawLinearElement>,\n        ).filter(\n          (element) => !includedElementIds.has(element.id),\n        ) as SuggestedBinding[])\n      : isBindableElement(element)\n      ? getElligibleElementsForBindableElementAndWhere(element).filter(\n          (binding) => !includedElementIds.has(binding[0].id),\n        )\n      : [],\n  );\n};\n\nconst getElligibleElementsForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  return [\n    getElligibleElementForBindingElement(linearElement, \"start\"),\n    getElligibleElementForBindingElement(linearElement, \"end\"),\n  ].filter(\n    (element): element is NonDeleted<ExcalidrawBindableElement> =>\n      element != null,\n  );\n};\n\nconst getElligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd),\n    Scene.getScene(linearElement)!,\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index),\n  );\n};\n\nconst getElligibleElementsForBindableElementAndWhere = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): SuggestedPointBinding[] => {\n  return Scene.getScene(bindableElement)!\n    .getElements()\n    .map((element) => {\n      if (!isBindingElement(element)) {\n        return null;\n      }\n      const canBindStart = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"start\",\n        bindableElement,\n      );\n      const canBindEnd = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"end\",\n        bindableElement,\n      );\n      if (!canBindStart && !canBindEnd) {\n        return null;\n      }\n      return [\n        element,\n        canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\",\n        bindableElement,\n      ];\n    })\n    .filter((maybeElement) => maybeElement != null) as SuggestedPointBinding[];\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): boolean => {\n  const existingBinding =\n    linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return (\n    existingBinding == null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      bindableElement,\n      startOrEnd,\n    ) &&\n    bindingBorderTest(\n      bindableElement,\n      getLinearElementEdgeCoors(linearElement, startOrEnd),\n    )\n  );\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (\n  sceneElements: readonly ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  // There are three copying mechanisms: Copy-paste, duplication and alt-drag.\n  // Only when alt-dragging the new \"duplicates\" act as the \"old\", while\n  // the \"old\" elements act as the \"new copy\" - essentially working reverse\n  // to the other two.\n  duplicatesServeAsOld?: \"duplicatesServeAsOld\" | undefined,\n): void => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const allBindableElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach((oldElement) => {\n    const { boundElementIds } = oldElement;\n    if (boundElementIds != null && boundElementIds.length > 0) {\n      boundElementIds.forEach((boundElementId) => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElementId)) {\n          allBoundElementIds.add(boundElementId);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const { elementId } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const { elementId } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n      }\n    }\n  });\n\n  // Update the linear elements\n  (\n    sceneElements.filter(({ id }) =>\n      allBoundElementIds.has(id),\n    ) as ExcalidrawLinearElement[]\n  ).forEach((element) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(\n        startBinding,\n        oldIdToDuplicatedId,\n      ),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId),\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements\n    .filter(({ id }) => allBindableElementIds.has(id))\n    .forEach((bindableElement) => {\n      const { boundElementIds } = bindableElement;\n      if (boundElementIds != null && boundElementIds.length > 0) {\n        mutateElement(bindableElement, {\n          boundElementIds: boundElementIds.map(\n            (boundElementId) =>\n              oldIdToDuplicatedId.get(boundElementId) ?? boundElementId,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDuplication = (\n  binding: PointBinding | null,\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null) {\n    return null;\n  }\n  const { elementId, focus, gap } = binding;\n  return {\n    focus,\n    gap,\n    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId,\n  };\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const deletedElementIds = new Set(\n    deletedElements.map((element) => element.id),\n  );\n  // Non deleted and need an update\n  const boundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  deletedElements.forEach((deletedElement) => {\n    if (isBindableElement(deletedElement)) {\n      deletedElement.boundElementIds?.forEach((id) => {\n        if (!deletedElementIds.has(id)) {\n          boundElementIds.add(id);\n        }\n      });\n    }\n  });\n  (\n    sceneElements.filter(({ id }) =>\n      boundElementIds.has(id),\n    ) as ExcalidrawLinearElement[]\n  ).forEach((element: ExcalidrawLinearElement) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDeletion(startBinding, deletedElementIds),\n      endBinding: newBindingAfterDeletion(endBinding, deletedElementIds),\n    });\n  });\n};\n\nconst newBindingAfterDeletion = (\n  binding: PointBinding | null,\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\n","import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\n\nimport {\n  rotate,\n  adjustXYWithRotation,\n  centerPoint,\n  rotatePoint,\n} from \"../math\";\nimport {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\nimport {\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { measureText, getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\nimport {\n  TransformHandleType,\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport { Point, PointerDownState } from \"../types\";\n\nexport const normalizeAngle = (angle: number): number => {\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n  return angle;\n};\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  pointerDownState: PointerDownState,\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  resizeArrowDirection: \"origin\" | \"end\",\n  shouldRotateWithDiscreteAngle: boolean,\n  shouldResizeFromCenter: boolean,\n  shouldMaintainAspectRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(\n        element,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n      );\n      updateBoundElements(element);\n    } else if (\n      isLinearElement(element) &&\n      element.points.length === 2 &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      reshapeSingleTwoPointElement(\n        element,\n        resizeArrowDirection,\n        shouldRotateWithDiscreteAngle,\n        pointerX,\n        pointerY,\n      );\n    } else if (\n      isTextElement(element) &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      resizeSingleTextElement(\n        element,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(\n        pointerDownState.originalElements.get(element.id) as typeof element,\n        shouldMaintainAspectRatio,\n        element,\n        transformHandleType,\n        shouldResizeFromCenter,\n        pointerX,\n        pointerY,\n      );\n    }\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        pointerDownState,\n        selectedElements,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (\n      transformHandleType === \"nw\" ||\n      transformHandleType === \"ne\" ||\n      transformHandleType === \"sw\" ||\n      transformHandleType === \"se\"\n    ) {\n      resizeMultipleElements(\n        selectedElements,\n        transformHandleType,\n        pointerX,\n        pointerY,\n      );\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle = (5 * Math.PI) / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n  if (shouldRotateWithDiscreteAngle) {\n    angle += SHIFT_LOCKING_ANGLE / 2;\n    angle -= angle % SHIFT_LOCKING_ANGLE;\n  }\n  angle = normalizeAngle(angle);\n  mutateElement(element, { angle });\n};\n\n// used in DEV only\nconst validateTwoPointElementNormalized = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  if (\n    element.points.length !== 2 ||\n    element.points[0][0] !== 0 ||\n    element.points[0][1] !== 0 ||\n    Math.abs(element.points[1][0]) !== element.width ||\n    Math.abs(element.points[1][1]) !== element.height\n  ) {\n    throw new Error(\"Two-point element is not normalized\");\n  }\n};\n\nconst getPerfectElementSizeWithRotation = (\n  elementType: string,\n  width: number,\n  height: number,\n  angle: number,\n): [number, number] => {\n  const size = getPerfectElementSize(\n    elementType,\n    ...rotate(width, height, 0, 0, angle),\n  );\n  return rotate(size.width, size.height, 0, 0, -angle);\n};\n\nexport const reshapeSingleTwoPointElement = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  resizeArrowDirection: \"origin\" | \"end\",\n  shouldRotateWithDiscreteAngle: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    validateTwoPointElementNormalized(element);\n  }\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let [width, height] =\n    resizeArrowDirection === \"end\"\n      ? [rotatedX - element.x, rotatedY - element.y]\n      : [\n          element.x + element.points[1][0] - rotatedX,\n          element.y + element.points[1][1] - rotatedY,\n        ];\n  if (shouldRotateWithDiscreteAngle) {\n    [width, height] = getPerfectElementSizeWithRotation(\n      element.type,\n      width,\n      height,\n      element.angle,\n    );\n  }\n  const [nextElementX, nextElementY] = adjustXYWithRotation(\n    resizeArrowDirection === \"end\"\n      ? { s: true, e: true }\n      : { n: true, w: true },\n    element.x,\n    element.y,\n    element.angle,\n    0,\n    0,\n    (element.points[1][0] - width) / 2,\n    (element.points[1][1] - height) / 2,\n  );\n  mutateElement(element, {\n    x: nextElementX,\n    y: nextElementY,\n    points: [\n      [0, 0],\n      [width, height],\n    ],\n  });\n};\n\nconst rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n) =>\n  isLinearElement(element) || isFreeDrawElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points),\n        ),\n      }\n    : {};\n\nconst MIN_FONT_SIZE = 1;\n\nconst measureFontSizeFromWH = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  nextWidth: number,\n  nextHeight: number,\n): { size: number; baseline: number } | null => {\n  // We only use width to scale font on resize\n  const nextFontSize = element.fontSize * (nextWidth / element.width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n  const metrics = measureText(\n    element.text,\n    getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),\n  );\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height),\n  };\n};\n\nconst getSidesForTransformHandle = (\n  transformHandleType: TransformHandleType,\n  shouldResizeFromCenter: boolean,\n) => {\n  return {\n    n:\n      /^(n|ne|nw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType)),\n    s:\n      /^(s|se|sw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType)),\n    w:\n      /^(w|nw|sw)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType)),\n    e:\n      /^(e|ne|se)$/.test(transformHandleType) ||\n      (shouldResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)),\n  };\n};\n\nconst resizeSingleTextElement = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let scale: number;\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n  }\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const nextFont = measureFontSizeFromWH(element, nextWidth, nextHeight);\n    if (nextFont === null) {\n      return;\n    }\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(\n      getSidesForTransformHandle(transformHandleType, shouldResizeFromCenter),\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n    mutateElement(element, {\n      fontSize: nextFont.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextFont.baseline,\n      x: nextElementX,\n      y: nextElementY,\n    });\n  }\n};\n\nexport const resizeSingleElement = (\n  stateAtResizeStart: NonDeletedExcalidrawElement,\n  shouldMaintainAspectRatio: boolean,\n  element: NonDeletedExcalidrawElement,\n  transformHandleDirection: TransformHandleDirection,\n  shouldResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    stateAtResizeStart.width,\n    stateAtResizeStart.height,\n  );\n  const startTopLeft: Point = [x1, y1];\n  const startBottomRight: Point = [x2, y2];\n  const startCenter: Point = centerPoint(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = rotatePoint(\n    [pointerX, pointerY],\n    startCenter,\n    -stateAtResizeStart.angle,\n  );\n\n  // Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    element,\n    element.width,\n    element.height,\n  );\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n  // Linear elements dimensions differ from bounds dimensions\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height;\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY;\n\n  // adjust dimensions for resizing from center\n  if (shouldResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldMaintainAspectRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] =\n    getResizedElementAbsoluteCoords(\n      stateAtResizeStart,\n      eleNewWidth,\n      eleNewHeight,\n    );\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  // Keeps opposite handle fixed during resize\n  if (shouldMaintainAspectRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // Flip horizontally\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  }\n  // Flip vertically\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n\n  if (shouldResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);\n\n  // Readjust points for linear elements\n  const rescaledPoints = rescalePointsInElement(\n    stateAtResizeStart,\n    eleNewWidth,\n    eleNewHeight,\n  );\n  // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    ...rescaledPoints,\n  };\n\n  if (\"scale\" in element && \"scale\" in stateAtResizeStart) {\n    mutateElement(element, {\n      scale: [\n        // defaulting because scaleX/Y can be 0/-0\n        (Math.sign(scaleX) || stateAtResizeStart.scale[0]) *\n          stateAtResizeStart.scale[0],\n        (Math.sign(scaleY) || stateAtResizeStart.scale[1]) *\n          stateAtResizeStart.scale[1],\n      ],\n    });\n  }\n\n  if (\n    resizedElement.width !== 0 &&\n    resizedElement.height !== 0 &&\n    Number.isFinite(resizedElement.x) &&\n    Number.isFinite(resizedElement.y)\n  ) {\n    updateBoundElements(element, {\n      newSize: { width: resizedElement.width, height: resizedElement.height },\n    });\n    mutateElement(element, resizedElement);\n  }\n};\n\nconst resizeMultipleElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements);\n  let scale: number;\n  let getNextXY: (\n    element: NonDeletedExcalidrawElement,\n    origCoords: readonly [number, number, number, number],\n    finalCoords: readonly [number, number, number, number],\n  ) => { x: number; y: number };\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, origY1], [finalX1, finalY1]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [, , origX2, origY2], [, , finalX2, finalY2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, , , origY2], [finalX1, , , finalY2]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [, origY1, origX2], [, finalY1, finalX2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n  }\n  if (scale > 0) {\n    const updates = elements.reduce(\n      (prev, element) => {\n        if (!prev) {\n          return prev;\n        }\n        const width = element.width * scale;\n        const height = element.height * scale;\n        let font: { fontSize?: number; baseline?: number } = {};\n        if (element.type === \"text\") {\n          const nextFont = measureFontSizeFromWH(element, width, height);\n          if (nextFont === null) {\n            return null;\n          }\n          font = { fontSize: nextFont.size, baseline: nextFont.baseline };\n        }\n        const origCoords = getElementAbsoluteCoords(element);\n\n        const rescaledPoints = rescalePointsInElement(element, width, height);\n\n        updateBoundElements(element, {\n          newSize: { width, height },\n          simultaneouslyUpdated: elements,\n        });\n\n        const finalCoords = getResizedElementAbsoluteCoords(\n          {\n            ...element,\n            ...rescaledPoints,\n          },\n          width,\n          height,\n        );\n\n        const { x, y } = getNextXY(element, origCoords, finalCoords);\n        return [...prev, { width, height, x, y, ...rescaledPoints, ...font }];\n      },\n      [] as\n        | {\n            width: number;\n            height: number;\n            x: number;\n            y: number;\n            points?: (readonly [number, number])[];\n            fontSize?: number;\n            baseline?: number;\n          }[]\n        | null,\n    );\n    if (updates) {\n      elements.forEach((element, index) => {\n        mutateElement(element, updates[index]);\n      });\n    }\n  }\n};\n\nconst rotateMultipleElements = (\n  pointerDownState: PointerDownState,\n  elements: readonly NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (shouldRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n  elements.forEach((element, index) => {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const origAngle =\n      pointerDownState.originalElements.get(element.id)?.angle ?? element.angle;\n    const [rotatedCX, rotatedCY] = rotate(\n      cx,\n      cy,\n      centerX,\n      centerY,\n      centerAngle + origAngle - element.angle,\n    );\n    mutateElement(element, {\n      x: element.x + (rotatedCX - cx),\n      y: element.y + (rotatedCY - cy),\n      angle: normalizeAngle(centerAngle + origAngle),\n    });\n  });\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0])\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n","import { SHAPES } from \"../shapes\";\nimport { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport Scene from \"../scene/Scene\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { PointerDownState } from \"../types\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  scene: Scene,\n  lockDirection: boolean = false,\n  distanceX: number = 0,\n  distanceY: number = 0,\n) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = { x: pointerX - x1, y: pointerY - y1 };\n  selectedElements.forEach((element) => {\n    let x: number;\n    let y: number;\n    if (lockDirection) {\n      const lockX = lockDirection && distanceX < distanceY;\n      const lockY = lockDirection && distanceX > distanceY;\n      const original = pointerDownState.originalElements.get(element.id);\n      x = lockX && original ? original.x : element.x + offset.x;\n      y = lockY && original ? original.y : element.y + offset.y;\n    } else {\n      x = element.x + offset.x;\n      y = element.y + offset.y;\n    }\n\n    mutateElement(element, {\n      x,\n      y,\n    });\n\n    updateBoundElements(element, {\n      simultaneouslyUpdated: selectedElements,\n    });\n  });\n};\n\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = (\n  draggingElement: NonDeletedExcalidrawElement,\n  elementType: typeof SHAPES[number][\"value\"],\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  shouldMaintainAspectRatio: boolean,\n  shouldResizeFromCenter: boolean,\n  /** whether to keep given aspect ratio when `isResizeWithSidesSameLength` is\n      true */\n  widthAspectRatio?: number | null,\n) => {\n  if (shouldMaintainAspectRatio) {\n    if (widthAspectRatio) {\n      height = width / widthAspectRatio;\n    } else {\n      ({ width, height } = getPerfectElementSize(\n        elementType,\n        width,\n        y < originY ? -height : height,\n      ));\n\n      if (height < 0) {\n        height = -height;\n      }\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (shouldResizeFromCenter) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height,\n    });\n  }\n};\n","import { CODES, KEYS } from \"../keys\";\nimport { isWritableElement, getFontString } from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \"./typeChecks\";\nimport { CLASSES } from \"../constants\";\nimport { ExcalidrawElement } from \"./types\";\nimport { AppState } from \"../types\";\n\nconst normalizeText = (text: string) => {\n  return (\n    text\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n      // normalize newlines\n      .replace(/\\r?\\n|\\r/g, \"\\n\")\n  );\n};\n\nconst getTransform = (\n  width: number,\n  height: number,\n  angle: number,\n  appState: AppState,\n  maxWidth: number,\n) => {\n  const { zoom, offsetTop, offsetLeft } = appState;\n  const degree = (180 * angle) / Math.PI;\n  // offsets must be multiplied by 2 to account for the division by 2 of\n  // the whole expression afterwards\n  let translateX = ((width - offsetLeft * 2) * (zoom.value - 1)) / 2;\n  const translateY = ((height - offsetTop * 2) * (zoom.value - 1)) / 2;\n  if (width > maxWidth && zoom.value !== 1) {\n    translateX = (maxWidth / 2) * (zoom.value - 1);\n  }\n  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\nexport const textWysiwyg = ({\n  id,\n  appState,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element,\n  canvas,\n  excalidrawContainer,\n}: {\n  id: ExcalidrawElement[\"id\"];\n  appState: AppState;\n  onChange?: (text: string) => void;\n  onSubmit: (data: { text: string; viaKeyboard: boolean }) => void;\n  getViewportCoords: (x: number, y: number) => [number, number];\n  element: ExcalidrawElement;\n  canvas: HTMLCanvasElement | null;\n  excalidrawContainer: HTMLDivElement | null;\n}) => {\n  const updateWysiwygStyle = () => {\n    const updatedElement = Scene.getScene(element)?.getElement(id);\n    if (updatedElement && isTextElement(updatedElement)) {\n      const [viewportX, viewportY] = getViewportCoords(\n        updatedElement.x,\n        updatedElement.y,\n      );\n      const { textAlign, angle } = updatedElement;\n\n      editable.value = updatedElement.text;\n\n      const lines = updatedElement.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n      const lineHeight = updatedElement.height / lines.length;\n      const maxWidth =\n        (appState.offsetLeft + appState.width - viewportX - 8) /\n          appState.zoom.value -\n        // margin-right of parent if any\n        Number(\n          getComputedStyle(\n            excalidrawContainer?.parentNode as Element,\n          ).marginRight.slice(0, -2),\n        );\n\n      Object.assign(editable.style, {\n        font: getFontString(updatedElement),\n        // must be defined *after* font \\_()_/\n        lineHeight: `${lineHeight}px`,\n        width: `${updatedElement.width}px`,\n        height: `${updatedElement.height}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(\n          updatedElement.width,\n          updatedElement.height,\n          angle,\n          appState,\n          maxWidth,\n        ),\n        textAlign,\n        color: updatedElement.strokeColor,\n        opacity: updatedElement.opacity / 100,\n        filter: \"var(--theme-filter)\",\n        maxWidth: `${maxWidth}px`,\n      });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n\n  Object.assign(editable.style, {\n    position: \"absolute\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace: \"pre\",\n    // must be specified because in dark mode canvas creates a stacking context\n    zIndex: \"var(--zIndex-wysiwyg)\",\n  });\n\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n\n  editable.onkeydown = (event) => {\n    event.stopPropagation();\n    if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (\n      event.key === KEYS.TAB ||\n      (event[KEYS.CTRL_OR_CMD] &&\n        (event.code === CODES.BRACKET_LEFT ||\n          event.code === CODES.BRACKET_RIGHT))\n    ) {\n      event.preventDefault();\n      if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {\n        outdent();\n      } else {\n        indent();\n      }\n      // We must send an input event to resize the element\n      editable.dispatchEvent(new Event(\"input\"));\n    }\n  };\n\n  const TAB_SIZE = 4;\n  const TAB = \" \".repeat(TAB_SIZE);\n  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);\n  const indent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex) => {\n      const startValue = value.slice(0, startIndex);\n      const endValue = value.slice(startIndex);\n\n      value = `${startValue}${TAB}${endValue}`;\n    });\n\n    editable.value = value;\n\n    editable.selectionStart = selectionStart + TAB_SIZE;\n    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;\n  };\n\n  const outdent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n    const removedTabs: number[] = [];\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex) => {\n      const tabMatch = value\n        .slice(startIndex, startIndex + TAB_SIZE)\n        .match(RE_LEADING_TAB);\n\n      if (tabMatch) {\n        const startValue = value.slice(0, startIndex);\n        const endValue = value.slice(startIndex + tabMatch[0].length);\n\n        // Delete a tab from the line\n        value = `${startValue}${endValue}`;\n        removedTabs.push(startIndex);\n      }\n    });\n\n    editable.value = value;\n\n    if (removedTabs.length) {\n      if (selectionStart > removedTabs[removedTabs.length - 1]) {\n        editable.selectionStart = Math.max(\n          selectionStart - TAB_SIZE,\n          removedTabs[removedTabs.length - 1],\n        );\n      } else {\n        // If the cursor is before the first tab removed, ex:\n        // Line| #1\n        //     Line #2\n        // Lin|e #3\n        // we should reset the selectionStart to his initial value.\n        editable.selectionStart = selectionStart;\n      }\n      editable.selectionEnd = Math.max(\n        editable.selectionStart,\n        selectionEnd - TAB_SIZE * removedTabs.length,\n      );\n    }\n  };\n\n  /**\n   * @returns indeces of start positions of selected lines, in reverse order\n   */\n  const getSelectedLinesStartIndices = () => {\n    let { selectionStart, selectionEnd, value } = editable;\n\n    // chars before selectionStart on the same line\n    const startOffset = value.slice(0, selectionStart).match(/[^\\n]*$/)![0]\n      .length;\n    // put caret at the start of the line\n    selectionStart = selectionStart - startOffset;\n\n    const selected = value.slice(selectionStart, selectionEnd);\n\n    return selected\n      .split(\"\\n\")\n      .reduce(\n        (startIndices, line, idx, lines) =>\n          startIndices.concat(\n            idx\n              ? // curr line index is prev line's start + prev line's length + \\n\n                startIndices[idx - 1] + lines[idx - 1].length + 1\n              : // first selected line\n                selectionStart,\n          ),\n        [] as number[],\n      )\n      .reverse();\n  };\n\n  const stopEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  // using a state variable instead of passing it to the handleSubmit callback\n  // so that we don't need to create separate a callback for event handlers\n  let submittedViaKeyboard = false;\n  const handleSubmit = () => {\n    // cleanup must be run before onSubmit otherwise when app blurs the wysiwyg\n    // it'd get stuck in an infinite loop of bluronSubmit after we re-focus the\n    // wysiwyg on update\n    cleanup();\n    onSubmit({\n      text: normalizeText(editable.value),\n      viaKeyboard: submittedViaKeyboard,\n    });\n  };\n\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n\n    if (observer) {\n      observer.disconnect();\n    }\n\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    window.removeEventListener(\"blur\", handleSubmit);\n\n    unbindUpdate();\n\n    editable.remove();\n  };\n\n  const bindBlurEvent = () => {\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    // Deferred so that the pointerdown that initiates the wysiwyg doesn't\n    // trigger the blur on ensuing pointerup.\n    // Also to handle cases such as picking a color which would trigger a blur\n    // in that same tick.\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n      // case: clicking on the same property  no change  no update  no focus\n      editable.focus();\n    });\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = (event: MouseEvent) => {\n    if (\n      (event.target instanceof HTMLElement ||\n        event.target instanceof SVGElement) &&\n      event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) &&\n      !isWritableElement(event.target)\n    ) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", bindBlurEvent);\n      // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = Scene.getScene(element)!.addCallback(() => {\n    updateWysiwygStyle();\n    editable.focus();\n  });\n\n  // ---------------------------------------------------------------------------\n\n  let isDestroyed = false;\n\n  // select on init (focusing is done separately inside the bindBlurEvent()\n  // because we need it to happen *after* the blur event from `pointerdown`)\n  editable.select();\n  bindBlurEvent();\n\n  // reposition wysiwyg in case of canvas is resized. Using ResizeObserver\n  // is preferred so we catch changes from host, where window may not resize.\n  let observer: ResizeObserver | null = null;\n  if (canvas && \"ResizeObserver\" in window) {\n    observer = new window.ResizeObserver(() => {\n      updateWysiwygStyle();\n    });\n    observer.observe(canvas);\n  } else {\n    window.addEventListener(\"resize\", updateWysiwygStyle);\n  }\n\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true,\n  });\n  excalidrawContainer\n    ?.querySelector(\".excalidraw-textEditorContainer\")!\n    .appendChild(editable);\n};\n","import { measureText, getFontString } from \"../utils\";\nimport { ExcalidrawTextElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\n\nexport const redrawTextBoundingBox = (element: ExcalidrawTextElement) => {\n  const metrics = measureText(element.text, getFontString(element));\n  mutateElement(element, {\n    width: metrics.width,\n    height: metrics.height,\n    baseline: metrics.baseline,\n  });\n};\n","import { AppState } from \"../types\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { getSelectedElements } from \"../scene\";\n\nexport const showSelectedShapeActions = (\n  appState: AppState,\n  elements: readonly NonDeletedExcalidrawElement[],\n) =>\n  Boolean(\n    !appState.viewModeEnabled &&\n      (appState.editingElement ||\n        getSelectedElements(elements, appState).length ||\n        appState.elementType !== \"selection\"),\n  );\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\nimport { isLinearElementType } from \"./typeChecks\";\n\nexport {\n  newElement,\n  newTextElement,\n  updateTextElement,\n  newLinearElement,\n  newImageElement,\n  duplicateElement,\n} from \"./newElement\";\nexport {\n  getElementAbsoluteCoords,\n  getElementBounds,\n  getCommonBounds,\n  getDiamondPoints,\n  getArrowheadPoints,\n  getClosestElementBounds,\n} from \"./bounds\";\n\nexport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n} from \"./transformHandles\";\nexport {\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n} from \"./collision\";\nexport {\n  resizeTest,\n  getCursorForResizingElement,\n  getElementWithTransformHandleType,\n  getTransformHandleTypeFromCoords,\n} from \"./resizeTest\";\nexport {\n  transformElements,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n} from \"./resizeElements\";\nexport {\n  dragSelectedElements,\n  getDragOffsetXY,\n  dragNewElement,\n} from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport {\n  getPerfectElementSize,\n  isInvisiblySmallElement,\n  resizePerfectLineForNWHandler,\n  getNormalizedDimensions,\n} from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\n\nexport const getElementMap = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce(\n    (acc: { [key: string]: ExcalidrawElement }, element: ExcalidrawElement) => {\n      acc[element.id] = element;\n      return acc;\n    },\n    {},\n  );\n\nexport const getSceneVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\nexport const getVisibleElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (el) => !el.isDeleted && !isInvisiblySmallElement(el),\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const getNonDeletedElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (element) => !element.isDeleted,\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n\nconst _clearElements = (\n  elements: readonly ExcalidrawElement[],\n): ExcalidrawElement[] =>\n  getNonDeletedElements(elements).map((element) =>\n    isLinearElementType(element.type)\n      ? { ...element, lastCommittedPoint: null }\n      : element,\n  );\n\nexport const clearElementsForDatabase = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForExport = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n","import { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element\";\nimport { Zoom } from \"../types\";\nimport { ScrollBars } from \"./types\";\nimport { getGlobalCSSVariable } from \"../utils\";\nimport { getLanguage } from \"../i18n\";\n\nexport const SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nexport const getScrollBars = (\n  elements: readonly ExcalidrawElement[],\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: number;\n    scrollY: number;\n    zoom: Zoom;\n  },\n): ScrollBars => {\n  if (elements.length === 0) {\n    return {\n      horizontal: null,\n      vertical: null,\n    };\n  }\n  // This is the bounding box of all the elements\n  const [elementsMinX, elementsMinY, elementsMaxX, elementsMaxY] =\n    getCommonBounds(elements);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom.value;\n  const viewportHeightWithZoom = viewportHeight / zoom.value;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  const safeArea = {\n    top: parseInt(getGlobalCSSVariable(\"sat\")),\n    bottom: parseInt(getGlobalCSSVariable(\"sab\")),\n    left: parseInt(getGlobalCSSVariable(\"sal\")),\n    right: parseInt(getGlobalCSSVariable(\"sar\")),\n  };\n\n  const isRTL = getLanguage().rtl;\n\n  // The viewport is the rectangle currently visible for the user\n  const viewportMinX = -scrollX + viewportWidthDiff / 2 + safeArea.left;\n  const viewportMinY = -scrollY + viewportHeightDiff / 2 + safeArea.top;\n  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;\n  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;\n\n  // The scene is the bounding box of both the elements and viewport\n  const sceneMinX = Math.min(elementsMinX, viewportMinX);\n  const sceneMinY = Math.min(elementsMinY, viewportMinY);\n  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);\n  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);\n\n  // The scrollbar represents where the viewport is in relationship to the scene\n\n  return {\n    horizontal:\n      viewportMinX === sceneMinX && viewportMaxX === sceneMaxX\n        ? null\n        : {\n            x:\n              Math.max(safeArea.left, SCROLLBAR_MARGIN) +\n              ((viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth,\n            y:\n              viewportHeight -\n              SCROLLBAR_WIDTH -\n              Math.max(SCROLLBAR_MARGIN, safeArea.bottom),\n            width:\n              ((viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),\n            height: SCROLLBAR_WIDTH,\n          },\n    vertical:\n      viewportMinY === sceneMinY && viewportMaxY === sceneMaxY\n        ? null\n        : {\n            x: isRTL\n              ? Math.max(safeArea.left, SCROLLBAR_MARGIN)\n              : viewportWidth -\n                SCROLLBAR_WIDTH -\n                Math.max(safeArea.right, SCROLLBAR_MARGIN),\n            y:\n              ((viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight +\n              Math.max(safeArea.top, SCROLLBAR_MARGIN),\n            width: SCROLLBAR_WIDTH,\n            height:\n              ((viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom),\n          },\n  };\n};\n\nexport const isOverScrollBars = (\n  scrollBars: ScrollBars,\n  x: number,\n  y: number,\n): {\n  isOverEither: boolean;\n  isOverHorizontal: boolean;\n  isOverVertical: boolean;\n} => {\n  const [isOverHorizontal, isOverVertical] = [\n    scrollBars.horizontal,\n    scrollBars.vertical,\n  ].map((scrollBar) => {\n    return (\n      scrollBar != null &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n    );\n  });\n  const isOverEither = isOverHorizontal || isOverVertical;\n  return { isOverEither, isOverHorizontal, isOverVertical };\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { getElementAbsoluteCoords, getElementBounds } from \"../element\";\nimport { AppState } from \"../types\";\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] =\n    getElementAbsoluteCoords(selection);\n  return elements.filter((element) => {\n    const [elementX1, elementY1, elementX2, elementY2] =\n      getElementBounds(element);\n\n    return (\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n};\n\nexport const isSomeElementSelected = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n): boolean =>\n  elements.some((element) => appState.selectedElementIds[element.id]);\n\n/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */\nexport const getCommonAttributeOfSelectedElements = <T>(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  getAttribute: (element: ExcalidrawElement) => T,\n): T | null => {\n  const attributes = Array.from(\n    new Set(\n      getSelectedElements(elements, appState).map((element) =>\n        getAttribute(element),\n      ),\n    ),\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n};\n\nexport const getSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => elements.filter((element) => appState.selectedElementIds[element.id]);\n\nexport const getTargetElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) =>\n  appState.editingElement\n    ? [appState.editingElement]\n    : getSelectedElements(elements, appState);\n","import { AppState, PointerCoords, Zoom } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport {\n  getCommonBounds,\n  getClosestElementBounds,\n  getVisibleElements,\n} from \"../element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"../utils\";\n\nconst isOutsideViewPort = (\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  cords: Array<number>,\n) => {\n  const [x1, y1, x2, y2] = cords;\n  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(\n    { sceneX: x1, sceneY: y1 },\n    appState,\n  );\n  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(\n    { sceneX: x2, sceneY: y2 },\n    appState,\n  );\n  return (\n    viewportX2 - viewportX1 > appState.width ||\n    viewportY2 - viewportY1 > appState.height\n  );\n};\n\nexport const centerScrollOn = ({\n  scenePoint,\n  viewportDimensions,\n  zoom,\n}: {\n  scenePoint: PointerCoords;\n  viewportDimensions: { height: number; width: number };\n  zoom: Zoom;\n}) => {\n  return {\n    scrollX:\n      (viewportDimensions.width / 2) * (1 / zoom.value) -\n      scenePoint.x -\n      zoom.translation.x * (1 / zoom.value),\n    scrollY:\n      (viewportDimensions.height / 2) * (1 / zoom.value) -\n      scenePoint.y -\n      zoom.translation.y * (1 / zoom.value),\n  };\n};\n\nexport const calculateScrollCenter = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n): { scrollX: number; scrollY: number } => {\n  elements = getVisibleElements(elements);\n\n  if (!elements.length) {\n    return {\n      scrollX: 0,\n      scrollY: 0,\n    };\n  }\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(\n      elements,\n      viewportCoordsToSceneCoords(\n        { clientX: appState.scrollX, clientY: appState.scrollY },\n        appState,\n      ),\n    );\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  return centerScrollOn({\n    scenePoint: { x: centerX, y: centerY },\n    viewportDimensions: { width: appState.width, height: appState.height },\n    zoom: appState.zoom,\n  });\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getElementAbsoluteCoords } from \"../element\";\n\nexport const hasBackground = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"line\";\n\nexport const hasStrokeColor = (type: string) => type !== \"image\";\n\nexport const hasStrokeWidth = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const hasStrokeStyle = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const canChangeSharpness = (type: string) =>\n  type === \"rectangle\" || type === \"arrow\" || type === \"line\";\n\nexport const hasText = (type: string) => type === \"text\";\n\nexport const canHaveArrowheads = (type: string) => type === \"arrow\";\n\nexport const getElementAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nexport const getElementsAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(\n    (element) => !element.isDeleted && isAtPositionFn(element),\n  );\n};\n\nexport const getElementContainingPosition = (\n  elements: readonly ExcalidrawElement[],\n  x: number,\n  y: number,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n  return hitElement;\n};\n","import { NormalizedZoomValue, PointerCoords, Zoom } from \"../types\";\n\nexport const getNewZoom = (\n  newZoomValue: NormalizedZoomValue,\n  prevZoom: Zoom,\n  canvasOffset: { left: number; top: number },\n  zoomOnViewportPoint: PointerCoords = { x: 0, y: 0 },\n): Zoom => {\n  return {\n    value: newZoomValue,\n    translation: {\n      x:\n        zoomOnViewportPoint.x -\n        canvasOffset.left -\n        (zoomOnViewportPoint.x - canvasOffset.left - prevZoom.translation.x) *\n          (newZoomValue / prevZoom.value),\n      y:\n        zoomOnViewportPoint.y -\n        canvasOffset.top -\n        (zoomOnViewportPoint.y - canvasOffset.top - prevZoom.translation.y) *\n          (newZoomValue / prevZoom.value),\n    },\n  };\n};\n\nexport const getNormalizedZoom = (zoom: number): NormalizedZoomValue => {\n  const normalizedZoom = parseFloat(zoom.toFixed(2));\n  const clampedZoom = Math.max(0.1, Math.min(normalizedZoom, 10));\n  return clampedZoom as NormalizedZoomValue;\n};\n","type CANVAS_ERROR_NAMES = \"CANVAS_ERROR\" | \"CANVAS_POSSIBLY_TOO_BIG\";\n\nexport class CanvasError extends Error {\n  constructor(\n    message: string = \"Couldn't export canvas.\",\n    name: CANVAS_ERROR_NAMES = \"CANVAS_ERROR\",\n  ) {\n    super();\n    this.name = name;\n    this.message = message;\n  }\n}\n\nexport class AbortError extends DOMException {\n  constructor(message: string = \"Request Aborted\") {\n    super(message, \"AbortError\");\n  }\n}\n","import React from \"react\";\n\nimport \"./Spinner.scss\";\n\nconst Spinner = ({\n  size = \"1em\",\n  circleWidth = 8,\n}: {\n  size?: string | number;\n  circleWidth?: number;\n}) => {\n  return (\n    <div className=\"Spinner\">\n      <svg viewBox=\"0 0 100 100\" style={{ width: size, height: size }}>\n        <circle\n          cx=\"50\"\n          cy=\"50\"\n          r={50 - circleWidth / 2}\n          strokeWidth={circleWidth}\n          fill=\"none\"\n          strokeMiterlimit=\"10\"\n        />\n      </svg>\n    </div>\n  );\n};\n\nexport default Spinner;\n","import \"./ToolIcon.scss\";\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport clsx from \"clsx\";\nimport { useExcalidrawContainer } from \"./App\";\nimport { AbortError } from \"../errors\";\nimport Spinner from \"./Spinner\";\nimport { PointerType } from \"../element/types\";\n\nexport type ToolButtonSize = \"small\" | \"medium\";\n\ntype ToolButtonBaseProps = {\n  icon?: React.ReactNode;\n  \"aria-label\": string;\n  \"aria-keyshortcuts\"?: string;\n  \"data-testid\"?: string;\n  label?: string;\n  title?: string;\n  name?: string;\n  id?: string;\n  size?: ToolButtonSize;\n  keyBindingLabel?: string;\n  showAriaLabel?: boolean;\n  hidden?: boolean;\n  visible?: boolean;\n  selected?: boolean;\n  className?: string;\n};\n\ntype ToolButtonProps =\n  | (ToolButtonBaseProps & {\n      type: \"button\";\n      children?: React.ReactNode;\n      onClick?(event: React.MouseEvent): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"icon\";\n      children?: React.ReactNode;\n      onClick?(): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"radio\";\n      checked: boolean;\n      onChange?(data: { pointerType: PointerType | null }): void;\n    });\n\nexport const ToolButton = React.forwardRef((props: ToolButtonProps, ref) => {\n  const { id: excalId } = useExcalidrawContainer();\n  const innerRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => innerRef.current);\n  const sizeCn = `ToolIcon_size_${props.size}`;\n\n  const [isLoading, setIsLoading] = useState(false);\n\n  const isMountedRef = useRef(true);\n\n  const onClick = async (event: React.MouseEvent) => {\n    const ret = \"onClick\" in props && props.onClick?.(event);\n\n    if (ret && \"then\" in ret) {\n      try {\n        setIsLoading(true);\n        await ret;\n      } catch (error: any) {\n        if (!(error instanceof AbortError)) {\n          throw error;\n        }\n      } finally {\n        if (isMountedRef.current) {\n          setIsLoading(false);\n        }\n      }\n    }\n  };\n\n  useEffect(\n    () => () => {\n      isMountedRef.current = false;\n    },\n    [],\n  );\n\n  const lastPointerTypeRef = useRef<PointerType | null>(null);\n\n  if (props.type === \"button\" || props.type === \"icon\") {\n    return (\n      <button\n        className={clsx(\n          \"ToolIcon_type_button\",\n          sizeCn,\n          props.className,\n          props.visible && !props.hidden\n            ? \"ToolIcon_type_button--show\"\n            : \"ToolIcon_type_button--hide\",\n          {\n            ToolIcon: !props.hidden,\n            \"ToolIcon--selected\": props.selected,\n            \"ToolIcon--plain\": props.type === \"icon\",\n          },\n        )}\n        data-testid={props[\"data-testid\"]}\n        hidden={props.hidden}\n        title={props.title}\n        aria-label={props[\"aria-label\"]}\n        type=\"button\"\n        onClick={onClick}\n        ref={innerRef}\n        disabled={isLoading}\n      >\n        {(props.icon || props.label) && (\n          <div className=\"ToolIcon__icon\" aria-hidden=\"true\">\n            {props.icon || props.label}\n            {props.keyBindingLabel && (\n              <span className=\"ToolIcon__keybinding\">\n                {props.keyBindingLabel}\n              </span>\n            )}\n          </div>\n        )}\n        {props.showAriaLabel && (\n          <div className=\"ToolIcon__label\">\n            {props[\"aria-label\"]} {isLoading && <Spinner />}\n          </div>\n        )}\n        {props.children}\n      </button>\n    );\n  }\n\n  return (\n    <label\n      className={clsx(\"ToolIcon\", props.className)}\n      title={props.title}\n      onPointerDown={(event) => {\n        lastPointerTypeRef.current = event.pointerType || null;\n      }}\n      onPointerUp={() => {\n        requestAnimationFrame(() => {\n          lastPointerTypeRef.current = null;\n        });\n      }}\n    >\n      <input\n        className={`ToolIcon_type_radio ${sizeCn}`}\n        type=\"radio\"\n        name={props.name}\n        aria-label={props[\"aria-label\"]}\n        aria-keyshortcuts={props[\"aria-keyshortcuts\"]}\n        data-testid={props[\"data-testid\"]}\n        id={`${excalId}-${props.id}`}\n        onChange={() => {\n          props.onChange?.({ pointerType: lastPointerTypeRef.current });\n        }}\n        checked={props.checked}\n        ref={innerRef}\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.icon}\n        {props.keyBindingLabel && (\n          <span className=\"ToolIcon__keybinding\">{props.keyBindingLabel}</span>\n        )}\n      </div>\n    </label>\n  );\n});\n\nToolButton.defaultProps = {\n  visible: true,\n  className: \"\",\n  size: \"medium\",\n};\n","//\n// All icons are imported from https://fontawesome.com/icons?d=gallery\n// Icons are under the license https://fontawesome.com/license\n//\n\n// Note: when adding new icons, review https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/RTL_Guidelines\n// to determine whether or not the icons should be mirrored in right-to-left languages.\n\nimport React from \"react\";\n\nimport oc from \"open-color\";\nimport clsx from \"clsx\";\nimport { Theme } from \"../element/types\";\nimport { THEME } from \"../constants\";\n\nconst activeElementColor = (theme: Theme) =>\n  theme === THEME.LIGHT ? oc.orange[4] : oc.orange[9];\nconst iconFillColor = (theme: Theme) =>\n  theme === THEME.LIGHT ? oc.black : oc.gray[4];\nconst handlerColor = (theme: Theme) =>\n  theme === THEME.LIGHT ? oc.white : \"#1e1e1e\";\n\ntype Opts = {\n  width?: number;\n  height?: number;\n  mirror?: true;\n} & React.SVGProps<SVGSVGElement>;\n\nexport const createIcon = (\n  d: string | React.ReactNode,\n  opts: number | Opts = 512,\n) => {\n  const {\n    width = 512,\n    height = width,\n    mirror,\n    style,\n  } = typeof opts === \"number\" ? ({ width: opts } as Opts) : opts;\n  return (\n    <svg\n      aria-hidden=\"true\"\n      focusable=\"false\"\n      role=\"img\"\n      viewBox={`0 0 ${width} ${height}`}\n      className={clsx({ \"rtl-mirror\": mirror })}\n      style={style}\n    >\n      {typeof d === \"string\" ? <path fill=\"currentColor\" d={d} /> : d}\n    </svg>\n  );\n};\n\nexport const checkIcon = createIcon(\n  <polyline fill=\"none\" stroke=\"currentColor\" points=\"20 6 9 17 4 12\" />,\n  {\n    width: 24,\n    height: 24,\n  },\n);\n\nexport const link = createIcon(\n  \"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\",\n  { mirror: true },\n);\n\nexport const save = createIcon(\n  \"M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z\",\n  { width: 448, height: 512 },\n);\n\nexport const saveAs = createIcon(\n  \"M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z\",\n  { width: 448, height: 512 },\n);\n\nexport const load = createIcon(\n  \"M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const clipboard = createIcon(\n  \"M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z\",\n  { width: 384, height: 512 },\n);\n\nexport const trash = createIcon(\n  \"M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z\",\n  { width: 448, height: 512 },\n);\n\nexport const palette = createIcon(\n  \"M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z\",\n);\n\nexport const exportFile = createIcon(\n  \"M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const exportImage = createIcon(\n  <>\n    <path d=\"M571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-187 44v-64 64z\" />\n    <path d=\"M384 121.941V128H256V0h6.059c6.362 0 12.471 2.53 16.97 7.029l97.941 97.941a24.01 24.01 0 017.03 16.971zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zm-135.455 16c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.491-48 48-48zm208 240h-256l.485-48.485L104.545 328c4.686-4.686 11.799-4.201 16.485.485L160.545 368 264.06 264.485c4.686-4.686 12.284-4.686 16.971 0L320.545 304v112z\" />\n  </>,\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const exportToFileIcon = createIcon(\n  \"M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z\",\n  { width: 512, height: 512 },\n);\n\nexport const zoomIn = createIcon(\n  \"M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const zoomOut = createIcon(\n  \"M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const done = createIcon(\n  \"M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z\",\n);\n\nexport const menu = createIcon(\n  \"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z\",\n);\n\nexport const undo = createIcon(\n  \"M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z\",\n  { mirror: true },\n);\n\nexport const redo = createIcon(\n  \"M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z\",\n  { mirror: true },\n);\n\nexport const questionCircle = createIcon(\n  \"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z\",\n  { mirror: true },\n);\n\nexport const share = createIcon(\n  \"M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z\",\n  { width: 24, height: 24 },\n);\n\nexport const shareIOS = createIcon(\n  \"M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z\",\n  { width: 24, height: 24 },\n);\n\nexport const shareWindows = createIcon(\n  <>\n    <path\n      stroke=\"currentColor\"\n      fill=\"currentColor\"\n      d=\"M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z\"\n    />\n    <path\n      stroke=\"currentColor\"\n      fill=\"currentColor\"\n      d=\"M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z\"\n    />\n  </>,\n  { width: 64, height: 64 },\n);\n\n// Icon imported form Storybook\n// Storybook is licensed under MIT https://github.com/storybookjs/storybook/blob/next/LICENSE\nexport const resetZoom = createIcon(\n  <path\n    stroke=\"currentColor\"\n    strokeWidth=\"40\"\n    fill=\"currentColor\"\n    d=\"M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z\"\n  />,\n  { width: 1024 },\n);\n\nexport const BringForwardIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M22 9.556C22 8.696 21.303 8 20.444 8H16v8H8v4.444C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path\n        d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24, mirror: true },\n  ),\n);\n\nexport const SendBackwardIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path\n        d=\"M22 9.556C22 8.696 21.303 8 20.444 8H9.556C8.696 8 8 8.697 8 9.556v10.888C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24, mirror: true },\n  ),\n);\n\nexport const BringToFrontIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M13 21a1 1 0 001 1h7a1 1 0 001-1v-7a1 1 0 00-1-1h-3v5h-5v3zM11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h3V6h5V3z\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path\n        d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24, mirror: true },\n  ),\n);\n\nexport const SendToBackIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path\n        d=\"M11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h8V3zM22 14a1 1 0 00-1-1h-7a1 1 0 00-1 1v7a1 1 0 001 1h8v-8z\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24, mirror: true },\n  ),\n);\n\n//\n// Align action icons created from scratch to match those of z-index actions\n// Note: vertical align icons are flipped so the larger item is always the\n// first one the user sees. Horizontal align icons should not be flipped since\n// that would make them lie about their function.\n//\nexport const AlignTopIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M 2,5 H 22\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n      />\n      <path\n        d=\"M 6,7 C 5.446,7 5,7.446 5,8 v 9.999992 c 0,0.554 0.446,1 1,1 h 3.0000001 c 0.554,0 0.9999999,-0.446 0.9999999,-1 V 8 C 10,7.446 9.5540001,7 9.0000001,7 Z m 9,0 c -0.554,0 -1,0.446 -1,1 v 5.999992 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 V 8 C 19,7.446 18.554,7 18,7 Z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24, mirror: true },\n  ),\n);\n\nexport const AlignBottomIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M 2,19 H 22\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n      />\n      <path\n        d=\"m 6,16.999992 c -0.554,0 -1,-0.446 -1,-1 V 6 C 5,5.446 5.446,5 6,5 H 9.0000001 C 9.5540001,5 10,5.446 10,6 v 9.999992 c 0,0.554 -0.4459999,1 -0.9999999,1 z m 9,0 c -0.554,0 -1,-0.446 -1,-1 V 10 c 0,-0.554 0.446,-1 1,-1 h 3 c 0.554,0 1,0.446 1,1 v 5.999992 c 0,0.554 -0.446,1 -1,1 z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24, mirror: true },\n  ),\n);\n\nexport const AlignLeftIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M 5,2 V 22\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n      />\n      <path\n        d=\"m 7.000004,5.999996 c 0,-0.554 0.446,-1 1,-1 h 9.999992 c 0.554,0 1,0.446 1,1 v 3.0000001 c 0,0.554 -0.446,0.9999999 -1,0.9999999 H 8.000004 c -0.554,0 -1,-0.4459999 -1,-0.9999999 z m 0,9 c 0,-0.554 0.446,-1 1,-1 h 5.999992 c 0.554,0 1,0.446 1,1 v 3 c 0,0.554 -0.446,1 -1,1 H 8.000004 c -0.554,0 -1,-0.446 -1,-1 z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24 },\n  ),\n);\n\nexport const AlignRightIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"M 19,2 V 22\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n      />\n      <path\n        d=\"m 16.999996,5.999996 c 0,-0.554 -0.446,-1 -1,-1 H 6.000004 c -0.554,0 -1,0.446 -1,1 v 3.0000001 c 0,0.554 0.446,0.9999999 1,0.9999999 h 9.999992 c 0.554,0 1,-0.4459999 1,-0.9999999 z m 0,9 c 0,-0.554 -0.446,-1 -1,-1 h -5.999992 c -0.554,0 -1,0.446 -1,1 v 3 c 0,0.554 0.446,1 1,1 h 5.999992 c 0.554,0 1,-0.446 1,-1 z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n    </>,\n    { width: 24 },\n  ),\n);\n\nexport const DistributeHorizontallyIcon = React.memo(\n  ({ theme }: { theme: Theme }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M19 5V19M5 5V19\"\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const DistributeVerticallyIcon = React.memo(\n  ({ theme }: { theme: Theme }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M5 5L19 5M5 19H19\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const CenterVerticallyIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        d=\"m 5.000004,16.999996 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -10 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z m 9,-2 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -6 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z\"\n        fill={activeElementColor(theme)}\n        stroke={activeElementColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path\n        d=\"M 2,12 H 22\"\n        fill={iconFillColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n        strokeDasharray=\"1, 2.8\"\n        strokeLinecap=\"round\"\n      />\n    </>,\n    { width: 24, mirror: true },\n  ),\n);\n\nexport const CenterHorizontallyIcon = React.memo(\n  ({ theme }: { theme: Theme }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 7 5 C 6.446 5 6 5.446 6 6 L 6 9 C 6 9.554 6.446 10 7 10 L 17 10 C 17.554 10 18 9.554 18 9 L 18 6 C 18 5.446 17.554 5 17 5 L 7 5 z M 9 14 C 8.446 14 8 14.446 8 15 L 8 18 C 8 18.554 8.446 19 9 19 L 15 19 C 15.554 19 16 18.554 16 18 L 16 15 C 16 14.446 15.554 14 15 14 L 9 14 z \"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M 12,2 V 22\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeDasharray=\"1, 2.8\"\n          strokeLinecap=\"round\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const users = createIcon(\n  \"M192 256c61.9 0 112-50.1 112-112S253.9 32 192 32 80 82.1 80 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C51.6 288 0 339.6 0 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zM480 256c53 0 96-43 96-96s-43-96-96-96-96 43-96 96 43 96 96 96zm48 32h-3.8c-13.9 4.8-28.6 8-44.2 8s-30.3-3.2-44.2-8H432c-20.4 0-39.2 5.9-55.7 15.4 24.4 26.3 39.7 61.2 39.7 99.8v38.4c0 2.2-.5 4.3-.6 6.4H592c26.5 0 48-21.5 48-48 0-61.9-50.1-112-112-112z\",\n  { width: 640, height: 512, mirror: true },\n);\n\n// not mirrored because it's inspired by a playback control, which is always RTL\nexport const start = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z\",\n);\n\nexport const stop = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z\",\n);\n\nexport const close = createIcon(\n  \"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z\",\n  { width: 352, height: 512 },\n);\n\nexport const back = createIcon(\n  \"M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z\",\n  { width: 320, height: 512, style: { marginLeft: \"-0.2rem\" }, mirror: true },\n);\n\nexport const clone = createIcon(\n  \"M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z\",\n  { mirror: true },\n);\n\n// modified https://feathericons.com/?query=shield\nexport const shield = createIcon(\n  \"M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z\",\n  { width: 24 },\n);\n\nexport const file = createIcon(\n  \"M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z\",\n  { width: 384, height: 512 },\n);\n\nexport const GroupIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path d=\"M25 26H111V111H25\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path d=\"M100 100H160V160H100\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <g\n        fill={handlerColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"6\"\n      >\n        <rect x=\"2.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n        <rect x=\"2.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n      </g>\n    </>,\n    { width: 182, height: 182, mirror: true },\n  ),\n);\n\nexport const UngroupIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path d=\"M25 26H111V111H25\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path d=\"M100 100H160V160H100\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <g\n        fill={handlerColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"6\"\n      >\n        <rect x=\"2.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n        <rect x=\"78.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"78.5\" width=\"30\" height=\"30\" />\n        <rect x=\"105.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n        <rect x=\"2.5\" y=\"102.5\" width=\"30\" height=\"30\" />\n      </g>\n    </>,\n    { width: 182, height: 182, mirror: true },\n  ),\n);\n\nexport const FillHachureIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\"\n      fill={iconFillColor(theme)}\n    />,\n    { width: 40, height: 20 },\n  ),\n);\n\nexport const FillCrossHatchIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <g fill={iconFillColor(theme)} fillRule=\"evenodd\" clipRule=\"evenodd\">\n      <path d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\" />\n      <path d=\"M14.0001 18L3.00006 4.00002L4.5727 2.76438L15.5727 16.7644L14.0001 18ZM25.0001 18L14.0001 4.00002L15.5727 2.76438L26.5727 16.7644L25.0001 18ZM36.0001 18L25.0001 4.00002L26.5727 2.76438L37.5727 16.7644L36.0001 18Z\" />\n    </g>,\n    { width: 40, height: 20 },\n  ),\n);\n\nexport const FillSolidIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(<path d=\"M2 2H38V18H2V2Z\" fill={iconFillColor(theme)} />, {\n    width: 40,\n    height: 20,\n  }),\n);\n\nexport const StrokeWidthIcon = React.memo(\n  ({ theme, strokeWidth }: { theme: Theme; strokeWidth: number }) =>\n    createIcon(\n      <path\n        d=\"M6 10H32\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={strokeWidth}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const StrokeStyleSolidIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M6 10H34\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2}\n      fill=\"none\"\n      strokeLinecap=\"round\"\n    />,\n    {\n      width: 40,\n      height: 20,\n    },\n  ),\n);\n\nexport const StrokeStyleDashedIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M6 10H34\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2.5}\n      strokeDasharray={\"10, 8\"}\n      fill=\"none\"\n      strokeLinecap=\"round\"\n    />,\n    { width: 40, height: 20 },\n  ),\n);\n\nexport const StrokeStyleDottedIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M6 10H36\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2.5}\n      strokeDasharray={\"2, 4.5\"}\n      fill=\"none\"\n      strokeLinecap=\"round\"\n    />,\n    { width: 40, height: 20 },\n  ),\n);\n\nexport const SloppinessArchitectIcon = React.memo(\n  ({ theme }: { theme: Theme }) =>\n    createIcon(\n      <path\n        d=\"M3.00098 16.1691C6.28774 13.9744 19.6399 2.8905 22.7215 3.00082C25.8041 3.11113 19.1158 15.5488 21.4962 16.8309C23.8757 18.1131 34.4155 11.7148 37.0001 10.6919\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const SloppinessArtistIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M3 17C6.68158 14.8752 16.1296 9.09849 22.0648 6.54922C28 3.99995 22.2896 13.3209 25 14C27.7104 14.6791 36.3757 9.6471 36.3757 9.6471M6.40706 15C13 11.1918 20.0468 1.51045 23.0234 3.0052C26 4.49995 20.457 12.8659 22.7285 16.4329C25 20 36.3757 13 36.3757 13\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n      fill=\"none\"\n    />,\n    { width: 40, height: 20, mirror: true },\n  ),\n);\n\nexport const SloppinessCartoonistIcon = React.memo(\n  ({ theme }: { theme: Theme }) =>\n    createIcon(\n      <path\n        d=\"M3 15.6468C6.93692 13.5378 22.5544 2.81528 26.6206 3.00242C30.6877 3.18956 25.6708 15.3346 27.4009 16.7705C29.1309 18.2055 35.4001 12.4762 37 11.6177M3.97143 10.4917C6.61158 9.24563 16.3706 2.61886 19.8104 3.01724C23.2522 3.41472 22.0773 12.2013 24.6181 12.8783C27.1598 13.5536 33.3179 8.04068 35.0571 7.07244\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const EdgeSharpIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M10 17L10 5L35 5\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n      fill=\"none\"\n    />,\n    { width: 40, height: 20, mirror: true },\n  ),\n);\n\nexport const EdgeRoundIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M10 17V15C10 8 13 5 21 5L33.5 5\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n      fill=\"none\"\n    />,\n    { width: 40, height: 20, mirror: true },\n  ),\n);\n\nexport const ArrowheadNoneIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M6 10H34\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2}\n      fill=\"none\"\n    />,\n    {\n      width: 40,\n      height: 20,\n    },\n  ),\n);\n\nexport const ArrowheadArrowIcon = React.memo(\n  ({ theme, flip = false }: { theme: Theme; flip?: boolean }) =>\n    createIcon(\n      <g\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        fill=\"none\"\n      >\n        <path d=\"M34 10H6M34 10L27 5M34 10L27 15\" />\n        <path d=\"M27.5 5L34.5 10L27.5 15\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadDotIcon = React.memo(\n  ({ theme, flip = false }: { theme: Theme; flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke={iconFillColor(theme)}\n        fill={iconFillColor(theme)}\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n      >\n        <path d=\"M32 10L6 10\" strokeWidth={2} />\n        <circle r=\"4\" transform=\"matrix(-1 0 0 1 30 10)\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadBarIcon = React.memo(\n  ({ theme, flip = false }: { theme: Theme; flip?: boolean }) =>\n    createIcon(\n      <g transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}>\n        <path\n          d=\"M34 10H5.99996M34 10L34 5M34 10L34 15\"\n          stroke={iconFillColor(theme)}\n          strokeWidth={2}\n          fill=\"none\"\n        />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadTriangleIcon = React.memo(\n  ({ theme, flip = false }: { theme: Theme; flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke={iconFillColor(theme)}\n        fill={iconFillColor(theme)}\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n      >\n        <path d=\"M32 10L6 10\" strokeWidth={2} />\n        <path d=\"M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FontSizeSmallIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      fill={iconFillColor(theme)}\n      d=\"M 0 69.092 L 0 55.03 A 124.24 124.24 0 0 0 4.706 57.02 Q 6.826 57.863 8.708 58.5 A 53.466 53.466 0 0 0 12.231 59.571 Q 17.236 60.889 21.387 60.889 A 20.909 20.909 0 0 0 24.265 60.704 Q 25.719 60.502 26.903 60.077 A 8.649 8.649 0 0 0 29.028 58.985 Q 31.689 57.08 31.689 53.321 Q 31.689 51.221 30.518 49.585 A 10.126 10.126 0 0 0 29.282 48.177 Q 28.352 47.287 27.075 46.436 A 23.719 23.719 0 0 0 25.752 45.627 Q 23.774 44.492 20.176 42.735 A 254.44 254.44 0 0 0 17.822 41.602 Q 11.503 38.631 8.236 35.888 A 19.742 19.742 0 0 1 8.008 35.694 A 22.18 22.18 0 0 1 2.783 29.102 Q 0.83 25.342 0.83 20.313 A 22.471 22.471 0 0 1 1.733 13.778 A 17.283 17.283 0 0 1 7.251 5.42 A 21.486 21.486 0 0 1 15.177 1.272 Q 18.361 0.338 22.166 0.09 A 43.573 43.573 0 0 1 25 0 A 42.399 42.399 0 0 1 34.349 1.01 A 39.075 39.075 0 0 1 35.62 1.319 A 67.407 67.407 0 0 1 42.108 3.382 A 83.357 83.357 0 0 1 46.191 5.03 L 41.309 16.797 Q 35.596 14.453 31.86 13.526 A 30.762 30.762 0 0 0 25.417 12.612 A 28.337 28.337 0 0 0 24.512 12.598 A 14.846 14.846 0 0 0 22.022 12.793 Q 19.498 13.224 17.92 14.6 Q 15.625 16.602 15.625 19.824 Q 15.625 21.826 16.553 23.316 Q 17.48 24.805 19.507 26.197 A 18.343 18.343 0 0 0 20.659 26.912 Q 22.596 28.035 26.516 29.953 A 299.99 299.99 0 0 0 29.102 31.201 Q 37.91 35.412 41.841 39.642 A 16.553 16.553 0 0 1 42.822 40.796 A 17.675 17.675 0 0 1 46.301 49.233 A 23.517 23.517 0 0 1 46.533 52.588 A 21.581 21.581 0 0 1 45.471 59.515 A 17.733 17.733 0 0 1 39.575 67.823 Q 33.745 72.486 24.094 73.243 A 49.683 49.683 0 0 1 20.215 73.389 A 51.712 51.712 0 0 1 9.448 72.315 A 40.672 40.672 0 0 1 0 69.092 Z\"\n    />,\n    { width: 47, height: 77 },\n  ),\n);\n\nexport const FontSizeMediumIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      fill={iconFillColor(theme)}\n      d=\"M 44.092 71.387 L 30.225 71.387 L 13.037 15.381 L 12.598 15.381 A 1505.093 1505.093 0 0 1 12.959 22.313 Q 13.426 31.715 13.508 36.4 A 102.991 102.991 0 0 1 13.525 38.184 L 13.525 71.387 L 0 71.387 L 0 0 L 20.605 0 L 37.5 54.59 L 37.793 54.59 L 55.713 0 L 76.318 0 L 76.318 71.387 L 62.207 71.387 L 62.207 37.598 Q 62.207 35.205 62.28 32.08 A 160.703 160.703 0 0 1 62.326 30.544 Q 62.452 26.754 62.866 17.168 A 5390.536 5390.536 0 0 1 62.939 15.479 L 62.5 15.479 L 44.092 71.387 Z\"\n    />,\n    { width: 77, height: 75 },\n  ),\n);\n\nexport const FontSizeLargeIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      fill={iconFillColor(theme)}\n      d=\"M 44.092 71.387 L 0 71.387 L 0 0 L 15.137 0 L 15.137 58.887 L 44.092 58.887 L 44.092 71.387 Z\"\n    />,\n    { width: 45, height: 75 },\n  ),\n);\n\nexport const FontSizeExtraLargeIcon = React.memo(\n  ({ theme }: { theme: Theme }) =>\n    createIcon(\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M 42.578 35.4 L 66.699 71.387 L 49.414 71.387 L 32.813 44.385 L 16.211 71.387 L 0 71.387 L 23.682 34.57 L 1.514 0 L 18.213 0 L 33.594 25.684 L 48.682 0 L 64.99 0 L 42.578 35.4 Z M 119.775 71.387 L 75.684 71.387 L 75.684 0 L 90.82 0 L 90.82 58.887 L 119.775 58.887 L 119.775 71.387 Z\"\n      />,\n      { width: 120, height: 75 },\n    ),\n);\n\nexport const FontFamilyHandDrawnIcon = React.memo(\n  ({ theme }: { theme: Theme }) =>\n    createIcon(\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z\"\n      />,\n      { width: 448, height: 512 },\n    ),\n);\n\nexport const FontFamilyNormalIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M 63.818 71.68 L 54.492 71.68 L 45.898 49.561 L 17.578 49.561 L 9.082 71.68 L 0 71.68 L 27.881 0 L 35.986 0 L 63.818 71.68 Z M 20.605 41.602 L 43.213 41.602 L 35.205 19.971 L 31.787 9.277 Q 30.322 15.137 28.711 19.971 L 20.605 41.602 Z\"\n      />\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M 68.994 71.68 L 52.686 71.68 L 47.51 54.688 L 21.484 54.688 L 16.309 71.68 L 0 71.68 L 25.195 0 L 43.701 0 L 68.994 71.68 Z M 25.293 41.992 L 43.896 41.992 A 27590.463 27590.463 0 0 1 42.2 36.532 Q 36.965 19.676 35.937 16.273 A 120.932 120.932 0 0 1 35.815 15.869 A 131.65 131.65 0 0 1 35.396 14.435 Q 34.951 12.879 34.675 11.741 A 34.866 34.866 0 0 1 34.521 11.084 A 141.762 141.762 0 0 1 33.706 14.075 Q 31.482 21.957 25.293 41.992 Z\"\n      />\n    </>,\n    { width: 70, height: 78 },\n  ),\n);\n\nexport const FontFamilyCodeIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z\"\n      />\n    </>,\n    { width: 640, height: 512 },\n  ),\n);\n\nexport const TextAlignLeftIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M12.83 352h262.34A12.82 12.82 0 00288 339.17v-38.34A12.82 12.82 0 00275.17 288H12.83A12.82 12.82 0 000 300.83v38.34A12.82 12.82 0 0012.83 352zm0-256h262.34A12.82 12.82 0 00288 83.17V44.83A12.82 12.82 0 00275.17 32H12.83A12.82 12.82 0 000 44.83v38.34A12.82 12.82 0 0012.83 96zM432 160H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zm0 256H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16z\"\n      fill={iconFillColor(theme)}\n      strokeLinecap=\"round\"\n    />,\n    { width: 448, height: 512 },\n  ),\n);\n\nexport const TextAlignCenterIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M432 160H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zm0 256H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zM108.1 96h231.81A12.09 12.09 0 00352 83.9V44.09A12.09 12.09 0 00339.91 32H108.1A12.09 12.09 0 0096 44.09V83.9A12.1 12.1 0 00108.1 96zm231.81 256A12.09 12.09 0 00352 339.9v-39.81A12.09 12.09 0 00339.91 288H108.1A12.09 12.09 0 0096 300.09v39.81a12.1 12.1 0 0012.1 12.1z\"\n      fill={iconFillColor(theme)}\n    />,\n    { width: 448, height: 512 },\n  ),\n);\n\nexport const TextAlignRightIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M16 224h416a16 16 0 0016-16v-32a16 16 0 00-16-16H16a16 16 0 00-16 16v32a16 16 0 0016 16zm416 192H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zm3.17-384H172.83A12.82 12.82 0 00160 44.83v38.34A12.82 12.82 0 00172.83 96h262.34A12.82 12.82 0 00448 83.17V44.83A12.82 12.82 0 00435.17 32zm0 256H172.83A12.82 12.82 0 00160 300.83v38.34A12.82 12.82 0 00172.83 352h262.34A12.82 12.82 0 00448 339.17v-38.34A12.82 12.82 0 00435.17 288z\"\n      fill={iconFillColor(theme)}\n      strokeLinecap=\"round\"\n    />,\n    { width: 448, height: 512 },\n  ),\n);\n","import { Action } from \"./types\";\n\nexport let actions: readonly Action[] = [];\n\nexport const register = (action: Action): Action => {\n  actions = actions.concat(action);\n  return action;\n};\n","import { isSomeElementSelected } from \"../scene\";\nimport { KEYS } from \"../keys\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { trash } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getElementsInGroup } from \"../groups\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst deleteSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return {\n    elements: elements.map((el) => {\n      if (appState.selectedElementIds[el.id]) {\n        return newElementWith(el, { isDeleted: true });\n      }\n      return el;\n    }),\n    appState: {\n      ...appState,\n      selectedElementIds: {},\n    },\n  };\n};\n\nconst handleGroupEditingState = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n): AppState => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(\n      getNonDeletedElements(elements),\n      appState.editingGroupId!,\n    );\n    if (siblingElements.length) {\n      return {\n        ...appState,\n        selectedElementIds: { [siblingElements[0].id]: true },\n      };\n    }\n  }\n  return appState;\n};\n\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        activePointIndex,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element) {\n        return false;\n      }\n      if (\n        // case: no point selected  delete whole element\n        activePointIndex == null ||\n        activePointIndex === -1 ||\n        // case: deleting last remaining point\n        element.points.length < 2\n      ) {\n        const nextElements = elements.filter((el) => el.id !== element.id);\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n\n        return {\n          elements: nextElements,\n          appState: {\n            ...nextAppState,\n            editingLinearElement: null,\n          },\n          commitToHistory: false,\n        };\n      }\n\n      // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n      const binding = {\n        startBindingElement:\n          activePointIndex === 0 ? null : startBindingElement,\n        endBindingElement:\n          activePointIndex === element.points.length - 1\n            ? null\n            : endBindingElement,\n      };\n\n      LinearElementEditor.movePoint(element, activePointIndex, \"delete\");\n\n      return {\n        elements,\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            ...binding,\n            activePointIndex: activePointIndex > 0 ? activePointIndex - 1 : 0,\n          },\n        },\n        commitToHistory: true,\n      };\n    }\n\n    let { elements: nextElements, appState: nextAppState } =\n      deleteSelectedElements(elements, appState);\n    fixBindingsAfterDeletion(\n      nextElements,\n      elements.filter(({ id }) => appState.selectedElementIds[id]),\n    );\n\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...nextAppState,\n        elementType: \"selection\",\n        multiElement: null,\n      },\n      commitToHistory: isSomeElementSelected(\n        getNonDeletedElements(elements),\n        appState,\n      ),\n    };\n  },\n  contextItemLabel: \"labels.delete\",\n  keyTest: (event) => event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={trash}\n      title={t(\"labels.delete\")}\n      aria-label={t(\"labels.delete\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { bumpVersion } from \"./element/mutateElement\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { getElementsInGroup } from \"./groups\";\nimport { AppState } from \"./types\";\nimport { findIndex, findLastIndex } from \"./utils\";\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  while (++index < elements.length) {\n    if (appState.selectedElementIds[elements[index].id]) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (elements[index].isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1))\n      : findIndex(elements, indexFilter, boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group  return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return candidateIndex;\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group  prevent\n      return -1;\n    }\n  }\n\n  if (!nextElement.groupIds.length) {\n    return candidateIndex;\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst getTargetElementsMap = (\n  elements: readonly ExcalidrawElement[],\n  indices: number[],\n) => {\n  return indices.reduce((acc, index) => {\n    const element = elements[index];\n    acc[element.id] = element;\n    return acc;\n  }, {} as Record<string, ExcalidrawElement>);\n};\n\nconst shiftElements = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  return elements.map((element) => {\n    if (targetElementsMap[element.id]) {\n      return bumpVersion(element);\n    }\n    return element;\n  });\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (!indicesToMove.includes(index)) {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const targetElements = Object.values(targetElementsMap).map((element) => {\n    return bumpVersion(element);\n  });\n\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n\n  return direction === \"left\"\n    ? [\n        ...leadingElements,\n        ...targetElements,\n        ...displacedElements,\n        ...trailingElements,\n      ]\n    : [\n        ...leadingElements,\n        ...displacedElements,\n        ...targetElements,\n        ...trailingElements,\n      ];\n};\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements, \"left\");\n};\n\nexport const moveOneRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements, \"right\");\n};\n\nexport const moveAllLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"left\");\n};\n\nexport const moveAllRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"right\");\n};\n","import React from \"react\";\nimport {\n  moveOneLeft,\n  moveOneRight,\n  moveAllLeft,\n  moveAllRight,\n} from \"../zindex\";\nimport { KEYS, isDarwin, CODES } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport {\n  SendBackwardIcon,\n  BringToFrontIcon,\n  SendToBackIcon,\n  BringForwardIcon,\n} from \"../components/icons\";\n\nexport const actionSendBackward = register({\n  name: \"sendBackward\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveOneLeft(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.sendBackward\",\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendBackward\")}  ${getShortcutKey(\"CtrlOrCmd+[\")}`}\n    >\n      <SendBackwardIcon theme={appState.theme} />\n    </button>\n  ),\n});\n\nexport const actionBringForward = register({\n  name: \"bringForward\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveOneRight(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.bringForward\",\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.bringForward\")}  ${getShortcutKey(\"CtrlOrCmd+]\")}`}\n    >\n      <BringForwardIcon theme={appState.theme} />\n    </button>\n  ),\n});\n\nexport const actionSendToBack = register({\n  name: \"sendToBack\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllLeft(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.sendToBack\",\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_LEFT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendToBack\")}  ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+[\")\n      }`}\n    >\n      <SendToBackIcon theme={appState.theme} />\n    </button>\n  ),\n});\n\nexport const actionBringToFront = register({\n  name: \"bringToFront\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllRight(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.bringToFront\",\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_RIGHT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={(event) => updateData(null)}\n      title={`${t(\"labels.bringToFront\")}  ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+]\")\n      }`}\n    >\n      <BringToFrontIcon theme={appState.theme} />\n    </button>\n  ),\n});\n","import { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { selectGroupsForSelectedElements } from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\n\nexport const actionSelectAll = register({\n  name: \"selectAll\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      return false;\n    }\n    return {\n      appState: selectGroupsForSelectedElements(\n        {\n          ...appState,\n          editingGroupId: null,\n          selectedElementIds: elements.reduce((map, element) => {\n            if (!element.isDeleted) {\n              map[element.id] = true;\n            }\n            return map;\n          }, {} as any),\n        },\n        getNonDeletedElements(elements),\n      ),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.selectAll\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A,\n});\n","import { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { clone } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport {\n  selectGroupsForSelectedElements,\n  getSelectedGroupForElement,\n  getElementsInGroup,\n} from \"../groups\";\nimport { AppState } from \"../types\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { ActionResult } from \"./types\";\nimport { GRID_SIZE } from \"../constants\";\n\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  perform: (elements, appState) => {\n    // duplicate point if selected while editing multi-point element\n    if (appState.editingLinearElement) {\n      const { activePointIndex, elementId } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element || activePointIndex === null) {\n        return false;\n      }\n      const { points } = element;\n      const selectedPoint = points[activePointIndex];\n      const nextPoint = points[activePointIndex + 1];\n      mutateElement(element, {\n        points: [\n          ...points.slice(0, activePointIndex + 1),\n          nextPoint\n            ? [\n                (selectedPoint[0] + nextPoint[0]) / 2,\n                (selectedPoint[1] + nextPoint[1]) / 2,\n              ]\n            : [selectedPoint[0] + 30, selectedPoint[1] + 30],\n          ...points.slice(activePointIndex + 1),\n        ],\n      });\n      return {\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            activePointIndex: activePointIndex + 1,\n          },\n        },\n        elements,\n        commitToHistory: true,\n      };\n    }\n\n    return {\n      ...duplicateElements(elements, appState),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={clone}\n      title={`${t(\"labels.duplicateSelection\")}  ${getShortcutKey(\n        \"CtrlOrCmd+D\",\n      )}`}\n      aria-label={t(\"labels.duplicateSelection\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nconst duplicateElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): Partial<ActionResult> => {\n  const groupIdMap = new Map();\n  const newElements: ExcalidrawElement[] = [];\n  const oldElements: ExcalidrawElement[] = [];\n  const oldIdToDuplicatedId = new Map();\n\n  const duplicateAndOffsetElement = (element: ExcalidrawElement) => {\n    const newElement = duplicateElement(\n      appState.editingGroupId,\n      groupIdMap,\n      element,\n      {\n        x: element.x + GRID_SIZE / 2,\n        y: element.y + GRID_SIZE / 2,\n      },\n    );\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n\n  const finalElements: ExcalidrawElement[] = [];\n\n  let index = 0;\n  while (index < elements.length) {\n    const element = elements[index];\n    if (appState.selectedElementIds[element.id]) {\n      if (element.groupIds.length) {\n        const groupId = getSelectedGroupForElement(appState, element);\n        // if group selected, duplicate it atomically\n        if (groupId) {\n          const groupElements = getElementsInGroup(elements, groupId);\n          finalElements.push(\n            ...groupElements,\n            ...groupElements.map((element) =>\n              duplicateAndOffsetElement(element),\n            ),\n          );\n          index = index + groupElements.length;\n          continue;\n        }\n      }\n      finalElements.push(element, duplicateAndOffsetElement(element));\n    } else {\n      finalElements.push(element);\n    }\n    index++;\n  }\n\n  fixBindingsAfterDuplication(finalElements, oldElements, oldIdToDuplicatedId);\n\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements(\n      {\n        ...appState,\n        selectedGroupIds: {},\n        selectedElementIds: newElements.reduce((acc, element) => {\n          acc[element.id] = true;\n          return acc;\n        }, {} as any),\n      },\n      getNonDeletedElements(finalElements),\n    ),\n  };\n};\n","import clsx from \"clsx\";\n\n// TODO: It might be \"clever\" to add option.icon to the existing component <ButtonSelect />\nexport const ButtonIconSelect = <T extends Object>({\n  options,\n  value,\n  onChange,\n  group,\n}: {\n  options: { value: T; text: string; icon: JSX.Element }[];\n  value: T | null;\n  onChange: (value: T) => void;\n  group: string;\n}) => (\n  <div className=\"buttonList buttonListIcon\">\n    {options.map((option) => (\n      <label\n        key={option.text}\n        className={clsx({ active: value === option.value })}\n        title={option.text}\n      >\n        <input\n          type=\"radio\"\n          name={group}\n          onChange={() => onChange(option.value)}\n          checked={value === option.value}\n        />\n        {option.icon}\n      </label>\n    ))}\n  </div>\n);\n","import React, { useLayoutEffect, useRef, useEffect } from \"react\";\nimport \"./Popover.scss\";\nimport { unstable_batchedUpdates } from \"react-dom\";\n\ntype Props = {\n  top?: number;\n  left?: number;\n  children?: React.ReactNode;\n  onCloseRequest?(event: PointerEvent): void;\n  fitInViewport?: boolean;\n};\n\nexport const Popover = ({\n  children,\n  left,\n  top,\n  onCloseRequest,\n  fitInViewport = false,\n}: Props) => {\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  // ensure the popover doesn't overflow the viewport\n  useLayoutEffect(() => {\n    if (fitInViewport && popoverRef.current) {\n      const element = popoverRef.current;\n      const { x, y, width, height } = element.getBoundingClientRect();\n\n      const viewportWidth = window.innerWidth;\n      if (x + width > viewportWidth) {\n        element.style.left = `${viewportWidth - width}px`;\n      }\n      const viewportHeight = window.innerHeight;\n      if (y + height > viewportHeight) {\n        element.style.top = `${viewportHeight - height}px`;\n      }\n    }\n  }, [fitInViewport]);\n\n  useEffect(() => {\n    if (onCloseRequest) {\n      const handler = (event: PointerEvent) => {\n        if (!popoverRef.current?.contains(event.target as Node)) {\n          unstable_batchedUpdates(() => onCloseRequest(event));\n        }\n      };\n      document.addEventListener(\"pointerdown\", handler, false);\n      return () => document.removeEventListener(\"pointerdown\", handler, false);\n    }\n  }, [onCloseRequest]);\n\n  return (\n    <div className=\"popover\" style={{ top, left }} ref={popoverRef}>\n      {children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\nimport { isTransparent } from \"../utils\";\n\nimport \"./ColorPicker.scss\";\nimport { isArrowKey, KEYS } from \"../keys\";\nimport { t, getLanguage } from \"../i18n\";\nimport { isWritableElement } from \"../utils\";\nimport colors from \"../colors\";\n\nconst isValidColor = (color: string) => {\n  const style = new Option().style;\n  style.color = color;\n  return !!style.color;\n};\n\nconst getColor = (color: string): string | null => {\n  if (isTransparent(color)) {\n    return color;\n  }\n\n  return isValidColor(color)\n    ? color\n    : isValidColor(`#${color}`)\n    ? `#${color}`\n    : null;\n};\n\n// This is a narrow reimplementation of the awesome react-color Twitter component\n// https://github.com/casesandberg/react-color/blob/master/src/components/twitter/Twitter.js\n\n// Unfortunately, we can't detect keyboard layout in the browser. So this will\n// only work well for QWERTY but not AZERTY or others...\nconst keyBindings = [\n  [\"1\", \"2\", \"3\", \"4\", \"5\"],\n  [\"q\", \"w\", \"e\", \"r\", \"t\"],\n  [\"a\", \"s\", \"d\", \"f\", \"g\"],\n].flat();\n\nconst Picker = ({\n  colors,\n  color,\n  onChange,\n  onClose,\n  label,\n  showInput = true,\n  type,\n}: {\n  colors: string[];\n  color: string | null;\n  onChange: (color: string) => void;\n  onClose: () => void;\n  label: string;\n  showInput: boolean;\n  type: \"canvasBackground\" | \"elementBackground\" | \"elementStroke\";\n}) => {\n  const firstItem = React.useRef<HTMLButtonElement>();\n  const activeItem = React.useRef<HTMLButtonElement>();\n  const gallery = React.useRef<HTMLDivElement>();\n  const colorInput = React.useRef<HTMLInputElement>();\n\n  React.useEffect(() => {\n    // After the component is first mounted focus on first input\n    if (activeItem.current) {\n      activeItem.current.focus();\n    } else if (colorInput.current) {\n      colorInput.current.focus();\n    } else if (gallery.current) {\n      gallery.current.focus();\n    }\n  }, []);\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (event.key === KEYS.TAB) {\n      const { activeElement } = document;\n      if (event.shiftKey) {\n        if (activeElement === firstItem.current) {\n          colorInput.current?.focus();\n          event.preventDefault();\n        }\n      } else if (activeElement === colorInput.current) {\n        firstItem.current?.focus();\n        event.preventDefault();\n      }\n    } else if (isArrowKey(event.key)) {\n      const { activeElement } = document;\n      const isRTL = getLanguage().rtl;\n      const index = Array.prototype.indexOf.call(\n        gallery!.current!.children,\n        activeElement,\n      );\n      if (index !== -1) {\n        const length = gallery!.current!.children.length - (showInput ? 1 : 0);\n        const nextIndex =\n          event.key === (isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT)\n            ? (index + 1) % length\n            : event.key === (isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT)\n            ? (length + index - 1) % length\n            : event.key === KEYS.ARROW_DOWN\n            ? (index + 5) % length\n            : event.key === KEYS.ARROW_UP\n            ? (length + index - 5) % length\n            : index;\n        (gallery!.current!.children![nextIndex] as any).focus();\n      }\n      event.preventDefault();\n    } else if (\n      keyBindings.includes(event.key.toLowerCase()) &&\n      !isWritableElement(event.target)\n    ) {\n      const index = keyBindings.indexOf(event.key.toLowerCase());\n      (gallery!.current!.children![index] as any).focus();\n      event.preventDefault();\n    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n      event.preventDefault();\n      onClose();\n    }\n    event.nativeEvent.stopImmediatePropagation();\n    event.stopPropagation();\n  };\n\n  return (\n    <div\n      className={`color-picker color-picker-type-${type}`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={t(\"labels.colorPicker\")}\n      onKeyDown={handleKeyDown}\n    >\n      <div className=\"color-picker-triangle color-picker-triangle-shadow\"></div>\n      <div className=\"color-picker-triangle\"></div>\n      <div\n        className=\"color-picker-content\"\n        ref={(el) => {\n          if (el) {\n            gallery.current = el;\n          }\n        }}\n        tabIndex={0}\n      >\n        {colors.map((_color, i) => {\n          const _colorWithoutHash = _color.replace(\"#\", \"\");\n          return (\n            <button\n              className=\"color-picker-swatch\"\n              onClick={(event) => {\n                (event.currentTarget as HTMLButtonElement).focus();\n                onChange(_color);\n              }}\n              title={`${t(`colors.${_colorWithoutHash}`)}${\n                !isTransparent(_color) ? ` (${_color})` : \"\"\n              }  ${keyBindings[i].toUpperCase()}`}\n              aria-label={t(`colors.${_colorWithoutHash}`)}\n              aria-keyshortcuts={keyBindings[i]}\n              style={{ color: _color }}\n              key={_color}\n              ref={(el) => {\n                if (el && i === 0) {\n                  firstItem.current = el;\n                }\n                if (el && _color === color) {\n                  activeItem.current = el;\n                }\n              }}\n              onFocus={() => {\n                onChange(_color);\n              }}\n            >\n              {isTransparent(_color) ? (\n                <div className=\"color-picker-transparent\"></div>\n              ) : undefined}\n              <span className=\"color-picker-keybinding\">{keyBindings[i]}</span>\n            </button>\n          );\n        })}\n        {showInput && (\n          <ColorInput\n            color={color}\n            label={label}\n            onChange={(color) => {\n              onChange(color);\n            }}\n            ref={colorInput}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst ColorInput = React.forwardRef(\n  (\n    {\n      color,\n      onChange,\n      label,\n    }: {\n      color: string | null;\n      onChange: (color: string) => void;\n      label: string;\n    },\n    ref,\n  ) => {\n    const [innerValue, setInnerValue] = React.useState(color);\n    const inputRef = React.useRef(null);\n\n    React.useEffect(() => {\n      setInnerValue(color);\n    }, [color]);\n\n    React.useImperativeHandle(ref, () => inputRef.current);\n\n    const changeColor = React.useCallback(\n      (inputValue: string) => {\n        const value = inputValue.toLowerCase();\n        const color = getColor(value);\n        if (color) {\n          onChange(color);\n        }\n        setInnerValue(value);\n      },\n      [onChange],\n    );\n\n    return (\n      <label className=\"color-input-container\">\n        <div className=\"color-picker-hash\">#</div>\n        <input\n          spellCheck={false}\n          className=\"color-picker-input\"\n          aria-label={label}\n          onChange={(event) => changeColor(event.target.value)}\n          value={(innerValue || \"\").replace(/^#/, \"\")}\n          onBlur={() => setInnerValue(color)}\n          ref={inputRef}\n        />\n      </label>\n    );\n  },\n);\n\nexport const ColorPicker = ({\n  type,\n  color,\n  onChange,\n  label,\n  isActive,\n  setActive,\n}: {\n  type: \"canvasBackground\" | \"elementBackground\" | \"elementStroke\";\n  color: string | null;\n  onChange: (color: string) => void;\n  label: string;\n  isActive: boolean;\n  setActive: (active: boolean) => void;\n}) => {\n  const pickerButton = React.useRef<HTMLButtonElement>(null);\n\n  return (\n    <div>\n      <div className=\"color-picker-control-container\">\n        <button\n          className=\"color-picker-label-swatch\"\n          aria-label={label}\n          style={color ? { \"--swatch-color\": color } : undefined}\n          onClick={() => setActive(!isActive)}\n          ref={pickerButton}\n        />\n        <ColorInput\n          color={color}\n          label={label}\n          onChange={(color) => {\n            onChange(color);\n          }}\n        />\n      </div>\n      <React.Suspense fallback=\"\">\n        {isActive ? (\n          <Popover\n            onCloseRequest={(event) =>\n              event.target !== pickerButton.current && setActive(false)\n            }\n          >\n            <Picker\n              colors={colors[type]}\n              color={color || null}\n              onChange={(changedColor) => {\n                onChange(changedColor);\n              }}\n              onClose={() => {\n                setActive(false);\n                pickerButton.current?.focus();\n              }}\n              label={label}\n              showInput={false}\n              type={type}\n            />\n          </Popover>\n        ) : null}\n      </React.Suspense>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\n\nimport \"./IconPicker.scss\";\nimport { isArrowKey, KEYS } from \"../keys\";\nimport { getLanguage } from \"../i18n\";\n\nfunction Picker<T>({\n  options,\n  value,\n  label,\n  onChange,\n  onClose,\n}: {\n  label: string;\n  value: T;\n  options: { value: T; text: string; icon: JSX.Element; keyBinding: string }[];\n  onChange: (value: T) => void;\n  onClose: () => void;\n}) {\n  const rFirstItem = React.useRef<HTMLButtonElement>();\n  const rActiveItem = React.useRef<HTMLButtonElement>();\n  const rGallery = React.useRef<HTMLDivElement>(null);\n\n  React.useEffect(() => {\n    // After the component is first mounted focus on first input\n    if (rActiveItem.current) {\n      rActiveItem.current.focus();\n    } else if (rGallery.current) {\n      rGallery.current.focus();\n    }\n  }, []);\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    const pressedOption = options.find(\n      (option) => option.keyBinding === event.key.toLowerCase(),\n    )!;\n\n    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {\n      // Keybinding navigation\n      const index = options.indexOf(pressedOption);\n      (rGallery!.current!.children![index] as any).focus();\n      event.preventDefault();\n    } else if (event.key === KEYS.TAB) {\n      // Tab navigation cycle through options. If the user tabs\n      // away from the picker, close the picker. We need to use\n      // a timeout here to let the stack clear before checking.\n      setTimeout(() => {\n        const active = rActiveItem.current;\n        const docActive = document.activeElement;\n        if (active !== docActive) {\n          onClose();\n        }\n      }, 0);\n    } else if (isArrowKey(event.key)) {\n      // Arrow navigation\n      const { activeElement } = document;\n      const isRTL = getLanguage().rtl;\n      const index = Array.prototype.indexOf.call(\n        rGallery!.current!.children,\n        activeElement,\n      );\n      if (index !== -1) {\n        const length = options.length;\n        let nextIndex = index;\n\n        switch (event.key) {\n          // Select the next option\n          case isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT:\n          case KEYS.ARROW_DOWN: {\n            nextIndex = (index + 1) % length;\n            break;\n          }\n          // Select the previous option\n          case isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT:\n          case KEYS.ARROW_UP: {\n            nextIndex = (length + index - 1) % length;\n            break;\n          }\n        }\n\n        (rGallery.current!.children![nextIndex] as any).focus();\n      }\n      event.preventDefault();\n    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n      // Close on escape or enter\n      event.preventDefault();\n      onClose();\n    }\n    event.nativeEvent.stopImmediatePropagation();\n    event.stopPropagation();\n  };\n\n  return (\n    <div\n      className={`picker`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={label}\n      onKeyDown={handleKeyDown}\n    >\n      <div className=\"picker-content\" ref={rGallery}>\n        {options.map((option, i) => (\n          <button\n            className=\"picker-option\"\n            onClick={(event) => {\n              (event.currentTarget as HTMLButtonElement).focus();\n              onChange(option.value);\n            }}\n            title={`${option.text}  ${option.keyBinding.toUpperCase()}`}\n            aria-label={option.text || \"none\"}\n            aria-keyshortcuts={option.keyBinding}\n            key={option.text}\n            ref={(el) => {\n              if (el && i === 0) {\n                rFirstItem.current = el;\n              }\n              if (el && option.value === value) {\n                rActiveItem.current = el;\n              }\n            }}\n            onFocus={() => {\n              onChange(option.value);\n            }}\n          >\n            {option.icon}\n            <span className=\"picker-keybinding\">{option.keyBinding}</span>\n          </button>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport function IconPicker<T>({\n  value,\n  label,\n  options,\n  onChange,\n  group = \"\",\n}: {\n  label: string;\n  value: T;\n  options: { value: T; text: string; icon: JSX.Element; keyBinding: string }[];\n  onChange: (value: T) => void;\n  group?: string;\n}) {\n  const [isActive, setActive] = React.useState(false);\n  const rPickerButton = React.useRef<any>(null);\n  const isRTL = getLanguage().rtl;\n\n  return (\n    <label className={\"picker-container\"}>\n      <button\n        name={group}\n        className={isActive ? \"active\" : \"\"}\n        aria-label={label}\n        onClick={() => setActive(!isActive)}\n        ref={rPickerButton}\n      >\n        {options.find((option) => option.value === value)?.icon}\n      </button>\n      <React.Suspense fallback=\"\">\n        {isActive ? (\n          <>\n            <Popover\n              onCloseRequest={(event) =>\n                event.target !== rPickerButton.current && setActive(false)\n              }\n              {...(isRTL ? { right: 5.5 } : { left: -5.5 })}\n            >\n              <Picker\n                options={options}\n                value={value}\n                label={label}\n                onChange={onChange}\n                onClose={() => {\n                  setActive(false);\n                  rPickerButton.current?.focus();\n                }}\n              />\n            </Popover>\n            <div className=\"picker-triangle\" />\n          </>\n        ) : null}\n      </React.Suspense>\n    </label>\n  );\n}\n","import { AppState } from \"../../src/types\";\nimport { ButtonIconSelect } from \"../components/ButtonIconSelect\";\nimport { ColorPicker } from \"../components/ColorPicker\";\nimport { IconPicker } from \"../components/IconPicker\";\nimport {\n  ArrowheadArrowIcon,\n  ArrowheadBarIcon,\n  ArrowheadDotIcon,\n  ArrowheadTriangleIcon,\n  ArrowheadNoneIcon,\n  EdgeRoundIcon,\n  EdgeSharpIcon,\n  FillCrossHatchIcon,\n  FillHachureIcon,\n  FillSolidIcon,\n  FontFamilyCodeIcon,\n  FontFamilyHandDrawnIcon,\n  FontFamilyNormalIcon,\n  FontSizeExtraLargeIcon,\n  FontSizeLargeIcon,\n  FontSizeMediumIcon,\n  FontSizeSmallIcon,\n  SloppinessArchitectIcon,\n  SloppinessArtistIcon,\n  SloppinessCartoonistIcon,\n  StrokeStyleDashedIcon,\n  StrokeStyleDottedIcon,\n  StrokeStyleSolidIcon,\n  StrokeWidthIcon,\n  TextAlignCenterIcon,\n  TextAlignLeftIcon,\n  TextAlignRightIcon,\n} from \"../components/icons\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  FONT_FAMILY,\n} from \"../constants\";\nimport {\n  getNonDeletedElements,\n  isTextElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { isLinearElement, isLinearElementType } from \"../element/typeChecks\";\nimport {\n  Arrowhead,\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  FontFamilyValues,\n  TextAlign,\n} from \"../element/types\";\nimport { getLanguage, t } from \"../i18n\";\nimport { randomInteger } from \"../random\";\nimport {\n  canChangeSharpness,\n  canHaveArrowheads,\n  getCommonAttributeOfSelectedElements,\n  getTargetElements,\n  isSomeElementSelected,\n} from \"../scene\";\nimport { hasStrokeColor } from \"../scene/comparisons\";\nimport { register } from \"./register\";\n\nconst changeProperty = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  callback: (element: ExcalidrawElement) => ExcalidrawElement,\n) => {\n  return elements.map((element) => {\n    if (\n      appState.selectedElementIds[element.id] ||\n      element.id === appState.editingElement?.id\n    ) {\n      return callback(element);\n    }\n    return element;\n  });\n};\n\nconst getFormValue = function <T>(\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  getAttribute: (element: ExcalidrawElement) => T,\n  defaultValue?: T,\n): T | null {\n  const editingElement = appState.editingElement;\n  const nonDeletedElements = getNonDeletedElements(elements);\n  return (\n    (editingElement && getAttribute(editingElement)) ??\n    (isSomeElementSelected(nonDeletedElements, appState)\n      ? getCommonAttributeOfSelectedElements(\n          nonDeletedElements,\n          appState,\n          getAttribute,\n        )\n      : defaultValue) ??\n    null\n  );\n};\n\nexport const actionChangeStrokeColor = register({\n  name: \"changeStrokeColor\",\n  perform: (elements, appState, value) => {\n    return {\n      ...(value.currentItemStrokeColor && {\n        elements: changeProperty(elements, appState, (el) => {\n          return hasStrokeColor(el.type)\n            ? newElementWith(el, {\n                strokeColor: value.currentItemStrokeColor,\n              })\n            : el;\n        }),\n      }),\n      appState: {\n        ...appState,\n        ...value,\n      },\n      commitToHistory: !!value.currentItemStrokeColor,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.stroke\")}</h3>\n      <ColorPicker\n        type=\"elementStroke\"\n        label={t(\"labels.stroke\")}\n        color={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeColor,\n          appState.currentItemStrokeColor,\n        )}\n        onChange={(color) => updateData({ currentItemStrokeColor: color })}\n        isActive={appState.openPopup === \"strokeColorPicker\"}\n        setActive={(active) =>\n          updateData({ openPopup: active ? \"strokeColorPicker\" : null })\n        }\n      />\n    </>\n  ),\n});\n\nexport const actionChangeBackgroundColor = register({\n  name: \"changeBackgroundColor\",\n  perform: (elements, appState, value) => {\n    return {\n      ...(value.currentItemBackgroundColor && {\n        elements: changeProperty(elements, appState, (el) =>\n          newElementWith(el, {\n            backgroundColor: value.currentItemBackgroundColor,\n          }),\n        ),\n      }),\n      appState: {\n        ...appState,\n        ...value,\n      },\n      commitToHistory: !!value.currentItemBackgroundColor,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.background\")}</h3>\n      <ColorPicker\n        type=\"elementBackground\"\n        label={t(\"labels.background\")}\n        color={getFormValue(\n          elements,\n          appState,\n          (element) => element.backgroundColor,\n          appState.currentItemBackgroundColor,\n        )}\n        onChange={(color) => updateData({ currentItemBackgroundColor: color })}\n        isActive={appState.openPopup === \"backgroundColorPicker\"}\n        setActive={(active) =>\n          updateData({ openPopup: active ? \"backgroundColorPicker\" : null })\n        }\n      />\n    </>\n  ),\n});\n\nexport const actionChangeFillStyle = register({\n  name: \"changeFillStyle\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          fillStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemFillStyle: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.fill\")}</legend>\n      <ButtonIconSelect\n        options={[\n          {\n            value: \"hachure\",\n            text: t(\"labels.hachure\"),\n            icon: <FillHachureIcon theme={appState.theme} />,\n          },\n          {\n            value: \"cross-hatch\",\n            text: t(\"labels.crossHatch\"),\n            icon: <FillCrossHatchIcon theme={appState.theme} />,\n          },\n          {\n            value: \"solid\",\n            text: t(\"labels.solid\"),\n            icon: <FillSolidIcon theme={appState.theme} />,\n          },\n        ]}\n        group=\"fill\"\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.fillStyle,\n          appState.currentItemFillStyle,\n        )}\n        onChange={(value) => {\n          updateData(value);\n        }}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeStrokeWidth = register({\n  name: \"changeStrokeWidth\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeWidth: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeWidth: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeWidth\")}</legend>\n      <ButtonIconSelect\n        group=\"stroke-width\"\n        options={[\n          {\n            value: 1,\n            text: t(\"labels.thin\"),\n            icon: <StrokeWidthIcon theme={appState.theme} strokeWidth={2} />,\n          },\n          {\n            value: 2,\n            text: t(\"labels.bold\"),\n            icon: <StrokeWidthIcon theme={appState.theme} strokeWidth={6} />,\n          },\n          {\n            value: 4,\n            text: t(\"labels.extraBold\"),\n            icon: <StrokeWidthIcon theme={appState.theme} strokeWidth={10} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeWidth,\n          appState.currentItemStrokeWidth,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeSloppiness = register({\n  name: \"changeSloppiness\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          seed: randomInteger(),\n          roughness: value,\n        }),\n      ),\n      appState: { ...appState, currentItemRoughness: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.sloppiness\")}</legend>\n      <ButtonIconSelect\n        group=\"sloppiness\"\n        options={[\n          {\n            value: 0,\n            text: t(\"labels.architect\"),\n            icon: <SloppinessArchitectIcon theme={appState.theme} />,\n          },\n          {\n            value: 1,\n            text: t(\"labels.artist\"),\n            icon: <SloppinessArtistIcon theme={appState.theme} />,\n          },\n          {\n            value: 2,\n            text: t(\"labels.cartoonist\"),\n            icon: <SloppinessCartoonistIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.roughness,\n          appState.currentItemRoughness,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeStrokeStyle = register({\n  name: \"changeStrokeStyle\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeStyle: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeStyle\")}</legend>\n      <ButtonIconSelect\n        group=\"strokeStyle\"\n        options={[\n          {\n            value: \"solid\",\n            text: t(\"labels.strokeStyle_solid\"),\n            icon: <StrokeStyleSolidIcon theme={appState.theme} />,\n          },\n          {\n            value: \"dashed\",\n            text: t(\"labels.strokeStyle_dashed\"),\n            icon: <StrokeStyleDashedIcon theme={appState.theme} />,\n          },\n          {\n            value: \"dotted\",\n            text: t(\"labels.strokeStyle_dotted\"),\n            icon: <StrokeStyleDottedIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeStyle,\n          appState.currentItemStrokeStyle,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeOpacity = register({\n  name: \"changeOpacity\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          opacity: value,\n        }),\n      ),\n      appState: { ...appState, currentItemOpacity: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <label className=\"control-label\">\n      {t(\"labels.opacity\")}\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"100\"\n        step=\"10\"\n        onChange={(event) => updateData(+event.target.value)}\n        onWheel={(event) => {\n          event.stopPropagation();\n          const target = event.target as HTMLInputElement;\n          const STEP = 10;\n          const MAX = 100;\n          const MIN = 0;\n          const value = +target.value;\n\n          if (event.deltaY < 0 && value < MAX) {\n            updateData(value + STEP);\n          } else if (event.deltaY > 0 && value > MIN) {\n            updateData(value - STEP);\n          }\n        }}\n        value={\n          getFormValue(\n            elements,\n            appState,\n            (element) => element.opacity,\n            appState.currentItemOpacity,\n          ) ?? undefined\n        }\n      />\n    </label>\n  ),\n});\n\nexport const actionChangeFontSize = register({\n  name: \"changeFontSize\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            fontSize: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemFontSize: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.fontSize\")}</legend>\n      <ButtonIconSelect\n        group=\"font-size\"\n        options={[\n          {\n            value: 16,\n            text: t(\"labels.small\"),\n            icon: <FontSizeSmallIcon theme={appState.theme} />,\n          },\n          {\n            value: 20,\n            text: t(\"labels.medium\"),\n            icon: <FontSizeMediumIcon theme={appState.theme} />,\n          },\n          {\n            value: 28,\n            text: t(\"labels.large\"),\n            icon: <FontSizeLargeIcon theme={appState.theme} />,\n          },\n          {\n            value: 36,\n            text: t(\"labels.veryLarge\"),\n            icon: <FontSizeExtraLargeIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => isTextElement(element) && element.fontSize,\n          appState.currentItemFontSize || DEFAULT_FONT_SIZE,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeFontFamily = register({\n  name: \"changeFontFamily\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            fontFamily: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemFontFamily: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const options: {\n      value: FontFamilyValues;\n      text: string;\n      icon: JSX.Element;\n    }[] = [\n      {\n        value: FONT_FAMILY.Virgil,\n        text: t(\"labels.handDrawn\"),\n        icon: <FontFamilyHandDrawnIcon theme={appState.theme} />,\n      },\n      {\n        value: FONT_FAMILY.Helvetica,\n        text: t(\"labels.normal\"),\n        icon: <FontFamilyNormalIcon theme={appState.theme} />,\n      },\n      {\n        value: FONT_FAMILY.Cascadia,\n        text: t(\"labels.code\"),\n        icon: <FontFamilyCodeIcon theme={appState.theme} />,\n      },\n    ];\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.fontFamily\")}</legend>\n        <ButtonIconSelect<FontFamilyValues | false>\n          group=\"font-family\"\n          options={options}\n          value={getFormValue(\n            elements,\n            appState,\n            (element) => isTextElement(element) && element.fontFamily,\n            appState.currentItemFontFamily || DEFAULT_FONT_FAMILY,\n          )}\n          onChange={(value) => updateData(value)}\n        />\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeTextAlign = register({\n  name: \"changeTextAlign\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            textAlign: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemTextAlign: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.textAlign\")}</legend>\n      <ButtonIconSelect<TextAlign | false>\n        group=\"text-align\"\n        options={[\n          {\n            value: \"left\",\n            text: t(\"labels.left\"),\n            icon: <TextAlignLeftIcon theme={appState.theme} />,\n          },\n          {\n            value: \"center\",\n            text: t(\"labels.center\"),\n            icon: <TextAlignCenterIcon theme={appState.theme} />,\n          },\n          {\n            value: \"right\",\n            text: t(\"labels.right\"),\n            icon: <TextAlignRightIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => isTextElement(element) && element.textAlign,\n          appState.currentItemTextAlign,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeSharpness = register({\n  name: \"changeSharpness\",\n  perform: (elements, appState, value) => {\n    const targetElements = getTargetElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    const shouldUpdateForNonLinearElements = targetElements.length\n      ? targetElements.every((el) => !isLinearElement(el))\n      : !isLinearElementType(appState.elementType);\n    const shouldUpdateForLinearElements = targetElements.length\n      ? targetElements.every(isLinearElement)\n      : isLinearElementType(appState.elementType);\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeSharpness: value,\n        }),\n      ),\n      appState: {\n        ...appState,\n        currentItemStrokeSharpness: shouldUpdateForNonLinearElements\n          ? value\n          : appState.currentItemStrokeSharpness,\n        currentItemLinearStrokeSharpness: shouldUpdateForLinearElements\n          ? value\n          : appState.currentItemLinearStrokeSharpness,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.edges\")}</legend>\n      <ButtonIconSelect\n        group=\"edges\"\n        options={[\n          {\n            value: \"sharp\",\n            text: t(\"labels.sharp\"),\n            icon: <EdgeSharpIcon theme={appState.theme} />,\n          },\n          {\n            value: \"round\",\n            text: t(\"labels.round\"),\n            icon: <EdgeRoundIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeSharpness,\n          (canChangeSharpness(appState.elementType) &&\n            (isLinearElementType(appState.elementType)\n              ? appState.currentItemLinearStrokeSharpness\n              : appState.currentItemStrokeSharpness)) ||\n            null,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeArrowhead = register({\n  name: \"changeArrowhead\",\n  perform: (\n    elements,\n    appState,\n    value: { position: \"start\" | \"end\"; type: Arrowhead },\n  ) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isLinearElement(el)) {\n          const { position, type } = value;\n\n          if (position === \"start\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              startArrowhead: type,\n            });\n            return element;\n          } else if (position === \"end\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              endArrowhead: type,\n            });\n            return element;\n          }\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        [value.position === \"start\"\n          ? \"currentItemStartArrowhead\"\n          : \"currentItemEndArrowhead\"]: value.type,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const isRTL = getLanguage().rtl;\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.arrowheads\")}</legend>\n        <div className=\"iconSelectList\">\n          <IconPicker\n            label=\"arrowhead_start\"\n            options={[\n              {\n                value: null,\n                text: t(\"labels.arrowhead_none\"),\n                icon: <ArrowheadNoneIcon theme={appState.theme} />,\n                keyBinding: \"q\",\n              },\n              {\n                value: \"arrow\",\n                text: t(\"labels.arrowhead_arrow\"),\n                icon: (\n                  <ArrowheadArrowIcon theme={appState.theme} flip={!isRTL} />\n                ),\n                keyBinding: \"w\",\n              },\n              {\n                value: \"bar\",\n                text: t(\"labels.arrowhead_bar\"),\n                icon: <ArrowheadBarIcon theme={appState.theme} flip={!isRTL} />,\n                keyBinding: \"e\",\n              },\n              {\n                value: \"dot\",\n                text: t(\"labels.arrowhead_dot\"),\n                icon: <ArrowheadDotIcon theme={appState.theme} flip={!isRTL} />,\n                keyBinding: \"r\",\n              },\n              {\n                value: \"triangle\",\n                text: t(\"labels.arrowhead_triangle\"),\n                icon: (\n                  <ArrowheadTriangleIcon theme={appState.theme} flip={!isRTL} />\n                ),\n                keyBinding: \"t\",\n              },\n            ]}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              appState,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.startArrowhead\n                  : appState.currentItemStartArrowhead,\n              appState.currentItemStartArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"start\", type: value })}\n          />\n          <IconPicker\n            label=\"arrowhead_end\"\n            group=\"arrowheads\"\n            options={[\n              {\n                value: null,\n                text: t(\"labels.arrowhead_none\"),\n                keyBinding: \"q\",\n                icon: <ArrowheadNoneIcon theme={appState.theme} />,\n              },\n              {\n                value: \"arrow\",\n                text: t(\"labels.arrowhead_arrow\"),\n                keyBinding: \"w\",\n                icon: (\n                  <ArrowheadArrowIcon theme={appState.theme} flip={isRTL} />\n                ),\n              },\n              {\n                value: \"bar\",\n                text: t(\"labels.arrowhead_bar\"),\n                keyBinding: \"e\",\n                icon: <ArrowheadBarIcon theme={appState.theme} flip={isRTL} />,\n              },\n              {\n                value: \"dot\",\n                text: t(\"labels.arrowhead_dot\"),\n                keyBinding: \"r\",\n                icon: <ArrowheadDotIcon theme={appState.theme} flip={isRTL} />,\n              },\n              {\n                value: \"triangle\",\n                text: t(\"labels.arrowhead_triangle\"),\n                icon: (\n                  <ArrowheadTriangleIcon theme={appState.theme} flip={isRTL} />\n                ),\n                keyBinding: \"t\",\n              },\n            ]}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              appState,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.endArrowhead\n                  : appState.currentItemEndArrowhead,\n              appState.currentItemEndArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"end\", type: value })}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n","import \"./ToolIcon.scss\";\n\nimport { t } from \"../i18n\";\nimport { ToolButton } from \"./ToolButton\";\nimport { THEME } from \"../constants\";\nimport { Theme } from \"../element/types\";\n\n// We chose to use only explicit toggle and not a third option for system value,\n// but this could be added in the future.\nexport const DarkModeToggle = (props: {\n  value: Theme;\n  onChange: (value: Theme) => void;\n  title?: string;\n}) => {\n  const title =\n    props.title ||\n    (props.value === \"dark\" ? t(\"buttons.lightMode\") : t(\"buttons.darkMode\"));\n\n  return (\n    <ToolButton\n      type=\"icon\"\n      icon={props.value === THEME.LIGHT ? ICONS.MOON : ICONS.SUN}\n      title={title}\n      aria-label={title}\n      onClick={() =>\n        props.onChange(props.value === THEME.DARK ? THEME.LIGHT : THEME.DARK)\n      }\n      data-testid=\"toggle-dark-mode\"\n    />\n  );\n};\n\nconst ICONS = {\n  SUN: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z\"\n      ></path>\n    </svg>\n  ),\n  MOON: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z\"\n      ></path>\n    </svg>\n  ),\n};\n","import \"./Tooltip.scss\";\n\nimport React, { useEffect } from \"react\";\n\nconst getTooltipDiv = () => {\n  const existingDiv = document.querySelector<HTMLDivElement>(\n    \".excalidraw-tooltip\",\n  );\n  if (existingDiv) {\n    return existingDiv;\n  }\n  const div = document.createElement(\"div\");\n  document.body.appendChild(div);\n  div.classList.add(\"excalidraw-tooltip\");\n  return div;\n};\n\nconst updateTooltip = (\n  item: HTMLDivElement,\n  tooltip: HTMLDivElement,\n  label: string,\n  long: boolean,\n) => {\n  tooltip.classList.add(\"excalidraw-tooltip--visible\");\n  tooltip.style.minWidth = long ? \"50ch\" : \"10ch\";\n  tooltip.style.maxWidth = long ? \"50ch\" : \"15ch\";\n\n  tooltip.textContent = label;\n\n  const {\n    x: itemX,\n    bottom: itemBottom,\n    top: itemTop,\n    width: itemWidth,\n  } = item.getBoundingClientRect();\n\n  const { width: labelWidth, height: labelHeight } =\n    tooltip.getBoundingClientRect();\n\n  const viewportWidth = window.innerWidth;\n  const viewportHeight = window.innerHeight;\n\n  const margin = 5;\n\n  const left = itemX + itemWidth / 2 - labelWidth / 2;\n  const offsetLeft =\n    left + labelWidth >= viewportWidth ? left + labelWidth - viewportWidth : 0;\n\n  const top = itemBottom + margin;\n  const offsetTop =\n    top + labelHeight >= viewportHeight\n      ? itemBottom - itemTop + labelHeight + margin * 2\n      : 0;\n\n  Object.assign(tooltip.style, {\n    top: `${top - offsetTop}px`,\n    left: `${left - offsetLeft}px`,\n  });\n};\n\ntype TooltipProps = {\n  children: React.ReactNode;\n  label: string;\n  long?: boolean;\n};\n\nexport const Tooltip = ({ children, label, long = false }: TooltipProps) => {\n  useEffect(() => {\n    return () =>\n      getTooltipDiv().classList.remove(\"excalidraw-tooltip--visible\");\n  }, []);\n\n  return (\n    <div\n      className=\"excalidraw-tooltip-wrapper\"\n      onPointerEnter={(event) =>\n        updateTooltip(\n          event.currentTarget as HTMLDivElement,\n          getTooltipDiv(),\n          label,\n          long,\n        )\n      }\n      onPointerLeave={() =>\n        getTooltipDiv().classList.remove(\"excalidraw-tooltip--visible\")\n      }\n    >\n      {children}\n    </div>\n  );\n};\n","import { useState } from \"react\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"./App\";\nimport { Dialog } from \"./Dialog\";\nimport { trash } from \"./icons\";\nimport { ToolButton } from \"./ToolButton\";\n\nimport \"./ClearCanvas.scss\";\n\nconst ClearCanvas = ({ onConfirm }: { onConfirm: () => void }) => {\n  const [showDialog, setShowDialog] = useState(false);\n  const toggleDialog = () => {\n    setShowDialog(!showDialog);\n  };\n\n  return (\n    <>\n      <ToolButton\n        type=\"button\"\n        icon={trash}\n        title={t(\"buttons.clearReset\")}\n        aria-label={t(\"buttons.clearReset\")}\n        showAriaLabel={useIsMobile()}\n        onClick={toggleDialog}\n        data-testid=\"clear-canvas-button\"\n      />\n\n      {showDialog && (\n        <Dialog\n          onCloseRequest={toggleDialog}\n          title={t(\"clearCanvasDialog.title\")}\n          className=\"clear-canvas\"\n          small={true}\n        >\n          <>\n            <p className=\"clear-canvas__content\"> {t(\"alerts.clearReset\")}</p>\n            <div className=\"clear-canvas-buttons\">\n              <ToolButton\n                type=\"button\"\n                title={t(\"buttons.clear\")}\n                aria-label={t(\"buttons.clear\")}\n                label={t(\"buttons.clear\")}\n                onClick={() => {\n                  onConfirm();\n                  toggleDialog();\n                }}\n                data-testid=\"confirm-clear-canvas-button\"\n                className=\"clear-canvas--confirm\"\n              />\n              <ToolButton\n                type=\"button\"\n                title={t(\"buttons.cancel\")}\n                aria-label={t(\"buttons.cancel\")}\n                label={t(\"buttons.cancel\")}\n                onClick={toggleDialog}\n                data-testid=\"cancel-clear-canvas-button\"\n                className=\"clear-canvas--cancel\"\n              />\n            </div>\n          </>\n        </Dialog>\n      )}\n    </>\n  );\n};\n\nexport default ClearCanvas;\n","import { ColorPicker } from \"../components/ColorPicker\";\nimport { zoomIn, zoomOut } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { DarkModeToggle } from \"../components/DarkModeToggle\";\nimport { THEME, ZOOM_STEP } from \"../constants\";\nimport { getCommonBounds, getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { CODES, KEYS } from \"../keys\";\nimport { getNormalizedZoom, getSelectedElements } from \"../scene\";\nimport { centerScrollOn } from \"../scene/scroll\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { AppState, NormalizedZoomValue } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getDefaultAppState } from \"../appState\";\nimport ClearCanvas from \"../components/ClearCanvas\";\n\nexport const actionChangeViewBackgroundColor = register({\n  name: \"changeViewBackgroundColor\",\n  perform: (_, appState, value) => {\n    return {\n      appState: { ...appState, ...value },\n      commitToHistory: !!value.viewBackgroundColor,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => {\n    return (\n      <div style={{ position: \"relative\" }}>\n        <ColorPicker\n          label={t(\"labels.canvasBackground\")}\n          type=\"canvasBackground\"\n          color={appState.viewBackgroundColor}\n          onChange={(color) => updateData({ viewBackgroundColor: color })}\n          isActive={appState.openPopup === \"canvasColorPicker\"}\n          setActive={(active) =>\n            updateData({ openPopup: active ? \"canvasColorPicker\" : null })\n          }\n          data-testid=\"canvas-background-picker\"\n        />\n      </div>\n    );\n  },\n});\n\nexport const actionClearCanvas = register({\n  name: \"clearCanvas\",\n  perform: (elements, appState, _, app) => {\n    app.imageCache.clear();\n    return {\n      elements: elements.map((element) =>\n        newElementWith(element, { isDeleted: true }),\n      ),\n      appState: {\n        ...getDefaultAppState(),\n        files: {},\n        theme: appState.theme,\n        elementLocked: appState.elementLocked,\n        exportBackground: appState.exportBackground,\n        exportEmbedScene: appState.exportEmbedScene,\n        gridSize: appState.gridSize,\n        showStats: appState.showStats,\n        pasteDialog: appState.pasteDialog,\n      },\n      commitToHistory: true,\n    };\n  },\n\n  PanelComponent: ({ updateData }) => <ClearCanvas onConfirm={updateData} />,\n});\n\nexport const actionZoomIn = register({\n  name: \"zoomIn\",\n  perform: (_elements, appState) => {\n    const zoom = getNewZoom(\n      getNormalizedZoom(appState.zoom.value + ZOOM_STEP),\n      appState.zoom,\n      { left: appState.offsetLeft, top: appState.offsetTop },\n      { x: appState.width / 2, y: appState.height / 2 },\n    );\n    return {\n      appState: {\n        ...appState,\n        zoom,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={zoomIn}\n      title={`${t(\"buttons.zoomIn\")}  ${getShortcutKey(\"CtrlOrCmd++\")}`}\n      aria-label={t(\"buttons.zoomIn\")}\n      onClick={() => {\n        updateData(null);\n      }}\n      size=\"small\"\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionZoomOut = register({\n  name: \"zoomOut\",\n  perform: (_elements, appState) => {\n    const zoom = getNewZoom(\n      getNormalizedZoom(appState.zoom.value - ZOOM_STEP),\n      appState.zoom,\n      { left: appState.offsetLeft, top: appState.offsetTop },\n      { x: appState.width / 2, y: appState.height / 2 },\n    );\n\n    return {\n      appState: {\n        ...appState,\n        zoom,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={zoomOut}\n      title={`${t(\"buttons.zoomOut\")}  ${getShortcutKey(\"CtrlOrCmd+-\")}`}\n      aria-label={t(\"buttons.zoomOut\")}\n      onClick={() => {\n        updateData(null);\n      }}\n      size=\"small\"\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionResetZoom = register({\n  name: \"resetZoom\",\n  perform: (_elements, appState) => {\n    return {\n      appState: {\n        ...appState,\n        zoom: getNewZoom(\n          1 as NormalizedZoomValue,\n          appState.zoom,\n          { left: appState.offsetLeft, top: appState.offsetTop },\n          {\n            x: appState.width / 2,\n            y: appState.height / 2,\n          },\n        ),\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData, appState }) => (\n    <Tooltip label={t(\"buttons.resetZoom\")}>\n      <ToolButton\n        type=\"button\"\n        className=\"reset-zoom-button\"\n        title={t(\"buttons.resetZoom\")}\n        aria-label={t(\"buttons.resetZoom\")}\n        onClick={() => {\n          updateData(null);\n        }}\n        size=\"small\"\n      >\n        {(appState.zoom.value * 100).toFixed(0)}%\n      </ToolButton>\n    </Tooltip>\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nconst zoomValueToFitBoundsOnViewport = (\n  bounds: [number, number, number, number],\n  viewportDimensions: { width: number; height: number },\n) => {\n  const [x1, y1, x2, y2] = bounds;\n  const commonBoundsWidth = x2 - x1;\n  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;\n  const commonBoundsHeight = y2 - y1;\n  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;\n  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);\n  const zoomAdjustedToSteps =\n    Math.floor(smallestZoomValue / ZOOM_STEP) * ZOOM_STEP;\n  const clampedZoomValueToFitElements = Math.min(\n    Math.max(zoomAdjustedToSteps, ZOOM_STEP),\n    1,\n  );\n  return clampedZoomValueToFitElements as NormalizedZoomValue;\n};\n\nconst zoomToFitElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  zoomToSelection: boolean,\n) => {\n  const nonDeletedElements = getNonDeletedElements(elements);\n  const selectedElements = getSelectedElements(nonDeletedElements, appState);\n\n  const commonBounds =\n    zoomToSelection && selectedElements.length > 0\n      ? getCommonBounds(selectedElements)\n      : getCommonBounds(nonDeletedElements);\n\n  const zoomValue = zoomValueToFitBoundsOnViewport(commonBounds, {\n    width: appState.width,\n    height: appState.height,\n  });\n  const newZoom = getNewZoom(zoomValue, appState.zoom, {\n    left: appState.offsetLeft,\n    top: appState.offsetTop,\n  });\n\n  const [x1, y1, x2, y2] = commonBounds;\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n  return {\n    appState: {\n      ...appState,\n      ...centerScrollOn({\n        scenePoint: { x: centerX, y: centerY },\n        viewportDimensions: {\n          width: appState.width,\n          height: appState.height,\n        },\n        zoom: newZoom,\n      }),\n      zoom: newZoom,\n    },\n    commitToHistory: false,\n  };\n};\n\nexport const actionZoomToSelected = register({\n  name: \"zoomToSelection\",\n  perform: (elements, appState) => zoomToFitElements(elements, appState, true),\n  keyTest: (event) =>\n    event.code === CODES.TWO &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionZoomToFit = register({\n  name: \"zoomToFit\",\n  perform: (elements, appState) => zoomToFitElements(elements, appState, false),\n  keyTest: (event) =>\n    event.code === CODES.ONE &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionToggleTheme = register({\n  name: \"toggleTheme\",\n  perform: (_, appState, value) => {\n    return {\n      appState: {\n        ...appState,\n        theme:\n          value || (appState.theme === THEME.LIGHT ? THEME.DARK : THEME.LIGHT),\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <div style={{ marginInlineStart: \"0.25rem\" }}>\n      <DarkModeToggle\n        value={appState.theme}\n        onChange={(theme) => {\n          updateData(theme);\n        }}\n      />\n    </div>\n  ),\n  keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES.D,\n});\n","import { KEYS } from \"../keys\";\nimport { isInvisiblySmallElement } from \"../element\";\nimport { resetCursor } from \"../utils\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { done } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { isPathALoop } from \"../math\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport Scene from \"../scene/Scene\";\nimport {\n  maybeBindLinearElement,\n  bindOrUnbindLinearElement,\n} from \"../element/binding\";\nimport { isBindingElement } from \"../element/typeChecks\";\n\nexport const actionFinalize = register({\n  name: \"finalize\",\n  perform: (elements, appState, _, { canvas, focusContainer }) => {\n    if (appState.editingLinearElement) {\n      const { elementId, startBindingElement, endBindingElement } =\n        appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(\n            element,\n            startBindingElement,\n            endBindingElement,\n          );\n        }\n        return {\n          elements:\n            element.points.length < 2 || isInvisiblySmallElement(element)\n              ? elements.filter((el) => el.id !== element.id)\n              : undefined,\n          appState: {\n            ...appState,\n            editingLinearElement: null,\n          },\n          commitToHistory: true,\n        };\n      }\n    }\n\n    let newElements = elements;\n\n    if (appState.pendingImageElement) {\n      mutateElement(appState.pendingImageElement, { isDeleted: true }, false);\n    }\n\n    if (window.document.activeElement instanceof HTMLElement) {\n      focusContainer();\n    }\n\n    const multiPointElement = appState.multiElement\n      ? appState.multiElement\n      : appState.editingElement?.type === \"freedraw\"\n      ? appState.editingElement\n      : null;\n\n    if (multiPointElement) {\n      // pen and mouse have hover\n      if (\n        multiPointElement.type !== \"freedraw\" &&\n        appState.lastPointerDownWith !== \"touch\"\n      ) {\n        const { points, lastCommittedPoint } = multiPointElement;\n        if (\n          !lastCommittedPoint ||\n          points[points.length - 1] !== lastCommittedPoint\n        ) {\n          mutateElement(multiPointElement, {\n            points: multiPointElement.points.slice(0, -1),\n          });\n        }\n      }\n      if (isInvisiblySmallElement(multiPointElement)) {\n        newElements = newElements.slice(0, -1);\n      }\n\n      // If the multi point line closes the loop,\n      // set the last point to first point.\n      // This ensures that loop remains closed at different scales.\n      const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);\n      if (\n        multiPointElement.type === \"line\" ||\n        multiPointElement.type === \"freedraw\"\n      ) {\n        if (isLoop) {\n          const linePoints = multiPointElement.points;\n          const firstPoint = linePoints[0];\n          mutateElement(multiPointElement, {\n            points: linePoints.map((point, index) =>\n              index === linePoints.length - 1\n                ? ([firstPoint[0], firstPoint[1]] as const)\n                : point,\n            ),\n          });\n        }\n      }\n\n      if (\n        isBindingElement(multiPointElement) &&\n        !isLoop &&\n        multiPointElement.points.length > 1\n      ) {\n        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n          multiPointElement,\n          -1,\n        );\n        maybeBindLinearElement(\n          multiPointElement,\n          appState,\n          Scene.getScene(multiPointElement)!,\n          { x, y },\n        );\n      }\n\n      if (!appState.elementLocked && appState.elementType !== \"freedraw\") {\n        appState.selectedElementIds[multiPointElement.id] = true;\n      }\n    }\n\n    if (\n      (!appState.elementLocked && appState.elementType !== \"freedraw\") ||\n      !multiPointElement\n    ) {\n      resetCursor(canvas);\n    }\n\n    return {\n      elements: newElements,\n      appState: {\n        ...appState,\n        elementType:\n          (appState.elementLocked || appState.elementType === \"freedraw\") &&\n          multiPointElement\n            ? appState.elementType\n            : \"selection\",\n        draggingElement: null,\n        multiElement: null,\n        editingElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds:\n          multiPointElement &&\n          !appState.elementLocked &&\n          appState.elementType !== \"freedraw\"\n            ? {\n                ...appState.selectedElementIds,\n                [multiPointElement.id]: true,\n              }\n            : appState.selectedElementIds,\n        pendingImageElement: null,\n      },\n      commitToHistory: appState.elementType === \"freedraw\",\n    };\n  },\n  keyTest: (event, appState) =>\n    (event.key === KEYS.ESCAPE &&\n      (appState.editingLinearElement !== null ||\n        (!appState.draggingElement && appState.multiElement === null))) ||\n    ((event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) &&\n      appState.multiElement !== null),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={done}\n      title={t(\"buttons.done\")}\n      aria-label={t(\"buttons.done\")}\n      onClick={updateData}\n      visible={appState.multiElement != null}\n    />\n  ),\n});\n","import \"./TextInput.scss\";\n\nimport React, { useState } from \"react\";\nimport { focusNearestParent } from \"../utils\";\n\nimport \"./ProjectName.scss\";\nimport { useExcalidrawContainer } from \"./App\";\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n  label: string;\n  isNameEditable: boolean;\n};\n\nexport const ProjectName = (props: Props) => {\n  const { id } = useExcalidrawContainer();\n  const [fileName, setFileName] = useState<string>(props.value);\n\n  const handleBlur = (event: any) => {\n    focusNearestParent(event.target);\n    const value = event.target.value;\n    if (value !== props.value) {\n      props.onChange(value);\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n      if (event.nativeEvent.isComposing || event.keyCode === 229) {\n        return;\n      }\n      event.currentTarget.blur();\n    }\n  };\n\n  return (\n    <div className=\"ProjectName\">\n      <label className=\"ProjectName-label\" htmlFor=\"filename\">\n        {`${props.label}${props.isNameEditable ? \"\" : \":\"}`}\n      </label>\n      {props.isNameEditable ? (\n        <input\n          className=\"TextInput\"\n          onBlur={handleBlur}\n          onKeyDown={handleKeyDown}\n          id={`${id}-filename`}\n          value={fileName}\n          onChange={(event) => setFileName(event.target.value)}\n        />\n      ) : (\n        <span className=\"TextInput TextInput--readonly\" id={`${id}-filename`}>\n          {props.value}\n        </span>\n      )}\n    </div>\n  );\n};\n","/**\n * https://stackoverflow.com/a/3368118\n * Draws a rounded rectangle using the current state of the canvas.\n * @param {CanvasRenderingContext2D} context\n * @param {Number} x The top left x coordinate\n * @param {Number} y The top left y coordinate\n * @param {Number} width The width of the rectangle\n * @param {Number} height The height of the rectangle\n * @param {Number} radius The corner radius\n */\nexport const roundRect = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - radius,\n    y + height,\n  );\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n  context.closePath();\n  context.fill();\n  context.stroke();\n};\n","import colors from \"./colors\";\nimport { AppState } from \"./types\";\n\nexport const getClientColors = (clientId: string, appState: AppState) => {\n  if (appState?.collaborators) {\n    const currentUser = appState.collaborators.get(clientId);\n    if (currentUser?.color) {\n      return currentUser.color;\n    }\n  }\n  // Naive way of getting an integer out of the clientId\n  const sum = clientId.split(\"\").reduce((a, str) => a + str.charCodeAt(0), 0);\n\n  // Skip transparent background.\n  const backgrounds = colors.elementBackground.slice(1);\n  const strokes = colors.elementStroke.slice(1);\n  return {\n    background: backgrounds[sum % backgrounds.length],\n    stroke: strokes[sum % strokes.length],\n  };\n};\n\nexport const getClientInitials = (username?: string | null) => {\n  if (!username) {\n    return \"?\";\n  }\n  const names = username.trim().split(\" \");\n\n  if (names.length < 2) {\n    return names[0].substring(0, 2).toUpperCase();\n  }\n\n  const firstName = names[0];\n  const lastName = names[names.length - 1];\n\n  return (firstName[0] + lastName[0]).toUpperCase();\n};\n","import {\n  PointerType,\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  TextAlign,\n  ExcalidrawElement,\n  GroupId,\n  ExcalidrawBindableElement,\n  Arrowhead,\n  ChartType,\n  FontFamilyValues,\n  FileId,\n  ExcalidrawImageElement,\n  Theme,\n} from \"./element/types\";\nimport { SHAPES } from \"./shapes\";\nimport { Point as RoughPoint } from \"roughjs/bin/geometry\";\nimport { LinearElementEditor } from \"./element/linearElementEditor\";\nimport { SuggestedBinding } from \"./element/binding\";\nimport { ImportedDataState } from \"./data/types\";\nimport type App from \"./components/App\";\nimport type { ResolvablePromise } from \"./utils\";\nimport { Spreadsheet } from \"./charts\";\nimport { Language } from \"./i18n\";\nimport { ClipboardData } from \"./clipboard\";\nimport { isOverScrollBars } from \"./scene\";\nimport { MaybeTransformHandleType } from \"./element/transformHandles\";\nimport Library from \"./data/library\";\nimport type { FileSystemHandle } from \"./data/filesystem\";\nimport type { ALLOWED_IMAGE_MIME_TYPES, MIME_TYPES } from \"./constants\";\n\nexport type Point = Readonly<RoughPoint>;\n\nexport type Collaborator = {\n  pointer?: {\n    x: number;\n    y: number;\n  };\n  button?: \"up\" | \"down\";\n  selectedElementIds?: AppState[\"selectedElementIds\"];\n  username?: string | null;\n  userState?: UserIdleState;\n  color?: {\n    background: string;\n    stroke: string;\n  };\n};\n\nexport type DataURL = string & { _brand: \"DataURL\" };\n\nexport type BinaryFileData = {\n  mimeType:\n    | typeof ALLOWED_IMAGE_MIME_TYPES[number]\n    // future user or unknown file type\n    | typeof MIME_TYPES.binary;\n  id: FileId;\n  dataURL: DataURL;\n  created: number;\n};\n\nexport type BinaryFileMetadata = Omit<BinaryFileData, \"dataURL\">;\n\nexport type BinaryFiles = Record<ExcalidrawElement[\"id\"], BinaryFileData>;\n\nexport type AppState = {\n  isLoading: boolean;\n  errorMessage: string | null;\n  draggingElement: NonDeletedExcalidrawElement | null;\n  resizingElement: NonDeletedExcalidrawElement | null;\n  multiElement: NonDeleted<ExcalidrawLinearElement> | null;\n  selectionElement: NonDeletedExcalidrawElement | null;\n  isBindingEnabled: boolean;\n  startBoundElement: NonDeleted<ExcalidrawBindableElement> | null;\n  suggestedBindings: SuggestedBinding[];\n  // element being edited, but not necessarily added to elements array yet\n  // (e.g. text element when typing into the input)\n  editingElement: NonDeletedExcalidrawElement | null;\n  editingLinearElement: LinearElementEditor | null;\n  elementType: typeof SHAPES[number][\"value\"];\n  elementLocked: boolean;\n  exportBackground: boolean;\n  exportEmbedScene: boolean;\n  exportWithDarkMode: boolean;\n  exportScale: number;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  currentItemFillStyle: ExcalidrawElement[\"fillStyle\"];\n  currentItemStrokeWidth: number;\n  currentItemStrokeStyle: ExcalidrawElement[\"strokeStyle\"];\n  currentItemRoughness: number;\n  currentItemOpacity: number;\n  currentItemFontFamily: FontFamilyValues;\n  currentItemFontSize: number;\n  currentItemTextAlign: TextAlign;\n  currentItemStrokeSharpness: ExcalidrawElement[\"strokeSharpness\"];\n  currentItemStartArrowhead: Arrowhead | null;\n  currentItemEndArrowhead: Arrowhead | null;\n  currentItemLinearStrokeSharpness: ExcalidrawElement[\"strokeSharpness\"];\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n  cursorButton: \"up\" | \"down\";\n  scrolledOutside: boolean;\n  name: string;\n  isResizing: boolean;\n  isRotating: boolean;\n  zoom: Zoom;\n  openMenu: \"canvas\" | \"shape\" | null;\n  openPopup:\n    | \"canvasColorPicker\"\n    | \"backgroundColorPicker\"\n    | \"strokeColorPicker\"\n    | null;\n  lastPointerDownWith: PointerType;\n  selectedElementIds: { [id: string]: boolean };\n  previousSelectedElementIds: { [id: string]: boolean };\n  shouldCacheIgnoreZoom: boolean;\n  showHelpDialog: boolean;\n  toastMessage: string | null;\n  zenModeEnabled: boolean;\n  theme: Theme;\n  gridSize: number | null;\n  viewModeEnabled: boolean;\n\n  /** top-most selected groups (i.e. does not include nested groups) */\n  selectedGroupIds: { [groupId: string]: boolean };\n  /** group being edited when you drill down to its constituent element\n    (e.g. when you double-click on a group's element) */\n  editingGroupId: GroupId | null;\n  width: number;\n  height: number;\n  offsetTop: number;\n  offsetLeft: number;\n\n  isLibraryOpen: boolean;\n  fileHandle: FileSystemHandle | null;\n  collaborators: Map<string, Collaborator>;\n  showStats: boolean;\n  currentChartType: ChartType;\n  pasteDialog:\n    | {\n        shown: false;\n        data: null;\n      }\n    | {\n        shown: true;\n        data: Spreadsheet;\n      };\n  /** imageElement waiting to be placed on canvas */\n  pendingImageElement: NonDeleted<ExcalidrawImageElement> | null;\n};\n\nexport type NormalizedZoomValue = number & { _brand: \"normalizedZoom\" };\n\nexport type Zoom = Readonly<{\n  value: NormalizedZoomValue;\n  translation: Readonly<{\n    x: number;\n    y: number;\n  }>;\n}>;\n\nexport type PointerCoords = Readonly<{\n  x: number;\n  y: number;\n}>;\n\nexport type Gesture = {\n  pointers: Map<number, PointerCoords>;\n  lastCenter: { x: number; y: number } | null;\n  initialDistance: number | null;\n  initialScale: number | null;\n};\n\nexport declare class GestureEvent extends UIEvent {\n  readonly rotation: number;\n  readonly scale: number;\n}\n\nexport type LibraryItem = readonly NonDeleted<ExcalidrawElement>[];\nexport type LibraryItems = readonly LibraryItem[];\n\n// NOTE ready/readyPromise props are optional for host apps' sake (our own\n// implem guarantees existence)\nexport type ExcalidrawAPIRefValue =\n  | ExcalidrawImperativeAPI\n  | {\n      readyPromise?: ResolvablePromise<ExcalidrawImperativeAPI>;\n      ready?: false;\n    };\n\nexport interface ExcalidrawProps {\n  onChange?: (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n  ) => void;\n  initialData?: ImportedDataState | null | Promise<ImportedDataState | null>;\n  excalidrawRef?: ForwardRef<ExcalidrawAPIRefValue>;\n  onCollabButtonClick?: () => void;\n  isCollaborating?: boolean;\n  onPointerUpdate?: (payload: {\n    pointer: { x: number; y: number };\n    button: \"down\" | \"up\";\n    pointersMap: Gesture[\"pointers\"];\n  }) => void;\n  onPaste?: (\n    data: ClipboardData,\n    event: ClipboardEvent | null,\n  ) => Promise<boolean> | boolean;\n  renderTopRightUI?: (\n    isMobile: boolean,\n    appState: AppState,\n  ) => JSX.Element | null;\n  renderFooter?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  langCode?: Language[\"code\"];\n  viewModeEnabled?: boolean;\n  zenModeEnabled?: boolean;\n  gridModeEnabled?: boolean;\n  libraryReturnUrl?: string;\n  theme?: Theme;\n  name?: string;\n  renderCustomStats?: (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n  ) => JSX.Element;\n  UIOptions?: UIOptions;\n  detectScroll?: boolean;\n  handleKeyboardGlobally?: boolean;\n  onLibraryChange?: (libraryItems: LibraryItems) => void | Promise<any>;\n  autoFocus?: boolean;\n  generateIdForFile?: (file: File) => string | Promise<string>;\n}\n\nexport type SceneData = {\n  elements?: ImportedDataState[\"elements\"];\n  appState?: ImportedDataState[\"appState\"];\n  collaborators?: Map<string, Collaborator>;\n  commitToHistory?: boolean;\n};\n\nexport enum UserIdleState {\n  ACTIVE = \"active\",\n  AWAY = \"away\",\n  IDLE = \"idle\",\n}\n\nexport type ExportOpts = {\n  saveFileToDisk?: boolean;\n  onExportToBackend?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n    canvas: HTMLCanvasElement | null,\n  ) => void;\n  renderCustomUI?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n    canvas: HTMLCanvasElement | null,\n  ) => JSX.Element;\n};\n\ntype CanvasActions = {\n  changeViewBackgroundColor?: boolean;\n  clearCanvas?: boolean;\n  export?: false | ExportOpts;\n  loadScene?: boolean;\n  saveToActiveFile?: boolean;\n  theme?: boolean;\n  saveAsImage?: boolean;\n};\n\nexport type UIOptions = {\n  canvasActions?: CanvasActions;\n};\n\nexport type AppProps = ExcalidrawProps & {\n  UIOptions: {\n    canvasActions: Required<CanvasActions> & { export: ExportOpts };\n  };\n  detectScroll: boolean;\n  handleKeyboardGlobally: boolean;\n};\n\n/** A subset of App class properties that we need to use elsewhere\n * in the app, eg Manager. Factored out into a separate type to keep DRY. */\nexport type AppClassProperties = {\n  props: AppProps;\n  canvas: HTMLCanvasElement | null;\n  focusContainer(): void;\n  library: Library;\n  imageCache: Map<\n    FileId,\n    {\n      image: HTMLImageElement | Promise<HTMLImageElement>;\n      mimeType: typeof ALLOWED_IMAGE_MIME_TYPES[number];\n    }\n  >;\n  files: BinaryFiles;\n};\n\nexport type PointerDownState = Readonly<{\n  // The first position at which pointerDown happened\n  origin: Readonly<{ x: number; y: number }>;\n  // Same as \"origin\" but snapped to the grid, if grid is on\n  originInGrid: Readonly<{ x: number; y: number }>;\n  // Scrollbar checks\n  scrollbars: ReturnType<typeof isOverScrollBars>;\n  // The previous pointer position\n  lastCoords: { x: number; y: number };\n  // map of original elements data\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>;\n  resize: {\n    // Handle when resizing, might change during the pointer interaction\n    handleType: MaybeTransformHandleType;\n    // This is determined on the initial pointer down event\n    isResizing: boolean;\n    // This is determined on the initial pointer down event\n    offset: { x: number; y: number };\n    // This is determined on the initial pointer down event\n    arrowDirection: \"origin\" | \"end\";\n    // This is a center point of selected elements determined on the initial pointer down event (for rotation only)\n    center: { x: number; y: number };\n  };\n  hit: {\n    // The element the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    element: NonDeleted<ExcalidrawElement> | null;\n    // The elements the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    allHitElements: NonDeleted<ExcalidrawElement>[];\n    // This is determined on the initial pointer down event\n    wasAddedToSelection: boolean;\n    // Whether selected element(s) were duplicated, might change during the\n    // pointer interaction\n    hasBeenDuplicated: boolean;\n    hasHitCommonBoundingBoxOfSelectedElements: boolean;\n  };\n  withCmdOrCtrl: boolean;\n  drag: {\n    // Might change during the pointer interation\n    hasOccurred: boolean;\n    // Might change during the pointer interation\n    offset: { x: number; y: number } | null;\n  };\n  // We need to have these in the state so that we can unsubscribe them\n  eventListeners: {\n    // It's defined on the initial pointer down event\n    onMove: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onUp: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyDown: null | ((event: KeyboardEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyUp: null | ((event: KeyboardEvent) => void);\n  };\n}>;\n\nexport type ExcalidrawImperativeAPI = {\n  updateScene: InstanceType<typeof App>[\"updateScene\"];\n  resetScene: InstanceType<typeof App>[\"resetScene\"];\n  getSceneElementsIncludingDeleted: InstanceType<\n    typeof App\n  >[\"getSceneElementsIncludingDeleted\"];\n  history: {\n    clear: InstanceType<typeof App>[\"resetHistory\"];\n  };\n  scrollToContent: InstanceType<typeof App>[\"scrollToContent\"];\n  getSceneElements: InstanceType<typeof App>[\"getSceneElements\"];\n  getAppState: () => InstanceType<typeof App>[\"state\"];\n  getFiles: () => InstanceType<typeof App>[\"files\"];\n  refresh: InstanceType<typeof App>[\"refresh\"];\n  importLibrary: InstanceType<typeof App>[\"importLibraryFromUrl\"];\n  setToastMessage: InstanceType<typeof App>[\"setToastMessage\"];\n  addFiles: (data: BinaryFileData[]) => void;\n  readyPromise: ResolvablePromise<ExcalidrawImperativeAPI>;\n  ready: true;\n  id: string;\n};\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { AppState, BinaryFiles, Zoom } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n  GroupId,\n  ExcalidrawBindableElement,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getElementBounds,\n  getCommonBounds,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColors } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  isSelectedViaGroup,\n  getSelectedGroupIds,\n  getElementsInGroup,\n} from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport {\n  SuggestedBinding,\n  SuggestedPointBinding,\n  isBindingEnabled,\n} from \"../element/binding\";\nimport {\n  TransformHandles,\n  TransformHandleType,\n} from \"../element/transformHandles\";\nimport { viewportCoordsToSceneCoords, supportsEmoji } from \"../utils\";\nimport { UserIdleState } from \"../types\";\nimport { THEME_FILTER } from \"../constants\";\n\nconst hasEmojiSupport = supportsEmoji();\n\nconst strokeRectWithRotation = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill: boolean = false,\n) => {\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.restore();\n};\n\nconst strokeDiamondWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.restore();\n};\n\nconst strokeEllipseWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\n\nconst fillCircle = (\n  context: CanvasRenderingContext2D,\n  cx: number,\n  cy: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n};\n\nconst strokeGrid = (\n  context: CanvasRenderingContext2D,\n  gridSize: number,\n  offsetX: number,\n  offsetY: number,\n  width: number,\n  height: number,\n) => {\n  context.save();\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.restore();\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  sceneState: SceneState,\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  context.save();\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  LinearElementEditor.getPointsGlobalCoordinates(element).forEach(\n    (point, idx) => {\n      context.strokeStyle = \"red\";\n      context.setLineDash([]);\n      context.fillStyle =\n        appState.editingLinearElement?.activePointIndex === idx\n          ? \"rgba(255, 127, 127, 0.9)\"\n          : \"rgba(255, 255, 255, 0.9)\";\n      const { POINT_HANDLE_SIZE } = LinearElementEditor;\n      fillCircle(\n        context,\n        point[0],\n        point[1],\n        POINT_HANDLE_SIZE / 2 / sceneState.zoom.value,\n      );\n    },\n  );\n  context.restore();\n};\n\nexport const renderScene = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  selectionElement: NonDeletedExcalidrawElement | null,\n  scale: number,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options passed to the renderer\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    // doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n    renderGrid = true,\n    /** when exporting the behavior is slightly different (e.g. we can't use\n        CSS filters) */\n    isExport = false,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n    renderGrid?: boolean;\n    isExport?: boolean;\n  } = {},\n) => {\n  if (canvas === null) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n\n  context.setTransform(1, 0, 0, 1, 0, 0);\n  context.save();\n  context.scale(scale, scale);\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  if (isExport && sceneState.theme === \"dark\") {\n    context.filter = THEME_FILTER;\n  }\n\n  // Paint background\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 || // #RGBA\n      sceneState.viewBackgroundColor.length === 9 || // #RRGGBBA\n      /(hsla|rgba)\\(/.test(sceneState.viewBackgroundColor);\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    context.save();\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.restore();\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  const zoomTranslationX = sceneState.zoom.translation.x;\n  const zoomTranslationY = sceneState.zoom.translation.y;\n  context.save();\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom.value, sceneState.zoom.value);\n\n  // Grid\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(\n      context,\n      appState.gridSize,\n      -Math.ceil(zoomTranslationX / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollX % appState.gridSize),\n      -Math.ceil(zoomTranslationY / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollY % appState.gridSize),\n      normalizedCanvasWidth / sceneState.zoom.value,\n      normalizedCanvasHeight / sceneState.zoom.value,\n    );\n  }\n\n  // Paint visible elements\n  const visibleElements = elements.filter((element) =>\n    isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n      zoom: sceneState.zoom,\n      offsetLeft: appState.offsetLeft,\n      offsetTop: appState.offsetTop,\n      scrollX: sceneState.scrollX,\n      scrollY: sceneState.scrollY,\n    }),\n  );\n\n  visibleElements.forEach((element) => {\n    try {\n      renderElement(element, rc, context, renderOptimizations, sceneState);\n    } catch (error: any) {\n      console.error(error);\n    }\n  });\n\n  if (appState.editingLinearElement) {\n    const element = LinearElementEditor.getElement(\n      appState.editingLinearElement.elementId,\n    );\n    if (element) {\n      renderLinearPointHandles(context, appState, sceneState, element);\n    }\n  }\n\n  // Paint selection element\n  if (selectionElement) {\n    try {\n      renderElement(\n        selectionElement,\n        rc,\n        context,\n        renderOptimizations,\n        sceneState,\n      );\n    } catch (error: any) {\n      console.error(error);\n    }\n  }\n\n  if (isBindingEnabled(appState)) {\n    appState.suggestedBindings\n      .filter((binding) => binding != null)\n      .forEach((suggestedBinding) => {\n        renderBindingHighlight(context, sceneState, suggestedBinding!);\n      });\n  }\n\n  // Paint selected elements\n  if (\n    renderSelection &&\n    !appState.multiElement &&\n    !appState.editingLinearElement\n  ) {\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = [];\n      // local user\n      if (\n        appState.selectedElementIds[element.id] &&\n        !isSelectedViaGroup(appState, element)\n      ) {\n        selectionColors.push(oc.black);\n      }\n      // remote users\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(\n          ...sceneState.remoteSelectedElementIds[element.id].map((socketId) => {\n            const { background } = getClientColors(socketId, appState);\n            return background;\n          }),\n        );\n      }\n      if (selectionColors.length) {\n        const [elementX1, elementY1, elementX2, elementY2] =\n          getElementAbsoluteCoords(element);\n        acc.push({\n          angle: element.angle,\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n          selectionColors,\n        });\n      }\n      return acc;\n    }, [] as { angle: number; elementX1: number; elementY1: number; elementX2: number; elementY2: number; selectionColors: string[] }[]);\n\n    const addSelectionForGroupId = (groupId: GroupId) => {\n      const groupElements = getElementsInGroup(elements, groupId);\n      const [elementX1, elementY1, elementX2, elementY2] =\n        getCommonBounds(groupElements);\n      selections.push({\n        angle: 0,\n        elementX1,\n        elementX2,\n        elementY1,\n        elementY2,\n        selectionColors: [oc.black],\n      });\n    };\n\n    for (const groupId of getSelectedGroupIds(appState)) {\n      // TODO: support multiplayer selected group IDs\n      addSelectionForGroupId(groupId);\n    }\n\n    if (appState.editingGroupId) {\n      addSelectionForGroupId(appState.editingGroupId);\n    }\n\n    selections.forEach((selection) =>\n      renderSelectionBorder(context, sceneState, selection),\n    );\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n\n    // Paint resize transformHandles\n    context.save();\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    if (locallySelectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(\n        locallySelectedElements[0],\n        sceneState.zoom,\n        \"mouse\", // when we render we don't know which pointer type so use mouse\n      );\n      if (!appState.viewModeEnabled) {\n        renderTransformHandles(\n          context,\n          sceneState,\n          transformHandles,\n          locallySelectedElements[0].angle,\n        );\n      }\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = 4 / sceneState.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / sceneState.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      strokeRectWithRotation(\n        context,\n        x1 - dashedLinePadding,\n        y1 - dashedLinePadding,\n        x2 - x1 + dashedLinePadding * 2,\n        y2 - y1 + dashedLinePadding * 2,\n        (x1 + x2) / 2,\n        (y1 + y2) / 2,\n        0,\n      );\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords(\n        [x1, y1, x2, y2],\n        0,\n        sceneState.zoom,\n        \"mouse\",\n        OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n      );\n      renderTransformHandles(context, sceneState, transformHandles, 0);\n    }\n    context.restore();\n  }\n\n  // Reset zoom\n  context.restore();\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let { x, y } = sceneState.remotePointerViewportCoords[clientId];\n\n    x -= appState.offsetLeft;\n    y -= appState.offsetTop;\n\n    const width = 9;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedCanvasWidth - width ||\n      y < 0 ||\n      y > normalizedCanvasHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n\n    const { background, stroke } = getClientColors(clientId, appState);\n\n    context.save();\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n\n    const userState = sceneState.remotePointerUserStates[clientId];\n    if (isOutOfBounds || userState === UserIdleState.AWAY) {\n      context.globalAlpha = 0.48;\n    }\n\n    if (\n      sceneState.remotePointerButton &&\n      sceneState.remotePointerButton[clientId] === \"down\"\n    ) {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    const username = sceneState.remotePointerUsernames[clientId];\n\n    let idleState = \"\";\n    if (userState === UserIdleState.AWAY) {\n      idleState = hasEmojiSupport ? \"\" : ` (${UserIdleState.AWAY})`;\n    } else if (userState === UserIdleState.IDLE) {\n      idleState = hasEmojiSupport ? \"\" : ` (${UserIdleState.IDLE})`;\n    } else if (userState === UserIdleState.ACTIVE) {\n      idleState = hasEmojiSupport ? \"\" : \"\";\n    }\n\n    const usernameAndIdleState = `${\n      username ? `${username} ` : \"\"\n    }${idleState}`;\n\n    if (!isOutOfBounds && usernameAndIdleState) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(usernameAndIdleState);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n\n      // Border\n      context.fillStyle = stroke;\n      context.fillRect(\n        offsetX - 1,\n        offsetY - 1,\n        measure.width + 2 * paddingHorizontal + 2,\n        measureHeight + 2 * paddingVertical + 2,\n      );\n      // Background\n      context.fillStyle = background;\n      context.fillRect(\n        offsetX,\n        offsetY,\n        measure.width + 2 * paddingHorizontal,\n        measureHeight + 2 * paddingVertical,\n      );\n      context.fillStyle = oc.white;\n\n      context.fillText(\n        usernameAndIdleState,\n        offsetX + paddingHorizontal,\n        offsetY + paddingVertical + measure.actualBoundingBoxAscent,\n      );\n    }\n\n    context.restore();\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    context.save();\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.restore();\n  }\n\n  context.restore();\n  return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n};\n\nconst renderTransformHandles = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  transformHandles: TransformHandles,\n  angle: number,\n): void => {\n  Object.keys(transformHandles).forEach((key) => {\n    const transformHandle = transformHandles[key as TransformHandleType];\n    if (transformHandle !== undefined) {\n      context.save();\n      context.lineWidth = 1 / sceneState.zoom.value;\n      if (key === \"rotation\") {\n        fillCircle(\n          context,\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          transformHandle[2] / 2,\n        );\n      } else {\n        strokeRectWithRotation(\n          context,\n          transformHandle[0],\n          transformHandle[1],\n          transformHandle[2],\n          transformHandle[3],\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          angle,\n          true, // fill before stroke\n        );\n      }\n      context.restore();\n    }\n  });\n};\n\nconst renderSelectionBorder = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  elementProperties: {\n    angle: number;\n    elementX1: number;\n    elementY1: number;\n    elementX2: number;\n    elementY2: number;\n    selectionColors: string[];\n  },\n) => {\n  const { angle, elementX1, elementY1, elementX2, elementY2, selectionColors } =\n    elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n\n  const dashedLinePadding = 4 / sceneState.zoom.value;\n  const dashWidth = 8 / sceneState.zoom.value;\n  const spaceWidth = 4 / sceneState.zoom.value;\n\n  context.save();\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    context.setLineDash([\n      dashWidth,\n      spaceWidth + (dashWidth + spaceWidth) * (count - 1),\n    ]);\n    context.lineDashOffset = (dashWidth + spaceWidth) * index;\n    strokeRectWithRotation(\n      context,\n      elementX1 - dashedLinePadding,\n      elementY1 - dashedLinePadding,\n      elementWidth + dashedLinePadding * 2,\n      elementHeight + dashedLinePadding * 2,\n      elementX1 + elementWidth / 2,\n      elementY1 + elementHeight / 2,\n      angle,\n    );\n  }\n  context.restore();\n};\n\nconst renderBindingHighlight = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  suggestedBinding: SuggestedBinding,\n) => {\n  const renderHighlight = Array.isArray(suggestedBinding)\n    ? renderBindingHighlightForSuggestedPointBinding\n    : renderBindingHighlightForBindableElement;\n\n  context.save();\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  renderHighlight(context, suggestedBinding as any);\n\n  context.restore();\n};\n\nconst renderBindingHighlightForBindableElement = (\n  context: CanvasRenderingContext2D,\n  element: ExcalidrawBindableElement,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height);\n\n  // So that we don't overlap the element itself\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      strokeRectWithRotation(\n        context,\n        x1 - padding,\n        y1 - padding,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = (padding * side) / height;\n      const hPadding = (padding * side) / width;\n      strokeDiamondWithRotation(\n        context,\n        width + wPadding * 2,\n        height + hPadding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"ellipse\":\n      strokeEllipseWithRotation(\n        context,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n  }\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (\n  context: CanvasRenderingContext2D,\n  suggestedBinding: SuggestedPointBinding,\n) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n\n  const threshold = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n  );\n\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  const pointIndices =\n    startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach((index) => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      element,\n      index,\n    );\n    fillCircle(context, x, y, threshold);\n  });\n};\n\nconst isVisibleElement = (\n  element: ExcalidrawElement,\n  canvasWidth: number,\n  canvasHeight: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + canvasWidth,\n      clientY: viewTransformations.offsetTop + canvasHeight,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  files: BinaryFiles,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) => {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      try {\n        renderElementToSvg(\n          element,\n          rsvg,\n          svgRoot,\n          files,\n          element.x + offsetX,\n          element.y + offsetY,\n        );\n      } catch (error: any) {\n        console.error(error);\n      }\n    }\n  });\n};\n","import {\n  FileWithHandle,\n  fileOpen as _fileOpen,\n  fileSave as _fileSave,\n  FileSystemHandle,\n  supported as nativeFileSystemSupported,\n} from \"browser-fs-access\";\nimport { EVENT, MIME_TYPES } from \"../constants\";\nimport { AbortError } from \"../errors\";\nimport { debounce } from \"../utils\";\n\ntype FILE_EXTENSION =\n  | \"gif\"\n  | \"jpg\"\n  | \"png\"\n  | \"svg\"\n  | \"json\"\n  | \"excalidraw\"\n  | \"excalidrawlib\";\n\nconst INPUT_CHANGE_INTERVAL_MS = 500;\n\nexport const fileOpen = <M extends boolean | undefined = false>(opts: {\n  extensions?: FILE_EXTENSION[];\n  description?: string;\n  multiple?: M;\n}): Promise<\n  M extends false | undefined ? FileWithHandle : FileWithHandle[]\n> => {\n  // an unsafe TS hack, alas not much we can do AFAIK\n  type RetType = M extends false | undefined\n    ? FileWithHandle\n    : FileWithHandle[];\n\n  const mimeTypes = opts.extensions?.reduce((mimeTypes, type) => {\n    mimeTypes.push(MIME_TYPES[type]);\n\n    return mimeTypes;\n  }, [] as string[]);\n\n  const extensions = opts.extensions?.reduce((acc, ext) => {\n    if (ext === \"jpg\") {\n      return acc.concat(\".jpg\", \".jpeg\");\n    }\n    return acc.concat(`.${ext}`);\n  }, [] as string[]);\n\n  return _fileOpen({\n    description: opts.description,\n    extensions,\n    mimeTypes,\n    multiple: opts.multiple ?? false,\n    legacySetup: (resolve, reject, input) => {\n      const scheduleRejection = debounce(reject, INPUT_CHANGE_INTERVAL_MS);\n      const focusHandler = () => {\n        checkForFile();\n        document.addEventListener(EVENT.KEYUP, scheduleRejection);\n        document.addEventListener(EVENT.POINTER_UP, scheduleRejection);\n        scheduleRejection();\n      };\n      const checkForFile = () => {\n        // this hack might not work when expecting multiple files\n        if (input.files?.length) {\n          const ret = opts.multiple ? [...input.files] : input.files[0];\n          resolve(ret as RetType);\n        }\n      };\n      requestAnimationFrame(() => {\n        window.addEventListener(EVENT.FOCUS, focusHandler);\n      });\n      const interval = window.setInterval(() => {\n        checkForFile();\n      }, INPUT_CHANGE_INTERVAL_MS);\n      return (rejectPromise) => {\n        clearInterval(interval);\n        scheduleRejection.cancel();\n        window.removeEventListener(EVENT.FOCUS, focusHandler);\n        document.removeEventListener(EVENT.KEYUP, scheduleRejection);\n        document.removeEventListener(EVENT.POINTER_UP, scheduleRejection);\n        if (rejectPromise) {\n          // so that something is shown in console if we need to debug this\n          console.warn(\"Opening the file was canceled (legacy-fs).\");\n          rejectPromise(new AbortError());\n        }\n      };\n    },\n  }) as Promise<RetType>;\n};\n\nexport const fileSave = (\n  blob: Blob,\n  opts: {\n    /** supply without the extension */\n    name: string;\n    /** file extension */\n    extension: FILE_EXTENSION;\n    description?: string;\n    /** existing FileSystemHandle */\n    fileHandle?: FileSystemHandle | null;\n  },\n) => {\n  return _fileSave(\n    blob,\n    {\n      fileName: `${opts.name}.${opts.extension}`,\n      description: opts.description,\n      extensions: [`.${opts.extension}`],\n    },\n    opts.fileHandle,\n  );\n};\n\nexport type { FileSystemHandle };\nexport { nativeFileSystemSupported };\n","import {\n  ExcalidrawElement,\n  ExcalidrawSelectionElement,\n  FontFamilyValues,\n} from \"../element/types\";\nimport { AppState, BinaryFiles, NormalizedZoomValue } from \"../types\";\nimport { ImportedDataState } from \"./types\";\nimport {\n  getElementMap,\n  getNormalizedDimensions,\n  isInvisiblySmallElement,\n} from \"../element\";\nimport { isLinearElementType } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n  FONT_FAMILY,\n} from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { bumpVersion } from \"../element/mutateElement\";\n\ntype RestoredAppState = Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n>;\n\nexport const AllowedExcalidrawElementTypes: Record<\n  ExcalidrawElement[\"type\"],\n  true\n> = {\n  selection: true,\n  text: true,\n  rectangle: true,\n  diamond: true,\n  ellipse: true,\n  line: true,\n  image: true,\n  arrow: true,\n  freedraw: true,\n};\n\nexport type RestoredDataState = {\n  elements: ExcalidrawElement[];\n  appState: RestoredAppState;\n  files: BinaryFiles;\n};\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamilyValues => {\n  if (Object.keys(FONT_FAMILY).includes(fontFamilyName)) {\n    return FONT_FAMILY[\n      fontFamilyName as keyof typeof FONT_FAMILY\n    ] as FontFamilyValues;\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nconst restoreElementWithProperties = <\n  T extends ExcalidrawElement,\n  K extends Pick<T, keyof Omit<Required<T>, keyof ExcalidrawElement>>,\n>(\n  element: Required<T>,\n  extra: Pick<\n    T,\n    // This extra Pick<T, keyof K> ensure no excess properties are passed.\n    // @ts-ignore TS complains here but type checks the call sites fine.\n    keyof K\n  > &\n    Partial<Pick<ExcalidrawElement, \"type\" | \"x\" | \"y\">>,\n): T => {\n  const base: Pick<T, keyof ExcalidrawElement> = {\n    type: extra.type || element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: element.isDeleted ?? false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: extra.x ?? element.x ?? 0,\n    y: extra.y ?? element.y ?? 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds ?? [],\n    strokeSharpness:\n      element.strokeSharpness ??\n      (isLinearElementType(element.type) ? \"round\" : \"sharp\"),\n    boundElementIds: element.boundElementIds ?? [],\n  };\n\n  return {\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as unknown as T;\n};\n\nconst restoreElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n): typeof element | null => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [string, string] = (\n          element as any\n        ).font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      return restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: element.text ?? \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n      });\n    case \"freedraw\": {\n      return restoreElementWithProperties(element, {\n        points: element.points,\n        lastCommittedPoint: null,\n        simulatePressure: element.simulatePressure,\n        pressures: element.pressures,\n      });\n    }\n    case \"image\":\n      return restoreElementWithProperties(element, {\n        status: element.status || \"pending\",\n        fileId: element.fileId,\n        scale: element.scale || [1, 1],\n      });\n    case \"line\":\n    // @ts-ignore LEGACY type\n    // eslint-disable-next-line no-fallthrough\n    case \"draw\":\n    case \"arrow\": {\n      const {\n        startArrowhead = null,\n        endArrowhead = element.type === \"arrow\" ? \"arrow\" : null,\n      } = element;\n\n      let x = element.x;\n      let y = element.y;\n      let points = // migrate old arrow model to new one\n        !Array.isArray(element.points) || element.points.length < 2\n          ? [\n              [0, 0],\n              [element.width, element.height],\n            ]\n          : element.points;\n\n      if (points[0][0] !== 0 || points[0][1] !== 0) {\n        ({ points, x, y } = LinearElementEditor.getNormalizedPoints(element));\n      }\n\n      return restoreElementWithProperties(element, {\n        type:\n          (element.type as ExcalidrawElement[\"type\"] | \"draw\") === \"draw\"\n            ? \"line\"\n            : element.type,\n        startBinding: element.startBinding,\n        endBinding: element.endBinding,\n        lastCommittedPoint: null,\n        startArrowhead,\n        endArrowhead,\n        points,\n        x,\n        y,\n      });\n    }\n    // generic elements\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\nexport const restoreElements = (\n  elements: ImportedDataState[\"elements\"],\n  /** NOTE doesn't serve for reconciliation */\n  localElements: readonly ExcalidrawElement[] | null | undefined,\n): ExcalidrawElement[] => {\n  const localElementsMap = localElements ? getElementMap(localElements) : null;\n  return (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      let migratedElement: ExcalidrawElement | null = restoreElement(element);\n      if (migratedElement) {\n        const localElement = localElementsMap?.[element.id];\n        if (localElement && localElement.version > migratedElement.version) {\n          migratedElement = bumpVersion(migratedElement, localElement.version);\n        }\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n};\n\nexport const restoreAppState = (\n  appState: ImportedDataState[\"appState\"],\n  localAppState: Partial<AppState> | null | undefined,\n): RestoredAppState => {\n  appState = appState || {};\n\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {} as typeof defaultAppState;\n\n  for (const [key, defaultValue] of Object.entries(defaultAppState) as [\n    keyof typeof defaultAppState,\n    any,\n  ][]) {\n    const suppliedValue = appState[key];\n    const localValue = localAppState ? localAppState[key] : undefined;\n    (nextAppState as any)[key] =\n      suppliedValue !== undefined\n        ? suppliedValue\n        : localValue !== undefined\n        ? localValue\n        : defaultValue;\n  }\n\n  return {\n    ...nextAppState,\n    elementType: AllowedExcalidrawElementTypes[nextAppState.elementType]\n      ? nextAppState.elementType\n      : \"selection\",\n    // Migrates from previous version where appState.zoom was a number\n    zoom:\n      typeof appState.zoom === \"number\"\n        ? {\n            value: appState.zoom as NormalizedZoomValue,\n            translation: defaultAppState.zoom.translation,\n          }\n        : appState.zoom || defaultAppState.zoom,\n  };\n};\n\nexport const restore = (\n  data: ImportedDataState | null,\n  /**\n   * Local AppState (`this.state` or initial state from localStorage) so that we\n   * don't overwrite local state with default values (when values not\n   * explicitly specified).\n   * Supply `null` if you can't get access to it.\n   */\n  localAppState: Partial<AppState> | null | undefined,\n  localElements: readonly ExcalidrawElement[] | null | undefined,\n): RestoredDataState => {\n  return {\n    elements: restoreElements(data?.elements, localElements),\n    appState: restoreAppState(data?.appState, localAppState || null),\n    files: data?.files || {},\n  };\n};\n","import { nanoid } from \"nanoid\";\nimport { cleanAppStateForExport } from \"../appState\";\nimport {\n  ALLOWED_IMAGE_MIME_TYPES,\n  EXPORT_DATA_TYPES,\n  MIME_TYPES,\n} from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { ExcalidrawElement, FileId } from \"../element/types\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { AppState, DataURL } from \"../types\";\nimport { FileSystemHandle } from \"./filesystem\";\nimport { isValidExcalidrawData } from \"./json\";\nimport { restore } from \"./restore\";\nimport { ImportedLibraryData } from \"./types\";\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n\n  if (blob.type === MIME_TYPES.png) {\n    try {\n      return await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).decodePngMetadata(blob);\n    } catch (error: any) {\n      if (error.message === \"INVALID\") {\n        throw new DOMException(\n          t(\"alerts.imageDoesNotContainScene\"),\n          \"EncodingError\",\n        );\n      } else {\n        throw new DOMException(\n          t(\"alerts.cannotRestoreFromImage\"),\n          \"EncodingError\",\n        );\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result as string);\n          }\n        };\n      });\n    }\n    if (blob.type === MIME_TYPES.svg) {\n      try {\n        return await (\n          await import(/* webpackChunkName: \"image\" */ \"./image\")\n        ).decodeSvgMetadata({\n          svg: contents,\n        });\n      } catch (error: any) {\n        if (error.message === \"INVALID\") {\n          throw new DOMException(\n            t(\"alerts.imageDoesNotContainScene\"),\n            \"EncodingError\",\n          );\n        } else {\n          throw new DOMException(\n            t(\"alerts.cannotRestoreFromImage\"),\n            \"EncodingError\",\n          );\n        }\n      }\n    }\n  }\n  return contents;\n};\n\nexport const getMimeType = (blob: Blob | string): string => {\n  let name: string;\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n    name = blob.name || \"\";\n  }\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return MIME_TYPES.json;\n  } else if (/\\.png$/.test(name)) {\n    return MIME_TYPES.png;\n  } else if (/\\.jpe?g$/.test(name)) {\n    return MIME_TYPES.jpg;\n  } else if (/\\.svg$/.test(name)) {\n    return MIME_TYPES.svg;\n  }\n  return \"\";\n};\n\nexport const getFileHandleType = (handle: FileSystemHandle | null) => {\n  if (!handle) {\n    return null;\n  }\n\n  return handle.name.match(/\\.(json|excalidraw|png|svg)$/)?.[1] || null;\n};\n\nexport const isImageFileHandleType = (\n  type: string | null,\n): type is \"png\" | \"svg\" => {\n  return type === \"png\" || type === \"svg\";\n};\n\nexport const isImageFileHandle = (handle: FileSystemHandle | null) => {\n  const type = getFileHandleType(handle);\n  return type === \"png\" || type === \"svg\";\n};\n\nexport const isSupportedImageFile = (\n  blob: Blob | null | undefined,\n): blob is Blob & { type: typeof ALLOWED_IMAGE_MIME_TYPES[number] } => {\n  const { type } = blob || {};\n  return (\n    !!type && (ALLOWED_IMAGE_MIME_TYPES as readonly string[]).includes(type)\n  );\n};\n\nexport const loadFromBlob = async (\n  blob: Blob,\n  /** @see restore.localAppState */\n  localAppState: AppState | null,\n  localElements: readonly ExcalidrawElement[] | null,\n) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data = JSON.parse(contents);\n    if (!isValidExcalidrawData(data)) {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    const result = restore(\n      {\n        elements: clearElementsForExport(data.elements || []),\n        appState: {\n          theme: localAppState?.theme,\n          fileHandle: blob.handle || null,\n          ...cleanAppStateForExport(data.appState || {}),\n          ...(localAppState\n            ? calculateScrollCenter(data.elements || [], localAppState, null)\n            : {}),\n        },\n        files: data.files,\n      },\n      localAppState,\n      localElements,\n    );\n\n    return result;\n  } catch (error: any) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadLibraryFromBlob = async (blob: Blob) => {\n  const contents = await parseFileContents(blob);\n  const data: ImportedLibraryData = JSON.parse(contents);\n  if (data.type !== EXPORT_DATA_TYPES.excalidrawLibrary) {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n\nexport const canvasToBlob = async (\n  canvas: HTMLCanvasElement,\n): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          return reject(\n            new CanvasError(\n              t(\"canvasError.canvasTooBig\"),\n              \"CANVAS_POSSIBLY_TOO_BIG\",\n            ),\n          );\n        }\n        resolve(blob);\n      });\n    } catch (error: any) {\n      reject(error);\n    }\n  });\n};\n\n/** generates SHA-1 digest from supplied file (if not supported, falls back\n    to a 40-char base64 random id) */\nexport const generateIdFromFile = async (file: File) => {\n  let id: FileId;\n  try {\n    const hashBuffer = await window.crypto.subtle.digest(\n      \"SHA-1\",\n      await file.arrayBuffer(),\n    );\n    id =\n      // convert buffer to byte array\n      Array.from(new Uint8Array(hashBuffer))\n        // convert to hex string\n        .map((byte) => byte.toString(16).padStart(2, \"0\"))\n        .join(\"\") as FileId;\n  } catch (error: any) {\n    console.error(error);\n    // length 40 to align with the HEX length of SHA-1 (which is 160 bit)\n    id = nanoid(40) as FileId;\n  }\n\n  return id;\n};\n\nexport const getDataURL = async (file: Blob | File): Promise<DataURL> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const dataURL = reader.result as DataURL;\n      resolve(dataURL);\n    };\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(file);\n  });\n};\n\nexport const dataURLToFile = (dataURL: DataURL, filename = \"\") => {\n  const dataIndexStart = dataURL.indexOf(\",\");\n  const byteString = atob(dataURL.slice(dataIndexStart + 1));\n  const mimeType = dataURL.slice(0, dataIndexStart).split(\":\")[1].split(\";\")[0];\n\n  const ab = new ArrayBuffer(byteString.length);\n  const ia = new Uint8Array(ab);\n  for (let i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n  return new File([ab], filename, { type: mimeType });\n};\n\nexport const resizeImageFile = async (\n  file: File,\n  maxWidthOrHeight: number,\n): Promise<File> => {\n  // SVG files shouldn't a can't be resized\n  if (file.type === MIME_TYPES.svg) {\n    return file;\n  }\n\n  const [pica, imageBlobReduce] = await Promise.all([\n    import(\"pica\").then((res) => res.default),\n    // a wrapper for pica for better API\n    import(\"image-blob-reduce\").then((res) => res.default),\n  ]);\n\n  // CRA's minification settings break pica in WebWorkers, so let's disable\n  // them for now\n  // https://github.com/nodeca/image-blob-reduce/issues/21#issuecomment-757365513\n  const reduce = imageBlobReduce({\n    pica: pica({ features: [\"js\", \"wasm\"] }),\n  });\n\n  const fileType = file.type;\n\n  if (!isSupportedImageFile(file)) {\n    throw new Error(t(\"errors.unsupportedFileType\"));\n  }\n\n  return new File(\n    [await reduce.toBlob(file, { max: maxWidthOrHeight })],\n    file.name,\n    { type: fileType },\n  );\n};\n\nexport const SVGStringToFile = (SVGString: string, filename: string = \"\") => {\n  return new File([new TextEncoder().encode(SVGString)], filename, {\n    type: MIME_TYPES.svg,\n  }) as File & { type: typeof MIME_TYPES.svg };\n};\n","import { fileOpen, fileSave } from \"./filesystem\";\nimport { cleanAppStateForExport, clearAppStateForDatabase } from \"../appState\";\nimport { EXPORT_DATA_TYPES, EXPORT_SOURCE, MIME_TYPES } from \"../constants\";\nimport { clearElementsForDatabase, clearElementsForExport } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { isImageFileHandle, loadFromBlob } from \"./blob\";\n\nimport {\n  ExportedDataState,\n  ImportedDataState,\n  ExportedLibraryData,\n} from \"./types\";\nimport Library from \"./library\";\n\n/**\n * Strips out files which are only referenced by deleted elements\n */\nconst filterOutDeletedFiles = (\n  elements: readonly ExcalidrawElement[],\n  files: BinaryFiles,\n) => {\n  const nextFiles: BinaryFiles = {};\n  for (const element of elements) {\n    if (\n      !element.isDeleted &&\n      \"fileId\" in element &&\n      element.fileId &&\n      files[element.fileId]\n    ) {\n      nextFiles[element.fileId] = files[element.fileId];\n    }\n  }\n  return nextFiles;\n};\n\nexport const serializeAsJSON = (\n  elements: readonly ExcalidrawElement[],\n  appState: Partial<AppState>,\n  files: BinaryFiles,\n  type: \"local\" | \"database\",\n): string => {\n  const data: ExportedDataState = {\n    type: EXPORT_DATA_TYPES.excalidraw,\n    version: 2,\n    source: EXPORT_SOURCE,\n    elements:\n      type === \"local\"\n        ? clearElementsForExport(elements)\n        : clearElementsForDatabase(elements),\n    appState:\n      type === \"local\"\n        ? cleanAppStateForExport(appState)\n        : clearAppStateForDatabase(appState),\n    files:\n      type === \"local\"\n        ? filterOutDeletedFiles(elements, files)\n        : // will be stripped from JSON\n          undefined,\n  };\n\n  return JSON.stringify(data, null, 2);\n};\n\nexport const saveAsJSON = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n) => {\n  const serialized = serializeAsJSON(elements, appState, files, \"local\");\n  const blob = new Blob([serialized], {\n    type: MIME_TYPES.excalidraw,\n  });\n\n  const fileHandle = await fileSave(blob, {\n    name: appState.name,\n    extension: \"excalidraw\",\n    description: \"Excalidraw file\",\n    fileHandle: isImageFileHandle(appState.fileHandle)\n      ? null\n      : appState.fileHandle,\n  });\n  return { fileHandle };\n};\n\nexport const loadFromJSON = async (\n  localAppState: AppState,\n  localElements: readonly ExcalidrawElement[] | null,\n) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n    // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442\n    // gets resolved. Else, iOS users cannot open `.excalidraw` files.\n    // extensions: [\"json\", \"excalidraw\", \"png\", \"svg\"],\n  });\n  return loadFromBlob(blob, localAppState, localElements);\n};\n\nexport const isValidExcalidrawData = (data?: {\n  type?: any;\n  elements?: any;\n  appState?: any;\n}): data is ImportedDataState => {\n  return (\n    data?.type === EXPORT_DATA_TYPES.excalidraw &&\n    (!data.elements ||\n      (Array.isArray(data.elements) &&\n        (!data.appState || typeof data.appState === \"object\")))\n  );\n};\n\nexport const isValidLibrary = (json: any) => {\n  return (\n    typeof json === \"object\" &&\n    json &&\n    json.type === EXPORT_DATA_TYPES.excalidrawLibrary &&\n    json.version === 1\n  );\n};\n\nexport const saveLibraryAsJSON = async (library: Library) => {\n  const libraryItems = await library.loadLibrary();\n  const data: ExportedLibraryData = {\n    type: EXPORT_DATA_TYPES.excalidrawLibrary,\n    version: 1,\n    source: EXPORT_SOURCE,\n    library: libraryItems,\n  };\n  const serialized = JSON.stringify(data, null, 2);\n  await fileSave(\n    new Blob([serialized], {\n      type: MIME_TYPES.excalidrawlib,\n    }),\n    {\n      name: \"library\",\n      extension: \"excalidrawlib\",\n      description: \"Excalidraw library file\",\n    },\n  );\n};\n\nexport const importLibraryFromJSON = async (library: Library) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw library files\",\n    // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442\n    // gets resolved. Else, iOS users cannot open `.excalidraw` files.\n    /*\n    extensions: [\".json\", \".excalidrawlib\"],\n    */\n  });\n  await library.importLibrary(blob);\n};\n","// -----------------------------------------------------------------------------\n// ExcalidrawImageElement & related helpers\n// -----------------------------------------------------------------------------\n\nimport { MIME_TYPES, SVG_NS } from \"../constants\";\nimport { t } from \"../i18n\";\nimport { AppClassProperties, DataURL, BinaryFiles } from \"../types\";\nimport { isInitializedImageElement } from \"./typeChecks\";\nimport {\n  ExcalidrawElement,\n  FileId,\n  InitializedExcalidrawImageElement,\n} from \"./types\";\n\nexport const loadHTMLImageElement = (dataURL: DataURL) => {\n  return new Promise<HTMLImageElement>((resolve, reject) => {\n    const image = new Image();\n    image.onload = () => {\n      resolve(image);\n    };\n    image.onerror = (error) => {\n      reject(error);\n    };\n    image.src = dataURL;\n  });\n};\n\n/** NOTE: updates cache even if already populated with given image. Thus,\n * you should filter out the images upstream if you want to optimize this. */\nexport const updateImageCache = async ({\n  fileIds,\n  files,\n  imageCache,\n}: {\n  fileIds: FileId[];\n  files: BinaryFiles;\n  imageCache: AppClassProperties[\"imageCache\"];\n}) => {\n  const updatedFiles = new Map<FileId, true>();\n  const erroredFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    fileIds.reduce((promises, fileId) => {\n      const fileData = files[fileId as string];\n      if (fileData && !updatedFiles.has(fileId)) {\n        updatedFiles.set(fileId, true);\n        return promises.concat(\n          (async () => {\n            try {\n              if (fileData.mimeType === MIME_TYPES.binary) {\n                throw new Error(\"Only images can be added to ImageCache\");\n              }\n\n              const imagePromise = loadHTMLImageElement(fileData.dataURL);\n              const data = {\n                image: imagePromise,\n                mimeType: fileData.mimeType,\n              } as const;\n              // store the promise immediately to indicate there's an in-progress\n              // initialization\n              imageCache.set(fileId, data);\n\n              const image = await imagePromise;\n\n              imageCache.set(fileId, { ...data, image });\n            } catch (error: any) {\n              erroredFiles.set(fileId, true);\n            }\n          })(),\n        );\n      }\n      return promises;\n    }, [] as Promise<any>[]),\n  );\n\n  return {\n    imageCache,\n    /** includes errored files because they cache was updated nonetheless */\n    updatedFiles,\n    /** files that failed when creating HTMLImageElement */\n    erroredFiles,\n  };\n};\n\nexport const getInitializedImageElements = (\n  elements: readonly ExcalidrawElement[],\n) =>\n  elements.filter((element) =>\n    isInitializedImageElement(element),\n  ) as InitializedExcalidrawImageElement[];\n\nexport const isHTMLSVGElement = (node: Node | null): node is SVGElement => {\n  // lower-casing due to XML/HTML convention differences\n  // https://johnresig.com/blog/nodename-case-sensitivity\n  return node?.nodeName.toLowerCase() === \"svg\";\n};\n\nexport const normalizeSVG = async (SVGString: string) => {\n  const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);\n  const svg = doc.querySelector(\"svg\");\n  const errorNode = doc.querySelector(\"parsererror\");\n  if (errorNode || !isHTMLSVGElement(svg)) {\n    throw new Error(t(\"errors.invalidSVGString\"));\n  } else {\n    if (!svg.hasAttribute(\"xmlns\")) {\n      svg.setAttribute(\"xmlns\", SVG_NS);\n    }\n\n    return svg.outerHTML;\n  }\n};\n","import rough from \"roughjs/bin/rough\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance } from \"../utils\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { DEFAULT_EXPORT_PADDING, SVG_NS, THEME_FILTER } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { serializeAsJSON } from \"../data/json\";\nimport {\n  getInitializedImageElements,\n  updateImageCache,\n} from \"../element/image\";\n\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\n\nexport const exportToCanvas = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n  {\n    exportBackground,\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n  },\n  createCanvas: (\n    width: number,\n    height: number,\n  ) => { canvas: HTMLCanvasElement; scale: number } = (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width * appState.exportScale;\n    canvas.height = height * appState.exportScale;\n    return { canvas, scale: appState.exportScale };\n  },\n) => {\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n\n  const { canvas, scale = 1 } = createCanvas(width, height);\n\n  const defaultAppState = getDefaultAppState();\n\n  const { imageCache } = await updateImageCache({\n    imageCache: new Map(),\n    fileIds: getInitializedImageElements(elements).map(\n      (element) => element.fileId,\n    ),\n    files,\n  });\n\n  renderScene(\n    elements,\n    appState,\n    null,\n    scale,\n    rough.canvas(canvas),\n    canvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      scrollX: -minX + exportPadding,\n      scrollY: -minY + exportPadding,\n      zoom: defaultAppState.zoom,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n      remotePointerUserStates: {},\n      theme: appState.exportWithDarkMode ? \"dark\" : \"light\",\n      imageCache,\n    },\n    {\n      renderScrollbars: false,\n      renderSelection: false,\n      renderOptimizations: true,\n      renderGrid: false,\n      isExport: true,\n    },\n  );\n\n  return canvas;\n};\n\nexport const exportToSvg = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    exportScale?: number;\n    viewBackgroundColor: string;\n    exportWithDarkMode?: boolean;\n    exportEmbedScene?: boolean;\n  },\n  files: BinaryFiles | null,\n): Promise<SVGSVGElement> => {\n  const {\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n    exportScale = 1,\n    exportEmbedScene,\n  } = appState;\n  let metadata = \"\";\n  if (exportEmbedScene) {\n    try {\n      metadata = await (\n        await import(/* webpackChunkName: \"image\" */ \"../../src/data/image\")\n      ).encodeSvgMetadata({\n        text: serializeAsJSON(elements, appState, files || {}, \"local\"),\n      });\n    } catch (error: any) {\n      console.error(error);\n    }\n  }\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n\n  // initialze SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * exportScale}`);\n  svgRoot.setAttribute(\"height\", `${height * exportScale}`);\n  if (appState.exportWithDarkMode) {\n    svgRoot.setAttribute(\"filter\", THEME_FILTER);\n  }\n\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style>\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"https://excalidraw.com/Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"https://excalidraw.com/Cascadia.woff2\");\n      }\n    </style>\n  </defs>\n  `;\n\n  // render background rect\n  if (appState.exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(elements, rsvg, svgRoot, files || {}, {\n    offsetX: -minX + exportPadding,\n    offsetY: -minY + exportPadding,\n  });\n\n  return svgRoot;\n};\n\n// calculate smallest area to fit the contents in\nconst getCanvasSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height = distance(minY, maxY) + exportPadding + exportPadding;\n\n  return [minX, minY, width, height];\n};\n\nexport const getExportSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  scale: number,\n): [number, number] => {\n  const [, , width, height] = getCanvasSize(elements, exportPadding).map(\n    (dimension) => Math.trunc(dimension * scale),\n  );\n\n  return [width, height];\n};\n","import colors from \"./colors\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, ENV } from \"./constants\";\nimport { newElement, newLinearElement, newTextElement } from \"./element\";\nimport { NonDeletedExcalidrawElement } from \"./element/types\";\nimport { randomId } from \"./random\";\n\nexport type ChartElements = readonly NonDeletedExcalidrawElement[];\n\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\n\nexport interface Spreadsheet {\n  title: string | null;\n  labels: string[] | null;\n  values: number[];\n}\n\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n\ntype ParseSpreadsheetResult =\n  | { type: typeof NOT_SPREADSHEET; reason: string }\n  | { type: typeof VALID_SPREADSHEET; spreadsheet: Spreadsheet };\n\nconst tryParseNumber = (s: string): number | null => {\n  const match = /^[$]?([0-9,]+(\\.[0-9]+)?)$/.exec(s);\n  if (!match) {\n    return null;\n  }\n  return parseFloat(match[1].replace(/,/g, \"\"));\n};\n\nconst isNumericColumn = (lines: string[][], columnIndex: number) =>\n  lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);\n\nconst tryParseCells = (cells: string[][]): ParseSpreadsheetResult => {\n  const numCols = cells[0].length;\n\n  if (numCols > 2) {\n    return { type: NOT_SPREADSHEET, reason: \"More than 2 columns\" };\n  }\n\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n    }\n\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map((line) =>\n      tryParseNumber(line[0]),\n    );\n\n    if (values.length < 2) {\n      return { type: NOT_SPREADSHEET, reason: \"Less than two rows\" };\n    }\n\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values as number[],\n      },\n    };\n  }\n\n  const valueColumnIndex = isNumericColumn(cells, 0) ? 0 : 1;\n\n  if (!isNumericColumn(cells, valueColumnIndex)) {\n    return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n  }\n\n  const labelColumnIndex = (valueColumnIndex + 1) % 2;\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n\n  if (rows.length < 2) {\n    return { type: NOT_SPREADSHEET, reason: \"Less than 2 rows\" };\n  }\n\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map((row) => row[labelColumnIndex]),\n      values: rows.map((row) => tryParseNumber(row[valueColumnIndex])!),\n    },\n  };\n};\n\nconst transposeCells = (cells: string[][]) => {\n  const nextCells: string[][] = [];\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow: string[] = [];\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n    nextCells.push(nextCellRow);\n  }\n  return nextCells;\n};\n\nexport const tryParseSpreadsheet = (text: string): ParseSpreadsheetResult => {\n  // Copy/paste from excel, spreadhseets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n\n  // Check for tab separated values\n  let lines = text\n    .trim()\n    .split(\"\\n\")\n    .map((line) => line.trim().split(\"\\t\"));\n\n  // Check for comma separated files\n  if (lines.length && lines[0].length !== 2) {\n    lines = text\n      .trim()\n      .split(\"\\n\")\n      .map((line) => line.trim().split(\",\"));\n  }\n\n  if (lines.length === 0) {\n    return { type: NOT_SPREADSHEET, reason: \"No values\" };\n  }\n\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);\n\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\",\n    };\n  }\n\n  const result = tryParseCells(lines);\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n  return result;\n};\n\nconst bgColors = colors.elementBackground.slice(\n  2,\n  colors.elementBackground.length,\n);\n\n// Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: colors.elementStroke[0],\n  strokeSharpness: \"sharp\",\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: \"middle\",\n} as const;\n\nconst getChartDimentions = (spreadsheet: Spreadsheet) => {\n  const chartWidth =\n    (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return { chartWidth, chartHeight };\n};\n\nconst chartXLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  return (\n    spreadsheet.labels?.map((label, index) => {\n      return newTextElement({\n        groupIds: [groupId],\n        backgroundColor,\n        ...commonProps,\n        text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n        x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n        y: y + BAR_GAP / 2,\n        width: BAR_WIDTH,\n        angle: 5.87,\n        fontSize: 16,\n        textAlign: \"center\",\n        verticalAlign: \"top\",\n      });\n    }) || []\n  );\n};\n\nconst chartYLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\",\n  });\n\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\",\n  });\n\n  return [minYLabel, maxYLabel];\n};\n\nconst chartLines = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    width: chartWidth,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: chartHeight,\n    points: [\n      [0, 0],\n      [0, -chartHeight],\n    ],\n  });\n\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  return [xLine, yLine, maxLine];\n};\n\n// For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\nconst chartBaseElements = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n  debug?: boolean,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n\n  const title = spreadsheet.title\n    ? newTextElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        text: spreadsheet.title,\n        x: x + chartWidth / 2,\n        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n        strokeSharpness: \"sharp\",\n        strokeStyle: \"solid\",\n        textAlign: \"center\",\n      })\n    : null;\n\n  const debugRect = debug\n    ? newElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        type: \"rectangle\",\n        x,\n        y: y - chartHeight,\n        width: chartWidth,\n        height: chartHeight,\n        strokeColor: colors.elementStroke[0],\n        fillStyle: \"solid\",\n        opacity: 6,\n      })\n    : null;\n\n  return [\n    ...(debugRect ? [debugRect] : []),\n    ...(title ? [title] : []),\n    ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartLines(spreadsheet, x, y, groupId, backgroundColor),\n  ];\n};\n\nconst chartTypeBar = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = (value / max) * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight,\n    });\n  });\n\n  return [\n    ...bars,\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n  ];\n};\n\nconst chartTypeLine = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  let index = 0;\n  const points = [];\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n\n  const maxX = Math.max(...points.map((element) => element[0]));\n  const maxY = Math.max(...points.map((element) => element[1]));\n  const minX = Math.min(...points.map((element) => element[0]));\n  const minY = Math.min(...points.map((element) => element[1]));\n\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points as any,\n  });\n\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP,\n    });\n  });\n\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = (value / max) * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      startArrowhead: null,\n      endArrowhead: null,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [\n        [0, 0],\n        [0, cy],\n      ],\n    });\n  });\n\n  return [\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n    line,\n    ...lines,\n    ...dots,\n  ];\n};\n\nexport const renderSpreadsheet = (\n  chartType: string,\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n  return chartTypeBar(spreadsheet, x, y);\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { getSelectedElements } from \"./scene\";\nimport { AppState, BinaryFiles } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, Spreadsheet, VALID_SPREADSHEET } from \"./charts\";\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"./constants\";\nimport { isInitializedImageElement } from \"./element/typeChecks\";\n\ntype ElementsClipboard = {\n  type: typeof EXPORT_DATA_TYPES.excalidrawClipboard;\n  elements: ExcalidrawElement[];\n  files: BinaryFiles | undefined;\n};\n\nexport interface ClipboardData {\n  spreadsheet?: Spreadsheet;\n  elements?: readonly ExcalidrawElement[];\n  files?: BinaryFiles;\n  text?: string;\n  errorMessage?: string;\n}\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nconst clipboardContainsElements = (\n  contents: any,\n): contents is { elements: ExcalidrawElement[]; files?: BinaryFiles } => {\n  if (\n    [\n      EXPORT_DATA_TYPES.excalidraw,\n      EXPORT_DATA_TYPES.excalidrawClipboard,\n    ].includes(contents?.type) &&\n    Array.isArray(contents.elements)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const copyToClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n) => {\n  const selectedElements = getSelectedElements(elements, appState);\n  const contents: ElementsClipboard = {\n    type: EXPORT_DATA_TYPES.excalidrawClipboard,\n    elements: selectedElements,\n    files: selectedElements.reduce((acc, element) => {\n      if (isInitializedImageElement(element) && files[element.fileId]) {\n        acc[element.fileId] = files[element.fileId];\n      }\n      return acc;\n    }, {} as BinaryFiles),\n  };\n  const json = JSON.stringify(contents);\n  CLIPBOARD = json;\n  try {\n    PREFER_APP_CLIPBOARD = false;\n    await copyTextToSystemClipboard(json);\n  } catch (error: any) {\n    PREFER_APP_CLIPBOARD = true;\n    console.error(error);\n  }\n};\n\nconst getAppClipboard = (): Partial<ElementsClipboard> => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    return JSON.parse(CLIPBOARD);\n  } catch (error: any) {\n    console.error(error);\n    return {};\n  }\n};\n\nconst parsePotentialSpreadsheet = (\n  text: string,\n): { spreadsheet: Spreadsheet } | { errorMessage: string } | null => {\n  const result = tryParseSpreadsheet(text);\n  if (result.type === VALID_SPREADSHEET) {\n    return { spreadsheet: result.spreadsheet };\n  }\n  return null;\n};\n\n/**\n * Retrieves content from system clipboard (either from ClipboardEvent or\n *  via async clipboard API if supported)\n */\nconst getSystemClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<string> => {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\").trim()\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    return text || \"\";\n  } catch {\n    return \"\";\n  }\n};\n\n/**\n * Attemps to parse clipboard. Prefers system clipboard.\n */\nexport const parseClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<ClipboardData> => {\n  const systemClipboard = await getSystemClipboard(event);\n\n  // if system clipboard empty, couldn't be resolved, or contains previously\n  // copied excalidraw scene as SVG, fall back to previously copied excalidraw\n  // elements\n  if (!systemClipboard || systemClipboard.includes(SVG_EXPORT_TAG)) {\n    return getAppClipboard();\n  }\n\n  // if system clipboard contains spreadsheet, use it even though it's\n  // technically possible it's staler than in-app clipboard\n  const spreadsheetResult = parsePotentialSpreadsheet(systemClipboard);\n  if (spreadsheetResult) {\n    return spreadsheetResult;\n  }\n\n  const appClipboardData = getAppClipboard();\n\n  try {\n    const systemClipboardData = JSON.parse(systemClipboard);\n    if (clipboardContainsElements(systemClipboardData)) {\n      return {\n        elements: systemClipboardData.elements,\n        files: systemClipboardData.files,\n      };\n    }\n    return appClipboardData;\n  } catch {\n    // system clipboard doesn't contain excalidraw elements  return plaintext\n    // unless we set a flag to prefer in-app clipboard because browser didn't\n    // support storing to system clipboard on copy\n    return PREFER_APP_CLIPBOARD && appClipboardData.elements\n      ? appClipboardData\n      : { text: systemClipboard };\n  }\n};\n\nexport const copyBlobToClipboardAsPng = async (blob: Blob) => {\n  await navigator.clipboard.write([\n    new window.ClipboardItem({ [MIME_TYPES.png]: blob }),\n  ]);\n};\n\nexport const copyTextToSystemClipboard = async (text: string | null) => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error: any) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string) => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error: any) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n","import {\n  copyBlobToClipboardAsPng,\n  copyTextToSystemClipboard,\n} from \"../clipboard\";\nimport { DEFAULT_EXPORT_PADDING, MIME_TYPES } from \"../constants\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\nimport { ExportType } from \"../scene/types\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { canvasToBlob } from \"./blob\";\nimport { fileSave, FileSystemHandle } from \"./filesystem\";\nimport { serializeAsJSON } from \"./json\";\n\nexport { loadFromBlob } from \"./blob\";\nexport { loadFromJSON, saveAsJSON } from \"./json\";\n\nexport const exportCanvas = async (\n  type: ExportType,\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n  {\n    exportBackground,\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n    name,\n    fileHandle = null,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    name: string;\n    fileHandle?: FileSystemHandle | null;\n  },\n) => {\n  if (elements.length === 0) {\n    throw new Error(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const tempSvg = await exportToSvg(\n      elements,\n      {\n        exportBackground,\n        exportWithDarkMode: appState.exportWithDarkMode,\n        viewBackgroundColor,\n        exportPadding,\n        exportScale: appState.exportScale,\n        exportEmbedScene: appState.exportEmbedScene && type === \"svg\",\n      },\n      files,\n    );\n    if (type === \"svg\") {\n      return await fileSave(\n        new Blob([tempSvg.outerHTML], { type: MIME_TYPES.svg }),\n        {\n          name,\n          extension: \"svg\",\n          fileHandle,\n        },\n      );\n    } else if (type === \"clipboard-svg\") {\n      await copyTextToSystemClipboard(tempSvg.outerHTML);\n      return;\n    }\n  }\n\n  const tempCanvas = await exportToCanvas(elements, appState, files, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n  });\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n  let blob = await canvasToBlob(tempCanvas);\n  tempCanvas.remove();\n\n  if (type === \"png\") {\n    if (appState.exportEmbedScene) {\n      blob = await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).encodePngMetadata({\n        blob,\n        metadata: serializeAsJSON(elements, appState, files, \"local\"),\n      });\n    }\n\n    return await fileSave(blob, {\n      name,\n      extension: \"png\",\n      fileHandle,\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      await copyBlobToClipboardAsPng(blob);\n    } catch (error: any) {\n      if (error.name === \"CANVAS_POSSIBLY_TOO_BIG\") {\n        throw error;\n      }\n      throw new Error(t(\"alerts.couldNotCopyToClipboard\"));\n    }\n  }\n};\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { checkIcon } from \"./icons\";\n\nimport \"./CheckboxItem.scss\";\n\nexport const CheckboxItem: React.FC<{\n  checked: boolean;\n  onChange: (checked: boolean) => void;\n}> = ({ children, checked, onChange }) => {\n  return (\n    <div\n      className={clsx(\"Checkbox\", { \"is-checked\": checked })}\n      onClick={(event) => {\n        onChange(!checked);\n        (\n          (event.currentTarget as HTMLDivElement).querySelector(\n            \".Checkbox-box\",\n          ) as HTMLButtonElement\n        ).focus();\n      }}\n    >\n      <button className=\"Checkbox-box\" role=\"checkbox\" aria-checked={checked}>\n        {checkIcon}\n      </button>\n      <div className=\"Checkbox-label\">{children}</div>\n    </div>\n  );\n};\n","import \"./Stack.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype StackProps = {\n  children: React.ReactNode;\n  gap?: number;\n  align?: \"start\" | \"center\" | \"end\" | \"baseline\";\n  justifyContent?: \"center\" | \"space-around\" | \"space-between\";\n  className?: string | boolean;\n  style?: React.CSSProperties;\n};\n\nconst RowStack = ({\n  children,\n  gap,\n  align,\n  justifyContent,\n  className,\n  style,\n}: StackProps) => {\n  return (\n    <div\n      className={clsx(\"Stack Stack_horizontal\", className)}\n      style={{\n        \"--gap\": gap,\n        alignItems: align,\n        justifyContent,\n        ...style,\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nconst ColStack = ({\n  children,\n  gap,\n  align,\n  justifyContent,\n  className,\n}: StackProps) => {\n  return (\n    <div\n      className={clsx(\"Stack Stack_vertical\", className)}\n      style={{\n        \"--gap\": gap,\n        justifyItems: align,\n        justifyContent,\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nexport default {\n  Row: RowStack,\n  Col: ColStack,\n};\n","import Stack from \"../components/Stack\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { save, file } from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport \"./ActiveFile.scss\";\n\ntype ActiveFileProps = {\n  fileName?: string;\n  onSave: () => void;\n};\n\nexport const ActiveFile = ({ fileName, onSave }: ActiveFileProps) => (\n  <Stack.Row className=\"ActiveFile\" gap={1} align=\"center\">\n    <span className=\"ActiveFile__fileName\">\n      {file}\n      <span>{fileName}</span>\n    </span>\n    <ToolButton\n      type=\"icon\"\n      icon={save}\n      title={t(\"buttons.save\")}\n      aria-label={t(\"buttons.save\")}\n      onClick={onSave}\n      data-testid=\"save-button\"\n    />\n  </Stack.Row>\n);\n","import { trackEvent } from \"../analytics\";\nimport { load, questionCircle, saveAs } from \"../components/icons\";\nimport { ProjectName } from \"../components/ProjectName\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport \"../components/ToolIcon.scss\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport { DarkModeToggle } from \"../components/DarkModeToggle\";\nimport { loadFromJSON, saveAsJSON } from \"../data\";\nimport { resaveAsImageWithScene } from \"../data/resave\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { CheckboxItem } from \"../components/CheckboxItem\";\nimport { getExportSize } from \"../scene/export\";\nimport { DEFAULT_EXPORT_PADDING, EXPORT_SCALES, THEME } from \"../constants\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ActiveFile } from \"../components/ActiveFile\";\nimport { isImageFileHandle } from \"../data/blob\";\nimport { nativeFileSystemSupported } from \"../data/filesystem\";\nimport { Theme } from \"../element/types\";\n\nexport const actionChangeProjectName = register({\n  name: \"changeProjectName\",\n  perform: (_elements, appState, value) => {\n    trackEvent(\"change\", \"title\");\n    return { appState: { ...appState, name: value }, commitToHistory: false };\n  },\n  PanelComponent: ({ appState, updateData, appProps }) => (\n    <ProjectName\n      label={t(\"labels.fileTitle\")}\n      value={appState.name || \"Unnamed\"}\n      onChange={(name: string) => updateData(name)}\n      isNameEditable={\n        typeof appProps.name === \"undefined\" && !appState.viewModeEnabled\n      }\n    />\n  ),\n});\n\nexport const actionChangeExportScale = register({\n  name: \"changeExportScale\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportScale: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ elements: allElements, appState, updateData }) => {\n    const elements = getNonDeletedElements(allElements);\n    const exportSelected = isSomeElementSelected(elements, appState);\n    const exportedElements = exportSelected\n      ? getSelectedElements(elements, appState)\n      : elements;\n\n    return (\n      <>\n        {EXPORT_SCALES.map((s) => {\n          const [width, height] = getExportSize(\n            exportedElements,\n            DEFAULT_EXPORT_PADDING,\n            s,\n          );\n\n          const scaleButtonTitle = `${t(\n            \"buttons.scale\",\n          )} ${s}x (${width}x${height})`;\n\n          return (\n            <ToolButton\n              key={s}\n              size=\"small\"\n              type=\"radio\"\n              icon={`${s}x`}\n              name=\"export-canvas-scale\"\n              title={scaleButtonTitle}\n              aria-label={scaleButtonTitle}\n              id=\"export-canvas-scale\"\n              checked={s === appState.exportScale}\n              onChange={() => updateData(s)}\n            />\n          );\n        })}\n      </>\n    );\n  },\n});\n\nexport const actionChangeExportBackground = register({\n  name: \"changeExportBackground\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportBackground: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <CheckboxItem\n      checked={appState.exportBackground}\n      onChange={(checked) => updateData(checked)}\n    >\n      {t(\"labels.withBackground\")}\n    </CheckboxItem>\n  ),\n});\n\nexport const actionChangeExportEmbedScene = register({\n  name: \"changeExportEmbedScene\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportEmbedScene: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <CheckboxItem\n      checked={appState.exportEmbedScene}\n      onChange={(checked) => updateData(checked)}\n    >\n      {t(\"labels.exportEmbedScene\")}\n      <Tooltip label={t(\"labels.exportEmbedScene_details\")} long={true}>\n        <div className=\"excalidraw-tooltip-icon\">{questionCircle}</div>\n      </Tooltip>\n    </CheckboxItem>\n  ),\n});\n\nexport const actionSaveToActiveFile = register({\n  name: \"saveToActiveFile\",\n  perform: async (elements, appState, value, app) => {\n    const fileHandleExists = !!appState.fileHandle;\n\n    try {\n      const { fileHandle } = isImageFileHandle(appState.fileHandle)\n        ? await resaveAsImageWithScene(elements, appState, app.files)\n        : await saveAsJSON(elements, appState, app.files);\n\n      return {\n        commitToHistory: false,\n        appState: {\n          ...appState,\n          fileHandle,\n          toastMessage: fileHandleExists\n            ? fileHandle?.name\n              ? t(\"toast.fileSavedToFilename\").replace(\n                  \"{filename}\",\n                  `\"${fileHandle.name}\"`,\n                )\n              : t(\"toast.fileSaved\")\n            : null,\n        },\n      };\n    } catch (error: any) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      }\n      return { commitToHistory: false };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey,\n  PanelComponent: ({ updateData, appState }) => (\n    <ActiveFile\n      onSave={() => updateData(null)}\n      fileName={appState.fileHandle?.name}\n    />\n  ),\n});\n\nexport const actionSaveFileToDisk = register({\n  name: \"saveFileToDisk\",\n  perform: async (elements, appState, value, app) => {\n    try {\n      const { fileHandle } = await saveAsJSON(\n        elements,\n        {\n          ...appState,\n          fileHandle: null,\n        },\n        app.files,\n      );\n      return { commitToHistory: false, appState: { ...appState, fileHandle } };\n    } catch (error: any) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      }\n      return { commitToHistory: false };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={saveAs}\n      title={t(\"buttons.saveAs\")}\n      aria-label={t(\"buttons.saveAs\")}\n      showAriaLabel={useIsMobile()}\n      hidden={!nativeFileSystemSupported}\n      onClick={() => updateData(null)}\n      data-testid=\"save-as-button\"\n    />\n  ),\n});\n\nexport const actionLoadScene = register({\n  name: \"loadScene\",\n  perform: async (elements, appState, _, app) => {\n    try {\n      const {\n        elements: loadedElements,\n        appState: loadedAppState,\n        files,\n      } = await loadFromJSON(appState, elements);\n      return {\n        elements: loadedElements,\n        appState: loadedAppState,\n        files,\n        commitToHistory: true,\n      };\n    } catch (error: any) {\n      if (error?.name === \"AbortError\") {\n        return false;\n      }\n      return {\n        elements,\n        appState: { ...appState, errorMessage: error.message },\n        files: app.files,\n        commitToHistory: false,\n      };\n    }\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O,\n  PanelComponent: ({ updateData, appState }) => (\n    <ToolButton\n      type=\"button\"\n      icon={load}\n      title={t(\"buttons.load\")}\n      aria-label={t(\"buttons.load\")}\n      showAriaLabel={useIsMobile()}\n      onClick={updateData}\n      data-testid=\"load-button\"\n    />\n  ),\n});\n\nexport const actionExportWithDarkMode = register({\n  name: \"exportWithDarkMode\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportWithDarkMode: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <div\n      style={{\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        marginTop: \"-45px\",\n        marginBottom: \"10px\",\n      }}\n    >\n      <DarkModeToggle\n        value={appState.exportWithDarkMode ? THEME.DARK : THEME.LIGHT}\n        onChange={(theme: Theme) => {\n          updateData(theme === THEME.DARK);\n        }}\n        title={t(\"labels.toggleExportColorScheme\")}\n      />\n    </div>\n  ),\n});\n","import { ExcalidrawElement } from \"../element/types\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { exportCanvas } from \".\";\nimport { getNonDeletedElements } from \"../element\";\nimport { getFileHandleType, isImageFileHandleType } from \"./blob\";\n\nexport const resaveAsImageWithScene = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n) => {\n  const { exportBackground, viewBackgroundColor, name, fileHandle } = appState;\n\n  const fileHandleType = getFileHandleType(fileHandle);\n\n  if (!fileHandle || !isImageFileHandleType(fileHandleType)) {\n    throw new Error(\n      \"fileHandle should exist and should be of type svg or png when resaving\",\n    );\n  }\n  appState = {\n    ...appState,\n    exportEmbedScene: true,\n  };\n\n  await exportCanvas(\n    fileHandleType,\n    getNonDeletedElements(elements),\n    appState,\n    files,\n    {\n      exportBackground,\n      viewBackgroundColor,\n      name,\n      fileHandle,\n    },\n  );\n\n  return { fileHandle };\n};\n","import {\n  isTextElement,\n  isExcalidrawElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement, newElementWith } from \"../element/mutateElement\";\nimport {\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n} from \"../constants\";\n\n// `copiedStyles` is exported only for tests.\nexport let copiedStyles: string = \"{}\";\n\nexport const actionCopyStyles = register({\n  name: \"copyStyles\",\n  perform: (elements, appState) => {\n    const element = elements.find((el) => appState.selectedElementIds[el.id]);\n    if (element) {\n      copiedStyles = JSON.stringify(element);\n    }\n    return {\n      appState: {\n        ...appState,\n        toastMessage: t(\"toast.copyStyles\"),\n      },\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: \"labels.copyStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C,\n});\n\nexport const actionPasteStyles = register({\n  name: \"pasteStyles\",\n  perform: (elements, appState) => {\n    const pastedElement = JSON.parse(copiedStyles);\n    if (!isExcalidrawElement(pastedElement)) {\n      return { elements, commitToHistory: false };\n    }\n    return {\n      elements: elements.map((element) => {\n        if (appState.selectedElementIds[element.id]) {\n          const newElement = newElementWith(element, {\n            backgroundColor: pastedElement?.backgroundColor,\n            strokeWidth: pastedElement?.strokeWidth,\n            strokeColor: pastedElement?.strokeColor,\n            strokeStyle: pastedElement?.strokeStyle,\n            fillStyle: pastedElement?.fillStyle,\n            opacity: pastedElement?.opacity,\n            roughness: pastedElement?.roughness,\n          });\n          if (isTextElement(newElement)) {\n            mutateElement(newElement, {\n              fontSize: pastedElement?.fontSize || DEFAULT_FONT_SIZE,\n              fontFamily: pastedElement?.fontFamily || DEFAULT_FONT_FAMILY,\n              textAlign: pastedElement?.textAlign || DEFAULT_TEXT_ALIGN,\n            });\n            redrawTextBoundingBox(newElement);\n          }\n          return newElement;\n        }\n        return element;\n      }),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.pasteStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,\n});\n","import { questionCircle } from \"../components/icons\";\n\ntype HelpIconProps = {\n  title?: string;\n  name?: string;\n  id?: string;\n  onClick?(): void;\n};\n\nexport const HelpIcon = (props: HelpIconProps) => (\n  <button\n    className=\"help-icon\"\n    onClick={props.onClick}\n    type=\"button\"\n    title={`${props.title}  ?`}\n    aria-label={props.title}\n  >\n    {questionCircle}\n  </button>\n);\n","import { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport { UngroupIcon, GroupIcon } from \"../components/icons\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport {\n  getSelectedGroupIds,\n  selectGroup,\n  selectGroupsForSelectedElements,\n  getElementsInGroup,\n  addToGroup,\n  removeFromSelectedGroups,\n  isElementInGroup,\n} from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\nimport { randomId } from \"../random\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\n\nconst allElementsInSameGroup = (elements: readonly ExcalidrawElement[]) => {\n  if (elements.length >= 2) {\n    const groupIds = elements[0].groupIds;\n    for (const groupId of groupIds) {\n      if (\n        elements.reduce(\n          (acc, element) => acc && isElementInGroup(element, groupId),\n          true,\n        )\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return (\n    selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements)\n  );\n};\n\nexport const actionGroup = register({\n  name: \"group\",\n  perform: (elements, appState) => {\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    if (selectedElements.length < 2) {\n      // nothing to group\n      return { appState, elements, commitToHistory: false };\n    }\n    // if everything is already grouped into 1 group, there is nothing to do\n    const selectedGroupIds = getSelectedGroupIds(appState);\n    if (selectedGroupIds.length === 1) {\n      const selectedGroupId = selectedGroupIds[0];\n      const elementIdsInGroup = new Set(\n        getElementsInGroup(elements, selectedGroupId).map(\n          (element) => element.id,\n        ),\n      );\n      const selectedElementIds = new Set(\n        selectedElements.map((element) => element.id),\n      );\n      const combinedSet = new Set([\n        ...Array.from(elementIdsInGroup),\n        ...Array.from(selectedElementIds),\n      ]);\n      if (combinedSet.size === elementIdsInGroup.size) {\n        // no incremental ids in the selected ids\n        return { appState, elements, commitToHistory: false };\n      }\n    }\n    const newGroupId = randomId();\n    const updatedElements = elements.map((element) => {\n      if (!appState.selectedElementIds[element.id]) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: addToGroup(\n          element.groupIds,\n          newGroupId,\n          appState.editingGroupId,\n        ),\n      });\n    });\n    // keep the z order within the group the same, but move them\n    // to the z order of the highest element in the layer stack\n    const elementsInGroup = getElementsInGroup(updatedElements, newGroupId);\n    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];\n    const lastGroupElementIndex =\n      updatedElements.lastIndexOf(lastElementInGroup);\n    const elementsAfterGroup = updatedElements.slice(lastGroupElementIndex + 1);\n    const elementsBeforeGroup = updatedElements\n      .slice(0, lastGroupElementIndex)\n      .filter(\n        (updatedElement) => !isElementInGroup(updatedElement, newGroupId),\n      );\n    const updatedElementsInOrder = [\n      ...elementsBeforeGroup,\n      ...elementsInGroup,\n      ...elementsAfterGroup,\n    ];\n\n    return {\n      appState: selectGroup(\n        newGroupId,\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(updatedElementsInOrder),\n      ),\n      elements: updatedElementsInOrder,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.group\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionGroup(elements, appState),\n  keyTest: (event) =>\n    !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<GroupIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.group\")}  ${getShortcutKey(\"CtrlOrCmd+G\")}`}\n      aria-label={t(\"labels.group\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n\nexport const actionUngroup = register({\n  name: \"ungroup\",\n  perform: (elements, appState) => {\n    const groupIds = getSelectedGroupIds(appState);\n    if (groupIds.length === 0) {\n      return { appState, elements, commitToHistory: false };\n    }\n    const nextElements = elements.map((element) => {\n      const nextGroupIds = removeFromSelectedGroups(\n        element.groupIds,\n        appState.selectedGroupIds,\n      );\n      if (nextGroupIds.length === element.groupIds.length) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: nextGroupIds,\n      });\n    });\n    return {\n      appState: selectGroupsForSelectedElements(\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(nextElements),\n      ),\n      elements: nextElements,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  contextItemLabel: \"labels.ungroup\",\n  contextItemPredicate: (elements, appState) =>\n    getSelectedGroupIds(appState).length > 0,\n\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      hidden={getSelectedGroupIds(appState).length === 0}\n      icon={<UngroupIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.ungroup\")}  ${getShortcutKey(\"CtrlOrCmd+Shift+G\")}`}\n      aria-label={t(\"labels.ungroup\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n","import { menu, palette } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { showSelectedShapeActions, getNonDeletedElements } from \"../element\";\nimport { register } from \"./register\";\nimport { allowFullScreen, exitFullScreen, isFullScreen } from \"../utils\";\nimport { CODES, KEYS } from \"../keys\";\nimport { HelpIcon } from \"../components/HelpIcon\";\n\nexport const actionToggleCanvasMenu = register({\n  name: \"toggleCanvasMenu\",\n  perform: (_, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"canvas\" ? null : \"canvas\",\n    },\n    commitToHistory: false,\n  }),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={menu}\n      aria-label={t(\"buttons.menu\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"canvas\"}\n    />\n  ),\n});\n\nexport const actionToggleEditMenu = register({\n  name: \"toggleEditMenu\",\n  perform: (_elements, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"shape\" ? null : \"shape\",\n    },\n    commitToHistory: false,\n  }),\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      visible={showSelectedShapeActions(\n        appState,\n        getNonDeletedElements(elements),\n      )}\n      type=\"button\"\n      icon={palette}\n      aria-label={t(\"buttons.edit\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"shape\"}\n    />\n  ),\n});\n\nexport const actionFullScreen = register({\n  name: \"toggleFullScreen\",\n  perform: () => {\n    if (!isFullScreen()) {\n      allowFullScreen();\n    }\n    if (isFullScreen()) {\n      exitFullScreen();\n    }\n    return {\n      commitToHistory: false,\n    };\n  },\n  keyTest: (event) => event.code === CODES.F && !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionShortcuts = register({\n  name: \"toggleShortcuts\",\n  perform: (_elements, appState, _, { focusContainer }) => {\n    if (appState.showHelpDialog) {\n      focusContainer();\n    }\n    return {\n      appState: {\n        ...appState,\n        showHelpDialog: !appState.showHelpDialog,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <HelpIcon title={t(\"helpDialog.title\")} onClick={updateData} />\n  ),\n  keyTest: (event) => event.key === KEYS.QUESTION_MARK,\n});\n","import \"./Avatar.scss\";\n\nimport React from \"react\";\n\ntype AvatarProps = {\n  children: string;\n  onClick: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\n  color: string;\n  border: string;\n};\n\nexport const Avatar = ({ children, color, border, onClick }: AvatarProps) => (\n  <div\n    className=\"Avatar\"\n    style={{ background: color, border: `1px solid ${border}` }}\n    onClick={onClick}\n  >\n    {children}\n  </div>\n);\n","import { register } from \"./register\";\nimport { getSelectedElements } from \"../scene\";\nimport { getNonDeletedElements } from \"../element\";\nimport { deepCopyElement } from \"../element/newElement\";\n\nexport const actionAddToLibrary = register({\n  name: \"addToLibrary\",\n  perform: (elements, appState, _, app) => {\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n\n    app.library.loadLibrary().then((items) => {\n      app.library.saveLibrary([\n        ...items,\n        selectedElements.map(deepCopyElement),\n      ]);\n    });\n    return false;\n  },\n  contextItemLabel: \"labels.addToLibrary\",\n});\n","import { getClientColors, getClientInitials } from \"../clients\";\nimport { Avatar } from \"../components/Avatar\";\nimport { centerScrollOn } from \"../scene/scroll\";\nimport { Collaborator } from \"../types\";\nimport { register } from \"./register\";\n\nexport const actionGoToCollaborator = register({\n  name: \"goToCollaborator\",\n  perform: (_elements, appState, value) => {\n    const point = value as Collaborator[\"pointer\"];\n    if (!point) {\n      return { appState, commitToHistory: false };\n    }\n\n    return {\n      appState: {\n        ...appState,\n        ...centerScrollOn({\n          scenePoint: point,\n          viewportDimensions: {\n            width: appState.width,\n            height: appState.height,\n          },\n          zoom: appState.zoom,\n        }),\n        // Close mobile menu\n        openMenu: appState.openMenu === \"canvas\" ? null : appState.openMenu,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData, data }) => {\n    const clientId: string | undefined = data?.id;\n    if (!clientId) {\n      return null;\n    }\n\n    const collaborator = appState.collaborators.get(clientId);\n\n    if (!collaborator) {\n      return null;\n    }\n\n    const { background, stroke } = getClientColors(clientId, appState);\n    const shortName = getClientInitials(collaborator.username);\n\n    return (\n      <Avatar\n        color={background}\n        border={stroke}\n        onClick={() => updateData(collaborator.pointer)}\n      >\n        {shortName}\n      </Avatar>\n    );\n  },\n});\n","import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n}\n\nexport interface Alignment {\n  position: \"start\" | \"center\" | \"end\";\n  axis: \"x\" | \"y\";\n}\n\nexport const alignElements = (\n  selectedElements: ExcalidrawElement[],\n  alignment: Alignment,\n): ExcalidrawElement[] => {\n  const groups: ExcalidrawElement[][] = getMaximumGroups(selectedElements);\n\n  const selectionBoundingBox = getCommonBoundingBox(selectedElements);\n\n  return groups.flatMap((group) => {\n    const translation = calculateTranslation(\n      group,\n      selectionBoundingBox,\n      alignment,\n    );\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst calculateTranslation = (\n  group: ExcalidrawElement[],\n  selectionBoundingBox: Box,\n  { axis, position }: Alignment,\n): { x: number; y: number } => {\n  const groupBoundingBox = getCommonBoundingBox(group);\n\n  const [min, max]: [\"minX\" | \"minY\", \"maxX\" | \"maxY\"] =\n    axis === \"x\" ? [\"minX\", \"maxX\"] : [\"minY\", \"maxY\"];\n\n  const noTranslation = { x: 0, y: 0 };\n  if (position === \"start\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[min] - groupBoundingBox[min],\n    };\n  } else if (position === \"end\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[max] - groupBoundingBox[max],\n    };\n  } // else if (position === \"center\") {\n  return {\n    ...noTranslation,\n    [axis]:\n      (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 -\n      (groupBoundingBox[min] + groupBoundingBox[max]) / 2,\n  };\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return { minX, minY, maxX, maxY };\n};\n","import { alignElements, Alignment } from \"../align\";\nimport {\n  AlignBottomIcon,\n  AlignLeftIcon,\n  AlignRightIcon,\n  AlignTopIcon,\n  CenterHorizontallyIcon,\n  CenterVerticallyIcon,\n} from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { KEYS } from \"../keys\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => getSelectedElements(getNonDeletedElements(elements), appState).length > 1;\n\nconst alignSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  alignment: Alignment,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  const updatedElements = alignElements(selectedElements, alignment);\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nexport const actionAlignTop = register({\n  name: \"alignTop\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"start\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignTopIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignTop\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Up\",\n      )}`}\n      aria-label={t(\"labels.alignTop\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignBottom = register({\n  name: \"alignBottom\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"end\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignBottomIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignBottom\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Down\",\n      )}`}\n      aria-label={t(\"labels.alignBottom\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignLeft = register({\n  name: \"alignLeft\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"start\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignLeftIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignLeft\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Left\",\n      )}`}\n      aria-label={t(\"labels.alignLeft\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignRight = register({\n  name: \"alignRight\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"end\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignRightIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignRight\")}  ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Right\",\n      )}`}\n      aria-label={t(\"labels.alignRight\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignVerticallyCentered = register({\n  name: \"alignVerticallyCentered\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"center\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<CenterVerticallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerVertically\")}\n      aria-label={t(\"labels.centerVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignHorizontallyCentered = register({\n  name: \"alignHorizontallyCentered\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"center\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<CenterHorizontallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerHorizontally\")}\n      aria-label={t(\"labels.centerHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport interface Distribution {\n  space: \"between\";\n  axis: \"x\" | \"y\";\n}\n\nexport const distributeElements = (\n  selectedElements: ExcalidrawElement[],\n  distribution: Distribution,\n): ExcalidrawElement[] => {\n  const [start, mid, end, extent] =\n    distribution.axis === \"x\"\n      ? ([\"minX\", \"midX\", \"maxX\", \"width\"] as const)\n      : ([\"minY\", \"midY\", \"maxY\", \"height\"] as const);\n\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements)\n    .map((group) => [group, getCommonBoundingBox(group)] as const)\n    .sort((a, b) => a[1][mid] - b[1][mid]);\n\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex((g) => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step =\n      (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n\n    let pos = groups[index0][1][mid];\n\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0,\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map((element) =>\n        newElementWith(element, {\n          x: element.x + translation.x,\n          y: element.y + translation.y,\n        }),\n      );\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0,\n    };\n\n    translation[distribution.axis] = pos - box[start];\n\n    pos += step;\n    pos += box[extent];\n\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n","import {\n  DistributeHorizontallyIcon,\n  DistributeVerticallyIcon,\n} from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { distributeElements, Distribution } from \"../disitrubte\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { CODES } from \"../keys\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => getSelectedElements(getNonDeletedElements(elements), appState).length > 1;\n\nconst distributeSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  distribution: Distribution,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  const updatedElements = distributeElements(selectedElements, distribution);\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nexport const distributeHorizontally = register({\n  name: \"distributeHorizontally\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, {\n        space: \"between\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.altKey && event.code === CODES.H,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<DistributeHorizontallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeHorizontally\")}  ${getShortcutKey(\n        \"Alt+H\",\n      )}`}\n      aria-label={t(\"labels.distributeHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const distributeVertically = register({\n  name: \"distributeVertically\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, {\n        space: \"between\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.altKey && event.code === CODES.V,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<DistributeVerticallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeVertically\")}  ${getShortcutKey(\"Alt+V\")}`}\n      aria-label={t(\"labels.distributeVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { register } from \"./register\";\nimport { getSelectedElements } from \"../scene\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { ExcalidrawElement, NonDeleted } from \"../element/types\";\nimport { normalizeAngle, resizeSingleElement } from \"../element/resizeElements\";\nimport { AppState } from \"../types\";\nimport { getTransformHandles } from \"../element/transformHandles\";\nimport { isFreeDrawElement, isLinearElement } from \"../element/typeChecks\";\nimport { updateBoundElements } from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\nconst enableActionFlipHorizontal = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const eligibleElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return eligibleElements.length === 1 && eligibleElements[0].type !== \"text\";\n};\n\nconst enableActionFlipVertical = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const eligibleElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return eligibleElements.length === 1;\n};\n\nexport const actionFlipHorizontal = register({\n  name: \"flipHorizontal\",\n  perform: (elements, appState) => {\n    return {\n      elements: flipSelectedElements(elements, appState, \"horizontal\"),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.shiftKey && event.code === \"KeyH\",\n  contextItemLabel: \"labels.flipHorizontal\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionFlipHorizontal(elements, appState),\n});\n\nexport const actionFlipVertical = register({\n  name: \"flipVertical\",\n  perform: (elements, appState) => {\n    return {\n      elements: flipSelectedElements(elements, appState, \"vertical\"),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.shiftKey && event.code === \"KeyV\",\n  contextItemLabel: \"labels.flipVertical\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionFlipVertical(elements, appState),\n});\n\nconst flipSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  flipDirection: \"horizontal\" | \"vertical\",\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  // remove once we allow for groups of elements to be flipped\n  if (selectedElements.length > 1) {\n    return elements;\n  }\n\n  const updatedElements = flipElements(\n    selectedElements,\n    appState,\n    flipDirection,\n  );\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nconst flipElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n  appState: AppState,\n  flipDirection: \"horizontal\" | \"vertical\",\n): ExcalidrawElement[] => {\n  elements.forEach((element) => {\n    flipElement(element, appState);\n    // If vertical flip, rotate an extra 180\n    if (flipDirection === \"vertical\") {\n      rotateElement(element, Math.PI);\n    }\n  });\n  return elements;\n};\n\nconst flipElement = (\n  element: NonDeleted<ExcalidrawElement>,\n  appState: AppState,\n) => {\n  const originalX = element.x;\n  const originalY = element.y;\n  const width = element.width;\n  const height = element.height;\n  const originalAngle = normalizeAngle(element.angle);\n\n  let finalOffsetX = 0;\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    finalOffsetX =\n      element.points.reduce((max, point) => Math.max(max, point[0]), 0) * 2 -\n      element.width;\n  }\n\n  // Rotate back to zero, if necessary\n  mutateElement(element, {\n    angle: normalizeAngle(0),\n  });\n  // Flip unrotated by pulling TransformHandle to opposite side\n  const transformHandles = getTransformHandles(element, appState.zoom);\n  let usingNWHandle = true;\n  let newNCoordsX = 0;\n  let nHandle = transformHandles.nw;\n  if (!nHandle) {\n    // Use ne handle instead\n    usingNWHandle = false;\n    nHandle = transformHandles.ne;\n    if (!nHandle) {\n      mutateElement(element, {\n        angle: originalAngle,\n      });\n      return;\n    }\n  }\n\n  if (isLinearElement(element)) {\n    for (let i = 1; i < element.points.length; i++) {\n      LinearElementEditor.movePoint(element, i, [\n        -element.points[i][0],\n        element.points[i][1],\n      ]);\n    }\n    LinearElementEditor.normalizePoints(element);\n  } else {\n    // calculate new x-coord for transformation\n    newNCoordsX = usingNWHandle ? element.x + 2 * width : element.x - 2 * width;\n    resizeSingleElement(\n      element,\n      true,\n      element,\n      usingNWHandle ? \"nw\" : \"ne\",\n      false,\n      newNCoordsX,\n      nHandle[1],\n    );\n    // fix the size to account for handle sizes\n    mutateElement(element, {\n      width,\n      height,\n    });\n  }\n\n  // Rotate by (360 degrees - original angle)\n  let angle = normalizeAngle(2 * Math.PI - originalAngle);\n  if (angle < 0) {\n    // check, probably unnecessary\n    angle = normalizeAngle(angle + 2 * Math.PI);\n  }\n  mutateElement(element, {\n    angle,\n  });\n\n  // Move back to original spot to appear \"flipped in place\"\n  mutateElement(element, {\n    x: originalX + finalOffsetX,\n    y: originalY,\n  });\n\n  updateBoundElements(element);\n};\n\nconst rotateElement = (element: ExcalidrawElement, rotationAngle: number) => {\n  const originalX = element.x;\n  const originalY = element.y;\n  let angle = normalizeAngle(element.angle + rotationAngle);\n  if (angle < 0) {\n    // check, probably unnecessary\n    angle = normalizeAngle(2 * Math.PI + angle);\n  }\n  mutateElement(element, {\n    angle,\n  });\n\n  // Move back to original spot\n  mutateElement(element, {\n    x: originalX,\n    y: originalY,\n  });\n};\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { copyToClipboard } from \"../clipboard\";\nimport { actionDeleteSelected } from \"./actionDeleteSelected\";\nimport { getSelectedElements } from \"../scene/selection\";\nimport { exportCanvas } from \"../data/index\";\nimport { getNonDeletedElements } from \"../element\";\nimport { t } from \"../i18n\";\n\nexport const actionCopy = register({\n  name: \"copy\",\n  perform: (elements, appState, _, app) => {\n    copyToClipboard(getNonDeletedElements(elements), appState, app.files);\n\n    return {\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: \"labels.copy\",\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined,\n});\n\nexport const actionCut = register({\n  name: \"cut\",\n  perform: (elements, appState, data, app) => {\n    actionCopy.perform(elements, appState, data, app);\n    return actionDeleteSelected.perform(elements, appState, data, app);\n  },\n  contextItemLabel: \"labels.cut\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.X,\n});\n\nexport const actionCopyAsSvg = register({\n  name: \"copyAsSvg\",\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard-svg\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        app.files,\n        appState,\n      );\n      return {\n        commitToHistory: false,\n      };\n    } catch (error: any) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  contextItemLabel: \"labels.copyAsSvg\",\n});\n\nexport const actionCopyAsPng = register({\n  name: \"copyAsPng\",\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        app.files,\n        appState,\n      );\n      return {\n        appState: {\n          ...appState,\n          toastMessage: t(\"toast.copyToClipboardAsPng\", {\n            exportSelection: selectedElements.length\n              ? t(\"toast.selection\")\n              : t(\"toast.canvas\"),\n            exportColorScheme: appState.exportWithDarkMode\n              ? t(\"buttons.darkMode\")\n              : t(\"buttons.lightMode\"),\n          }),\n        },\n        commitToHistory: false,\n      };\n    } catch (error: any) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  contextItemLabel: \"labels.copyAsPng\",\n  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey,\n});\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { GRID_SIZE } from \"../constants\";\nimport { AppState } from \"../types\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleGridMode = register({\n  name: \"gridMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"grid\");\n    return {\n      appState: {\n        ...appState,\n        gridSize: this.checked!(appState) ? null : GRID_SIZE,\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState: AppState) => appState.gridSize !== null,\n  contextItemLabel: \"labels.showGrid\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE,\n});\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleZenMode = register({\n  name: \"zenMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"zen\");\n\n    return {\n      appState: {\n        ...appState,\n        zenModeEnabled: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.zenModeEnabled,\n  contextItemLabel: \"buttons.zenMode\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z,\n});\n","import { register } from \"./register\";\nimport { CODES, KEYS } from \"../keys\";\n\nexport const actionToggleStats = register({\n  name: \"stats\",\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        showStats: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.showStats,\n  contextItemLabel: \"stats.title\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.SLASH,\n});\n","import { Action, ActionResult } from \"./types\";\nimport { undo, redo } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport History, { HistoryEntry } from \"../history\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { isWindows, KEYS } from \"../keys\";\nimport { getElementMap } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst writeData = (\n  prevElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  updater: () => HistoryEntry | null,\n): ActionResult => {\n  const commitToHistory = false;\n  if (\n    !appState.multiElement &&\n    !appState.resizingElement &&\n    !appState.editingElement &&\n    !appState.draggingElement\n  ) {\n    const data = updater();\n    if (data === null) {\n      return { commitToHistory };\n    }\n\n    const prevElementMap = getElementMap(prevElements);\n    const nextElements = data.elements;\n    const nextElementMap = getElementMap(nextElements);\n\n    const deletedElements = prevElements.filter(\n      (prevElement) => !nextElementMap.hasOwnProperty(prevElement.id),\n    );\n    const elements = nextElements\n      .map((nextElement) =>\n        newElementWith(\n          prevElementMap[nextElement.id] || nextElement,\n          nextElement,\n        ),\n      )\n      .concat(\n        deletedElements.map((prevElement) =>\n          newElementWith(prevElement, { isDeleted: true }),\n        ),\n      );\n    fixBindingsAfterDeletion(elements, deletedElements);\n\n    return {\n      elements,\n      appState: { ...appState, ...data.appState },\n      commitToHistory,\n      syncHistory: true,\n    };\n  }\n  return { commitToHistory };\n};\n\ntype ActionCreator = (history: History) => Action;\n\nexport const createUndoAction: ActionCreator = (history) => ({\n  name: \"undo\",\n  perform: (elements, appState) =>\n    writeData(elements, appState, () => history.undoOnce()),\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    event.key.toLowerCase() === KEYS.Z &&\n    !event.shiftKey,\n  PanelComponent: ({ updateData, data }) => (\n    <ToolButton\n      type=\"button\"\n      icon={undo}\n      aria-label={t(\"buttons.undo\")}\n      onClick={updateData}\n      size={data?.size || \"medium\"}\n    />\n  ),\n  commitToHistory: () => false,\n});\n\nexport const createRedoAction: ActionCreator = (history) => ({\n  name: \"redo\",\n  perform: (elements, appState) =>\n    writeData(elements, appState, () => history.redoOnce()),\n  keyTest: (event) =>\n    (event[KEYS.CTRL_OR_CMD] &&\n      event.shiftKey &&\n      event.key.toLowerCase() === KEYS.Z) ||\n    (isWindows && event.ctrlKey && !event.shiftKey && event.key === KEYS.Y),\n  PanelComponent: ({ updateData, data }) => (\n    <ToolButton\n      type=\"button\"\n      icon={redo}\n      aria-label={t(\"buttons.redo\")}\n      onClick={updateData}\n      size={data?.size || \"medium\"}\n    />\n  ),\n  commitToHistory: () => false,\n});\n","import React from \"react\";\nimport {\n  Action,\n  ActionsManagerInterface,\n  UpdaterFn,\n  ActionName,\n  ActionResult,\n  PanelComponentProps,\n} from \"./types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppClassProperties, AppState } from \"../types\";\nimport { MODES } from \"../constants\";\n\nexport class ActionManager implements ActionsManagerInterface {\n  actions = {} as ActionsManagerInterface[\"actions\"];\n\n  updater: (actionResult: ActionResult | Promise<ActionResult>) => void;\n\n  getAppState: () => Readonly<AppState>;\n  getElementsIncludingDeleted: () => readonly ExcalidrawElement[];\n  app: AppClassProperties;\n\n  constructor(\n    updater: UpdaterFn,\n    getAppState: () => AppState,\n    getElementsIncludingDeleted: () => readonly ExcalidrawElement[],\n    app: AppClassProperties,\n  ) {\n    this.updater = (actionResult) => {\n      if (actionResult && \"then\" in actionResult) {\n        actionResult.then((actionResult) => {\n          return updater(actionResult);\n        });\n      } else {\n        return updater(actionResult);\n      }\n    };\n    this.getAppState = getAppState;\n    this.getElementsIncludingDeleted = getElementsIncludingDeleted;\n    this.app = app;\n  }\n\n  registerAction(action: Action) {\n    this.actions[action.name] = action;\n  }\n\n  registerAll(actions: readonly Action[]) {\n    actions.forEach((action) => this.registerAction(action));\n  }\n\n  handleKeyDown(event: React.KeyboardEvent | KeyboardEvent) {\n    const canvasActions = this.app.props.UIOptions.canvasActions;\n    const data = Object.values(this.actions)\n      .sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0))\n      .filter(\n        (action) =>\n          (action.name in canvasActions\n            ? canvasActions[action.name as keyof typeof canvasActions]\n            : true) &&\n          action.keyTest &&\n          action.keyTest(\n            event,\n            this.getAppState(),\n            this.getElementsIncludingDeleted(),\n          ),\n      );\n\n    if (data.length === 0) {\n      return false;\n    }\n    const { viewModeEnabled } = this.getAppState();\n    if (viewModeEnabled) {\n      if (!Object.values(MODES).includes(data[0].name)) {\n        return false;\n      }\n    }\n\n    event.preventDefault();\n    this.updater(\n      data[0].perform(\n        this.getElementsIncludingDeleted(),\n        this.getAppState(),\n        null,\n        this.app,\n      ),\n    );\n    return true;\n  }\n\n  executeAction(action: Action) {\n    this.updater(\n      action.perform(\n        this.getElementsIncludingDeleted(),\n        this.getAppState(),\n        null,\n        this.app,\n      ),\n    );\n  }\n\n  /**\n   * @param data additional data sent to the PanelComponent\n   */\n  renderAction = (name: ActionName, data?: PanelComponentProps[\"data\"]) => {\n    const canvasActions = this.app.props.UIOptions.canvasActions;\n\n    if (\n      this.actions[name] &&\n      \"PanelComponent\" in this.actions[name] &&\n      (name in canvasActions\n        ? canvasActions[name as keyof typeof canvasActions]\n        : true)\n    ) {\n      const action = this.actions[name];\n      const PanelComponent = action.PanelComponent!;\n      const updateData = (formState?: any) => {\n        this.updater(\n          action.perform(\n            this.getElementsIncludingDeleted(),\n            this.getAppState(),\n            formState,\n            this.app,\n          ),\n        );\n      };\n\n      return (\n        <PanelComponent\n          elements={this.getElementsIncludingDeleted()}\n          appState={this.getAppState()}\n          updateData={updateData}\n          appProps={this.app.props}\n          data={data}\n        />\n      );\n    }\n\n    return null;\n  };\n}\n","import { loadLibraryFromBlob } from \"./blob\";\nimport { LibraryItems, LibraryItem } from \"../types\";\nimport { restoreElements } from \"./restore\";\nimport { getNonDeletedElements } from \"../element\";\nimport type App from \"../components/App\";\n\nclass Library {\n  private libraryCache: LibraryItems | null = null;\n  private app: App;\n\n  constructor(app: App) {\n    this.app = app;\n  }\n\n  resetLibrary = async () => {\n    await this.app.props.onLibraryChange?.([]);\n    this.libraryCache = [];\n  };\n\n  restoreLibraryItem = (libraryItem: LibraryItem): LibraryItem | null => {\n    const elements = getNonDeletedElements(restoreElements(libraryItem, null));\n    return elements.length ? elements : null;\n  };\n\n  /** imports library (currently merges, removing duplicates) */\n  async importLibrary(blob: Blob) {\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      return;\n    }\n\n    /**\n     * checks if library item does not exist already in current library\n     */\n    const isUniqueitem = (\n      existingLibraryItems: LibraryItems,\n      targetLibraryItem: LibraryItem,\n    ) => {\n      return !existingLibraryItems.find((libraryItem) => {\n        if (libraryItem.length !== targetLibraryItem.length) {\n          return false;\n        }\n\n        // detect z-index difference by checking the excalidraw elements\n        // are in order\n        return libraryItem.every((libItemExcalidrawItem, idx) => {\n          return (\n            libItemExcalidrawItem.id === targetLibraryItem[idx].id &&\n            libItemExcalidrawItem.versionNonce ===\n              targetLibraryItem[idx].versionNonce\n          );\n        });\n      });\n    };\n\n    const existingLibraryItems = await this.loadLibrary();\n\n    const filtered = libraryFile.library!.reduce((acc, libraryItem) => {\n      const restoredItem = this.restoreLibraryItem(libraryItem);\n      if (restoredItem && isUniqueitem(existingLibraryItems, restoredItem)) {\n        acc.push(restoredItem);\n      }\n      return acc;\n    }, [] as Mutable<LibraryItems>);\n\n    await this.saveLibrary([...existingLibraryItems, ...filtered]);\n  }\n\n  loadLibrary = (): Promise<LibraryItems> => {\n    return new Promise(async (resolve) => {\n      if (this.libraryCache) {\n        return resolve(JSON.parse(JSON.stringify(this.libraryCache)));\n      }\n\n      try {\n        const libraryItems = this.app.libraryItemsFromStorage;\n        if (!libraryItems) {\n          return resolve([]);\n        }\n\n        const items = libraryItems.reduce((acc, item) => {\n          const restoredItem = this.restoreLibraryItem(item);\n          if (restoredItem) {\n            acc.push(item);\n          }\n          return acc;\n        }, [] as Mutable<LibraryItems>);\n\n        // clone to ensure we don't mutate the cached library elements in the app\n        this.libraryCache = JSON.parse(JSON.stringify(items));\n\n        resolve(items);\n      } catch (error: any) {\n        console.error(error);\n        resolve([]);\n      }\n    });\n  };\n\n  saveLibrary = async (items: LibraryItems) => {\n    const prevLibraryItems = this.libraryCache;\n    try {\n      const serializedItems = JSON.stringify(items);\n      // cache optimistically so that the app has access to the latest\n      // immediately\n      this.libraryCache = JSON.parse(serializedItems);\n      await this.app.props.onLibraryChange?.(items);\n    } catch (error: any) {\n      this.libraryCache = prevLibraryItems;\n      throw error;\n    }\n  };\n}\n\nexport default Library;\n","import { PointerCoords } from \"./types\";\n\nexport const getCenter = (pointers: Map<number, PointerCoords>) => {\n  const allCoords = Array.from(pointers.values());\n  return {\n    x: sum(allCoords, (coords) => coords.x) / allCoords.length,\n    y: sum(allCoords, (coords) => coords.y) / allCoords.length,\n  };\n};\n\nexport const getDistance = ([a, b]: readonly PointerCoords[]) =>\n  Math.hypot(a.x - b.x, a.y - b.y);\n\nconst sum = <T>(array: readonly T[], mapper: (item: T) => number): number =>\n  array.reduce((acc, item) => acc + mapper(item), 0);\n","import { AppState } from \"./types\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\n\nexport interface HistoryEntry {\n  appState: ReturnType<typeof clearAppStatePropertiesForHistory>;\n  elements: ExcalidrawElement[];\n}\n\ninterface DehydratedExcalidrawElement {\n  id: string;\n  versionNonce: number;\n}\n\ninterface DehydratedHistoryEntry {\n  appState: string;\n  elements: DehydratedExcalidrawElement[];\n}\n\nconst clearAppStatePropertiesForHistory = (appState: AppState) => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name,\n  };\n};\n\nclass History {\n  private elementCache = new Map<string, Map<number, ExcalidrawElement>>();\n  private recording: boolean = true;\n  private stateHistory: DehydratedHistoryEntry[] = [];\n  private redoStack: DehydratedHistoryEntry[] = [];\n  private lastEntry: HistoryEntry | null = null;\n\n  private hydrateHistoryEntry({\n    appState,\n    elements,\n  }: DehydratedHistoryEntry): HistoryEntry {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map((dehydratedExcalidrawElement) => {\n        const element = this.elementCache\n          .get(dehydratedExcalidrawElement.id)\n          ?.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(\n            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`,\n          );\n        }\n        return element;\n      }),\n    };\n  }\n\n  private dehydrateHistoryEntry({\n    appState,\n    elements,\n  }: HistoryEntry): DehydratedHistoryEntry {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map((element: ExcalidrawElement) => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id)!;\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce,\n        };\n      }),\n    };\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n      redoStack: this.redoStack.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  private generateEntry = (\n    appState: AppState,\n    elements: readonly ExcalidrawElement[],\n  ): DehydratedHistoryEntry =>\n    this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (\n          isLinearElement(element) &&\n          appState.multiElement &&\n          appState.multiElement.id === element.id\n        ) {\n          // don't store multi-point arrow if still has only one point\n          if (\n            appState.multiElement &&\n            appState.multiElement.id === element.id &&\n            element.points.length < 2\n          ) {\n            return elements;\n          }\n\n          elements.push({\n            ...element,\n            // don't store last point if not committed\n            points:\n              element.lastCommittedPoint !==\n              element.points[element.points.length - 1]\n                ? element.points.slice(0, -1)\n                : element.points,\n          });\n        } else {\n          elements.push(element);\n        }\n        return elements;\n      }, [] as Mutable<typeof elements>),\n    });\n\n  shouldCreateEntry(nextEntry: HistoryEntry): boolean {\n    const { lastEntry } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (\n        !prev ||\n        !next ||\n        prev.id !== next.id ||\n        prev.versionNonce !== next.versionNonce\n      ) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key: keyof typeof nextEntry.appState;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        if (\n          nextEntry.appState[key]?.elementId ===\n          lastEntry.appState[key]?.elementId\n        ) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\" || key === \"selectedGroupIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pushEntry(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry: HistoryEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(): HistoryEntry | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce(): HistoryEntry | null {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    this.lastEntry = this.hydrateHistoryEntry(\n      this.generateEntry(appState, elements),\n    );\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state: AppState, elements: readonly ExcalidrawElement[]) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\n\nexport default History;\n","import { KEYS } from \"./keys\";\n\n// We inline font-awesome icons in order to save on js size rather than including the font awesome react library\nexport const SHAPES = [\n  {\n    icon: (\n      // fa-mouse-pointer\n      <svg viewBox=\"0 0 320 512\" className=\"\">\n        <path d=\"M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z\" />\n      </svg>\n    ),\n    value: \"selection\",\n    key: KEYS.V,\n  },\n  {\n    icon: (\n      // fa-square\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z\" />\n      </svg>\n    ),\n    value: \"rectangle\",\n    key: KEYS.R,\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 223.646 223.646\">\n        <path d=\"M111.823 0L16.622 111.823 111.823 223.646 207.025 111.823z\" />\n      </svg>\n    ),\n    value: \"diamond\",\n    key: KEYS.D,\n  },\n  {\n    icon: (\n      // fa-circle\n      <svg viewBox=\"0 0 512 512\">\n        <path d=\"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z\" />\n      </svg>\n    ),\n    value: \"ellipse\",\n    key: KEYS.E,\n  },\n  {\n    icon: (\n      // fa-long-arrow-alt-right\n      <svg viewBox=\"0 0 448 512\" className=\"rtl-mirror\">\n        <path d=\"M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z\" />\n      </svg>\n    ),\n    value: \"arrow\",\n    key: KEYS.A,\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 6 6\">\n        <line\n          x1=\"0\"\n          y1=\"3\"\n          x2=\"6\"\n          y2=\"3\"\n          stroke=\"currentColor\"\n          strokeLinecap=\"round\"\n        />\n      </svg>\n    ),\n    value: \"line\",\n    key: [KEYS.P, KEYS.L],\n  },\n  {\n    icon: (\n      // fa-pencil\n      <svg viewBox=\"0 0 512 512\">\n        <path\n          fill=\"currentColor\"\n          d=\"M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z\"\n        ></path>\n      </svg>\n    ),\n    value: \"freedraw\",\n    key: KEYS.X,\n  },\n  {\n    icon: (\n      // fa-font\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M432 416h-23.41L277.88 53.69A32 32 0 0 0 247.58 32h-47.16a32 32 0 0 0-30.3 21.69L39.41 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-19.58l23.3-64h152.56l23.3 64H304a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM176.85 272L224 142.51 271.15 272z\" />\n      </svg>\n    ),\n    value: \"text\",\n    key: KEYS.T,\n  },\n  {\n    icon: (\n      // fa-image\n      <svg viewBox=\"0 0 512 512\">\n        <path\n          fill=\"currentColor\"\n          d=\"M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 336H54a6 6 0 0 1-6-6V118a6 6 0 0 1 6-6h404a6 6 0 0 1 6 6v276a6 6 0 0 1-6 6zM128 152c-22.091 0-40 17.909-40 40s17.909 40 40 40 40-17.909 40-40-17.909-40-40-40zM96 352h320v-80l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L192 304l-39.515-39.515c-4.686-4.686-12.284-4.686-16.971 0L96 304v48z\"\n        ></path>\n      </svg>\n    ),\n    value: \"image\",\n    key: null,\n  },\n] as const;\n\nexport const findShapeByKey = (key: string) => {\n  const shape = SHAPES.find((shape, index) => {\n    return (\n      key === (index + 1).toString() ||\n      (shape.key &&\n        (typeof shape.key === \"string\"\n          ? shape.key === key\n          : (shape.key as readonly string[]).includes(key)))\n    );\n  });\n  return shape?.value || null;\n};\n","import { t } from \"../i18n\";\nimport { isDarwin } from \"../keys\";\nimport { getShortcutKey } from \"../utils\";\n\nexport type ShortcutName =\n  | \"cut\"\n  | \"copy\"\n  | \"paste\"\n  | \"copyStyles\"\n  | \"pasteStyles\"\n  | \"selectAll\"\n  | \"deleteSelectedElements\"\n  | \"duplicateSelection\"\n  | \"sendBackward\"\n  | \"bringForward\"\n  | \"sendToBack\"\n  | \"bringToFront\"\n  | \"copyAsPng\"\n  | \"copyAsSvg\"\n  | \"group\"\n  | \"ungroup\"\n  | \"gridMode\"\n  | \"zenMode\"\n  | \"stats\"\n  | \"addToLibrary\"\n  | \"viewMode\"\n  | \"flipHorizontal\"\n  | \"flipVertical\";\n\nconst shortcutMap: Record<ShortcutName, string[]> = {\n  cut: [getShortcutKey(\"CtrlOrCmd+X\")],\n  copy: [getShortcutKey(\"CtrlOrCmd+C\")],\n  paste: [getShortcutKey(\"CtrlOrCmd+V\")],\n  copyStyles: [getShortcutKey(\"CtrlOrCmd+Alt+C\")],\n  pasteStyles: [getShortcutKey(\"CtrlOrCmd+Alt+V\")],\n  selectAll: [getShortcutKey(\"CtrlOrCmd+A\")],\n  deleteSelectedElements: [getShortcutKey(\"Del\")],\n  duplicateSelection: [\n    getShortcutKey(\"CtrlOrCmd+D\"),\n    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n  ],\n  sendBackward: [getShortcutKey(\"CtrlOrCmd+[\")],\n  bringForward: [getShortcutKey(\"CtrlOrCmd+]\")],\n  sendToBack: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n  ],\n  bringToFront: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n  ],\n  copyAsPng: [getShortcutKey(\"Shift+Alt+C\")],\n  copyAsSvg: [],\n  group: [getShortcutKey(\"CtrlOrCmd+G\")],\n  ungroup: [getShortcutKey(\"CtrlOrCmd+Shift+G\")],\n  gridMode: [getShortcutKey(\"CtrlOrCmd+'\")],\n  zenMode: [getShortcutKey(\"Alt+Z\")],\n  stats: [getShortcutKey(\"Alt+/\")],\n  addToLibrary: [],\n  flipHorizontal: [getShortcutKey(\"Shift+H\")],\n  flipVertical: [getShortcutKey(\"Shift+V\")],\n  viewMode: [getShortcutKey(\"Alt+R\")],\n};\n\nexport const getShortcutFromShortcutName = (name: ShortcutName) => {\n  const shortcuts = shortcutMap[name];\n  // if multiple shortcuts availiable, take the first one\n  return shortcuts && shortcuts.length > 0 ? shortcuts[0] : \"\";\n};\n","import { render, unmountComponentAtNode } from \"react-dom\";\nimport clsx from \"clsx\";\nimport { Popover } from \"./Popover\";\nimport { t } from \"../i18n\";\n\nimport \"./ContextMenu.scss\";\nimport {\n  getShortcutFromShortcutName,\n  ShortcutName,\n} from \"../actions/shortcuts\";\nimport { Action } from \"../actions/types\";\nimport { ActionManager } from \"../actions/manager\";\nimport { AppState } from \"../types\";\n\nexport type ContextMenuOption = \"separator\" | Action;\n\ntype ContextMenuProps = {\n  options: ContextMenuOption[];\n  onCloseRequest?(): void;\n  top: number;\n  left: number;\n  actionManager: ActionManager;\n  appState: Readonly<AppState>;\n};\n\nconst ContextMenu = ({\n  options,\n  onCloseRequest,\n  top,\n  left,\n  actionManager,\n  appState,\n}: ContextMenuProps) => {\n  return (\n    <Popover\n      onCloseRequest={onCloseRequest}\n      top={top}\n      left={left}\n      fitInViewport={true}\n    >\n      <ul\n        className=\"context-menu\"\n        onContextMenu={(event) => event.preventDefault()}\n      >\n        {options.map((option, idx) => {\n          if (option === \"separator\") {\n            return <hr key={idx} className=\"context-menu-option-separator\" />;\n          }\n\n          const actionName = option.name;\n          const label = option.contextItemLabel\n            ? t(option.contextItemLabel)\n            : \"\";\n          return (\n            <li key={idx} data-testid={actionName} onClick={onCloseRequest}>\n              <button\n                className={clsx(\"context-menu-option\", {\n                  dangerous: actionName === \"deleteSelectedElements\",\n                  checkmark: option.checked?.(appState),\n                })}\n                onClick={() => actionManager.executeAction(option)}\n              >\n                <div className=\"context-menu-option__label\">{label}</div>\n                <kbd className=\"context-menu-option__shortcut\">\n                  {actionName\n                    ? getShortcutFromShortcutName(actionName as ShortcutName)\n                    : \"\"}\n                </kbd>\n              </button>\n            </li>\n          );\n        })}\n      </ul>\n    </Popover>\n  );\n};\n\nconst contextMenuNodeByContainer = new WeakMap<HTMLElement, HTMLDivElement>();\n\nconst getContextMenuNode = (container: HTMLElement): HTMLDivElement => {\n  let contextMenuNode = contextMenuNodeByContainer.get(container);\n  if (contextMenuNode) {\n    return contextMenuNode;\n  }\n  contextMenuNode = document.createElement(\"div\");\n  container\n    .querySelector(\".excalidraw-contextMenuContainer\")!\n    .appendChild(contextMenuNode);\n  contextMenuNodeByContainer.set(container, contextMenuNode);\n  return contextMenuNode;\n};\n\ntype ContextMenuParams = {\n  options: (ContextMenuOption | false | null | undefined)[];\n  top: ContextMenuProps[\"top\"];\n  left: ContextMenuProps[\"left\"];\n  actionManager: ContextMenuProps[\"actionManager\"];\n  appState: Readonly<AppState>;\n  container: HTMLElement;\n};\n\nconst handleClose = (container: HTMLElement) => {\n  const contextMenuNode = contextMenuNodeByContainer.get(container);\n  if (contextMenuNode) {\n    unmountComponentAtNode(contextMenuNode);\n    contextMenuNode.remove();\n    contextMenuNodeByContainer.delete(container);\n  }\n};\n\nexport default {\n  push(params: ContextMenuParams) {\n    const options = Array.of<ContextMenuOption>();\n    params.options.forEach((option) => {\n      if (option) {\n        options.push(option);\n      }\n    });\n    if (options.length) {\n      render(\n        <ContextMenu\n          top={params.top}\n          left={params.left}\n          options={options}\n          onCloseRequest={() => handleClose(params.container)}\n          actionManager={params.actionManager}\n          appState={params.appState}\n        />,\n        getContextMenuNode(params.container),\n      );\n    }\n  },\n};\n","import React from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement, PointerType } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport {\n  canChangeSharpness,\n  canHaveArrowheads,\n  getTargetElements,\n  hasBackground,\n  hasStrokeStyle,\n  hasStrokeWidth,\n  hasText,\n} from \"../scene\";\nimport { SHAPES } from \"../shapes\";\nimport { AppState, Zoom } from \"../types\";\nimport { capitalizeString, isTransparent, setCursorForShape } from \"../utils\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport { hasStrokeColor } from \"../scene/comparisons\";\n\nexport const SelectedShapeActions = ({\n  appState,\n  elements,\n  renderAction,\n  elementType,\n}: {\n  appState: AppState;\n  elements: readonly ExcalidrawElement[];\n  renderAction: ActionManager[\"renderAction\"];\n  elementType: ExcalidrawElement[\"type\"];\n}) => {\n  const targetElements = getTargetElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  const isEditing = Boolean(appState.editingElement);\n  const isMobile = useIsMobile();\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const showFillIcons =\n    hasBackground(elementType) ||\n    targetElements.some(\n      (element) =>\n        hasBackground(element.type) && !isTransparent(element.backgroundColor),\n    );\n  const showChangeBackgroundIcons =\n    hasBackground(elementType) ||\n    targetElements.some((element) => hasBackground(element.type));\n\n  let commonSelectedType: string | null = targetElements[0]?.type || null;\n\n  for (const element of targetElements) {\n    if (element.type !== commonSelectedType) {\n      commonSelectedType = null;\n      break;\n    }\n  }\n\n  return (\n    <div className=\"panelColumn\">\n      {((hasStrokeColor(elementType) &&\n        elementType !== \"image\" &&\n        commonSelectedType !== \"image\") ||\n        targetElements.some((element) => hasStrokeColor(element.type))) &&\n        renderAction(\"changeStrokeColor\")}\n      {showChangeBackgroundIcons && renderAction(\"changeBackgroundColor\")}\n      {showFillIcons && renderAction(\"changeFillStyle\")}\n\n      {(hasStrokeWidth(elementType) ||\n        targetElements.some((element) => hasStrokeWidth(element.type))) &&\n        renderAction(\"changeStrokeWidth\")}\n\n      {(elementType === \"freedraw\" ||\n        targetElements.some((element) => element.type === \"freedraw\")) &&\n        renderAction(\"changeStrokeShape\")}\n\n      {(hasStrokeStyle(elementType) ||\n        targetElements.some((element) => hasStrokeStyle(element.type))) && (\n        <>\n          {renderAction(\"changeStrokeStyle\")}\n          {renderAction(\"changeSloppiness\")}\n        </>\n      )}\n\n      {(canChangeSharpness(elementType) ||\n        targetElements.some((element) => canChangeSharpness(element.type))) && (\n        <>{renderAction(\"changeSharpness\")}</>\n      )}\n\n      {(hasText(elementType) ||\n        targetElements.some((element) => hasText(element.type))) && (\n        <>\n          {renderAction(\"changeFontSize\")}\n\n          {renderAction(\"changeFontFamily\")}\n\n          {renderAction(\"changeTextAlign\")}\n        </>\n      )}\n\n      {(canHaveArrowheads(elementType) ||\n        targetElements.some((element) => canHaveArrowheads(element.type))) && (\n        <>{renderAction(\"changeArrowhead\")}</>\n      )}\n\n      {renderAction(\"changeOpacity\")}\n\n      <fieldset>\n        <legend>{t(\"labels.layers\")}</legend>\n        <div className=\"buttonList\">\n          {renderAction(\"sendToBack\")}\n          {renderAction(\"sendBackward\")}\n          {renderAction(\"bringToFront\")}\n          {renderAction(\"bringForward\")}\n        </div>\n      </fieldset>\n\n      {targetElements.length > 1 && (\n        <fieldset>\n          <legend>{t(\"labels.align\")}</legend>\n          <div className=\"buttonList\">\n            {\n              // swap this order for RTL so the button positions always match their action\n              // (i.e. the leftmost button aligns left)\n            }\n            {isRTL ? (\n              <>\n                {renderAction(\"alignRight\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignLeft\")}\n              </>\n            ) : (\n              <>\n                {renderAction(\"alignLeft\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignRight\")}\n              </>\n            )}\n            {targetElements.length > 2 &&\n              renderAction(\"distributeHorizontally\")}\n            <div className=\"iconRow\">\n              {renderAction(\"alignTop\")}\n              {renderAction(\"alignVerticallyCentered\")}\n              {renderAction(\"alignBottom\")}\n              {targetElements.length > 2 &&\n                renderAction(\"distributeVertically\")}\n            </div>\n          </div>\n        </fieldset>\n      )}\n      {!isMobile && !isEditing && targetElements.length > 0 && (\n        <fieldset>\n          <legend>{t(\"labels.actions\")}</legend>\n          <div className=\"buttonList\">\n            {renderAction(\"duplicateSelection\")}\n            {renderAction(\"deleteSelectedElements\")}\n            {renderAction(\"group\")}\n            {renderAction(\"ungroup\")}\n          </div>\n        </fieldset>\n      )}\n    </div>\n  );\n};\n\nexport const ShapesSwitcher = ({\n  canvas,\n  elementType,\n  setAppState,\n  onImageAction,\n}: {\n  canvas: HTMLCanvasElement | null;\n  elementType: ExcalidrawElement[\"type\"];\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  onImageAction: (data: { pointerType: PointerType | null }) => void;\n}) => (\n  <>\n    {SHAPES.map(({ value, icon, key }, index) => {\n      const label = t(`toolBar.${value}`);\n      const letter = key && (typeof key === \"string\" ? key : key[0]);\n      const shortcut = letter\n        ? `${capitalizeString(letter)} ${t(\"helpDialog.or\")} ${index + 1}`\n        : `${index + 1}`;\n      return (\n        <ToolButton\n          className=\"Shape\"\n          key={value}\n          type=\"radio\"\n          icon={icon}\n          checked={elementType === value}\n          name=\"editor-current-shape\"\n          title={`${capitalizeString(label)}  ${shortcut}`}\n          keyBindingLabel={`${index + 1}`}\n          aria-label={capitalizeString(label)}\n          aria-keyshortcuts={shortcut}\n          data-testid={value}\n          onChange={({ pointerType }) => {\n            setAppState({\n              elementType: value,\n              multiElement: null,\n              selectedElementIds: {},\n            });\n            setCursorForShape(canvas, value);\n            if (value === \"image\") {\n              onImageAction({ pointerType });\n            }\n          }}\n        />\n      );\n    })}\n  </>\n);\n\nexport const ZoomActions = ({\n  renderAction,\n  zoom,\n}: {\n  renderAction: ActionManager[\"renderAction\"];\n  zoom: Zoom;\n}) => (\n  <Stack.Col gap={1}>\n    <Stack.Row gap={1} align=\"center\">\n      {renderAction(\"zoomOut\")}\n      {renderAction(\"zoomIn\")}\n      {renderAction(\"resetZoom\")}\n    </Stack.Row>\n  </Stack.Col>\n);\n","import React from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { AppState } from \"../types\";\n\nexport const BackgroundPickerAndDarkModeToggle = ({\n  appState,\n  setAppState,\n  actionManager,\n  showThemeBtn,\n}: {\n  actionManager: ActionManager;\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  showThemeBtn: boolean;\n}) => (\n  <div style={{ display: \"flex\" }}>\n    {actionManager.renderAction(\"changeViewBackgroundColor\")}\n    {showThemeBtn && actionManager.renderAction(\"toggleTheme\")}\n  </div>\n);\n","import clsx from \"clsx\";\nimport { ToolButton } from \"./ToolButton\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { users } from \"./icons\";\n\nimport \"./CollabButton.scss\";\n\nconst CollabButton = ({\n  isCollaborating,\n  collaboratorCount,\n  onClick,\n}: {\n  isCollaborating: boolean;\n  collaboratorCount: number;\n  onClick: () => void;\n}) => {\n  return (\n    <>\n      <ToolButton\n        className={clsx(\"CollabButton\", {\n          \"is-collaborating\": isCollaborating,\n        })}\n        onClick={onClick}\n        icon={users}\n        type=\"button\"\n        title={t(\"labels.liveCollaboration\")}\n        aria-label={t(\"labels.liveCollaboration\")}\n        showAriaLabel={useIsMobile()}\n      >\n        {collaboratorCount > 0 && (\n          <div className=\"CollabButton-collaborators\">{collaboratorCount}</div>\n        )}\n      </ToolButton>\n    </>\n  );\n};\n\nexport default CollabButton;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { render, unmountComponentAtNode } from \"react-dom\";\nimport { ActionsManagerInterface } from \"../actions/types\";\nimport { probablySupportsClipboardBlob } from \"../clipboard\";\nimport { canvasToBlob } from \"../data/blob\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"./App\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { exportToCanvas } from \"../scene/export\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport { clipboard, exportImage } from \"./icons\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport \"./ExportDialog.scss\";\nimport OpenColor from \"open-color\";\nimport { CheckboxItem } from \"./CheckboxItem\";\nimport { DEFAULT_EXPORT_PADDING } from \"../constants\";\nimport { nativeFileSystemSupported } from \"../data/filesystem\";\n\nconst supportsContextFilters =\n  \"filter\" in document.createElement(\"canvas\").getContext(\"2d\")!;\n\nexport const ErrorCanvasPreview = () => {\n  return (\n    <div>\n      <h3>{t(\"canvasError.cannotShowPreview\")}</h3>\n      <p>\n        <span>{t(\"canvasError.canvasTooBig\")}</span>\n      </p>\n      <em>({t(\"canvasError.canvasTooBigTip\")})</em>\n    </div>\n  );\n};\n\nconst renderPreview = (\n  content: HTMLCanvasElement | Error,\n  previewNode: HTMLDivElement,\n) => {\n  unmountComponentAtNode(previewNode);\n  previewNode.innerHTML = \"\";\n  if (content instanceof HTMLCanvasElement) {\n    previewNode.appendChild(content);\n  } else {\n    render(<ErrorCanvasPreview />, previewNode);\n  }\n};\n\nexport type ExportCB = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  scale?: number,\n) => void;\n\nconst ExportButton: React.FC<{\n  color: keyof OpenColor;\n  onClick: () => void;\n  title: string;\n  shade?: number;\n}> = ({ children, title, onClick, color, shade = 6 }) => {\n  return (\n    <button\n      className=\"ExportDialog-imageExportButton\"\n      style={{\n        [\"--button-color\" as any]: OpenColor[color][shade],\n        [\"--button-color-darker\" as any]: OpenColor[color][shade + 1],\n        [\"--button-color-darkest\" as any]: OpenColor[color][shade + 2],\n      }}\n      title={title}\n      aria-label={title}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  );\n};\n\nconst ImageExportModal = ({\n  elements,\n  appState,\n  files,\n  exportPadding = DEFAULT_EXPORT_PADDING,\n  actionManager,\n  onExportToPng,\n  onExportToSvg,\n  onExportToClipboard,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  files: BinaryFiles;\n  exportPadding?: number;\n  actionManager: ActionsManagerInterface;\n  onExportToPng: ExportCB;\n  onExportToSvg: ExportCB;\n  onExportToClipboard: ExportCB;\n  onCloseRequest: () => void;\n}) => {\n  const someElementIsSelected = isSomeElementSelected(elements, appState);\n  const [exportSelected, setExportSelected] = useState(someElementIsSelected);\n  const previewRef = useRef<HTMLDivElement>(null);\n  const { exportBackground, viewBackgroundColor } = appState;\n\n  const exportedElements = exportSelected\n    ? getSelectedElements(elements, appState)\n    : elements;\n\n  useEffect(() => {\n    setExportSelected(someElementIsSelected);\n  }, [someElementIsSelected]);\n\n  useEffect(() => {\n    const previewNode = previewRef.current;\n    if (!previewNode) {\n      return;\n    }\n    exportToCanvas(exportedElements, appState, files, {\n      exportBackground,\n      viewBackgroundColor,\n      exportPadding,\n    })\n      .then((canvas) => {\n        // if converting to blob fails, there's some problem that will\n        // likely prevent preview and export (e.g. canvas too big)\n        return canvasToBlob(canvas).then(() => {\n          renderPreview(canvas, previewNode);\n        });\n      })\n      .catch((error) => {\n        console.error(error);\n        renderPreview(new CanvasError(), previewNode);\n      });\n  }, [\n    appState,\n    files,\n    exportedElements,\n    exportBackground,\n    exportPadding,\n    viewBackgroundColor,\n  ]);\n\n  return (\n    <div className=\"ExportDialog\">\n      <div className=\"ExportDialog__preview\" ref={previewRef} />\n      {supportsContextFilters &&\n        actionManager.renderAction(\"exportWithDarkMode\")}\n      <div style={{ display: \"grid\", gridTemplateColumns: \"1fr\" }}>\n        <div\n          style={{\n            display: \"grid\",\n            gridTemplateColumns: \"repeat(auto-fit, minmax(190px, 1fr))\",\n            // dunno why this is needed, but when the items wrap it creates\n            // an overflow\n            overflow: \"hidden\",\n          }}\n        >\n          {actionManager.renderAction(\"changeExportBackground\")}\n          {someElementIsSelected && (\n            <CheckboxItem\n              checked={exportSelected}\n              onChange={(checked) => setExportSelected(checked)}\n            >\n              {t(\"labels.onlySelected\")}\n            </CheckboxItem>\n          )}\n          {actionManager.renderAction(\"changeExportEmbedScene\")}\n        </div>\n      </div>\n      <div style={{ display: \"flex\", alignItems: \"center\", marginTop: \".6em\" }}>\n        <Stack.Row gap={2}>\n          {actionManager.renderAction(\"changeExportScale\")}\n        </Stack.Row>\n        <p style={{ marginLeft: \"1em\", userSelect: \"none\" }}>Scale</p>\n      </div>\n      <div\n        style={{\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          margin: \".6em 0\",\n        }}\n      >\n        {!nativeFileSystemSupported &&\n          actionManager.renderAction(\"changeProjectName\")}\n      </div>\n      <Stack.Row gap={2} justifyContent=\"center\" style={{ margin: \"2em 0\" }}>\n        <ExportButton\n          color=\"indigo\"\n          title={t(\"buttons.exportToPng\")}\n          aria-label={t(\"buttons.exportToPng\")}\n          onClick={() => onExportToPng(exportedElements)}\n        >\n          PNG\n        </ExportButton>\n        <ExportButton\n          color=\"red\"\n          title={t(\"buttons.exportToSvg\")}\n          aria-label={t(\"buttons.exportToSvg\")}\n          onClick={() => onExportToSvg(exportedElements)}\n        >\n          SVG\n        </ExportButton>\n        {probablySupportsClipboardBlob && (\n          <ExportButton\n            title={t(\"buttons.copyPngToClipboard\")}\n            onClick={() => onExportToClipboard(exportedElements)}\n            color=\"gray\"\n            shade={7}\n          >\n            {clipboard}\n          </ExportButton>\n        )}\n      </Stack.Row>\n    </div>\n  );\n};\n\nexport const ImageExportDialog = ({\n  elements,\n  appState,\n  files,\n  exportPadding = DEFAULT_EXPORT_PADDING,\n  actionManager,\n  onExportToPng,\n  onExportToSvg,\n  onExportToClipboard,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  files: BinaryFiles;\n  exportPadding?: number;\n  actionManager: ActionsManagerInterface;\n  onExportToPng: ExportCB;\n  onExportToSvg: ExportCB;\n  onExportToClipboard: ExportCB;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(false);\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n  }, []);\n\n  return (\n    <>\n      <ToolButton\n        onClick={() => {\n          setModalIsShown(true);\n        }}\n        data-testid=\"image-export-button\"\n        icon={exportImage}\n        type=\"button\"\n        aria-label={t(\"buttons.exportImage\")}\n        showAriaLabel={useIsMobile()}\n        title={t(\"buttons.exportImage\")}\n      />\n      {modalIsShown && (\n        <Dialog onCloseRequest={handleClose} title={t(\"buttons.exportImage\")}>\n          <ImageExportModal\n            elements={elements}\n            appState={appState}\n            files={files}\n            exportPadding={exportPadding}\n            actionManager={actionManager}\n            onExportToPng={onExportToPng}\n            onExportToSvg={onExportToSvg}\n            onExportToClipboard={onExportToClipboard}\n            onCloseRequest={handleClose}\n          />\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import \"./FixedSideContainer.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype FixedSideContainerProps = {\n  children: React.ReactNode;\n  side: \"top\" | \"left\" | \"right\";\n  className?: string;\n};\n\nexport const FixedSideContainer = ({\n  children,\n  side,\n  className,\n}: FixedSideContainerProps) => (\n  <div\n    className={clsx(\n      \"FixedSideContainer\",\n      `FixedSideContainer_side_${side}`,\n      className,\n    )}\n  >\n    {children}\n  </div>\n);\n","import { t } from \"../i18n\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getSelectedElements } from \"../scene\";\n\nimport \"./HintViewer.scss\";\nimport { AppState } from \"../types\";\nimport {\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"../element/typeChecks\";\nimport { getShortcutKey } from \"../utils\";\n\ninterface HintViewerProps {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  isMobile: boolean;\n}\n\nconst getHints = ({ appState, elements, isMobile }: HintViewerProps) => {\n  const { elementType, isResizing, isRotating, lastPointerDownWith } = appState;\n  const multiMode = appState.multiElement !== null;\n\n  if (elementType === \"arrow\" || elementType === \"line\") {\n    if (!multiMode) {\n      return t(\"hints.linearElement\");\n    }\n    return t(\"hints.linearElementMulti\");\n  }\n\n  if (elementType === \"freedraw\") {\n    return t(\"hints.freeDraw\");\n  }\n\n  if (elementType === \"text\") {\n    return t(\"hints.text\");\n  }\n\n  if (appState.elementType === \"image\" && appState.pendingImageElement) {\n    return t(\"hints.placeImage\");\n  }\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  if (\n    isResizing &&\n    lastPointerDownWith === \"mouse\" &&\n    selectedElements.length === 1\n  ) {\n    const targetElement = selectedElements[0];\n    if (isLinearElement(targetElement) && targetElement.points.length === 2) {\n      return t(\"hints.lockAngle\");\n    }\n    return isImageElement(targetElement)\n      ? t(\"hints.resizeImage\")\n      : t(\"hints.resize\");\n  }\n\n  if (isRotating && lastPointerDownWith === \"mouse\") {\n    return t(\"hints.rotate\");\n  }\n\n  if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n    if (appState.editingLinearElement) {\n      return appState.editingLinearElement.activePointIndex\n        ? t(\"hints.lineEditor_pointSelected\")\n        : t(\"hints.lineEditor_nothingSelected\");\n    }\n    return t(\"hints.lineEditor_info\");\n  }\n\n  if (selectedElements.length === 1 && isTextElement(selectedElements[0])) {\n    return t(\"hints.text_selected\");\n  }\n\n  if (appState.editingElement && isTextElement(appState.editingElement)) {\n    return t(\"hints.text_editing\");\n  }\n\n  if (elementType === \"selection\" && !selectedElements.length && !isMobile) {\n    return t(\"hints.canvasPanning\");\n  }\n\n  return null;\n};\n\nexport const HintViewer = ({\n  appState,\n  elements,\n  isMobile,\n}: HintViewerProps) => {\n  let hint = getHints({\n    appState,\n    elements,\n    isMobile,\n  });\n  if (!hint) {\n    return null;\n  }\n\n  hint = getShortcutKey(hint);\n\n  return (\n    <div className=\"HintViewer\">\n      <span>{hint}</span>\n    </div>\n  );\n};\n","import \"./Island.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype IslandProps = {\n  children: React.ReactNode;\n  padding?: number;\n  className?: string | boolean;\n  style?: object;\n};\n\nexport const Island = React.forwardRef<HTMLDivElement, IslandProps>(\n  ({ children, padding, className, style }, ref) => (\n    <div\n      className={clsx(\"Island\", className)}\n      style={{ \"--padding\": padding, ...style }}\n      ref={ref}\n    >\n      {children}\n    </div>\n  ),\n);\n","import clsx from \"clsx\";\nimport oc from \"open-color\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { close } from \"../components/icons\";\nimport { MIME_TYPES } from \"../constants\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { exportToSvg } from \"../scene/export\";\nimport { BinaryFiles, LibraryItem } from \"../types\";\nimport \"./LibraryUnit.scss\";\n\n// fa-plus\nconst PLUS_ICON = (\n  <svg viewBox=\"0 0 1792 1792\">\n    <path\n      fill=\"currentColor\"\n      d=\"M1600 736v192q0 40-28 68t-68 28h-416v416q0 40-28 68t-68 28h-192q-40 0-68-28t-28-68v-416h-416q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h416v-416q0-40 28-68t68-28h192q40 0 68 28t28 68v416h416q40 0 68 28t28 68z\"\n    />\n  </svg>\n);\n\nexport const LibraryUnit = ({\n  elements,\n  files,\n  pendingElements,\n  onRemoveFromLibrary,\n  onClick,\n}: {\n  elements?: LibraryItem;\n  files: BinaryFiles;\n  pendingElements?: LibraryItem;\n  onRemoveFromLibrary: () => void;\n  onClick: () => void;\n}) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n  useEffect(() => {\n    const node = ref.current;\n    if (!node) {\n      return;\n    }\n\n    (async () => {\n      const elementsToRender = elements || pendingElements;\n      if (!elementsToRender) {\n        return;\n      }\n      const svg = await exportToSvg(\n        elementsToRender,\n        {\n          exportBackground: false,\n          viewBackgroundColor: oc.white,\n        },\n        files,\n      );\n      node.innerHTML = svg.outerHTML;\n    })();\n\n    return () => {\n      node.innerHTML = \"\";\n    };\n  }, [elements, pendingElements, files]);\n\n  const [isHovered, setIsHovered] = useState(false);\n  const isMobile = useIsMobile();\n\n  const adder = (isHovered || isMobile) && pendingElements && (\n    <div className=\"library-unit__adder\">{PLUS_ICON}</div>\n  );\n\n  return (\n    <div\n      className={clsx(\"library-unit\", {\n        \"library-unit__active\": elements || pendingElements,\n      })}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n    >\n      <div\n        className={clsx(\"library-unit__dragger\", {\n          \"library-unit__pulse\": !!pendingElements,\n        })}\n        ref={ref}\n        draggable={!!elements}\n        onClick={!!elements || !!pendingElements ? onClick : undefined}\n        onDragStart={(event) => {\n          setIsHovered(false);\n          event.dataTransfer.setData(\n            MIME_TYPES.excalidrawlib,\n            JSON.stringify(elements),\n          );\n        }}\n      />\n      {adder}\n      {elements && (isHovered || isMobile) && (\n        <button\n          className=\"library-unit__removeFromLibrary\"\n          aria-label={t(\"labels.removeFromLibrary\")}\n          onClick={onRemoveFromLibrary}\n        >\n          {close}\n        </button>\n      )}\n    </div>\n  );\n};\n","import { t } from \"../i18n\";\n\nexport const LoadingMessage = () => {\n  // !! KEEP THIS IN SYNC WITH index.html !!\n  return (\n    <div className=\"LoadingMessage\">\n      <span>{t(\"labels.loadingScene\")}</span>\n    </div>\n  );\n};\n","import \"./ToolIcon.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\nimport { ToolButtonSize } from \"./ToolButton\";\n\ntype LockIconProps = {\n  title?: string;\n  name?: string;\n  checked: boolean;\n  onChange?(): void;\n  zenModeEnabled?: boolean;\n};\n\nconst DEFAULT_SIZE: ToolButtonSize = \"medium\";\n\nconst ICONS = {\n  CHECKED: (\n    <svg\n      width=\"1792\"\n      height=\"1792\"\n      viewBox=\"0 0 1792 1792\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path d=\"M640 768h512v-192q0-106-75-181t-181-75-181 75-75 181v192zm832 96v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-192q0-184 132-316t316-132 316 132 132 316v192h32q40 0 68 28t28 68z\" />\n    </svg>\n  ),\n  UNCHECKED: (\n    <svg\n      width=\"1792\"\n      height=\"1792\"\n      viewBox=\"0 0 1792 1792\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className=\"unlocked-icon rtl-mirror\"\n    >\n      <path d=\"M1728 576v256q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45v-256q0-106-75-181t-181-75-181 75-75 181v192h96q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h672v-192q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5z\" />\n    </svg>\n  ),\n};\n\nexport const LockButton = (props: LockIconProps) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon__lock ToolIcon_type_floating zen-mode-visibility\",\n        `ToolIcon_size_${DEFAULT_SIZE}`,\n        {\n          \"zen-mode-visibility--hidden\": props.zenModeEnabled,\n        },\n      )}\n      title={`${props.title}  Q`}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name={props.name}\n        onChange={props.onChange}\n        checked={props.checked}\n        aria-label={props.title}\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.checked ? ICONS.CHECKED : ICONS.UNCHECKED}\n      </div>\n    </label>\n  );\n};\n","import React from \"react\";\nimport { t } from \"../i18n\";\nimport { useExcalidrawContainer } from \"./App\";\n\ninterface SectionProps extends React.HTMLProps<HTMLElement> {\n  heading: string;\n  children: React.ReactNode | ((header: React.ReactNode) => React.ReactNode);\n}\n\nexport const Section = ({ heading, children, ...props }: SectionProps) => {\n  const { id } = useExcalidrawContainer();\n  const header = (\n    <h2 className=\"visually-hidden\" id={`${id}-${heading}-title`}>\n      {t(`headings.${heading}`)}\n    </h2>\n  );\n  return (\n    <section {...props} aria-labelledby={`${id}-${heading}-title`}>\n      {typeof children === \"function\" ? (\n        children(header)\n      ) : (\n        <>\n          {header}\n          {children}\n        </>\n      )}\n    </section>\n  );\n};\n","import \"./UserList.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype UserListProps = {\n  children: React.ReactNode;\n  className?: string;\n  mobile?: boolean;\n};\n\nexport const UserList = ({ children, className, mobile }: UserListProps) => {\n  return (\n    <div className={clsx(\"UserList\", className, { UserList_mobile: mobile })}>\n      {children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { t } from \"../i18n\";\nimport { AppState } from \"../types\";\nimport { capitalizeString } from \"../utils\";\n\nconst LIBRARY_ICON = (\n  <svg viewBox=\"0 0 576 512\">\n    <path\n      fill=\"currentColor\"\n      d=\"M542.22 32.05c-54.8 3.11-163.72 14.43-230.96 55.59-4.64 2.84-7.27 7.89-7.27 13.17v363.87c0 11.55 12.63 18.85 23.28 13.49 69.18-34.82 169.23-44.32 218.7-46.92 16.89-.89 30.02-14.43 30.02-30.66V62.75c.01-17.71-15.35-31.74-33.77-30.7zM264.73 87.64C197.5 46.48 88.58 35.17 33.78 32.05 15.36 31.01 0 45.04 0 62.75V400.6c0 16.24 13.13 29.78 30.02 30.66 49.49 2.6 149.59 12.11 218.77 46.95 10.62 5.35 23.21-1.94 23.21-13.46V100.63c0-5.29-2.62-10.14-7.27-12.99z\"\n    ></path>\n  </svg>\n);\n\nexport const LibraryButton: React.FC<{\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}> = ({ appState, setAppState }) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon_type_floating ToolIcon__library zen-mode-visibility\",\n        `ToolIcon_size_medium`,\n        {\n          \"zen-mode-visibility--hidden\": appState.zenModeEnabled,\n        },\n      )}\n      title={`${capitalizeString(t(\"toolBar.library\"))}  0`}\n      style={{ marginInlineStart: \"var(--space-factor)\" }}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name=\"editor-library\"\n        onChange={(event) => {\n          setAppState({ isLibraryOpen: event.target.checked });\n        }}\n        checked={appState.isLibraryOpen}\n        aria-label={capitalizeString(t(\"toolBar.library\"))}\n        aria-keyshortcuts=\"0\"\n      />\n      <div className=\"ToolIcon__icon\">{LIBRARY_ICON}</div>\n    </label>\n  );\n};\n","import React from \"react\";\nimport { AppState } from \"../types\";\nimport { ActionManager } from \"../actions/manager\";\nimport { t } from \"../i18n\";\nimport Stack from \"./Stack\";\nimport { showSelectedShapeActions } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { Island } from \"./Island\";\nimport { HintViewer } from \"./HintViewer\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { SelectedShapeActions, ShapesSwitcher } from \"./Actions\";\nimport { Section } from \"./Section\";\nimport CollabButton from \"./CollabButton\";\nimport { SCROLLBAR_WIDTH, SCROLLBAR_MARGIN } from \"../scene/scrollbars\";\nimport { LockButton } from \"./LockButton\";\nimport { UserList } from \"./UserList\";\nimport { BackgroundPickerAndDarkModeToggle } from \"./BackgroundPickerAndDarkModeToggle\";\nimport { LibraryButton } from \"./LibraryButton\";\n\ntype MobileMenuProps = {\n  appState: AppState;\n  actionManager: ActionManager;\n  renderJSONExportDialog: () => React.ReactNode;\n  renderImageExportDialog: () => React.ReactNode;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  libraryMenu: JSX.Element | null;\n  onCollabButtonClick?: () => void;\n  onLockToggle: () => void;\n  canvas: HTMLCanvasElement | null;\n  isCollaborating: boolean;\n  renderCustomFooter?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  viewModeEnabled: boolean;\n  showThemeBtn: boolean;\n  onImageAction: (data: { insertOnCanvasDirectly: boolean }) => void;\n  renderTopRightUI?: (\n    isMobile: boolean,\n    appState: AppState,\n  ) => JSX.Element | null;\n};\n\nexport const MobileMenu = ({\n  appState,\n  elements,\n  libraryMenu,\n  actionManager,\n  renderJSONExportDialog,\n  renderImageExportDialog,\n  setAppState,\n  onCollabButtonClick,\n  onLockToggle,\n  canvas,\n  isCollaborating,\n  renderCustomFooter,\n  viewModeEnabled,\n  showThemeBtn,\n  onImageAction,\n  renderTopRightUI,\n}: MobileMenuProps) => {\n  const renderToolbar = () => {\n    return (\n      <FixedSideContainer side=\"top\" className=\"App-top-bar\">\n        <Section heading=\"shapes\">\n          {(heading) => (\n            <Stack.Col gap={4} align=\"center\">\n              <Stack.Row gap={1}>\n                <Island padding={1}>\n                  {heading}\n                  <Stack.Row gap={1}>\n                    <ShapesSwitcher\n                      canvas={canvas}\n                      elementType={appState.elementType}\n                      setAppState={setAppState}\n                      onImageAction={({ pointerType }) => {\n                        onImageAction({\n                          insertOnCanvasDirectly: pointerType !== \"mouse\",\n                        });\n                      }}\n                    />\n                  </Stack.Row>\n                </Island>\n                {renderTopRightUI && renderTopRightUI(true, appState)}\n                <LockButton\n                  checked={appState.elementLocked}\n                  onChange={onLockToggle}\n                  title={t(\"toolBar.lock\")}\n                />\n                <LibraryButton appState={appState} setAppState={setAppState} />\n              </Stack.Row>\n              {libraryMenu}\n            </Stack.Col>\n          )}\n        </Section>\n        <HintViewer appState={appState} elements={elements} isMobile={true} />\n      </FixedSideContainer>\n    );\n  };\n\n  const renderAppToolbar = () => {\n    if (viewModeEnabled) {\n      return (\n        <div className=\"App-toolbar-content\">\n          {actionManager.renderAction(\"toggleCanvasMenu\")}\n        </div>\n      );\n    }\n    return (\n      <div className=\"App-toolbar-content\">\n        {actionManager.renderAction(\"toggleCanvasMenu\")}\n        {actionManager.renderAction(\"toggleEditMenu\")}\n        {actionManager.renderAction(\"undo\")}\n        {actionManager.renderAction(\"redo\")}\n        {actionManager.renderAction(\n          appState.multiElement ? \"finalize\" : \"duplicateSelection\",\n        )}\n        {actionManager.renderAction(\"deleteSelectedElements\")}\n      </div>\n    );\n  };\n\n  const renderCanvasActions = () => {\n    if (viewModeEnabled) {\n      return (\n        <>\n          {renderJSONExportDialog()}\n          {renderImageExportDialog()}\n        </>\n      );\n    }\n    return (\n      <>\n        {actionManager.renderAction(\"clearCanvas\")}\n        {actionManager.renderAction(\"loadScene\")}\n        {renderJSONExportDialog()}\n        {renderImageExportDialog()}\n        {onCollabButtonClick && (\n          <CollabButton\n            isCollaborating={isCollaborating}\n            collaboratorCount={appState.collaborators.size}\n            onClick={onCollabButtonClick}\n          />\n        )}\n        {\n          <BackgroundPickerAndDarkModeToggle\n            actionManager={actionManager}\n            appState={appState}\n            setAppState={setAppState}\n            showThemeBtn={showThemeBtn}\n          />\n        }\n      </>\n    );\n  };\n  return (\n    <>\n      {!viewModeEnabled && renderToolbar()}\n      <div\n        className=\"App-bottom-bar\"\n        style={{\n          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n        }}\n      >\n        <Island padding={0}>\n          {appState.openMenu === \"canvas\" ? (\n            <Section className=\"App-mobile-menu\" heading=\"canvasActions\">\n              <div className=\"panelColumn\">\n                <Stack.Col gap={4}>\n                  {renderCanvasActions()}\n                  {renderCustomFooter?.(true, appState)}\n                  {appState.collaborators.size > 0 && (\n                    <fieldset>\n                      <legend>{t(\"labels.collaborators\")}</legend>\n                      <UserList mobile>\n                        {Array.from(appState.collaborators)\n                          // Collaborator is either not initialized or is actually the current user.\n                          .filter(\n                            ([_, client]) => Object.keys(client).length !== 0,\n                          )\n                          .map(([clientId, client]) => (\n                            <React.Fragment key={clientId}>\n                              {actionManager.renderAction(\"goToCollaborator\", {\n                                id: clientId,\n                              })}\n                            </React.Fragment>\n                          ))}\n                      </UserList>\n                    </fieldset>\n                  )}\n                </Stack.Col>\n              </div>\n            </Section>\n          ) : appState.openMenu === \"shape\" &&\n            !viewModeEnabled &&\n            showSelectedShapeActions(appState, elements) ? (\n            <Section className=\"App-mobile-menu\" heading=\"selectedShapeActions\">\n              <SelectedShapeActions\n                appState={appState}\n                elements={elements}\n                renderAction={actionManager.renderAction}\n                elementType={appState.elementType}\n              />\n            </Section>\n          ) : null}\n          <footer className=\"App-toolbar\">\n            {renderAppToolbar()}\n            {appState.scrolledOutside && !appState.openMenu && (\n              <button\n                className=\"scroll-back-to-content\"\n                onClick={() => {\n                  setAppState({\n                    ...calculateScrollCenter(elements, appState, canvas),\n                  });\n                }}\n              >\n                {t(\"buttons.scrollBackToContent\")}\n              </button>\n            )}\n          </footer>\n        </Island>\n      </div>\n    </>\n  );\n};\n","import oc from \"open-color\";\nimport React, { useLayoutEffect, useRef, useState } from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { ChartElements, renderSpreadsheet, Spreadsheet } from \"../charts\";\nimport { ChartType } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { exportToSvg } from \"../scene/export\";\nimport { AppState, LibraryItem } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport \"./PasteChartDialog.scss\";\n\ntype OnInsertChart = (chartType: ChartType, elements: ChartElements) => void;\n\nconst ChartPreviewBtn = (props: {\n  spreadsheet: Spreadsheet | null;\n  chartType: ChartType;\n  selected: boolean;\n  onClick: OnInsertChart;\n}) => {\n  const previewRef = useRef<HTMLDivElement | null>(null);\n  const [chartElements, setChartElements] = useState<ChartElements | null>(\n    null,\n  );\n\n  useLayoutEffect(() => {\n    if (!props.spreadsheet) {\n      return;\n    }\n\n    const elements = renderSpreadsheet(\n      props.chartType,\n      props.spreadsheet,\n      0,\n      0,\n    );\n    setChartElements(elements);\n    let svg: SVGSVGElement;\n    const previewNode = previewRef.current!;\n\n    (async () => {\n      svg = await exportToSvg(\n        elements,\n        {\n          exportBackground: false,\n          viewBackgroundColor: oc.white,\n        },\n        null, // files\n      );\n\n      previewNode.appendChild(svg);\n\n      if (props.selected) {\n        (previewNode.parentNode as HTMLDivElement).focus();\n      }\n    })();\n\n    return () => {\n      previewNode.removeChild(svg);\n    };\n  }, [props.spreadsheet, props.chartType, props.selected]);\n\n  return (\n    <button\n      className=\"ChartPreview\"\n      onClick={() => {\n        if (chartElements) {\n          props.onClick(props.chartType, chartElements);\n        }\n      }}\n    >\n      <div ref={previewRef} />\n    </button>\n  );\n};\n\nexport const PasteChartDialog = ({\n  setAppState,\n  appState,\n  onClose,\n  onInsertChart,\n}: {\n  appState: AppState;\n  onClose: () => void;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  onInsertChart: (elements: LibraryItem) => void;\n}) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  const handleChartClick = (chartType: ChartType, elements: ChartElements) => {\n    onInsertChart(elements);\n    trackEvent(\"magic\", \"chart\", chartType);\n    setAppState({\n      currentChartType: chartType,\n      pasteDialog: {\n        shown: false,\n        data: null,\n      },\n    });\n  };\n\n  return (\n    <Dialog\n      small\n      onCloseRequest={handleClose}\n      title={t(\"labels.pasteCharts\")}\n      className={\"PasteChartDialog\"}\n      autofocus={false}\n    >\n      <div className={\"container\"}>\n        <ChartPreviewBtn\n          chartType=\"bar\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"bar\"}\n          onClick={handleChartClick}\n        />\n        <ChartPreviewBtn\n          chartType=\"line\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"line\"}\n          onClick={handleChartClick}\n        />\n      </div>\n    </Dialog>\n  );\n};\n","import React from \"react\";\nimport { t } from \"../i18n\";\nimport { isDarwin, isWindows } from \"../keys\";\nimport { Dialog } from \"./Dialog\";\nimport { getShortcutKey } from \"../utils\";\nimport \"./HelpDialog.scss\";\n\nconst Header = () => (\n  <div className=\"HelpDialog--header\">\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://github.com/excalidraw/excalidraw#documentation\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.documentation\")}\n    </a>\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://blog.excalidraw.com\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.blog\")}\n    </a>\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://github.com/excalidraw/excalidraw/issues\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.github\")}\n    </a>\n  </div>\n);\n\nconst Section = (props: { title: string; children: React.ReactNode }) => (\n  <>\n    <h3>{props.title}</h3>\n    {props.children}\n  </>\n);\n\nconst Columns = (props: { children: React.ReactNode }) => (\n  <div\n    style={{\n      display: \"flex\",\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n    }}\n  >\n    {props.children}\n  </div>\n);\n\nconst Column = (props: { children: React.ReactNode }) => (\n  <div style={{ width: \"49%\" }}>{props.children}</div>\n);\n\nconst ShortcutIsland = (props: {\n  caption: string;\n  children: React.ReactNode;\n}) => (\n  <div className=\"HelpDialog--island\">\n    <h3 className=\"HelpDialog--island-title\">{props.caption}</h3>\n    {props.children}\n  </div>\n);\n\nconst Shortcut = (props: {\n  label: string;\n  shortcuts: string[];\n  isOr: boolean;\n}) => {\n  return (\n    <div className=\"HelpDialog--shortcut\">\n      <div\n        style={{\n          display: \"flex\",\n          margin: \"0\",\n          padding: \"4px 8px\",\n          alignItems: \"center\",\n        }}\n      >\n        <div\n          style={{\n            lineHeight: 1.4,\n          }}\n        >\n          {props.label}\n        </div>\n        <div\n          style={{\n            display: \"flex\",\n            flex: \"0 0 auto\",\n            justifyContent: \"flex-end\",\n            marginInlineStart: \"auto\",\n            minWidth: \"30%\",\n          }}\n        >\n          {props.shortcuts.map((shortcut, index) => (\n            <React.Fragment key={index}>\n              <ShortcutKey>{shortcut}</ShortcutKey>\n              {props.isOr &&\n                index !== props.shortcuts.length - 1 &&\n                t(\"helpDialog.or\")}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nShortcut.defaultProps = {\n  isOr: true,\n};\n\nconst ShortcutKey = (props: { children: React.ReactNode }) => (\n  <kbd className=\"HelpDialog--key\" {...props} />\n);\n\nexport const HelpDialog = ({ onClose }: { onClose?: () => void }) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  return (\n    <>\n      <Dialog\n        onCloseRequest={handleClose}\n        title={t(\"helpDialog.title\")}\n        className={\"HelpDialog\"}\n      >\n        <Header />\n        <Section title={t(\"helpDialog.shortcuts\")}>\n          <Columns>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.shapes\")}>\n                <Shortcut\n                  label={t(\"toolBar.selection\")}\n                  shortcuts={[\"V\", \"1\"]}\n                />\n                <Shortcut\n                  label={t(\"toolBar.rectangle\")}\n                  shortcuts={[\"R\", \"2\"]}\n                />\n                <Shortcut label={t(\"toolBar.diamond\")} shortcuts={[\"D\", \"3\"]} />\n                <Shortcut label={t(\"toolBar.ellipse\")} shortcuts={[\"E\", \"4\"]} />\n                <Shortcut label={t(\"toolBar.arrow\")} shortcuts={[\"A\", \"5\"]} />\n                <Shortcut label={t(\"toolBar.line\")} shortcuts={[\"P\", \"6\"]} />\n                <Shortcut\n                  label={t(\"toolBar.freedraw\")}\n                  shortcuts={[\"Shift+P\", \"7\"]}\n                />\n                <Shortcut label={t(\"toolBar.text\")} shortcuts={[\"T\", \"8\"]} />\n                <Shortcut label={t(\"toolBar.image\")} shortcuts={[\"9\"]} />\n                <Shortcut label={t(\"toolBar.library\")} shortcuts={[\"0\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.editSelectedShape\")}\n                  shortcuts={[\n                    getShortcutKey(\"Enter\"),\n                    t(\"helpDialog.doubleClick\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.textNewLine\")}\n                  shortcuts={[\n                    getShortcutKey(\"Enter\"),\n                    getShortcutKey(\"Shift+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.textFinish\")}\n                  shortcuts={[\n                    getShortcutKey(\"Esc\"),\n                    getShortcutKey(\"CtrlOrCmd+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedArrow\")}\n                  shortcuts={[\n                    \"A\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedLine\")}\n                  shortcuts={[\n                    \"L\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut label={t(\"toolBar.lock\")} shortcuts={[\"Q\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.preventBinding\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd\")]}\n                />\n              </ShortcutIsland>\n              <ShortcutIsland caption={t(\"helpDialog.view\")}>\n                <Shortcut\n                  label={t(\"buttons.zoomIn\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd++\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.zoomOut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+-\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.resetZoom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+0\")]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToFit\")}\n                  shortcuts={[\"Shift+1\"]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToSelection\")}\n                  shortcuts={[\"Shift+2\"]}\n                />\n                <Shortcut label={t(\"buttons.fullScreen\")} shortcuts={[\"F\"]} />\n                <Shortcut\n                  label={t(\"buttons.zenMode\")}\n                  shortcuts={[getShortcutKey(\"Alt+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.showGrid\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+'\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.viewMode\")}\n                  shortcuts={[getShortcutKey(\"Alt+R\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.toggleTheme\")}\n                  shortcuts={[getShortcutKey(\"Alt+Shift+D\")]}\n                />\n                <Shortcut\n                  label={t(\"stats.title\")}\n                  shortcuts={[getShortcutKey(\"Alt+/\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.editor\")}>\n                <Shortcut\n                  label={t(\"labels.selectAll\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+A\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.multiSelect\")}\n                  shortcuts={[getShortcutKey(`Shift+${t(\"helpDialog.click\")}`)]}\n                />\n                <Shortcut\n                  label={t(\"labels.moveCanvas\")}\n                  shortcuts={[\n                    getShortcutKey(`Space+${t(\"helpDialog.drag\")}`),\n                    getShortcutKey(`Wheel+${t(\"helpDialog.drag\")}`),\n                  ]}\n                  isOr={true}\n                />\n                <Shortcut\n                  label={t(\"labels.cut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+X\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copy\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.paste\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyAsPng\")}\n                  shortcuts={[getShortcutKey(\"Shift+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.pasteStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.delete\")}\n                  shortcuts={[getShortcutKey(\"Del\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendToBack\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringToFront\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendBackward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+[\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringForward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+]\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignTop\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Up\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignBottom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Down\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignLeft\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Left\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignRight\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Right\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.duplicateSelection\")}\n                  shortcuts={[\n                    getShortcutKey(\"CtrlOrCmd+D\"),\n                    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"buttons.undo\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.redo\")}\n                  shortcuts={\n                    isWindows\n                      ? [\n                          getShortcutKey(\"CtrlOrCmd+Y\"),\n                          getShortcutKey(\"CtrlOrCmd+Shift+Z\"),\n                        ]\n                      : [getShortcutKey(\"CtrlOrCmd+Shift+Z\")]\n                  }\n                />\n                <Shortcut\n                  label={t(\"labels.group\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+G\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.ungroup\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+G\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.flipHorizontal\")}\n                  shortcuts={[getShortcutKey(\"Shift+H\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.flipVertical\")}\n                  shortcuts={[getShortcutKey(\"Shift+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.showStroke\")}\n                  shortcuts={[getShortcutKey(\"S\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.showBackground\")}\n                  shortcuts={[getShortcutKey(\"G\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n          </Columns>\n        </Section>\n      </Dialog>\n    </>\n  );\n};\n","import OpenColor from \"open-color\";\n\nimport \"./Card.scss\";\n\nexport const Card: React.FC<{\n  color: keyof OpenColor;\n}> = ({ children, color }) => {\n  return (\n    <div\n      className=\"Card\"\n      style={{\n        [\"--card-color\" as any]: OpenColor[color][7],\n        [\"--card-color-darker\" as any]: OpenColor[color][8],\n        [\"--card-color-darkest\" as any]: OpenColor[color][9],\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport { ActionsManagerInterface } from \"../actions/types\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"./App\";\nimport { AppState, ExportOpts, BinaryFiles } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport { exportFile, exportToFileIcon, link } from \"./icons\";\nimport { ToolButton } from \"./ToolButton\";\nimport { actionSaveFileToDisk } from \"../actions/actionExport\";\nimport { Card } from \"./Card\";\n\nimport \"./ExportDialog.scss\";\nimport { nativeFileSystemSupported } from \"../data/filesystem\";\n\nexport type ExportCB = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  scale?: number,\n) => void;\n\nconst JSONExportModal = ({\n  elements,\n  appState,\n  files,\n  actionManager,\n  exportOpts,\n  canvas,\n}: {\n  appState: AppState;\n  files: BinaryFiles;\n  elements: readonly NonDeletedExcalidrawElement[];\n  actionManager: ActionsManagerInterface;\n  onCloseRequest: () => void;\n  exportOpts: ExportOpts;\n  canvas: HTMLCanvasElement | null;\n}) => {\n  const { onExportToBackend } = exportOpts;\n  return (\n    <div className=\"ExportDialog ExportDialog--json\">\n      <div className=\"ExportDialog-cards\">\n        {exportOpts.saveFileToDisk && (\n          <Card color=\"lime\">\n            <div className=\"Card-icon\">{exportToFileIcon}</div>\n            <h2>{t(\"exportDialog.disk_title\")}</h2>\n            <div className=\"Card-details\">\n              {t(\"exportDialog.disk_details\")}\n              {!nativeFileSystemSupported &&\n                actionManager.renderAction(\"changeProjectName\")}\n            </div>\n            <ToolButton\n              className=\"Card-button\"\n              type=\"button\"\n              title={t(\"exportDialog.disk_button\")}\n              aria-label={t(\"exportDialog.disk_button\")}\n              showAriaLabel={true}\n              onClick={() => {\n                actionManager.executeAction(actionSaveFileToDisk);\n              }}\n            />\n          </Card>\n        )}\n        {onExportToBackend && (\n          <Card color=\"pink\">\n            <div className=\"Card-icon\">{link}</div>\n            <h2>{t(\"exportDialog.link_title\")}</h2>\n            <div className=\"Card-details\">{t(\"exportDialog.link_details\")}</div>\n            <ToolButton\n              className=\"Card-button\"\n              type=\"button\"\n              title={t(\"exportDialog.link_button\")}\n              aria-label={t(\"exportDialog.link_button\")}\n              showAriaLabel={true}\n              onClick={() =>\n                onExportToBackend(elements, appState, files, canvas)\n              }\n            />\n          </Card>\n        )}\n        {exportOpts.renderCustomUI &&\n          exportOpts.renderCustomUI(elements, appState, files, canvas)}\n      </div>\n    </div>\n  );\n};\n\nexport const JSONExportDialog = ({\n  elements,\n  appState,\n  files,\n  actionManager,\n  exportOpts,\n  canvas,\n}: {\n  elements: readonly NonDeletedExcalidrawElement[];\n  appState: AppState;\n  files: BinaryFiles;\n  actionManager: ActionsManagerInterface;\n  exportOpts: ExportOpts;\n  canvas: HTMLCanvasElement | null;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(false);\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n  }, []);\n\n  return (\n    <>\n      <ToolButton\n        onClick={() => {\n          setModalIsShown(true);\n        }}\n        data-testid=\"json-export-button\"\n        icon={exportFile}\n        type=\"button\"\n        aria-label={t(\"buttons.export\")}\n        showAriaLabel={useIsMobile()}\n        title={t(\"buttons.export\")}\n      />\n      {modalIsShown && (\n        <Dialog onCloseRequest={handleClose} title={t(\"buttons.export\")}>\n          <JSONExportModal\n            elements={elements}\n            appState={appState}\n            files={files}\n            actionManager={actionManager}\n            onCloseRequest={handleClose}\n            exportOpts={exportOpts}\n            canvas={canvas}\n          />\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import clsx from \"clsx\";\nimport React, {\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { CLASSES } from \"../constants\";\nimport { exportCanvas } from \"../data\";\nimport { importLibraryFromJSON, saveLibraryAsJSON } from \"../data/json\";\nimport { isTextElement, showSelectedShapeActions } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { Language, t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { calculateScrollCenter, getSelectedElements } from \"../scene\";\nimport { ExportType } from \"../scene/types\";\nimport {\n  AppProps,\n  AppState,\n  ExcalidrawProps,\n  BinaryFiles,\n  LibraryItem,\n  LibraryItems,\n} from \"../types\";\nimport { muteFSAbortError } from \"../utils\";\nimport { SelectedShapeActions, ShapesSwitcher, ZoomActions } from \"./Actions\";\nimport { BackgroundPickerAndDarkModeToggle } from \"./BackgroundPickerAndDarkModeToggle\";\nimport CollabButton from \"./CollabButton\";\nimport { ErrorDialog } from \"./ErrorDialog\";\nimport { ExportCB, ImageExportDialog } from \"./ImageExportDialog\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { HintViewer } from \"./HintViewer\";\nimport { exportFile, load, trash } from \"./icons\";\nimport { Island } from \"./Island\";\nimport \"./LayerUI.scss\";\nimport { LibraryUnit } from \"./LibraryUnit\";\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport { LockButton } from \"./LockButton\";\nimport { MobileMenu } from \"./MobileMenu\";\nimport { PasteChartDialog } from \"./PasteChartDialog\";\nimport { Section } from \"./Section\";\nimport { HelpDialog } from \"./HelpDialog\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport { Tooltip } from \"./Tooltip\";\nimport { UserList } from \"./UserList\";\nimport Library from \"../data/library\";\nimport { JSONExportDialog } from \"./JSONExportDialog\";\nimport { LibraryButton } from \"./LibraryButton\";\nimport { isImageFileHandle } from \"../data/blob\";\n\ninterface LayerUIProps {\n  actionManager: ActionManager;\n  appState: AppState;\n  files: BinaryFiles;\n  canvas: HTMLCanvasElement | null;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onCollabButtonClick?: () => void;\n  onLockToggle: () => void;\n  onInsertElements: (elements: readonly NonDeletedExcalidrawElement[]) => void;\n  zenModeEnabled: boolean;\n  showExitZenModeBtn: boolean;\n  showThemeBtn: boolean;\n  toggleZenMode: () => void;\n  langCode: Language[\"code\"];\n  isCollaborating: boolean;\n  renderTopRightUI?: (\n    isMobile: boolean,\n    appState: AppState,\n  ) => JSX.Element | null;\n  renderCustomFooter?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  viewModeEnabled: boolean;\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  UIOptions: AppProps[\"UIOptions\"];\n  focusContainer: () => void;\n  library: Library;\n  id: string;\n  onImageAction: (data: { insertOnCanvasDirectly: boolean }) => void;\n}\n\nconst useOnClickOutside = (\n  ref: RefObject<HTMLElement>,\n  cb: (event: MouseEvent) => void,\n) => {\n  useEffect(() => {\n    const listener = (event: MouseEvent) => {\n      if (!ref.current) {\n        return;\n      }\n\n      if (\n        event.target instanceof Element &&\n        (ref.current.contains(event.target) ||\n          !document.body.contains(event.target))\n      ) {\n        return;\n      }\n\n      cb(event);\n    };\n    document.addEventListener(\"pointerdown\", listener, false);\n\n    return () => {\n      document.removeEventListener(\"pointerdown\", listener);\n    };\n  }, [ref, cb]);\n};\n\nconst LibraryMenuItems = ({\n  libraryItems,\n  onRemoveFromLibrary,\n  onAddToLibrary,\n  onInsertShape,\n  pendingElements,\n  theme,\n  setAppState,\n  setLibraryItems,\n  libraryReturnUrl,\n  focusContainer,\n  library,\n  files,\n  id,\n}: {\n  libraryItems: LibraryItems;\n  pendingElements: LibraryItem;\n  onRemoveFromLibrary: (index: number) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: (elements: LibraryItem) => void;\n  theme: AppState[\"theme\"];\n  files: BinaryFiles;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  setLibraryItems: (library: LibraryItems) => void;\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  focusContainer: () => void;\n  library: Library;\n  id: string;\n}) => {\n  const isMobile = useIsMobile();\n  const numCells = libraryItems.length + (pendingElements.length > 0 ? 1 : 0);\n  const CELLS_PER_ROW = isMobile ? 4 : 6;\n  const numRows = Math.max(1, Math.ceil(numCells / CELLS_PER_ROW));\n  const rows = [];\n  let addedPendingElements = false;\n\n  const referrer =\n    libraryReturnUrl || window.location.origin + window.location.pathname;\n\n  rows.push(\n    <div className=\"layer-ui__library-header\" key=\"library-header\">\n      <ToolButton\n        key=\"import\"\n        type=\"button\"\n        title={t(\"buttons.load\")}\n        aria-label={t(\"buttons.load\")}\n        icon={load}\n        onClick={() => {\n          importLibraryFromJSON(library)\n            .then(() => {\n              // Close and then open to get the libraries updated\n              setAppState({ isLibraryOpen: false });\n              setAppState({ isLibraryOpen: true });\n            })\n            .catch(muteFSAbortError)\n            .catch((error) => {\n              setAppState({ errorMessage: error.message });\n            });\n        }}\n      />\n      {!!libraryItems.length && (\n        <>\n          <ToolButton\n            key=\"export\"\n            type=\"button\"\n            title={t(\"buttons.export\")}\n            aria-label={t(\"buttons.export\")}\n            icon={exportFile}\n            onClick={() => {\n              saveLibraryAsJSON(library)\n                .catch(muteFSAbortError)\n                .catch((error) => {\n                  setAppState({ errorMessage: error.message });\n                });\n            }}\n          />\n          <ToolButton\n            key=\"reset\"\n            type=\"button\"\n            title={t(\"buttons.resetLibrary\")}\n            aria-label={t(\"buttons.resetLibrary\")}\n            icon={trash}\n            onClick={() => {\n              if (window.confirm(t(\"alerts.resetLibrary\"))) {\n                library.resetLibrary();\n                setLibraryItems([]);\n                focusContainer();\n              }\n            }}\n          />\n        </>\n      )}\n      <a\n        href={`https://libraries.excalidraw.com?target=${\n          window.name || \"_blank\"\n        }&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}`}\n        target=\"_excalidraw_libraries\"\n      >\n        {t(\"labels.libraries\")}\n      </a>\n    </div>,\n  );\n\n  for (let row = 0; row < numRows; row++) {\n    const y = CELLS_PER_ROW * row;\n    const children = [];\n    for (let x = 0; x < CELLS_PER_ROW; x++) {\n      const shouldAddPendingElements: boolean =\n        pendingElements.length > 0 &&\n        !addedPendingElements &&\n        y + x >= libraryItems.length;\n      addedPendingElements = addedPendingElements || shouldAddPendingElements;\n\n      children.push(\n        <Stack.Col key={x}>\n          <LibraryUnit\n            elements={libraryItems[y + x]}\n            files={files}\n            pendingElements={\n              shouldAddPendingElements ? pendingElements : undefined\n            }\n            onRemoveFromLibrary={onRemoveFromLibrary.bind(null, y + x)}\n            onClick={\n              shouldAddPendingElements\n                ? onAddToLibrary.bind(null, pendingElements)\n                : onInsertShape.bind(null, libraryItems[y + x])\n            }\n          />\n        </Stack.Col>,\n      );\n    }\n    rows.push(\n      <Stack.Row align=\"center\" gap={1} key={row}>\n        {children}\n      </Stack.Row>,\n    );\n  }\n\n  return (\n    <Stack.Col align=\"start\" gap={1} className=\"layer-ui__library-items\">\n      {rows}\n    </Stack.Col>\n  );\n};\n\nconst LibraryMenu = ({\n  onClickOutside,\n  onInsertShape,\n  pendingElements,\n  onAddToLibrary,\n  theme,\n  setAppState,\n  files,\n  libraryReturnUrl,\n  focusContainer,\n  library,\n  id,\n}: {\n  pendingElements: LibraryItem;\n  onClickOutside: (event: MouseEvent) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: () => void;\n  theme: AppState[\"theme\"];\n  files: BinaryFiles;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  focusContainer: () => void;\n  library: Library;\n  id: string;\n}) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n  useOnClickOutside(ref, (event) => {\n    // If click on the library icon, do nothing.\n    if ((event.target as Element).closest(\".ToolIcon_type_button__library\")) {\n      return;\n    }\n    onClickOutside(event);\n  });\n\n  const [libraryItems, setLibraryItems] = useState<LibraryItems>([]);\n\n  const [loadingState, setIsLoading] = useState<\n    \"preloading\" | \"loading\" | \"ready\"\n  >(\"preloading\");\n\n  const loadingTimerRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    Promise.race([\n      new Promise((resolve) => {\n        loadingTimerRef.current = window.setTimeout(() => {\n          resolve(\"loading\");\n        }, 100);\n      }),\n      library.loadLibrary().then((items) => {\n        setLibraryItems(items);\n        setIsLoading(\"ready\");\n      }),\n    ]).then((data) => {\n      if (data === \"loading\") {\n        setIsLoading(\"loading\");\n      }\n    });\n    return () => {\n      clearTimeout(loadingTimerRef.current!);\n    };\n  }, [library]);\n\n  const removeFromLibrary = useCallback(\n    async (indexToRemove) => {\n      const items = await library.loadLibrary();\n      const nextItems = items.filter((_, index) => index !== indexToRemove);\n      library.saveLibrary(nextItems).catch((error) => {\n        setLibraryItems(items);\n        setAppState({ errorMessage: t(\"alerts.errorRemovingFromLibrary\") });\n      });\n      setLibraryItems(nextItems);\n    },\n    [library, setAppState],\n  );\n\n  const addToLibrary = useCallback(\n    async (elements: LibraryItem) => {\n      if (elements.some((element) => element.type === \"image\")) {\n        return setAppState({\n          errorMessage: \"Support for adding images to the library coming soon!\",\n        });\n      }\n\n      const items = await library.loadLibrary();\n      const nextItems = [...items, elements];\n      onAddToLibrary();\n      library.saveLibrary(nextItems).catch((error) => {\n        setLibraryItems(items);\n        setAppState({ errorMessage: t(\"alerts.errorAddingToLibrary\") });\n      });\n      setLibraryItems(nextItems);\n    },\n    [onAddToLibrary, library, setAppState],\n  );\n\n  return loadingState === \"preloading\" ? null : (\n    <Island padding={1} ref={ref} className=\"layer-ui__library\">\n      {loadingState === \"loading\" ? (\n        <div className=\"layer-ui__library-message\">\n          {t(\"labels.libraryLoadingMessage\")}\n        </div>\n      ) : (\n        <LibraryMenuItems\n          libraryItems={libraryItems}\n          onRemoveFromLibrary={removeFromLibrary}\n          onAddToLibrary={addToLibrary}\n          onInsertShape={onInsertShape}\n          pendingElements={pendingElements}\n          setAppState={setAppState}\n          setLibraryItems={setLibraryItems}\n          libraryReturnUrl={libraryReturnUrl}\n          focusContainer={focusContainer}\n          library={library}\n          theme={theme}\n          files={files}\n          id={id}\n        />\n      )}\n    </Island>\n  );\n};\n\nconst LayerUI = ({\n  actionManager,\n  appState,\n  files,\n  setAppState,\n  canvas,\n  elements,\n  onCollabButtonClick,\n  onLockToggle,\n  onInsertElements,\n  zenModeEnabled,\n  showExitZenModeBtn,\n  showThemeBtn,\n  toggleZenMode,\n  isCollaborating,\n  renderTopRightUI,\n  renderCustomFooter,\n  viewModeEnabled,\n  libraryReturnUrl,\n  UIOptions,\n  focusContainer,\n  library,\n  id,\n  onImageAction,\n}: LayerUIProps) => {\n  const isMobile = useIsMobile();\n\n  const renderJSONExportDialog = () => {\n    if (!UIOptions.canvasActions.export) {\n      return null;\n    }\n\n    return (\n      <JSONExportDialog\n        elements={elements}\n        appState={appState}\n        files={files}\n        actionManager={actionManager}\n        exportOpts={UIOptions.canvasActions.export}\n        canvas={canvas}\n      />\n    );\n  };\n\n  const renderImageExportDialog = () => {\n    if (!UIOptions.canvasActions.saveAsImage) {\n      return null;\n    }\n\n    const createExporter =\n      (type: ExportType): ExportCB =>\n      async (exportedElements) => {\n        const fileHandle = await exportCanvas(\n          type,\n          exportedElements,\n          appState,\n          files,\n          {\n            exportBackground: appState.exportBackground,\n            name: appState.name,\n            viewBackgroundColor: appState.viewBackgroundColor,\n          },\n        )\n          .catch(muteFSAbortError)\n          .catch((error) => {\n            console.error(error);\n            setAppState({ errorMessage: error.message });\n          });\n\n        if (\n          appState.exportEmbedScene &&\n          fileHandle &&\n          isImageFileHandle(fileHandle)\n        ) {\n          setAppState({ fileHandle });\n        }\n      };\n\n    return (\n      <ImageExportDialog\n        elements={elements}\n        appState={appState}\n        files={files}\n        actionManager={actionManager}\n        onExportToPng={createExporter(\"png\")}\n        onExportToSvg={createExporter(\"svg\")}\n        onExportToClipboard={createExporter(\"clipboard\")}\n      />\n    );\n  };\n\n  const Separator = () => {\n    return <div style={{ width: \".625em\" }} />;\n  };\n\n  const renderViewModeCanvasActions = () => {\n    return (\n      <Section\n        heading=\"canvasActions\"\n        className={clsx(\"zen-mode-transition\", {\n          \"transition-left\": zenModeEnabled,\n        })}\n      >\n        {/* the zIndex ensures this menu has higher stacking order,\n         see https://github.com/excalidraw/excalidraw/pull/1445 */}\n        <Island padding={2} style={{ zIndex: 1 }}>\n          <Stack.Col gap={4}>\n            <Stack.Row gap={1} justifyContent=\"space-between\">\n              {renderJSONExportDialog()}\n              {renderImageExportDialog()}\n            </Stack.Row>\n          </Stack.Col>\n        </Island>\n      </Section>\n    );\n  };\n\n  const renderCanvasActions = () => (\n    <Section\n      heading=\"canvasActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      {/* the zIndex ensures this menu has higher stacking order,\n         see https://github.com/excalidraw/excalidraw/pull/1445 */}\n      <Island padding={2} style={{ zIndex: 1 }}>\n        <Stack.Col gap={4}>\n          <Stack.Row gap={1} justifyContent=\"space-between\">\n            {actionManager.renderAction(\"clearCanvas\")}\n            <Separator />\n            {actionManager.renderAction(\"loadScene\")}\n            {renderJSONExportDialog()}\n            {renderImageExportDialog()}\n            <Separator />\n            {onCollabButtonClick && (\n              <CollabButton\n                isCollaborating={isCollaborating}\n                collaboratorCount={appState.collaborators.size}\n                onClick={onCollabButtonClick}\n              />\n            )}\n          </Stack.Row>\n          <BackgroundPickerAndDarkModeToggle\n            actionManager={actionManager}\n            appState={appState}\n            setAppState={setAppState}\n            showThemeBtn={showThemeBtn}\n          />\n          {appState.fileHandle && (\n            <>{actionManager.renderAction(\"saveToActiveFile\")}</>\n          )}\n        </Stack.Col>\n      </Island>\n    </Section>\n  );\n\n  const renderSelectedShapeActions = () => (\n    <Section\n      heading=\"selectedShapeActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      <Island\n        className={CLASSES.SHAPE_ACTIONS_MENU}\n        padding={2}\n        style={{\n          // we want to make sure this doesn't overflow so substracting 200\n          // which is approximately height of zoom footer and top left menu items with some buffer\n          // if active file name is displayed, subtracting 248 to account for its height\n          maxHeight: `${appState.height - (appState.fileHandle ? 248 : 200)}px`,\n        }}\n      >\n        <SelectedShapeActions\n          appState={appState}\n          elements={elements}\n          renderAction={actionManager.renderAction}\n          elementType={appState.elementType}\n        />\n      </Island>\n    </Section>\n  );\n\n  const closeLibrary = useCallback(\n    (event) => {\n      setAppState({ isLibraryOpen: false });\n    },\n    [setAppState],\n  );\n\n  const deselectItems = useCallback(() => {\n    setAppState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n    });\n  }, [setAppState]);\n\n  const libraryMenu = appState.isLibraryOpen ? (\n    <LibraryMenu\n      pendingElements={getSelectedElements(elements, appState)}\n      onClickOutside={closeLibrary}\n      onInsertShape={onInsertElements}\n      onAddToLibrary={deselectItems}\n      setAppState={setAppState}\n      libraryReturnUrl={libraryReturnUrl}\n      focusContainer={focusContainer}\n      library={library}\n      theme={appState.theme}\n      files={files}\n      id={id}\n    />\n  ) : null;\n\n  const renderFixedSideContainer = () => {\n    const shouldRenderSelectedShapeActions = showSelectedShapeActions(\n      appState,\n      elements,\n    );\n\n    return (\n      <FixedSideContainer side=\"top\">\n        <div className=\"App-menu App-menu_top\">\n          <Stack.Col\n            gap={4}\n            className={clsx({ \"disable-pointerEvents\": zenModeEnabled })}\n          >\n            {viewModeEnabled\n              ? renderViewModeCanvasActions()\n              : renderCanvasActions()}\n            {shouldRenderSelectedShapeActions && renderSelectedShapeActions()}\n          </Stack.Col>\n          {!viewModeEnabled && (\n            <Section heading=\"shapes\">\n              {(heading) => (\n                <Stack.Col gap={4} align=\"start\">\n                  <Stack.Row gap={1}>\n                    <LockButton\n                      zenModeEnabled={zenModeEnabled}\n                      checked={appState.elementLocked}\n                      onChange={onLockToggle}\n                      title={t(\"toolBar.lock\")}\n                    />\n                    <Island\n                      padding={1}\n                      className={clsx({ \"zen-mode\": zenModeEnabled })}\n                    >\n                      <HintViewer\n                        appState={appState}\n                        elements={elements}\n                        isMobile={isMobile}\n                      />\n                      {heading}\n                      <Stack.Row gap={1}>\n                        <ShapesSwitcher\n                          canvas={canvas}\n                          elementType={appState.elementType}\n                          setAppState={setAppState}\n                          onImageAction={({ pointerType }) => {\n                            onImageAction({\n                              insertOnCanvasDirectly: pointerType !== \"mouse\",\n                            });\n                          }}\n                        />\n                      </Stack.Row>\n                    </Island>\n                    <LibraryButton\n                      appState={appState}\n                      setAppState={setAppState}\n                    />\n                  </Stack.Row>\n                  {libraryMenu}\n                </Stack.Col>\n              )}\n            </Section>\n          )}\n          <div\n            className={clsx(\n              \"layer-ui__wrapper__top-right zen-mode-transition\",\n              {\n                \"transition-right\": zenModeEnabled,\n              },\n            )}\n          >\n            <UserList>\n              {appState.collaborators.size > 0 &&\n                Array.from(appState.collaborators)\n                  // Collaborator is either not initialized or is actually the current user.\n                  .filter(([_, client]) => Object.keys(client).length !== 0)\n                  .map(([clientId, client]) => (\n                    <Tooltip\n                      label={client.username || \"Unknown user\"}\n                      key={clientId}\n                    >\n                      {actionManager.renderAction(\"goToCollaborator\", {\n                        id: clientId,\n                      })}\n                    </Tooltip>\n                  ))}\n            </UserList>\n            {renderTopRightUI?.(isMobile, appState)}\n          </div>\n        </div>\n      </FixedSideContainer>\n    );\n  };\n\n  const renderBottomAppMenu = () => {\n    return (\n      <footer\n        role=\"contentinfo\"\n        className=\"layer-ui__wrapper__footer App-menu App-menu_bottom\"\n      >\n        <div\n          className={clsx(\n            \"layer-ui__wrapper__footer-left zen-mode-transition\",\n            {\n              \"layer-ui__wrapper__footer-left--transition-left\": zenModeEnabled,\n            },\n          )}\n        >\n          <Stack.Col gap={2}>\n            <Section heading=\"canvasActions\">\n              <Island padding={1}>\n                <ZoomActions\n                  renderAction={actionManager.renderAction}\n                  zoom={appState.zoom}\n                />\n              </Island>\n              {!viewModeEnabled && (\n                <div\n                  className={clsx(\"undo-redo-buttons zen-mode-transition\", {\n                    \"layer-ui__wrapper__footer-left--transition-bottom\":\n                      zenModeEnabled,\n                  })}\n                >\n                  {actionManager.renderAction(\"undo\", { size: \"small\" })}\n                  {actionManager.renderAction(\"redo\", { size: \"small\" })}\n                </div>\n              )}\n            </Section>\n          </Stack.Col>\n        </div>\n        <div\n          className={clsx(\n            \"layer-ui__wrapper__footer-center zen-mode-transition\",\n            {\n              \"layer-ui__wrapper__footer-left--transition-bottom\":\n                zenModeEnabled,\n            },\n          )}\n        >\n          {renderCustomFooter?.(false, appState)}\n        </div>\n        <div\n          className={clsx(\n            \"layer-ui__wrapper__footer-right zen-mode-transition\",\n            {\n              \"transition-right disable-pointerEvents\": zenModeEnabled,\n            },\n          )}\n        >\n          {actionManager.renderAction(\"toggleShortcuts\")}\n        </div>\n        <button\n          className={clsx(\"disable-zen-mode\", {\n            \"disable-zen-mode--visible\": showExitZenModeBtn,\n          })}\n          onClick={toggleZenMode}\n        >\n          {t(\"buttons.exitZenMode\")}\n        </button>\n      </footer>\n    );\n  };\n\n  const dialogs = (\n    <>\n      {appState.isLoading && <LoadingMessage />}\n      {appState.errorMessage && (\n        <ErrorDialog\n          message={appState.errorMessage}\n          onClose={() => setAppState({ errorMessage: null })}\n        />\n      )}\n      {appState.showHelpDialog && (\n        <HelpDialog\n          onClose={() => {\n            setAppState({ showHelpDialog: false });\n          }}\n        />\n      )}\n      {appState.pasteDialog.shown && (\n        <PasteChartDialog\n          setAppState={setAppState}\n          appState={appState}\n          onInsertChart={onInsertElements}\n          onClose={() =>\n            setAppState({\n              pasteDialog: { shown: false, data: null },\n            })\n          }\n        />\n      )}\n    </>\n  );\n\n  return isMobile ? (\n    <>\n      {dialogs}\n      <MobileMenu\n        appState={appState}\n        elements={elements}\n        actionManager={actionManager}\n        libraryMenu={libraryMenu}\n        renderJSONExportDialog={renderJSONExportDialog}\n        renderImageExportDialog={renderImageExportDialog}\n        setAppState={setAppState}\n        onCollabButtonClick={onCollabButtonClick}\n        onLockToggle={onLockToggle}\n        canvas={canvas}\n        isCollaborating={isCollaborating}\n        renderCustomFooter={renderCustomFooter}\n        viewModeEnabled={viewModeEnabled}\n        showThemeBtn={showThemeBtn}\n        onImageAction={onImageAction}\n        renderTopRightUI={renderTopRightUI}\n      />\n    </>\n  ) : (\n    <div\n      className={clsx(\"layer-ui__wrapper\", {\n        \"disable-pointerEvents\":\n          appState.draggingElement ||\n          appState.resizingElement ||\n          (appState.editingElement && !isTextElement(appState.editingElement)),\n      })}\n    >\n      {dialogs}\n      {renderFixedSideContainer()}\n      {renderBottomAppMenu()}\n      {appState.scrolledOutside && (\n        <button\n          className=\"scroll-back-to-content\"\n          onClick={() => {\n            setAppState({\n              ...calculateScrollCenter(elements, appState, canvas),\n            });\n          }}\n        >\n          {t(\"buttons.scrollBackToContent\")}\n        </button>\n      )}\n    </div>\n  );\n};\n\nconst areEqual = (prev: LayerUIProps, next: LayerUIProps) => {\n  const getNecessaryObj = (appState: AppState): Partial<AppState> => {\n    const {\n      suggestedBindings,\n      startBoundElement: boundElement,\n      ...ret\n    } = appState;\n    return ret;\n  };\n  const prevAppState = getNecessaryObj(prev.appState);\n  const nextAppState = getNecessaryObj(next.appState);\n\n  const keys = Object.keys(prevAppState) as (keyof Partial<AppState>)[];\n  return (\n    prev.renderCustomFooter === next.renderCustomFooter &&\n    prev.langCode === next.langCode &&\n    prev.elements === next.elements &&\n    prev.files === next.files &&\n    keys.every((key) => prevAppState[key] === nextAppState[key])\n  );\n};\n\nexport default React.memo(LayerUI, areEqual);\n","import React from \"react\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { getTargetElements } from \"../scene\";\nimport { AppState, ExcalidrawProps } from \"../types\";\nimport { close } from \"./icons\";\nimport { Island } from \"./Island\";\nimport \"./Stats.scss\";\n\nexport const Stats = (props: {\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onClose: () => void;\n  renderCustomStats: ExcalidrawProps[\"renderCustomStats\"];\n}) => {\n  const isMobile = useIsMobile();\n\n  const boundingBox = getCommonBounds(props.elements);\n  const selectedElements = getTargetElements(props.elements, props.appState);\n  const selectedBoundingBox = getCommonBounds(selectedElements);\n\n  if (isMobile && props.appState.openMenu) {\n    return null;\n  }\n\n  return (\n    <div className=\"Stats\">\n      <Island padding={2}>\n        <div className=\"close\" onClick={props.onClose}>\n          {close}\n        </div>\n        <h3>{t(\"stats.title\")}</h3>\n        <table>\n          <tbody>\n            <tr>\n              <th colSpan={2}>{t(\"stats.scene\")}</th>\n            </tr>\n            <tr>\n              <td>{t(\"stats.elements\")}</td>\n              <td>{props.elements.length}</td>\n            </tr>\n            <tr>\n              <td>{t(\"stats.width\")}</td>\n              <td>{Math.round(boundingBox[2]) - Math.round(boundingBox[0])}</td>\n            </tr>\n            <tr>\n              <td>{t(\"stats.height\")}</td>\n              <td>{Math.round(boundingBox[3]) - Math.round(boundingBox[1])}</td>\n            </tr>\n\n            {selectedElements.length === 1 && (\n              <tr>\n                <th colSpan={2}>{t(\"stats.element\")}</th>\n              </tr>\n            )}\n\n            {selectedElements.length > 1 && (\n              <>\n                <tr>\n                  <th colSpan={2}>{t(\"stats.selected\")}</th>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.elements\")}</td>\n                  <td>{selectedElements.length}</td>\n                </tr>\n              </>\n            )}\n            {selectedElements.length > 0 && (\n              <>\n                <tr>\n                  <td>{\"x\"}</td>\n                  <td>{Math.round(selectedBoundingBox[0])}</td>\n                </tr>\n                <tr>\n                  <td>{\"y\"}</td>\n                  <td>{Math.round(selectedBoundingBox[1])}</td>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.width\")}</td>\n                  <td>\n                    {Math.round(\n                      selectedBoundingBox[2] - selectedBoundingBox[0],\n                    )}\n                  </td>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.height\")}</td>\n                  <td>\n                    {Math.round(\n                      selectedBoundingBox[3] - selectedBoundingBox[1],\n                    )}\n                  </td>\n                </tr>\n              </>\n            )}\n            {selectedElements.length === 1 && (\n              <tr>\n                <td>{t(\"stats.angle\")}</td>\n                <td>\n                  {`${Math.round(\n                    (selectedElements[0].angle * 180) / Math.PI,\n                  )}`}\n                </td>\n              </tr>\n            )}\n            {props.renderCustomStats?.(props.elements, props.appState)}\n          </tbody>\n        </table>\n      </Island>\n    </div>\n  );\n};\n","import { useCallback, useEffect, useRef } from \"react\";\nimport { TOAST_TIMEOUT } from \"../constants\";\nimport \"./Toast.scss\";\n\nexport const Toast = ({\n  message,\n  clearToast,\n}: {\n  message: string;\n  clearToast: () => void;\n}) => {\n  const timerRef = useRef<number>(0);\n\n  const scheduleTimeout = useCallback(\n    () =>\n      (timerRef.current = window.setTimeout(() => clearToast(), TOAST_TIMEOUT)),\n    [clearToast],\n  );\n\n  useEffect(() => {\n    scheduleTimeout();\n    return () => clearTimeout(timerRef.current);\n  }, [scheduleTimeout, message]);\n\n  return (\n    <div\n      className=\"Toast\"\n      onMouseEnter={() => clearTimeout(timerRef?.current)}\n      onMouseLeave={scheduleTimeout}\n    >\n      <p className=\"Toast__message\">{message}</p>\n    </div>\n  );\n};\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleViewMode = register({\n  name: \"viewMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"view\");\n    return {\n      appState: {\n        ...appState,\n        viewModeEnabled: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.viewModeEnabled,\n  contextItemLabel: \"labels.viewMode\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R,\n});\n","import React, { useContext } from \"react\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport rough from \"roughjs/bin/rough\";\nimport clsx from \"clsx\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  actionAddToLibrary,\n  actionBringForward,\n  actionBringToFront,\n  actionCopy,\n  actionCopyAsPng,\n  actionCopyAsSvg,\n  actionCopyStyles,\n  actionCut,\n  actionDeleteSelected,\n  actionDuplicateSelection,\n  actionFinalize,\n  actionFlipHorizontal,\n  actionFlipVertical,\n  actionGroup,\n  actionPasteStyles,\n  actionSelectAll,\n  actionSendBackward,\n  actionSendToBack,\n  actionToggleGridMode,\n  actionToggleStats,\n  actionToggleZenMode,\n  actionUngroup,\n} from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { ActionResult } from \"../actions/types\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport {\n  copyToClipboard,\n  parseClipboard,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n} from \"../clipboard\";\nimport {\n  APP_NAME,\n  CURSOR_TYPE,\n  DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,\n  DEFAULT_UI_OPTIONS,\n  DEFAULT_VERTICAL_ALIGN,\n  DRAGGING_THRESHOLD,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  ENV,\n  EVENT,\n  GRID_SIZE,\n  IMAGE_RENDER_TIMEOUT,\n  LINE_CONFIRM_THRESHOLD,\n  MAX_ALLOWED_FILE_BYTES,\n  MIME_TYPES,\n  MQ_MAX_HEIGHT_LANDSCAPE,\n  MQ_MAX_WIDTH_LANDSCAPE,\n  MQ_MAX_WIDTH_PORTRAIT,\n  POINTER_BUTTON,\n  SCROLL_TIMEOUT,\n  TAP_TWICE_TIMEOUT,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  THEME,\n  TOUCH_CTX_MENU_TIMEOUT,\n  URL_HASH_KEYS,\n  URL_QUERY_KEYS,\n  ZOOM_STEP,\n} from \"../constants\";\nimport { loadFromBlob } from \"../data\";\nimport { isValidLibrary } from \"../data/json\";\nimport Library from \"../data/library\";\nimport { restore, restoreElements } from \"../data/restore\";\nimport {\n  dragNewElement,\n  dragSelectedElements,\n  duplicateElement,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getDragOffsetXY,\n  getElementWithTransformHandleType,\n  getNormalizedDimensions,\n  getPerfectElementSize,\n  getResizeArrowDirection,\n  getResizeOffsetXY,\n  getTransformHandleTypeFromCoords,\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n  isInvisiblySmallElement,\n  isNonDeletedElement,\n  isTextElement,\n  newElement,\n  newLinearElement,\n  newTextElement,\n  newImageElement,\n  textWysiwyg,\n  transformElements,\n  updateTextElement,\n} from \"../element\";\nimport {\n  bindOrUnbindSelectedElements,\n  fixBindingsAfterDeletion,\n  fixBindingsAfterDuplication,\n  getEligibleElementsForBinding,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  isLinearElementSimpleAndAlreadyBound,\n  maybeBindLinearElement,\n  shouldEnableBindingForPointerEvent,\n  unbindLinearElements,\n  updateBoundElements,\n} from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  bumpVersion,\n  mutateElement,\n  newElementWith,\n} from \"../element/mutateElement\";\nimport { deepCopyElement, newFreeDrawElement } from \"../element/newElement\";\nimport {\n  isBindingElement,\n  isBindingElementType,\n  isImageElement,\n  isInitializedImageElement,\n  isLinearElement,\n  isLinearElementType,\n} from \"../element/typeChecks\";\nimport {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n  InitializedExcalidrawImageElement,\n  ExcalidrawImageElement,\n  FileId,\n} from \"../element/types\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport {\n  editGroupForSelectedElement,\n  getElementsInGroup,\n  getSelectedGroupIdForElement,\n  getSelectedGroupIds,\n  isElementInGroup,\n  isSelectedViaGroup,\n  selectGroupsForSelectedElements,\n} from \"../groups\";\nimport History from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport {\n  CODES,\n  shouldResizeFromCenter,\n  shouldMaintainAspectRatio,\n  shouldRotateWithDiscreteAngle,\n  isArrowKey,\n  KEYS,\n} from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { renderScene } from \"../renderer\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport {\n  calculateScrollCenter,\n  getElementContainingPosition,\n  getElementsAtPosition,\n  getElementsWithinSelection,\n  getNormalizedZoom,\n  getSelectedElements,\n  hasBackground,\n  isOverScrollBars,\n  isSomeElementSelected,\n} from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { SceneState, ScrollBars } from \"../scene/types\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { findShapeByKey } from \"../shapes\";\nimport {\n  AppClassProperties,\n  AppProps,\n  AppState,\n  BinaryFileData,\n  DataURL,\n  ExcalidrawImperativeAPI,\n  BinaryFiles,\n  Gesture,\n  GestureEvent,\n  LibraryItems,\n  PointerDownState,\n  SceneData,\n} from \"../types\";\nimport {\n  debounce,\n  distance,\n  getNearestScrollableContainer,\n  isInputLike,\n  isToolIcon,\n  isWritableElement,\n  resetCursor,\n  resolvablePromise,\n  sceneCoordsToViewportCoords,\n  setCursor,\n  setCursorForShape,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n  withBatchedUpdates,\n} from \"../utils\";\nimport ContextMenu, { ContextMenuOption } from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Stats } from \"./Stats\";\nimport { Toast } from \"./Toast\";\nimport { actionToggleViewMode } from \"../actions/actionToggleViewMode\";\nimport {\n  dataURLToFile,\n  generateIdFromFile,\n  getDataURL,\n  isSupportedImageFile,\n  resizeImageFile,\n  SVGStringToFile,\n} from \"../data/blob\";\nimport {\n  getInitializedImageElements,\n  loadHTMLImageElement,\n  normalizeSVG,\n  updateImageCache as _updateImageCache,\n} from \"../element/image\";\nimport throttle from \"lodash.throttle\";\nimport { fileOpen, nativeFileSystemSupported } from \"../data/filesystem\";\n\nconst IsMobileContext = React.createContext(false);\nexport const useIsMobile = () => useContext(IsMobileContext);\nconst ExcalidrawContainerContext = React.createContext<{\n  container: HTMLDivElement | null;\n  id: string | null;\n}>({ container: null, id: null });\nexport const useExcalidrawContainer = () =>\n  useContext(ExcalidrawContainerContext);\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nclass App extends React.Component<AppProps, AppState> {\n  canvas: AppClassProperties[\"canvas\"] = null;\n  rc: RoughCanvas | null = null;\n  unmounted: boolean = false;\n  actionManager: ActionManager;\n  isMobile = false;\n  detachIsMobileMqHandler?: () => void;\n\n  private excalidrawContainerRef = React.createRef<HTMLDivElement>();\n\n  public static defaultProps: Partial<AppProps> = {\n    // needed for tests to pass since we directly render App in many tests\n    UIOptions: DEFAULT_UI_OPTIONS,\n  };\n\n  private scene: Scene;\n  private resizeObserver: ResizeObserver | undefined;\n  private nearestScrollableContainer: HTMLElement | Document | undefined;\n  public library: AppClassProperties[\"library\"];\n  public libraryItemsFromStorage: LibraryItems | undefined;\n  private id: string;\n  private history: History;\n  private excalidrawContainerValue: {\n    container: HTMLDivElement | null;\n    id: string;\n  };\n\n  public files: BinaryFiles = {};\n  public imageCache: AppClassProperties[\"imageCache\"] = new Map();\n\n  constructor(props: AppProps) {\n    super(props);\n    const defaultAppState = getDefaultAppState();\n    const {\n      excalidrawRef,\n      viewModeEnabled = false,\n      zenModeEnabled = false,\n      gridModeEnabled = false,\n      theme = defaultAppState.theme,\n      name = defaultAppState.name,\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      theme,\n      isLoading: true,\n      ...this.getCanvasOffsets(),\n      viewModeEnabled,\n      zenModeEnabled,\n      gridSize: gridModeEnabled ? GRID_SIZE : null,\n      name,\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n\n    this.id = nanoid();\n\n    if (excalidrawRef) {\n      const readyPromise =\n        (\"current\" in excalidrawRef && excalidrawRef.current?.readyPromise) ||\n        resolvablePromise<ExcalidrawImperativeAPI>();\n\n      const api: ExcalidrawImperativeAPI = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        addFiles: this.addFiles,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory,\n        },\n        scrollToContent: this.scrollToContent,\n        getSceneElements: this.getSceneElements,\n        getAppState: () => this.state,\n        getFiles: () => this.files,\n        refresh: this.refresh,\n        importLibrary: this.importLibraryFromUrl,\n        setToastMessage: this.setToastMessage,\n        id: this.id,\n      } as const;\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n      readyPromise.resolve(api);\n    }\n\n    this.excalidrawContainerValue = {\n      container: this.excalidrawContainerRef.current,\n      id: this.id,\n    };\n\n    this.scene = new Scene();\n    this.library = new Library(this);\n    this.history = new History();\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => this.scene.getElementsIncludingDeleted(),\n      this,\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(this.history));\n    this.actionManager.registerAction(createRedoAction(this.history));\n  }\n\n  private renderCanvas() {\n    const canvasScale = window.devicePixelRatio;\n    const {\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      viewModeEnabled,\n    } = this.state;\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n    if (viewModeEnabled) {\n      return (\n        <canvas\n          className=\"excalidraw__canvas\"\n          style={{\n            width: canvasDOMWidth,\n            height: canvasDOMHeight,\n            cursor: CURSOR_TYPE.GRAB,\n          }}\n          width={canvasWidth}\n          height={canvasHeight}\n          ref={this.handleCanvasRef}\n          onContextMenu={this.handleCanvasContextMenu}\n          onPointerMove={this.handleCanvasPointerMove}\n          onPointerUp={this.removePointer}\n          onPointerCancel={this.removePointer}\n          onTouchMove={this.handleTouchMove}\n          onPointerDown={this.handleCanvasPointerDown}\n        >\n          {t(\"labels.drawingCanvas\")}\n        </canvas>\n      );\n    }\n    return (\n      <canvas\n        className=\"excalidraw__canvas\"\n        style={{\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n        }}\n        width={canvasWidth}\n        height={canvasHeight}\n        ref={this.handleCanvasRef}\n        onContextMenu={this.handleCanvasContextMenu}\n        onPointerDown={this.handleCanvasPointerDown}\n        onDoubleClick={this.handleCanvasDoubleClick}\n        onPointerMove={this.handleCanvasPointerMove}\n        onPointerUp={this.removePointer}\n        onPointerCancel={this.removePointer}\n        onTouchMove={this.handleTouchMove}\n      >\n        {t(\"labels.drawingCanvas\")}\n      </canvas>\n    );\n  }\n\n  public render() {\n    const { zenModeEnabled, viewModeEnabled } = this.state;\n\n    const {\n      onCollabButtonClick,\n      renderTopRightUI,\n      renderFooter,\n      renderCustomStats,\n    } = this.props;\n\n    return (\n      <div\n        className={clsx(\"excalidraw excalidraw-container\", {\n          \"excalidraw--view-mode\": viewModeEnabled,\n          \"excalidraw--mobile\": this.isMobile,\n        })}\n        ref={this.excalidrawContainerRef}\n        onDrop={this.handleAppOnDrop}\n        tabIndex={0}\n        onKeyDown={\n          this.props.handleKeyboardGlobally ? undefined : this.onKeyDown\n        }\n      >\n        <ExcalidrawContainerContext.Provider\n          value={this.excalidrawContainerValue}\n        >\n          <IsMobileContext.Provider value={this.isMobile}>\n            <LayerUI\n              canvas={this.canvas}\n              appState={this.state}\n              files={this.files}\n              setAppState={this.setAppState}\n              actionManager={this.actionManager}\n              elements={this.scene.getElements()}\n              onCollabButtonClick={onCollabButtonClick}\n              onLockToggle={this.toggleLock}\n              onInsertElements={(elements) =>\n                this.addElementsFromPasteOrLibrary({\n                  elements,\n                  position: \"center\",\n                  files: null,\n                })\n              }\n              zenModeEnabled={zenModeEnabled}\n              toggleZenMode={this.toggleZenMode}\n              langCode={getLanguage().code}\n              isCollaborating={this.props.isCollaborating || false}\n              renderTopRightUI={renderTopRightUI}\n              renderCustomFooter={renderFooter}\n              viewModeEnabled={viewModeEnabled}\n              showExitZenModeBtn={\n                typeof this.props?.zenModeEnabled === \"undefined\" &&\n                zenModeEnabled\n              }\n              showThemeBtn={\n                typeof this.props?.theme === \"undefined\" &&\n                this.props.UIOptions.canvasActions.theme\n              }\n              libraryReturnUrl={this.props.libraryReturnUrl}\n              UIOptions={this.props.UIOptions}\n              focusContainer={this.focusContainer}\n              library={this.library}\n              id={this.id}\n              onImageAction={this.onImageAction}\n            />\n            <div className=\"excalidraw-textEditorContainer\" />\n            <div className=\"excalidraw-contextMenuContainer\" />\n            {this.state.showStats && (\n              <Stats\n                appState={this.state}\n                setAppState={this.setAppState}\n                elements={this.scene.getElements()}\n                onClose={this.toggleStats}\n                renderCustomStats={renderCustomStats}\n              />\n            )}\n            {this.state.toastMessage !== null && (\n              <Toast\n                message={this.state.toastMessage}\n                clearToast={this.clearToast}\n              />\n            )}\n            <main>{this.renderCanvas()}</main>\n          </IsMobileContext.Provider>\n        </ExcalidrawContainerContext.Provider>\n      </div>\n    );\n  }\n\n  public focusContainer: AppClassProperties[\"focusContainer\"] = () => {\n    if (this.props.autoFocus) {\n      this.excalidrawContainerRef.current?.focus();\n    }\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.scene.getElementsIncludingDeleted();\n  };\n\n  public getSceneElements = () => {\n    return this.scene.getElements();\n  };\n\n  private syncActionResult = withBatchedUpdates(\n    (actionResult: ActionResult) => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n\n      let editingElement: AppState[\"editingElement\"] | null = null;\n      if (actionResult.elements) {\n        actionResult.elements.forEach((element) => {\n          if (\n            this.state.editingElement?.id === element.id &&\n            this.state.editingElement !== element &&\n            isNonDeletedElement(element)\n          ) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n      }\n\n      if (actionResult.files) {\n        this.files = actionResult.replaceFiles\n          ? actionResult.files\n          : { ...this.files, ...actionResult.files };\n        this.addNewImagesToImageCache();\n      }\n\n      if (actionResult.appState || editingElement) {\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n\n        let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;\n        let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;\n        let gridSize = actionResult?.appState?.gridSize || null;\n        let theme = actionResult?.appState?.theme || THEME.LIGHT;\n        let name = actionResult?.appState?.name ?? this.state.name;\n        if (typeof this.props.viewModeEnabled !== \"undefined\") {\n          viewModeEnabled = this.props.viewModeEnabled;\n        }\n\n        if (typeof this.props.zenModeEnabled !== \"undefined\") {\n          zenModeEnabled = this.props.zenModeEnabled;\n        }\n\n        if (typeof this.props.gridModeEnabled !== \"undefined\") {\n          gridSize = this.props.gridModeEnabled ? GRID_SIZE : null;\n        }\n\n        if (typeof this.props.theme !== \"undefined\") {\n          theme = this.props.theme;\n        }\n\n        if (typeof this.props.name !== \"undefined\") {\n          name = this.props.name;\n        }\n        this.setState(\n          (state) => {\n            // using Object.assign instead of spread to fool TS 4.2.2+ into\n            // regarding the resulting type as not containing undefined\n            // (which the following expression will never contain)\n            return Object.assign(actionResult.appState || {}, {\n              editingElement:\n                editingElement || actionResult.appState?.editingElement || null,\n              viewModeEnabled,\n              zenModeEnabled,\n              gridSize,\n              theme,\n              name,\n            });\n          },\n          () => {\n            if (actionResult.syncHistory) {\n              this.history.setCurrentState(\n                this.state,\n                this.scene.getElementsIncludingDeleted(),\n              );\n            }\n          },\n        );\n      }\n    },\n  );\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.setState({ isBindingEnabled: true });\n  });\n\n  private onUnload = () => {\n    this.onBlur();\n  };\n\n  private disableEvent: EventListener = (event) => {\n    event.preventDefault();\n  };\n\n  private onFontLoaded = () => {\n    this.scene.getElementsIncludingDeleted().forEach((element) => {\n      if (isTextElement(element)) {\n        invalidateShapeForElement(element);\n      }\n    });\n    this.onSceneUpdated();\n  };\n\n  private importLibraryFromUrl = async (url: string, token?: string | null) => {\n    if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {\n      const hash = new URLSearchParams(window.location.hash.slice(1));\n      hash.delete(URL_HASH_KEYS.addLibrary);\n      window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);\n    } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {\n      const query = new URLSearchParams(window.location.search);\n      query.delete(URL_QUERY_KEYS.addLibrary);\n      window.history.replaceState({}, APP_NAME, `?${query.toString()}`);\n    }\n\n    try {\n      const request = await fetch(decodeURIComponent(url));\n      const blob = await request.blob();\n      const json = JSON.parse(await blob.text());\n      if (!isValidLibrary(json)) {\n        throw new Error();\n      }\n      if (\n        token === this.id ||\n        window.confirm(\n          t(\"alerts.confirmAddLibrary\", { numShapes: json.library.length }),\n        )\n      ) {\n        await this.library.importLibrary(blob);\n        // hack to rerender the library items after import\n        if (this.state.isLibraryOpen) {\n          this.setState({ isLibraryOpen: false });\n        }\n        this.setState({ isLibraryOpen: true });\n      }\n    } catch (error: any) {\n      window.alert(t(\"alerts.errorLoadingLibrary\"));\n      console.error(error);\n    } finally {\n      this.focusContainer();\n    }\n  };\n\n  private resetHistory = () => {\n    this.history.clear();\n  };\n\n  /**\n   * Resets scene & history.\n   * ! Do not use to clear scene user action !\n   */\n  private resetScene = withBatchedUpdates(\n    (opts?: { resetLoadingState: boolean }) => {\n      this.scene.replaceAllElements([]);\n      this.setState((state) => ({\n        ...getDefaultAppState(),\n        isLoading: opts?.resetLoadingState ? false : state.isLoading,\n        theme: this.state.theme,\n      }));\n      this.resetHistory();\n    },\n  );\n\n  private initializeScene = async () => {\n    if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n      (window as any).launchQueue.setConsumer(\n        async (launchParams: { files: any[] }) => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob: Blob = await fileHandle.getFile();\n          blob.handle = fileHandle;\n          loadFromBlob(\n            blob,\n            this.state,\n            this.scene.getElementsIncludingDeleted(),\n          )\n            .then((scene) => {\n              this.syncActionResult({\n                ...scene,\n                appState: {\n                  ...(scene.appState || this.state),\n                  isLoading: false,\n                },\n                commitToHistory: true,\n              });\n            })\n            .catch((error) => {\n              this.setState({ isLoading: false, errorMessage: error.message });\n            });\n        },\n      );\n    }\n\n    if (!this.state.isLoading) {\n      this.setState({ isLoading: true });\n    }\n    let initialData = null;\n    try {\n      initialData = (await this.props.initialData) || null;\n      if (initialData?.libraryItems) {\n        this.libraryItemsFromStorage = initialData.libraryItems;\n      }\n    } catch (error: any) {\n      console.error(error);\n      initialData = {\n        appState: {\n          errorMessage:\n            error.message ||\n            \"Encountered an error during importing or restoring scene data\",\n        },\n      };\n    }\n\n    const scene = restore(initialData, null, null);\n\n    scene.appState = {\n      ...scene.appState,\n      elementType:\n        scene.appState.elementType === \"image\"\n          ? \"selection\"\n          : scene.appState.elementType,\n      isLoading: false,\n    };\n    if (initialData?.scrollToContent) {\n      scene.appState = {\n        ...scene.appState,\n        ...calculateScrollCenter(\n          scene.elements,\n          {\n            ...scene.appState,\n            width: this.state.width,\n            height: this.state.height,\n            offsetTop: this.state.offsetTop,\n            offsetLeft: this.state.offsetLeft,\n          },\n          null,\n        ),\n      };\n    }\n\n    this.resetHistory();\n    this.syncActionResult({\n      ...scene,\n      commitToHistory: true,\n    });\n\n    const libraryUrl =\n      // current\n      new URLSearchParams(window.location.hash.slice(1)).get(\n        URL_HASH_KEYS.addLibrary,\n      ) ||\n      // legacy, kept for compat reasons\n      new URLSearchParams(window.location.search).get(\n        URL_QUERY_KEYS.addLibrary,\n      );\n\n    if (libraryUrl) {\n      await this.importLibraryFromUrl(libraryUrl);\n    }\n  };\n\n  public async componentDidMount() {\n    this.excalidrawContainerValue.container =\n      this.excalidrawContainerRef.current;\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n        history: {\n          configurable: true,\n          value: this.history,\n        },\n      });\n    }\n\n    this.scene.addCallback(this.onSceneUpdated);\n    this.addEventListeners();\n\n    if (this.excalidrawContainerRef.current) {\n      this.focusContainer();\n    }\n\n    if (\"ResizeObserver\" in window && this.excalidrawContainerRef?.current) {\n      this.resizeObserver = new ResizeObserver(() => {\n        // compute isMobile state\n        // ---------------------------------------------------------------------\n        const { width, height } =\n          this.excalidrawContainerRef.current!.getBoundingClientRect();\n        this.isMobile =\n          width < MQ_MAX_WIDTH_PORTRAIT ||\n          (height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE);\n        // refresh offsets\n        // ---------------------------------------------------------------------\n        this.updateDOMRect();\n      });\n      this.resizeObserver?.observe(this.excalidrawContainerRef.current);\n    } else if (window.matchMedia) {\n      const mediaQuery = window.matchMedia(\n        `(max-width: ${MQ_MAX_WIDTH_PORTRAIT}px), (max-height: ${MQ_MAX_HEIGHT_LANDSCAPE}px) and (max-width: ${MQ_MAX_WIDTH_LANDSCAPE}px)`,\n      );\n      const handler = () => (this.isMobile = mediaQuery.matches);\n      mediaQuery.addListener(handler);\n      this.detachIsMobileMqHandler = () => mediaQuery.removeListener(handler);\n    }\n\n    const searchParams = new URLSearchParams(window.location.search.slice(1));\n\n    if (searchParams.has(\"web-share-target\")) {\n      // Obtain a file that was shared via the Web Share Target API.\n      this.restoreFileFromShare();\n    } else {\n      this.updateDOMRect(this.initializeScene);\n    }\n  }\n\n  public componentWillUnmount() {\n    this.files = {};\n    this.imageCache.clear();\n    this.resizeObserver?.disconnect();\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n  }\n\n  private onResize = withBatchedUpdates(() => {\n    this.scene\n      .getElementsIncludingDeleted()\n      .forEach((element) => invalidateShapeForElement(element));\n    this.setState({});\n  });\n\n  private removeEventListeners() {\n    document.removeEventListener(EVENT.POINTER_UP, this.removePointer);\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n    this.nearestScrollableContainer?.removeEventListener(\n      EVENT.SCROLL,\n      this.onScroll,\n    );\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    window.removeEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.removeEventListener(EVENT.DROP, this.disableEvent, false);\n\n    document.removeEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n\n    this.detachIsMobileMqHandler?.();\n  }\n\n  private addEventListeners() {\n    this.removeEventListeners();\n    document.addEventListener(EVENT.POINTER_UP, this.removePointer); // #3553\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    if (this.props.handleKeyboardGlobally) {\n      document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    }\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, { passive: true });\n    document.addEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n    );\n    // rerender text elements on font load to fix #637 && #1553\n    document.fonts?.addEventListener?.(\"loadingdone\", this.onFontLoaded);\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n    if (this.state.viewModeEnabled) {\n      return;\n    }\n\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n    if (this.props.detectScroll) {\n      this.nearestScrollableContainer = getNearestScrollableContainer(\n        this.excalidrawContainerRef.current!,\n      );\n      this.nearestScrollableContainer.addEventListener(\n        EVENT.SCROLL,\n        this.onScroll,\n      );\n    }\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    window.addEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.addEventListener(EVENT.DROP, this.disableEvent, false);\n  }\n\n  componentDidUpdate(prevProps: AppProps, prevState: AppState) {\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {\n      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });\n    }\n\n    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {\n      this.addEventListeners();\n      this.deselectElements();\n    }\n\n    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {\n      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });\n    }\n\n    if (prevProps.theme !== this.props.theme && this.props.theme) {\n      this.setState({ theme: this.props.theme });\n    }\n\n    if (prevProps.gridModeEnabled !== this.props.gridModeEnabled) {\n      this.setState({\n        gridSize: this.props.gridModeEnabled ? GRID_SIZE : null,\n      });\n    }\n\n    if (this.props.name && prevProps.name !== this.props.name) {\n      this.setState({\n        name: this.props.name,\n      });\n    }\n\n    this.excalidrawContainerRef.current?.classList.toggle(\n      \"theme--dark\",\n      this.state.theme === \"dark\",\n    );\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.selectedElementIds[this.state.editingLinearElement.elementId]\n    ) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        this.actionManager.executeAction(actionFinalize);\n      });\n    }\n    const { multiElement } = prevState;\n    if (\n      prevState.elementType !== this.state.elementType &&\n      multiElement != null &&\n      isBindingEnabled(this.state) &&\n      isBindingElement(multiElement)\n    ) {\n      maybeBindLinearElement(\n        multiElement,\n        this.state,\n        this.scene,\n        tupleToCoors(\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            multiElement,\n            -1,\n          ),\n        ),\n      );\n    }\n\n    const cursorButton: {\n      [id: string]: string | undefined;\n    } = {};\n    const pointerViewportCoords: SceneState[\"remotePointerViewportCoords\"] = {};\n    const remoteSelectedElementIds: SceneState[\"remoteSelectedElementIds\"] = {};\n    const pointerUsernames: { [id: string]: string } = {};\n    const pointerUserStates: { [id: string]: string } = {};\n    this.state.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n          remoteSelectedElementIds[id].push(socketId);\n        }\n      }\n      if (!user.pointer) {\n        return;\n      }\n      if (user.username) {\n        pointerUsernames[socketId] = user.username;\n      }\n      if (user.userState) {\n        pointerUserStates[socketId] = user.userState;\n      }\n      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(\n        {\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y,\n        },\n        this.state,\n      );\n      cursorButton[socketId] = user.button;\n    });\n    const renderingElements = this.scene.getElements().filter((element) => {\n      if (isImageElement(element)) {\n        if (\n          // not placed on canvas yet (but in elements array)\n          this.state.pendingImageElement &&\n          element.id === this.state.pendingImageElement.id\n        ) {\n          return false;\n        }\n      }\n      // don't render text element that's being currently edited (it's\n      // rendered on remote only)\n      return (\n        !this.state.editingElement ||\n        this.state.editingElement.type !== \"text\" ||\n        element.id !== this.state.editingElement.id\n      );\n    });\n    const { atLeastOneVisibleElement, scrollBars } = renderScene(\n      renderingElements,\n      this.state,\n      this.state.selectionElement,\n      window.devicePixelRatio,\n      this.rc!,\n      this.canvas!,\n      {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords,\n        remotePointerButton: cursorButton,\n        remoteSelectedElementIds,\n        remotePointerUsernames: pointerUsernames,\n        remotePointerUserStates: pointerUserStates,\n        shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n        theme: this.state.theme,\n        imageCache: this.imageCache,\n      },\n      {\n        renderOptimizations: true,\n        renderScrollbars: !this.isMobile,\n      },\n    );\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside =\n      // hide when editing text\n      this.state.editingElement?.type === \"text\"\n        ? false\n        : !atLeastOneVisibleElement && renderingElements.length > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside });\n    }\n\n    this.history.record(this.state, this.scene.getElementsIncludingDeleted());\n\n    this.scheduleImageRefresh();\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      this.props.onChange?.(\n        this.scene.getElementsIncludingDeleted(),\n        this.state,\n        this.files,\n      );\n    }\n  }\n\n  private onScroll = debounce(() => {\n    const { offsetTop, offsetLeft } = this.getCanvasOffsets();\n    this.setState((state) => {\n      if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {\n        return null;\n      }\n      return { offsetTop, offsetLeft };\n    });\n  }, SCROLL_TIMEOUT);\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.cutAll();\n    event.preventDefault();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    event.preventDefault();\n  });\n\n  private cutAll = () => {\n    this.copyAll();\n    this.actionManager.executeAction(actionDeleteSelected);\n  };\n\n  private copyAll = () => {\n    copyToClipboard(this.scene.getElements(), this.state, this.files);\n  };\n\n  private static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  private onTapStart = (event: TouchEvent) => {\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(\n        App.resetTapTwice,\n        TAP_TWICE_TIMEOUT,\n      );\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const [touch] = event.touches;\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n    event.preventDefault();\n    if (event.touches.length === 2) {\n      this.setState({\n        selectedElementIds: {},\n      });\n    }\n  };\n\n  private onTapEnd = (event: TouchEvent) => {\n    if (event.touches.length > 0) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: this.state.previousSelectedElementIds,\n      });\n    }\n  };\n\n  private pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent | null) => {\n      // #686\n      const target = document.activeElement;\n      const isExcalidrawActive =\n        this.excalidrawContainerRef.current?.contains(target);\n      if (!isExcalidrawActive) {\n        return;\n      }\n\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n      if (\n        // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n        // thus these checks don't make sense\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n\n      // must be called in the same frame (thus before any awaits) as the paste\n      // event else some browsers (FF...) will clear the clipboardData\n      // (something something security)\n      let file = event?.clipboardData?.files[0];\n\n      const data = await parseClipboard(event);\n\n      if (!file && data.text) {\n        const string = data.text.trim();\n        if (string.startsWith(\"<svg\") && string.endsWith(\"</svg>\")) {\n          // ignore SVG validation/normalization which will be done during image\n          // initialization\n          file = SVGStringToFile(string);\n        }\n      }\n\n      if (isSupportedImageFile(file)) {\n        const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n          { clientX: cursorX, clientY: cursorY },\n          this.state,\n        );\n\n        const imageElement = this.createImageElement({ sceneX, sceneY });\n        this.insertImageElement(imageElement, file);\n        this.initializeImageDimensions(imageElement);\n        this.setState({ selectedElementIds: { [imageElement.id]: true } });\n\n        return;\n      }\n\n      if (this.props.onPaste) {\n        try {\n          if ((await this.props.onPaste(data, event)) === false) {\n            return;\n          }\n        } catch (error: any) {\n          console.error(error);\n        }\n      }\n      if (data.errorMessage) {\n        this.setState({ errorMessage: data.errorMessage });\n      } else if (data.spreadsheet) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true,\n          },\n        });\n      } else if (data.elements) {\n        this.addElementsFromPasteOrLibrary({\n          elements: data.elements,\n          files: data.files || null,\n          position: \"cursor\",\n        });\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n      this.selectShapeTool(\"selection\");\n      event?.preventDefault();\n    },\n  );\n\n  private addElementsFromPasteOrLibrary = (opts: {\n    elements: readonly ExcalidrawElement[];\n    files: BinaryFiles | null;\n    position: { clientX: number; clientY: number } | \"cursor\" | \"center\";\n  }) => {\n    const elements = restoreElements(opts.elements, null);\n    const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const clientX =\n      typeof opts.position === \"object\"\n        ? opts.position.clientX\n        : opts.position === \"cursor\"\n        ? cursorX\n        : this.state.width / 2 + this.state.offsetLeft;\n    const clientY =\n      typeof opts.position === \"object\"\n        ? opts.position.clientY\n        : opts.position === \"cursor\"\n        ? cursorY\n        : this.state.height / 2 + this.state.offsetTop;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n    const groupIdMap = new Map();\n\n    const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n\n    const oldIdToDuplicatedId = new Map();\n    const newElements = elements.map((element) => {\n      const newElement = duplicateElement(\n        this.state.editingGroupId,\n        groupIdMap,\n        element,\n        {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY,\n        },\n      );\n      oldIdToDuplicatedId.set(element.id, newElement.id);\n      return newElement;\n    });\n    const nextElements = [\n      ...this.scene.getElementsIncludingDeleted(),\n      ...newElements,\n    ];\n    fixBindingsAfterDuplication(nextElements, elements, oldIdToDuplicatedId);\n\n    if (opts.files) {\n      this.files = { ...this.files, ...opts.files };\n    }\n\n    this.scene.replaceAllElements(nextElements);\n    this.history.resumeRecording();\n    this.setState(\n      selectGroupsForSelectedElements(\n        {\n          ...this.state,\n          isLibraryOpen: false,\n          selectedElementIds: newElements.reduce((map, element) => {\n            map[element.id] = true;\n            return map;\n          }, {} as any),\n          selectedGroupIds: {},\n        },\n        this.scene.getElements(),\n      ),\n      () => {\n        if (opts.files) {\n          this.addNewImagesToImageCache();\n        }\n      },\n    );\n    this.selectShapeTool(\"selection\");\n  };\n\n  private addTextFromPaste(text: any) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n    );\n\n    const element = newTextElement({\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    });\n\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({ selectedElementIds: { [element.id]: true } });\n    this.history.resumeRecording();\n  }\n\n  // Collaboration\n\n  setAppState = (obj: any) => {\n    this.setState(obj);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement> | PointerEvent) => {\n    // remove touch handler for context menu on touch devices\n    if (event.pointerType === \"touch\" && touchTimeout) {\n      clearTimeout(touchTimeout);\n      touchTimeout = 0;\n      invalidateContextMenu = false;\n    }\n\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  toggleLock = () => {\n    this.setState((prevState) => {\n      return {\n        elementLocked: !prevState.elementLocked,\n        elementType: prevState.elementLocked\n          ? \"selection\"\n          : prevState.elementType,\n      };\n    });\n  };\n\n  toggleZenMode = () => {\n    this.actionManager.executeAction(actionToggleZenMode);\n  };\n\n  toggleStats = () => {\n    if (!this.state.showStats) {\n      trackEvent(\"dialog\", \"stats\");\n    }\n    this.actionManager.executeAction(actionToggleStats);\n  };\n\n  scrollToContent = (\n    target:\n      | ExcalidrawElement\n      | readonly ExcalidrawElement[] = this.scene.getElements(),\n  ) => {\n    this.setState({\n      ...calculateScrollCenter(\n        Array.isArray(target) ? target : [target],\n        this.state,\n        this.canvas,\n      ),\n    });\n  };\n\n  clearToast = () => {\n    this.setState({ toastMessage: null });\n  };\n\n  setToastMessage = (toastMessage: string) => {\n    this.setState({ toastMessage });\n  };\n\n  restoreFileFromShare = async () => {\n    try {\n      const webShareTargetCache = await caches.open(\"web-share-target\");\n\n      const file = await webShareTargetCache.match(\"shared-file\");\n      if (file) {\n        const blob = await file.blob();\n        this.loadFileToCanvas(blob);\n        await webShareTargetCache.delete(\"shared-file\");\n        window.history.replaceState(null, APP_NAME, window.location.pathname);\n      }\n    } catch (error: any) {\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  /** adds supplied files to existing files in the appState */\n  public addFiles: ExcalidrawImperativeAPI[\"addFiles\"] = withBatchedUpdates(\n    (files) => {\n      const filesMap = files.reduce((acc, fileData) => {\n        acc.set(fileData.id, fileData);\n        return acc;\n      }, new Map<FileId, BinaryFileData>());\n\n      this.files = { ...this.files, ...Object.fromEntries(filesMap) };\n\n      // bump versions for elements that reference added files so that\n      // we/host apps can detect the change, and invalidate the image & shape\n      // cache\n      this.scene.getElements().forEach((element) => {\n        if (\n          isInitializedImageElement(element) &&\n          filesMap.has(element.fileId)\n        ) {\n          this.imageCache.delete(element.fileId);\n          invalidateShapeForElement(element);\n          bumpVersion(element);\n        }\n      });\n      this.scene.informMutation();\n\n      this.addNewImagesToImageCache();\n    },\n  );\n\n  public updateScene = withBatchedUpdates(\n    <K extends keyof AppState>(sceneData: {\n      elements?: SceneData[\"elements\"];\n      appState?: Pick<AppState, K> | null;\n      collaborators?: SceneData[\"collaborators\"];\n      commitToHistory?: SceneData[\"commitToHistory\"];\n    }) => {\n      if (sceneData.commitToHistory) {\n        this.history.resumeRecording();\n      }\n\n      if (sceneData.appState) {\n        this.setState(sceneData.appState);\n      }\n\n      if (sceneData.elements) {\n        this.scene.replaceAllElements(sceneData.elements);\n      }\n\n      if (sceneData.collaborators) {\n        this.setState({ collaborators: sceneData.collaborators });\n      }\n    },\n  );\n\n  private onSceneUpdated = () => {\n    this.setState({});\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      cursorX = event.clientX;\n      cursorY = event.clientY;\n    },\n  );\n\n  // Input handling\n\n  private onKeyDown = withBatchedUpdates(\n    (event: React.KeyboardEvent | KeyboardEvent) => {\n      // normalize `event.key` when CapsLock is pressed #2372\n      if (\n        \"Proxy\" in window &&\n        ((!event.shiftKey && /^[A-Z]$/.test(event.key)) ||\n          (event.shiftKey && /^[a-z]$/.test(event.key)))\n      ) {\n        event = new Proxy(event, {\n          get(ev: any, prop) {\n            const value = ev[prop];\n            if (typeof value === \"function\") {\n              // fix for Proxies hijacking `this`\n              return value.bind(ev);\n            }\n            return prop === \"key\"\n              ? // CapsLock inverts capitalization based on ShiftKey, so invert\n                // it back\n                event.shiftKey\n                ? ev.key.toUpperCase()\n                : ev.key.toLowerCase()\n              : value;\n          },\n        });\n      }\n\n      if (\n        (isWritableElement(event.target) && event.key !== KEYS.ESCAPE) ||\n        // case: using arrows to move between buttons\n        (isArrowKey(event.key) && isInputLike(event.target))\n      ) {\n        return;\n      }\n\n      if (event.key === KEYS.QUESTION_MARK) {\n        this.setState({\n          showHelpDialog: true,\n        });\n      }\n\n      if (this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n\n      if (this.state.viewModeEnabled) {\n        return;\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {\n        this.setState({ isBindingEnabled: false });\n      }\n\n      if (event.code === CODES.ZERO) {\n        this.setState({ isLibraryOpen: !this.state.isLibraryOpen });\n      }\n\n      if (isArrowKey(event.key)) {\n        const step =\n          (this.state.gridSize &&\n            (event.shiftKey\n              ? ELEMENT_TRANSLATE_AMOUNT\n              : this.state.gridSize)) ||\n          (event.shiftKey\n            ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n            : ELEMENT_TRANSLATE_AMOUNT);\n\n        const selectedElements = this.scene\n          .getElements()\n          .filter((element) => this.state.selectedElementIds[element.id]);\n\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (event.key === KEYS.ARROW_LEFT) {\n          offsetX = -step;\n        } else if (event.key === KEYS.ARROW_RIGHT) {\n          offsetX = step;\n        } else if (event.key === KEYS.ARROW_UP) {\n          offsetY = -step;\n        } else if (event.key === KEYS.ARROW_DOWN) {\n          offsetY = step;\n        }\n\n        selectedElements.forEach((element) => {\n          mutateElement(element, {\n            x: element.x + offsetX,\n            y: element.y + offsetY,\n          });\n\n          updateBoundElements(element, {\n            simultaneouslyUpdated: selectedElements,\n          });\n        });\n\n        this.maybeSuggestBindingForAll(selectedElements);\n\n        event.preventDefault();\n      } else if (event.key === KEYS.ENTER) {\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0])\n        ) {\n          if (\n            !this.state.editingLinearElement ||\n            this.state.editingLinearElement.elementId !== selectedElements[0].id\n          ) {\n            this.history.resumeRecording();\n            this.setState({\n              editingLinearElement: new LinearElementEditor(\n                selectedElements[0],\n                this.scene,\n              ),\n            });\n          }\n        } else if (\n          selectedElements.length === 1 &&\n          !isLinearElement(selectedElements[0])\n        ) {\n          const selectedElement = selectedElements[0];\n          this.startTextEditing({\n            sceneX: selectedElement.x + selectedElement.width / 2,\n            sceneY: selectedElement.y + selectedElement.height / 2,\n          });\n          event.preventDefault();\n          return;\n        }\n      } else if (\n        !event.ctrlKey &&\n        !event.altKey &&\n        !event.metaKey &&\n        this.state.draggingElement === null\n      ) {\n        const shape = findShapeByKey(event.key);\n        if (shape) {\n          this.selectShapeTool(shape);\n        } else if (event.key === KEYS.Q) {\n          this.toggleLock();\n        }\n      }\n      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        setCursor(this.canvas, CURSOR_TYPE.GRABBING);\n      }\n\n      if (event.key === KEYS.G || event.key === KEYS.S) {\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n        if (\n          this.state.elementType === \"selection\" &&\n          !selectedElements.length\n        ) {\n          return;\n        }\n\n        if (\n          event.key === KEYS.G &&\n          (hasBackground(this.state.elementType) ||\n            selectedElements.some((element) => hasBackground(element.type)))\n        ) {\n          this.setState({ openPopup: \"backgroundColorPicker\" });\n        }\n        if (event.key === KEYS.S) {\n          this.setState({ openPopup: \"strokeColorPicker\" });\n        }\n      }\n    },\n  );\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.viewModeEnabled) {\n        setCursor(this.canvas, CURSOR_TYPE.GRAB);\n      } else if (this.state.elementType === \"selection\") {\n        resetCursor(this.canvas);\n      } else {\n        setCursorForShape(this.canvas, this.state.elementType);\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n      }\n      isHoldingSpace = false;\n    }\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n      this.setState({ isBindingEnabled: true });\n    }\n    if (isArrowKey(event.key)) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n      isBindingEnabled(this.state)\n        ? bindOrUnbindSelectedElements(selectedElements)\n        : unbindLinearElements(selectedElements);\n      this.setState({ suggestedBindings: [] });\n    }\n  });\n\n  private selectShapeTool(elementType: AppState[\"elementType\"]) {\n    if (!isHoldingSpace) {\n      setCursorForShape(this.canvas, elementType);\n    }\n    if (isToolIcon(document.activeElement)) {\n      this.focusContainer();\n    }\n    if (!isLinearElementType(elementType)) {\n      this.setState({ suggestedBindings: [] });\n    }\n    if (elementType === \"image\") {\n      this.onImageAction();\n    }\n    if (elementType !== \"selection\") {\n      this.setState({\n        elementType,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    } else {\n      this.setState({ elementType });\n    }\n  }\n\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      selectedElementIds: {},\n    });\n    gesture.initialScale = this.state.zoom.value;\n  });\n\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // onGestureChange only has zoom factor but not the center.\n    // If we're on iPad or iPhone, then we recognize multi-touch and will\n    // zoom in at the right location on the touchMove handler already.\n    // On Macbook, we don't have those events so will zoom in at the\n    // current location instead.\n    if (gesture.pointers.size === 2) {\n      return;\n    }\n\n    const initialScale = gesture.initialScale;\n    if (initialScale) {\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * event.scale),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          { x: cursorX, y: cursorY },\n        ),\n      }));\n    }\n  });\n\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      previousSelectedElementIds: {},\n      selectedElementIds: this.state.previousSelectedElementIds,\n    });\n    gesture.initialScale = null;\n  });\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      isExistingElement = false,\n    }: {\n      isExistingElement?: boolean;\n    },\n  ) {\n    const updateElement = (text: string, isDeleted = false) => {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id && isTextElement(_element)) {\n            return updateTextElement(_element, {\n              text,\n              isDeleted,\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      appState: this.state,\n      canvas: this.canvas,\n      getViewportCoords: (x, y) => {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          {\n            sceneX: x,\n            sceneY: y,\n          },\n          this.state,\n        );\n        return [\n          viewportX - this.state.offsetLeft,\n          viewportY - this.state.offsetTop,\n        ];\n      },\n      onChange: withBatchedUpdates((text) => {\n        updateElement(text);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates(({ text, viaKeyboard }) => {\n        const isDeleted = !text.trim();\n        updateElement(text, isDeleted);\n        // select the created text element only if submitting via keyboard\n        // (when submitting via click it should act as signal to deselect)\n        if (!isDeleted && viaKeyboard) {\n          this.setState((prevState) => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [element.id]: true,\n            },\n          }));\n        }\n        if (isDeleted) {\n          fixBindingsAfterDeletion(this.scene.getElements(), [element]);\n        }\n        if (!isDeleted || isExistingElement) {\n          this.history.resumeRecording();\n        }\n\n        this.setState({\n          draggingElement: null,\n          editingElement: null,\n        });\n        if (this.state.elementLocked) {\n          setCursorForShape(this.canvas, this.state.elementType);\n        }\n\n        this.focusContainer();\n      }),\n      element,\n      excalidrawContainer: this.excalidrawContainerRef.current,\n    });\n    // deselect all other elements when inserting text\n    this.deselectElements();\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text);\n  }\n\n  private deselectElements() {\n    this.setState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      editingGroupId: null,\n    });\n  }\n\n  private getTextElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawTextElement> | null {\n    const element = this.getElementAtPosition(x, y);\n\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n\n  private getElementAtPosition(\n    x: number,\n    y: number,\n    opts?: {\n      /** if true, returns the first selected element (with highest z-index)\n        of all hit elements */\n      preferSelected?: boolean;\n    },\n  ): NonDeleted<ExcalidrawElement> | null {\n    const allHitElements = this.getElementsAtPosition(x, y);\n    if (allHitElements.length > 1) {\n      if (opts?.preferSelected) {\n        for (let index = allHitElements.length - 1; index > -1; index--) {\n          if (this.state.selectedElementIds[allHitElements[index].id]) {\n            return allHitElements[index];\n          }\n        }\n      }\n      const elementWithHighestZIndex =\n        allHitElements[allHitElements.length - 1];\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return isHittingElementBoundingBoxWithoutHittingElement(\n        elementWithHighestZIndex,\n        this.state,\n        x,\n        y,\n      )\n        ? allHitElements[allHitElements.length - 2]\n        : elementWithHighestZIndex;\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n    return null;\n  }\n\n  private getElementsAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement>[] {\n    return getElementsAtPosition(this.scene.getElements(), (element) =>\n      hitTest(element, this.state, x, y),\n    );\n  }\n\n  private startTextEditing = ({\n    sceneX,\n    sceneY,\n    insertAtParentCenter = true,\n  }: {\n    /** X position to insert text at */\n    sceneX: number;\n    /** Y position to insert text at */\n    sceneY: number;\n    /** whether to attempt to insert at element center if applicable */\n    insertAtParentCenter?: boolean;\n  }) => {\n    const existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n\n    const parentCenterPosition =\n      insertAtParentCenter &&\n      this.getTextWysiwygSnappedToCenterPosition(\n        sceneX,\n        sceneY,\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n    const element = existingTextElement\n      ? existingTextElement\n      : newTextElement({\n          x: parentCenterPosition\n            ? parentCenterPosition.elementCenterX\n            : sceneX,\n          y: parentCenterPosition\n            ? parentCenterPosition.elementCenterY\n            : sceneY,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          strokeStyle: this.state.currentItemStrokeStyle,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n          strokeSharpness: this.state.currentItemStrokeSharpness,\n          text: \"\",\n          fontSize: this.state.currentItemFontSize,\n          fontFamily: this.state.currentItemFontFamily,\n          textAlign: parentCenterPosition\n            ? \"center\"\n            : this.state.currentItemTextAlign,\n          verticalAlign: parentCenterPosition\n            ? \"middle\"\n            : DEFAULT_VERTICAL_ALIGN,\n        });\n\n    this.setState({ editingElement: element });\n\n    if (existingTextElement) {\n      // if text element is no longer centered to a container, reset\n      // verticalAlign to default because it's currently internal-only\n      if (!parentCenterPosition || element.textAlign !== \"center\") {\n        mutateElement(element, { verticalAlign: DEFAULT_VERTICAL_ALIGN });\n      }\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n\n      // case: creating new text not centered to parent elemenent  offset Y\n      // so that the text is centered to cursor position\n      if (!parentCenterPosition) {\n        mutateElement(element, {\n          y: element.y - element.baseline / 2,\n        });\n      }\n    }\n\n    this.setState({\n      editingElement: element,\n    });\n\n    this.handleTextWysiwyg(element, {\n      isExistingElement: !!existingTextElement,\n    });\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    // text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n    // we should only be able to double click when mode is selection\n    if (this.state.elementType !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      if (\n        !this.state.editingLinearElement ||\n        this.state.editingLinearElement.elementId !== selectedElements[0].id\n      ) {\n        this.history.resumeRecording();\n        this.setState({\n          editingLinearElement: new LinearElementEditor(\n            selectedElements[0],\n            this.scene,\n          ),\n        });\n      }\n      return;\n    }\n\n    resetCursor(this.canvas);\n\n    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    const selectedGroupIds = getSelectedGroupIds(this.state);\n\n    if (selectedGroupIds.length > 0) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      const selectedGroupId =\n        hitElement &&\n        getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n      if (selectedGroupId) {\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              editingGroupId: selectedGroupId,\n              selectedElementIds: { [hitElement!.id]: true },\n              selectedGroupIds: {},\n            },\n            this.scene.getElements(),\n          ),\n        );\n        return;\n      }\n    }\n\n    resetCursor(this.canvas);\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {\n      this.startTextEditing({\n        sceneX,\n        sceneY,\n        insertAtParentCenter: !event.altKey,\n      });\n    }\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    const initialScale = gesture.initialScale;\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance;\n\n      this.setState(({ zoom, scrollX, scrollY, offsetLeft, offsetTop }) => ({\n        scrollX: scrollX + deltaX / zoom.value,\n        scrollY: scrollY + deltaY / zoom.value,\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * scaleFactor),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          center,\n        ),\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter =\n        gesture.initialDistance =\n        gesture.initialScale =\n          null;\n    }\n\n    if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n      return;\n    }\n\n    const isPointerOverScrollBars = isOverScrollBars(\n      currentScrollBars,\n      event.clientX - this.state.offsetLeft,\n      event.clientY - this.state.offsetTop,\n    );\n    const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor(this.canvas);\n      } else {\n        setCursorForShape(this.canvas, this.state.elementType);\n      }\n    }\n\n    const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n    const { x: scenePointerX, y: scenePointerY } = scenePointer;\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.editingLinearElement.isDragging\n    ) {\n      const editingLinearElement = LinearElementEditor.handlePointerMove(\n        event,\n        scenePointerX,\n        scenePointerY,\n        this.state.editingLinearElement,\n        this.state.gridSize,\n      );\n      if (editingLinearElement !== this.state.editingLinearElement) {\n        this.setState({ editingLinearElement });\n      }\n      if (editingLinearElement.lastUncommittedPoint != null) {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      } else {\n        this.setState({ suggestedBindings: [] });\n      }\n    }\n\n    if (isBindingElementType(this.state.elementType)) {\n      // Hovering with a selected tool or creating new linear element via click\n      // and point\n      const { draggingElement } = this.state;\n      if (isBindingElement(draggingElement)) {\n        this.maybeSuggestBindingForLinearElementAtCursor(\n          draggingElement,\n          \"end\",\n          scenePointer,\n          this.state.startBoundElement,\n        );\n      } else {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      }\n    }\n\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.canvas, this.state.elementType);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        // threshold, add a point\n        if (\n          distance2d(\n            scenePointerX - rx,\n            scenePointerY - ry,\n            lastPoint[0],\n            lastPoint[1],\n          ) >= LINE_CONFIRM_THRESHOLD\n        ) {\n          mutateElement(multiElement, {\n            points: [...points, [scenePointerX - rx, scenePointerY - ry]],\n          });\n        } else {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n          // in this branch, we're inside the commit zone, and no uncommitted\n          // point exists. Thus do nothing (don't add/remove points).\n        }\n      } else if (\n        points.length > 2 &&\n        lastCommittedPoint &&\n        distance2d(\n          scenePointerX - rx,\n          scenePointerY - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        mutateElement(multiElement, {\n          points: points.slice(0, -1),\n        });\n      } else {\n        if (isPathALoop(points, this.state.zoom.value)) {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        }\n        // update last uncommitted point\n        mutateElement(multiElement, {\n          points: [\n            ...points.slice(0, -1),\n            [scenePointerX - rx, scenePointerY - ry],\n          ],\n        });\n      }\n\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.elementType !== \"selection\" &&\n        this.state.elementType !== \"text\")\n    ) {\n      return;\n    }\n\n    const elements = this.scene.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    if (\n      selectedElements.length === 1 &&\n      !isOverScrollBar &&\n      !this.state.editingLinearElement\n    ) {\n      const elementWithTransformHandleType = getElementWithTransformHandleType(\n        elements,\n        this.state,\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (\n        elementWithTransformHandleType &&\n        elementWithTransformHandleType.transformHandleType\n      ) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement(elementWithTransformHandleType),\n        );\n        return;\n      }\n    } else if (selectedElements.length > 1 && !isOverScrollBar) {\n      const transformHandleType = getTransformHandleTypeFromCoords(\n        getCommonBounds(selectedElements),\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (transformHandleType) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement({\n            transformHandleType,\n          }),\n        );\n        return;\n      }\n    }\n\n    const hitElement = this.getElementAtPosition(\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (this.state.elementType === \"text\") {\n      setCursor(\n        this.canvas,\n        isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR,\n      );\n    } else if (this.state.viewModeEnabled) {\n      setCursor(this.canvas, CURSOR_TYPE.GRAB);\n    } else if (isOverScrollBar) {\n      setCursor(this.canvas, CURSOR_TYPE.AUTO);\n    } else if (\n      // if using cmd/ctrl, we're not dragging\n      !event[KEYS.CTRL_OR_CMD] &&\n      (hitElement ||\n        this.isHittingCommonBoundingBoxOfSelectedElements(\n          scenePointer,\n          selectedElements,\n        ))\n    ) {\n      setCursor(this.canvas, CURSOR_TYPE.MOVE);\n    } else {\n      setCursor(this.canvas, CURSOR_TYPE.AUTO);\n    }\n  };\n\n  // set touch moving for mobile context menu\n  private handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {\n    invalidateContextMenu = true;\n  };\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    // remove any active selection when we start to interact with canvas\n    // (mainly, we care about removing selection outside the component which\n    //  would prevent our copy handling otherwise)\n    const selection = document.getSelection();\n    if (selection?.anchorNode) {\n      selection.removeAllRanges();\n    }\n\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n    this.maybeCleanupAfterMissingPointerUp(event);\n\n    if (isPanning) {\n      return;\n    }\n\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    this.updateGestureOnPointerDown(event);\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // State for the duration of a pointer interaction, which starts with a\n    // pointerDown event, ends with a pointerUp event (or another pointerDown)\n    const pointerDownState = this.initialPointerDownState(event);\n\n    if (this.handleDraggingScrollBar(event, pointerDownState)) {\n      return;\n    }\n\n    this.clearSelectionIfNotUsingSelection();\n    this.updateBindingEnabledOnPointerMove(event);\n\n    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n      return;\n    }\n\n    if (this.state.elementType === \"text\") {\n      this.handleTextOnPointerDown(event, pointerDownState);\n      return;\n    } else if (\n      this.state.elementType === \"arrow\" ||\n      this.state.elementType === \"line\"\n    ) {\n      this.handleLinearElementOnPointerDown(\n        event,\n        this.state.elementType,\n        pointerDownState,\n      );\n    } else if (this.state.elementType === \"image\") {\n      // reset image preview on pointerdown\n      setCursor(this.canvas, CURSOR_TYPE.CROSSHAIR);\n\n      if (!this.state.pendingImageElement) {\n        return;\n      }\n\n      this.setState({\n        draggingElement: this.state.pendingImageElement,\n        editingElement: this.state.pendingImageElement,\n        pendingImageElement: null,\n        multiElement: null,\n      });\n\n      const { x, y } = viewportCoordsToSceneCoords(event, this.state);\n      mutateElement(this.state.pendingImageElement, {\n        x,\n        y,\n      });\n    } else if (this.state.elementType === \"freedraw\") {\n      this.handleFreeDrawElementOnPointerDown(\n        event,\n        this.state.elementType,\n        pointerDownState,\n      );\n    } else {\n      this.createGenericElementOnPointerDown(\n        this.state.elementType,\n        pointerDownState,\n      );\n    }\n\n    const onPointerMove =\n      this.onPointerMoveFromPointerDownHandler(pointerDownState);\n\n    const onPointerUp =\n      this.onPointerUpFromPointerDownHandler(pointerDownState);\n\n    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n\n    lastPointerUp = onPointerUp;\n\n    if (!this.state.viewModeEnabled) {\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n      window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n      window.addEventListener(EVENT.KEYUP, onKeyUp);\n      pointerDownState.eventListeners.onMove = onPointerMove;\n      pointerDownState.eventListeners.onUp = onPointerUp;\n      pointerDownState.eventListeners.onKeyUp = onKeyUp;\n      pointerDownState.eventListeners.onKeyDown = onKeyDown;\n    }\n  };\n\n  private maybeOpenContextMenuAfterPointerDownOnTouchDevices = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void => {\n    // deal with opening context menu on touch devices\n    if (event.pointerType === \"touch\") {\n      invalidateContextMenu = false;\n\n      if (touchTimeout) {\n        // If there's already a touchTimeout, this means that there's another\n        // touch down and we are doing another touch, so we shouldn't open the\n        // context menu.\n        invalidateContextMenu = true;\n      } else {\n        // open the context menu with the first touch's clientX and clientY\n        // if the touch is not moving\n        touchTimeout = window.setTimeout(() => {\n          touchTimeout = 0;\n          if (!invalidateContextMenu) {\n            this.handleCanvasContextMenu(event);\n          }\n        }, TOUCH_CTX_MENU_TIMEOUT);\n      }\n    }\n  };\n\n  private maybeCleanupAfterMissingPointerUp(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  }\n\n  // Returns whether the event is a panning\n  private handleCanvasPanUsingWheelOrSpaceDrag = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): boolean => {\n    if (\n      !(\n        gesture.pointers.size === 0 &&\n        (event.button === POINTER_BUTTON.WHEEL ||\n          (event.button === POINTER_BUTTON.MAIN && isHoldingSpace) ||\n          this.state.viewModeEnabled)\n      )\n    ) {\n      return false;\n    }\n    isPanning = true;\n\n    let nextPastePrevented = false;\n    const isLinux = /Linux/.test(window.navigator.platform);\n\n    setCursor(this.canvas, CURSOR_TYPE.GRABBING);\n    let { clientX: lastX, clientY: lastY } = event;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const deltaX = lastX - event.clientX;\n      const deltaY = lastY - event.clientY;\n      lastX = event.clientX;\n      lastY = event.clientY;\n\n      /*\n       * Prevent paste event if we move while middle clicking on Linux.\n       * See issue #1383.\n       */\n      if (\n        isLinux &&\n        !nextPastePrevented &&\n        (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)\n      ) {\n        nextPastePrevented = true;\n\n        /* Prevent the next paste event */\n        const preventNextPaste = (event: ClipboardEvent) => {\n          document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n          event.stopPropagation();\n        };\n\n        /*\n         * Reenable next paste in case of disabled middle click paste for\n         * any reason:\n         * - rigth click paste\n         * - empty clipboard\n         */\n        const enableNextPaste = () => {\n          setTimeout(() => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n          }, 100);\n        };\n\n        document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n        window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n      }\n\n      this.setState({\n        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,\n        scrollY: this.state.scrollY - deltaY / this.state.zoom.value,\n      });\n    });\n    const teardown = withBatchedUpdates(\n      (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          if (this.state.viewModeEnabled) {\n            setCursor(this.canvas, CURSOR_TYPE.GRAB);\n          } else {\n            setCursorForShape(this.canvas, this.state.elementType);\n          }\n        }\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n      }),\n    );\n    window.addEventListener(EVENT.BLUR, teardown);\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.POINTER_UP, teardown);\n    return true;\n  };\n\n  private updateGestureOnPointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n  }\n\n  private initialPointerDownState(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): PointerDownState {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n\n    return {\n      origin,\n      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],\n      originInGrid: tupleToCoors(\n        getGridPoint(origin.x, origin.y, this.state.gridSize),\n      ),\n      scrollbars: isOverScrollBars(\n        currentScrollBars,\n        event.clientX - this.state.offsetLeft,\n        event.clientY - this.state.offsetTop,\n      ),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin },\n      originalElements: this.scene.getElements().reduce((acc, element) => {\n        acc.set(element.id, deepCopyElement(element));\n        return acc;\n      }, new Map() as PointerDownState[\"originalElements\"]),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: { x: 0, y: 0 },\n        arrowDirection: \"origin\",\n        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 },\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements:\n          this.isHittingCommonBoundingBoxOfSelectedElements(\n            origin,\n            selectedElements,\n          ),\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null,\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null,\n      },\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  private handleDraggingScrollBar(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (\n      !(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)\n    ) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.canvas, this.state.elementType);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\",\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  private clearSelectionIfNotUsingSelection = (): void => {\n    if (this.state.elementType !== \"selection\") {\n      this.setState({\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    }\n  };\n\n  /**\n   * @returns whether the pointer event has been completely handled\n   */\n  private handleSelectionOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean => {\n    if (this.state.elementType === \"selection\") {\n      const elements = this.scene.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n      if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType =\n          getElementWithTransformHandleType(\n            elements,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n            this.state.zoom,\n            event.pointerType,\n          );\n        if (elementWithTransformHandleType != null) {\n          this.setState({\n            resizingElement: elementWithTransformHandleType.element,\n          });\n          pointerDownState.resize.handleType =\n            elementWithTransformHandleType.transformHandleType;\n        }\n      } else if (selectedElements.length > 1) {\n        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(\n          getCommonBounds(selectedElements),\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n      }\n      if (pointerDownState.resize.handleType) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement({\n            transformHandleType: pointerDownState.resize.handleType,\n          }),\n        );\n        pointerDownState.resize.isResizing = true;\n        pointerDownState.resize.offset = tupleToCoors(\n          getResizeOffsetXY(\n            pointerDownState.resize.handleType,\n            selectedElements,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0]) &&\n          selectedElements[0].points.length === 2\n        ) {\n          pointerDownState.resize.arrowDirection = getResizeArrowDirection(\n            pointerDownState.resize.handleType,\n            selectedElements[0],\n          );\n        }\n      } else {\n        if (this.state.editingLinearElement) {\n          const ret = LinearElementEditor.handlePointerDown(\n            event,\n            this.state,\n            (appState) => this.setState(appState),\n            this.history,\n            pointerDownState.origin,\n          );\n          if (ret.hitElement) {\n            pointerDownState.hit.element = ret.hitElement;\n          }\n          if (ret.didAddPoint) {\n            return true;\n          }\n        }\n\n        // hitElement may already be set above, so check first\n        pointerDownState.hit.element =\n          pointerDownState.hit.element ??\n          this.getElementAtPosition(\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          );\n\n        // For overlapped elements one position may hit\n        // multiple elements\n        pointerDownState.hit.allHitElements = this.getElementsAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n        );\n\n        const hitElement = pointerDownState.hit.element;\n        const someHitElementIsSelected =\n          pointerDownState.hit.allHitElements.some((element) =>\n            this.isASelectedElement(element),\n          );\n        if (\n          (hitElement === null || !someHitElementIsSelected) &&\n          !event.shiftKey &&\n          !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n        ) {\n          this.clearSelection(hitElement);\n        }\n\n        // If we click on something\n        if (hitElement != null) {\n          // on CMD/CTRL, drill down to hit element regardless of groups etc.\n          if (event[KEYS.CTRL_OR_CMD]) {\n            if (!this.state.selectedElementIds[hitElement.id]) {\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n            this.setState((prevState) => ({\n              ...editGroupForSelectedElement(prevState, hitElement),\n              previousSelectedElementIds: this.state.selectedElementIds,\n            }));\n            // mark as not completely handled so as to allow dragging etc.\n            return false;\n          }\n\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            // if we are currently editing a group, exiting editing mode and deselect the group.\n            if (\n              this.state.editingGroupId &&\n              !isElementInGroup(hitElement, this.state.editingGroupId)\n            ) {\n              this.setState({\n                selectedElementIds: {},\n                selectedGroupIds: {},\n                editingGroupId: null,\n              });\n            }\n\n            // Add hit element to selection. At this point if we're not holding\n            // SHIFT the previously selected element(s) were deselected above\n            // (make sure you use setState updater to use latest state)\n            if (\n              !someHitElementIsSelected &&\n              !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n            ) {\n              this.setState((prevState) => {\n                return selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      ...prevState.selectedElementIds,\n                      [hitElement.id]: true,\n                    },\n                  },\n                  this.scene.getElements(),\n                );\n              });\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n          }\n        }\n\n        this.setState({\n          previousSelectedElementIds: this.state.selectedElementIds,\n        });\n      }\n    }\n    return false;\n  };\n\n  private isASelectedElement(hitElement: ExcalidrawElement | null): boolean {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  private isHittingCommonBoundingBoxOfSelectedElements(\n    point: Readonly<{ x: number; y: number }>,\n    selectedElements: readonly ExcalidrawElement[],\n  ): boolean {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return (\n      point.x > x1 - threshold &&\n      point.x < x2 + threshold &&\n      point.y > y1 - threshold &&\n      point.y < y2 + threshold\n    );\n  }\n\n  private handleTextOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): void => {\n    // if we're currently still editing text, clicking outside\n    // should only finalize it, not create another (irrespective\n    // of state.elementLocked)\n    if (this.state.editingElement?.type === \"text\") {\n      return;\n    }\n\n    this.startTextEditing({\n      sceneX: pointerDownState.origin.x,\n      sceneY: pointerDownState.origin.y,\n      insertAtParentCenter: !event.altKey,\n    });\n\n    resetCursor(this.canvas);\n    if (!this.state.elementLocked) {\n      this.setState({\n        elementType: \"selection\",\n      });\n    }\n  };\n\n  private handleFreeDrawElementOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    elementType: ExcalidrawFreeDrawElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ) => {\n    // Begin a mark capture. This does not have to update state yet.\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      null,\n    );\n\n    const element = newFreeDrawElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n      simulatePressure: event.pressure === 0.5,\n    });\n\n    this.setState((prevState) => ({\n      selectedElementIds: {\n        ...prevState.selectedElementIds,\n        [element.id]: false,\n      },\n    }));\n\n    const pressures = element.simulatePressure\n      ? element.pressures\n      : [...element.pressures, event.pressure];\n\n    mutateElement(element, {\n      points: [[0, 0]],\n      pressures,\n    });\n\n    const boundElement = getHoveredElementForBinding(\n      pointerDownState.origin,\n      this.scene,\n    );\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({\n      draggingElement: element,\n      editingElement: element,\n      startBoundElement: boundElement,\n      suggestedBindings: [],\n    });\n  };\n\n  private createImageElement = ({\n    sceneX,\n    sceneY,\n  }: {\n    sceneX: number;\n    sceneY: number;\n  }) => {\n    const [gridX, gridY] = getGridPoint(sceneX, sceneY, this.state.gridSize);\n\n    const element = newImageElement({\n      type: \"image\",\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n    });\n\n    return element;\n  };\n\n  private handleLinearElementOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    elementType: ExcalidrawLinearElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n\n      // finalize if completing a loop\n      if (\n        multiElement.type === \"line\" &&\n        isPathALoop(multiElement.points, this.state.zoom.value)\n      ) {\n        mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n      // clicking inside commit zone  finalize arrow\n      if (\n        multiElement.points.length > 1 &&\n        lastCommittedPoint &&\n        distance2d(\n          pointerDownState.origin.x - rx,\n          pointerDownState.origin.y - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [multiElement.id]: true,\n        },\n      }));\n      // clicking outside commit zone  update reference for last committed\n      // point\n      mutateElement(multiElement, {\n        lastCommittedPoint: multiElement.points[multiElement.points.length - 1],\n      });\n      setCursor(this.canvas, CURSOR_TYPE.POINTER);\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        this.state.gridSize,\n      );\n\n      /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n      If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n      an arrow, we want it to be null for both. Otherwise, we want it to use the\n      values from appState. */\n\n      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;\n      const [startArrowhead, endArrowhead] =\n        elementType === \"arrow\"\n          ? [currentItemStartArrowhead, currentItemEndArrowhead]\n          : [null, null];\n\n      const element = newLinearElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n        startArrowhead,\n        endArrowhead,\n      });\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [element.id]: false,\n        },\n      }));\n      mutateElement(element, {\n        points: [...element.points, [0, 0]],\n      });\n      const boundElement = getHoveredElementForBinding(\n        pointerDownState.origin,\n        this.scene,\n      );\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        draggingElement: element,\n        editingElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: [],\n      });\n    }\n  };\n\n  private createGenericElementOnPointerDown = (\n    elementType: ExcalidrawGenericElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.state.gridSize,\n    );\n    const element = newElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n    });\n\n    if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n        draggingElement: element,\n      });\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        multiElement: null,\n        draggingElement: element,\n        editingElement: element,\n      });\n    }\n  };\n\n  private onKeyDownFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onKeyUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onPointerMoveFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((event: PointerEvent) => {\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(\n          getDragOffsetXY(\n            getSelectedElements(this.scene.getElements(), this.state),\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n      }\n\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        (this.state.elementType === \"arrow\" ||\n          this.state.elementType === \"line\")\n      ) {\n        if (\n          distance2d(\n            pointerCoords.x,\n            pointerCoords.y,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ) < DRAGGING_THRESHOLD\n        ) {\n          return;\n        }\n      }\n\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n\n      if (this.state.editingLinearElement) {\n        const didDrag = LinearElementEditor.handlePointDragging(\n          this.state,\n          (appState) => this.setState(appState),\n          pointerCoords.x,\n          pointerCoords.y,\n          (element, startOrEnd) => {\n            this.maybeSuggestBindingForLinearElementAtCursor(\n              element,\n              startOrEnd,\n              pointerCoords,\n            );\n          },\n        );\n\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(\n        (element) => this.isASelectedElement(element),\n      );\n\n      if (\n        hasHitASelectedElement ||\n        pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n      ) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n        // prevent dragging even if we're no longer holding cmd/ctrl otherwise\n        // it would have weird results (stuff jumping all over the screen)\n        if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl) {\n          const [dragX, dragY] = getGridPoint(\n            pointerCoords.x - pointerDownState.drag.offset.x,\n            pointerCoords.y - pointerDownState.drag.offset.y,\n            this.state.gridSize,\n          );\n\n          const [dragDistanceX, dragDistanceY] = [\n            Math.abs(pointerCoords.x - pointerDownState.origin.x),\n            Math.abs(pointerCoords.y - pointerDownState.origin.y),\n          ];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n\n          dragSelectedElements(\n            pointerDownState,\n            selectedElements,\n            dragX,\n            dragY,\n            this.scene,\n            lockDirection,\n            dragDistanceX,\n            dragDistanceY,\n          );\n          this.maybeSuggestBindingForAll(selectedElements);\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n            for (const element of this.scene.getElementsIncludingDeleted()) {\n              if (\n                this.state.selectedElementIds[element.id] ||\n                // case: the state.selectedElementIds might not have been\n                // updated yet by the time this mousemove event is fired\n                (element.id === hitElement?.id &&\n                  pointerDownState.hit.wasAddedToSelection)\n              ) {\n                const duplicatedElement = duplicateElement(\n                  this.state.editingGroupId,\n                  groupIdMap,\n                  element,\n                );\n                const [originDragX, originDragY] = getGridPoint(\n                  pointerDownState.origin.x - pointerDownState.drag.offset.x,\n                  pointerDownState.origin.y - pointerDownState.drag.offset.y,\n                  this.state.gridSize,\n                );\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY),\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            fixBindingsAfterDuplication(\n              nextSceneElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n              \"duplicatesServeAsOld\",\n            );\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      if (draggingElement.type === \"freedraw\") {\n        const points = draggingElement.points;\n        const dx = pointerCoords.x - draggingElement.x;\n        const dy = pointerCoords.y - draggingElement.y;\n\n        const pressures = draggingElement.simulatePressure\n          ? draggingElement.pressures\n          : [...draggingElement.pressures, event.pressure];\n\n        mutateElement(draggingElement, {\n          points: [...points, [dx, dy]],\n          pressures,\n        });\n      } else if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        const points = draggingElement.points;\n        let dx = gridX - draggingElement.x;\n        let dy = gridY - draggingElement.y;\n\n        if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {\n          ({ width: dx, height: dy } = getPerfectElementSize(\n            this.state.elementType,\n            dx,\n            dy,\n          ));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, { points: [...points, [dx, dy]] });\n        } else if (points.length > 1) {\n          mutateElement(draggingElement, {\n            points: [...points.slice(0, -1), [dx, dy]],\n          });\n        }\n\n        if (isBindingElement(draggingElement)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingForLinearElementAtCursor(\n            draggingElement,\n            \"end\",\n            pointerCoords,\n            this.state.startBoundElement,\n          );\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n\n      if (this.state.elementType === \"selection\") {\n        const elements = this.scene.getElements();\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {\n            this.setState((prevState) =>\n              selectGroupsForSelectedElements(\n                {\n                  ...prevState,\n                  selectedElementIds: {\n                    [pointerDownState.hit.element!.id]: true,\n                  },\n                },\n                this.scene.getElements(),\n              ),\n            );\n          } else {\n            this.setState({\n              selectedElementIds: {},\n              selectedGroupIds: {},\n              editingGroupId: null,\n            });\n          }\n        }\n        const elementsWithinSelection = getElementsWithinSelection(\n          elements,\n          draggingElement,\n        );\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                ...elementsWithinSelection.reduce((map, element) => {\n                  map[element.id] = true;\n                  return map;\n                }, {} as any),\n                ...(pointerDownState.hit.element\n                  ? {\n                      // if using ctrl/cmd, select the hitElement only if we\n                      // haven't box-selected anything else\n                      [pointerDownState.hit.element.id]:\n                        !elementsWithinSelection.length,\n                    }\n                  : null),\n              },\n            },\n            this.scene.getElements(),\n          ),\n        );\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  private handlePointerMoveOverScrollbars(\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.setState({\n        scrollX: this.state.scrollX - dx / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.setState({\n        scrollY: this.state.scrollY - dy / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n\n  private onPointerUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((childEvent: PointerEvent) => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n        isResizing,\n        isRotating,\n      } = this.state;\n\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement:\n          multiElement || isTextElement(this.state.editingElement)\n            ? this.state.editingElement\n            : null,\n      });\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        const editingLinearElement = LinearElementEditor.handlePointerUp(\n          childEvent,\n          this.state.editingLinearElement,\n          this.state,\n        );\n        if (editingLinearElement !== this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement,\n            suggestedBindings: [],\n          });\n        }\n      }\n\n      lastPointerUp = null;\n\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        pointerDownState.eventListeners.onMove!,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerDownState.eventListeners.onUp!,\n      );\n      window.removeEventListener(\n        EVENT.KEYDOWN,\n        pointerDownState.eventListeners.onKeyDown!,\n      );\n      window.removeEventListener(\n        EVENT.KEYUP,\n        pointerDownState.eventListeners.onKeyUp!,\n      );\n\n      if (this.state.pendingImageElement) {\n        this.setState({ pendingImageElement: null });\n      }\n\n      if (draggingElement?.type === \"freedraw\") {\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        const points = draggingElement.points;\n        let dx = pointerCoords.x - draggingElement.x;\n        let dy = pointerCoords.y - draggingElement.y;\n\n        // Allows dots to avoid being flagged as infinitely small\n        if (dx === points[0][0] && dy === points[0][1]) {\n          dy += 0.0001;\n          dx += 0.0001;\n        }\n\n        const pressures = draggingElement.simulatePressure\n          ? []\n          : [...draggingElement.pressures, childEvent.pressure];\n\n        mutateElement(draggingElement, {\n          points: [...points, [dx, dy]],\n          pressures,\n          lastCommittedPoint: [dx, dy],\n        });\n\n        this.actionManager.executeAction(actionFinalize);\n\n        return;\n      }\n      if (isImageElement(draggingElement)) {\n        const imageElement = draggingElement;\n        try {\n          this.initializeImageDimensions(imageElement);\n          this.setState(\n            { selectedElementIds: { [imageElement.id]: true } },\n            () => {\n              this.actionManager.executeAction(actionFinalize);\n            },\n          );\n        } catch (error: any) {\n          console.error(error);\n          this.scene.replaceAllElements(\n            this.scene\n              .getElementsIncludingDeleted()\n              .filter((el) => el.id !== imageElement.id),\n          );\n          this.actionManager.executeAction(actionFinalize);\n        }\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement!.points.length > 1) {\n          this.history.resumeRecording();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        if (\n          !pointerDownState.drag.hasOccurred &&\n          draggingElement &&\n          !multiElement\n        ) {\n          mutateElement(draggingElement, {\n            points: [\n              ...draggingElement.points,\n              [\n                pointerCoords.x - draggingElement.x,\n                pointerCoords.y - draggingElement.y,\n              ],\n            ],\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement,\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (\n            isBindingEnabled(this.state) &&\n            isBindingElement(draggingElement)\n          ) {\n            maybeBindLinearElement(\n              draggingElement,\n              this.state,\n              this.scene,\n              pointerCoords,\n            );\n          }\n          this.setState({ suggestedBindings: [], startBoundElement: null });\n          if (!elementLocked) {\n            resetCursor(this.canvas);\n            this.setState((prevState) => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          } else {\n            this.setState((prevState) => ({\n              draggingElement: null,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        elementType !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(\n          this.scene.getElementsIncludingDeleted().slice(0, -1),\n        );\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      if (draggingElement) {\n        mutateElement(\n          draggingElement,\n          getNormalizedDimensions(draggingElement),\n        );\n      }\n\n      if (resizingElement) {\n        this.history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(\n          this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n        );\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (\n        hitElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !pointerDownState.hit.wasAddedToSelection\n      ) {\n        if (childEvent.shiftKey) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              // We want to unselect all groups hitElement is part of\n              // as well as all elements that are part of the groups\n              // hitElement is part of\n              const idsOfSelectedElementsThatAreInGroups = hitElement.groupIds\n                .flatMap((groupId) =>\n                  getElementsInGroup(this.scene.getElements(), groupId),\n                )\n                .map((element) => ({ [element.id]: false }))\n                .reduce((prevId, acc) => ({ ...prevId, ...acc }), {});\n\n              this.setState((_prevState) => ({\n                selectedGroupIds: {\n                  ..._prevState.selectedElementIds,\n                  ...hitElement.groupIds\n                    .map((gId) => ({ [gId]: false }))\n                    .reduce((prev, acc) => ({ ...prev, ...acc }), {}),\n                },\n                selectedElementIds: {\n                  ..._prevState.selectedElementIds,\n                  ...idsOfSelectedElementsThatAreInGroups,\n                },\n              }));\n            } else {\n              // remove element from selection while\n              // keeping prev elements selected\n              this.setState((prevState) =>\n                selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      ...prevState.selectedElementIds,\n                      [hitElement!.id]: false,\n                    },\n                  },\n                  this.scene.getElements(),\n                ),\n              );\n            }\n          } else {\n            // add element to selection while\n            // keeping prev elements selected\n            this.setState((_prevState) => ({\n              selectedElementIds: {\n                ..._prevState.selectedElementIds,\n                [hitElement!.id]: true,\n              },\n            }));\n          }\n        } else {\n          this.setState((prevState) => ({\n            ...selectGroupsForSelectedElements(\n              {\n                ...prevState,\n                selectedElementIds: { [hitElement.id]: true },\n              },\n              this.scene.getElements(),\n            ),\n          }));\n        }\n      }\n\n      if (\n        !this.state.editingLinearElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !this.state.isResizing &&\n        ((hitElement &&\n          isHittingElementBoundingBoxWithoutHittingElement(\n            hitElement,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          )) ||\n          (!hitElement &&\n            pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements))\n      ) {\n        // Deselect selected elements\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n\n        return;\n      }\n\n      if (!elementLocked && elementType !== \"freedraw\" && draggingElement) {\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true,\n          },\n        }));\n      }\n\n      if (\n        elementType !== \"selection\" ||\n        isSomeElementSelected(this.scene.getElements(), this.state)\n      ) {\n        this.history.resumeRecording();\n      }\n\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state)\n          ? bindOrUnbindSelectedElements\n          : unbindLinearElements)(\n          getSelectedElements(this.scene.getElements(), this.state),\n        );\n      }\n\n      if (!elementLocked && elementType !== \"freedraw\") {\n        resetCursor(this.canvas);\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n        });\n      }\n    });\n  }\n\n  private initializeImage = async ({\n    imageFile,\n    imageElement: _imageElement,\n    showCursorImagePreview = false,\n  }: {\n    imageFile: File;\n    imageElement: ExcalidrawImageElement;\n    showCursorImagePreview?: boolean;\n  }) => {\n    // at this point this should be guaranteed image file, but we do this check\n    // to satisfy TS down the line\n    if (!isSupportedImageFile(imageFile)) {\n      throw new Error(t(\"errors.unsupportedFileType\"));\n    }\n    const mimeType = imageFile.type;\n\n    setCursor(this.canvas, \"wait\");\n\n    if (mimeType === MIME_TYPES.svg) {\n      try {\n        imageFile = SVGStringToFile(\n          await normalizeSVG(await imageFile.text()),\n          imageFile.name,\n        );\n      } catch (error: any) {\n        console.warn(error);\n        throw new Error(t(\"errors.svgImageInsertError\"));\n      }\n    }\n\n    // generate image id (by default the file digest) before any\n    // resizing/compression takes place to keep it more portable\n    const fileId = await ((this.props.generateIdForFile?.(\n      imageFile,\n    ) as Promise<FileId>) || generateIdFromFile(imageFile));\n\n    if (!fileId) {\n      console.warn(\n        \"Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one.\",\n      );\n      throw new Error(t(\"errors.imageInsertError\"));\n    }\n\n    const existingFileData = this.files[fileId];\n    if (!existingFileData?.dataURL) {\n      try {\n        imageFile = await resizeImageFile(\n          imageFile,\n          DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,\n        );\n      } catch (error: any) {\n        console.error(\"error trying to resing image file on insertion\", error);\n      }\n\n      if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {\n        throw new Error(\n          t(\"errors.fileTooBig\", {\n            maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`,\n          }),\n        );\n      }\n    }\n\n    if (showCursorImagePreview) {\n      const dataURL = this.files[fileId]?.dataURL;\n      // optimization so that we don't unnecessarily resize the original\n      // full-size file for cursor preview\n      // (it's much faster to convert the resized dataURL to File)\n      const resizedFile = dataURL && dataURLToFile(dataURL);\n\n      this.setImagePreviewCursor(resizedFile || imageFile);\n    }\n\n    const dataURL =\n      this.files[fileId]?.dataURL || (await getDataURL(imageFile));\n\n    const imageElement = mutateElement(\n      _imageElement,\n      {\n        fileId,\n      },\n      false,\n    ) as NonDeleted<InitializedExcalidrawImageElement>;\n\n    return new Promise<NonDeleted<InitializedExcalidrawImageElement>>(\n      async (resolve, reject) => {\n        try {\n          this.files = {\n            ...this.files,\n            [fileId]: {\n              mimeType,\n              id: fileId,\n              dataURL,\n              created: Date.now(),\n            },\n          };\n          const cachedImageData = this.imageCache.get(fileId);\n          if (!cachedImageData) {\n            this.addNewImagesToImageCache();\n            await this.updateImageCache([imageElement]);\n          }\n          if (cachedImageData?.image instanceof Promise) {\n            await cachedImageData.image;\n          }\n          if (\n            this.state.pendingImageElement?.id !== imageElement.id &&\n            this.state.draggingElement?.id !== imageElement.id\n          ) {\n            this.initializeImageDimensions(imageElement, true);\n          }\n          resolve(imageElement);\n        } catch (error: any) {\n          console.error(error);\n          reject(new Error(t(\"errors.imageInsertError\")));\n        } finally {\n          if (!showCursorImagePreview) {\n            resetCursor(this.canvas);\n          }\n        }\n      },\n    );\n  };\n\n  /**\n   * inserts image into elements array and rerenders\n   */\n  private insertImageElement = async (\n    imageElement: ExcalidrawImageElement,\n    imageFile: File,\n    showCursorImagePreview?: boolean,\n  ) => {\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      imageElement,\n    ]);\n\n    try {\n      await this.initializeImage({\n        imageFile,\n        imageElement,\n        showCursorImagePreview,\n      });\n    } catch (error: any) {\n      mutateElement(imageElement, {\n        isDeleted: true,\n      });\n      this.actionManager.executeAction(actionFinalize);\n      this.setState({\n        errorMessage: error.message || t(\"errors.imageInsertError\"),\n      });\n    }\n  };\n\n  private setImagePreviewCursor = async (imageFile: File) => {\n    // mustn't be larger than 128 px\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Basic_User_Interface/Using_URL_values_for_the_cursor_property\n    const cursorImageSizePx = 96;\n\n    const imagePreview = await resizeImageFile(imageFile, cursorImageSizePx);\n\n    let previewDataURL = await getDataURL(imagePreview);\n\n    // SVG cannot be resized via `resizeImageFile` so we resize by rendering to\n    // a small canvas\n    if (imageFile.type === MIME_TYPES.svg) {\n      const img = await loadHTMLImageElement(previewDataURL);\n\n      let height = Math.min(img.height, cursorImageSizePx);\n      let width = height * (img.width / img.height);\n\n      if (width > cursorImageSizePx) {\n        width = cursorImageSizePx;\n        height = width * (img.height / img.width);\n      }\n\n      const canvas = document.createElement(\"canvas\");\n      canvas.height = height;\n      canvas.width = width;\n      const context = canvas.getContext(\"2d\")!;\n\n      context.drawImage(img, 0, 0, width, height);\n\n      previewDataURL = canvas.toDataURL(MIME_TYPES.svg) as DataURL;\n    }\n\n    if (this.state.pendingImageElement) {\n      setCursor(this.canvas, `url(${previewDataURL}) 4 4, auto`);\n    }\n  };\n\n  private onImageAction = async (\n    { insertOnCanvasDirectly } = { insertOnCanvasDirectly: false },\n  ) => {\n    try {\n      const clientX = this.state.width / 2 + this.state.offsetLeft;\n      const clientY = this.state.height / 2 + this.state.offsetTop;\n\n      const { x, y } = viewportCoordsToSceneCoords(\n        { clientX, clientY },\n        this.state,\n      );\n\n      const imageFile = await fileOpen({\n        description: \"Image\",\n        extensions: [\"jpg\", \"png\", \"svg\", \"gif\"],\n      });\n\n      const imageElement = this.createImageElement({\n        sceneX: x,\n        sceneY: y,\n      });\n\n      if (insertOnCanvasDirectly) {\n        this.insertImageElement(imageElement, imageFile);\n        this.initializeImageDimensions(imageElement);\n        this.setState(\n          {\n            selectedElementIds: { [imageElement.id]: true },\n          },\n          () => {\n            this.actionManager.executeAction(actionFinalize);\n          },\n        );\n      } else {\n        this.setState(\n          {\n            pendingImageElement: imageElement,\n          },\n          () => {\n            this.insertImageElement(\n              imageElement,\n              imageFile,\n              /* showCursorImagePreview */ true,\n            );\n          },\n        );\n      }\n    } catch (error: any) {\n      if (error.name !== \"AbortError\") {\n        console.error(error);\n      }\n      this.setState(\n        {\n          pendingImageElement: null,\n          editingElement: null,\n          elementType: \"selection\",\n        },\n        () => {\n          this.actionManager.executeAction(actionFinalize);\n        },\n      );\n    }\n  };\n\n  private initializeImageDimensions = (\n    imageElement: ExcalidrawImageElement,\n    forceNaturalSize = false,\n  ) => {\n    const image =\n      isInitializedImageElement(imageElement) &&\n      this.imageCache.get(imageElement.fileId)?.image;\n\n    if (!image || image instanceof Promise) {\n      if (\n        imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value &&\n        imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value\n      ) {\n        const placeholderSize = 100 / this.state.zoom.value;\n        mutateElement(imageElement, {\n          x: imageElement.x - placeholderSize / 2,\n          y: imageElement.y - placeholderSize / 2,\n          width: placeholderSize,\n          height: placeholderSize,\n        });\n      }\n\n      return;\n    }\n\n    if (\n      forceNaturalSize ||\n      // if user-created bounding box is below threshold, assume the\n      // intention was to click instead of drag, and use the image's\n      // intrinsic size\n      (imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value &&\n        imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value)\n    ) {\n      const minHeight = Math.max(this.state.height - 120, 160);\n      // max 65% of canvas height, clamped to <300px, vh - 120px>\n      const maxHeight = Math.min(\n        minHeight,\n        Math.floor(this.state.height * 0.5) / this.state.zoom.value,\n      );\n\n      const height = Math.min(image.naturalHeight, maxHeight);\n      const width = height * (image.naturalWidth / image.naturalHeight);\n\n      // add current imageElement width/height to account for previous centering\n      // of the placholder image\n      const x = imageElement.x + imageElement.width / 2 - width / 2;\n      const y = imageElement.y + imageElement.height / 2 - height / 2;\n\n      mutateElement(imageElement, { x, y, width, height });\n    }\n  };\n\n  /** updates image cache, refreshing updated elements and/or setting status\n      to error for images that fail during <img> element creation */\n  private updateImageCache = async (\n    elements: readonly InitializedExcalidrawImageElement[],\n    files = this.files,\n  ) => {\n    const { updatedFiles, erroredFiles } = await _updateImageCache({\n      imageCache: this.imageCache,\n      fileIds: elements.map((element) => element.fileId),\n      files,\n    });\n    if (updatedFiles.size || erroredFiles.size) {\n      for (const element of elements) {\n        if (updatedFiles.has(element.fileId)) {\n          invalidateShapeForElement(element);\n        }\n      }\n    }\n    if (erroredFiles.size) {\n      this.scene.replaceAllElements(\n        this.scene.getElementsIncludingDeleted().map((element) => {\n          if (\n            isInitializedImageElement(element) &&\n            erroredFiles.has(element.fileId)\n          ) {\n            return newElementWith(element, {\n              status: \"error\",\n            });\n          }\n          return element;\n        }),\n      );\n    }\n\n    return { updatedFiles, erroredFiles };\n  };\n\n  /** adds new images to imageCache and re-renders if needed */\n  private addNewImagesToImageCache = async (\n    imageElements: InitializedExcalidrawImageElement[] = getInitializedImageElements(\n      this.scene.getElements(),\n    ),\n    files: BinaryFiles = this.files,\n  ) => {\n    const uncachedImageElements = imageElements.filter(\n      (element) => !element.isDeleted && !this.imageCache.has(element.fileId),\n    );\n\n    if (uncachedImageElements.length) {\n      const { updatedFiles } = await this.updateImageCache(\n        uncachedImageElements,\n        files,\n      );\n      if (updatedFiles.size) {\n        this.scene.informMutation();\n      }\n    }\n  };\n\n  /** generally you should use `addNewImagesToImageCache()` directly if you need\n   *  to render new images. This is just a failsafe  */\n  private scheduleImageRefresh = throttle(() => {\n    this.addNewImagesToImageCache();\n  }, IMAGE_RENDER_TIMEOUT);\n\n  private updateBindingEnabledOnPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n    if (this.state.isBindingEnabled !== shouldEnableBinding) {\n      this.setState({ isBindingEnabled: shouldEnableBinding });\n    }\n  };\n\n  private maybeSuggestBindingAtCursor = (pointerCoords: {\n    x: number;\n    y: number;\n  }): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null ? [hoveredBindableElement] : [],\n    });\n  };\n\n  private maybeSuggestBindingForLinearElementAtCursor = (\n    linearElement: NonDeleted<ExcalidrawLinearElement>,\n    startOrEnd: \"start\" | \"end\",\n    pointerCoords: {\n      x: number;\n      y: number;\n    },\n    // During line creation the start binding hasn't been written yet\n    // into `linearElement`\n    oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n  ): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null &&\n        !isLinearElementSimpleAndAlreadyBound(\n          linearElement,\n          oppositeBindingBoundElement?.id,\n          hoveredBindableElement,\n        )\n          ? [hoveredBindableElement]\n          : [],\n    });\n  };\n\n  private maybeSuggestBindingForAll(\n    selectedElements: NonDeleted<ExcalidrawElement>[],\n  ): void {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({ suggestedBindings });\n  }\n\n  private clearSelection(hitElement: ExcalidrawElement | null): void {\n    this.setState((prevState) => ({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId:\n        prevState.editingGroupId &&\n        hitElement != null &&\n        isElementInGroup(hitElement, prevState.editingGroupId)\n          ? prevState.editingGroupId\n          : null,\n    }));\n    this.setState({\n      selectedElementIds: {},\n      previousSelectedElementIds: this.state.selectedElementIds,\n    });\n  }\n\n  private handleCanvasRef = (canvas: HTMLCanvasElement) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.canvas = canvas;\n      this.rc = rough.canvas(this.canvas);\n\n      this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n        passive: false,\n      });\n      this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    } else {\n      this.canvas?.removeEventListener(EVENT.WHEEL, this.handleWheel);\n      this.canvas?.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas?.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    }\n  };\n\n  private handleAppOnDrop = async (event: React.DragEvent<HTMLDivElement>) => {\n    try {\n      const file = event.dataTransfer.files[0];\n\n      if (isSupportedImageFile(file)) {\n        // first attempt to decode scene from the image if it's embedded\n        // ---------------------------------------------------------------------\n\n        if (file?.type === MIME_TYPES.png || file?.type === MIME_TYPES.svg) {\n          try {\n            if (nativeFileSystemSupported) {\n              try {\n                // This will only work as of Chrome 86,\n                // but can be safely ignored on older releases.\n                const item = event.dataTransfer.items[0];\n                (file as any).handle = await (\n                  item as any\n                ).getAsFileSystemHandle();\n              } catch (error: any) {\n                console.warn(error.name, error.message);\n              }\n            }\n\n            const scene = await loadFromBlob(\n              file,\n              this.state,\n              this.scene.getElementsIncludingDeleted(),\n            );\n            this.syncActionResult({\n              ...scene,\n              appState: {\n                ...(scene.appState || this.state),\n                isLoading: false,\n              },\n              replaceFiles: true,\n              commitToHistory: true,\n            });\n            return;\n          } catch (error: any) {\n            if (error.name !== \"EncodingError\") {\n              throw error;\n            }\n          }\n        }\n\n        // if no scene is embedded or we fail for whatever reason, fall back\n        // to importing as regular image\n        // ---------------------------------------------------------------------\n\n        const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n          event,\n          this.state,\n        );\n\n        const imageElement = this.createImageElement({ sceneX, sceneY });\n        this.insertImageElement(imageElement, file);\n        this.initializeImageDimensions(imageElement);\n        this.setState({ selectedElementIds: { [imageElement.id]: true } });\n\n        return;\n      }\n    } catch (error: any) {\n      return this.setState({\n        isLoading: false,\n        errorMessage: error.message,\n      });\n    }\n\n    const libraryShapes = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n    if (libraryShapes !== \"\") {\n      this.addElementsFromPasteOrLibrary({\n        elements: JSON.parse(libraryShapes),\n        position: event,\n        files: null,\n      });\n      return;\n    }\n\n    const file = event.dataTransfer?.files[0];\n    if (\n      file?.type === MIME_TYPES.excalidrawlib ||\n      file?.name?.endsWith(\".excalidrawlib\")\n    ) {\n      this.library\n        .importLibrary(file)\n        .then(() => {\n          // Close and then open to get the libraries updated\n          this.setState({ isLibraryOpen: false });\n          this.setState({ isLibraryOpen: true });\n        })\n        .catch((error) =>\n          this.setState({ isLoading: false, errorMessage: error.message }),\n        );\n      // default: assume an Excalidraw file regardless of extension/MimeType\n    } else {\n      this.setState({ isLoading: true });\n      if (nativeFileSystemSupported) {\n        try {\n          // This will only work as of Chrome 86,\n          // but can be safely ignored on older releases.\n          const item = event.dataTransfer.items[0];\n          (file as any).handle = await (item as any).getAsFileSystemHandle();\n        } catch (error: any) {\n          console.warn(error.name, error.message);\n        }\n      }\n      await this.loadFileToCanvas(file);\n    }\n  };\n\n  loadFileToCanvas = (file: Blob) => {\n    loadFromBlob(file, this.state, this.scene.getElementsIncludingDeleted())\n      .then((scene) => {\n        this.syncActionResult({\n          ...scene,\n          appState: {\n            ...(scene.appState || this.state),\n            isLoading: false,\n          },\n          replaceFiles: true,\n          commitToHistory: true,\n        });\n      })\n      .catch((error) => {\n        this.setState({ isLoading: false, errorMessage: error.message });\n      });\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.preventDefault();\n\n    const { x, y } = viewportCoordsToSceneCoords(event, this.state);\n    const element = this.getElementAtPosition(x, y, { preferSelected: true });\n\n    const type = element ? \"element\" : \"canvas\";\n\n    const container = this.excalidrawContainerRef.current!;\n    const { top: offsetTop, left: offsetLeft } =\n      container.getBoundingClientRect();\n    const left = event.clientX - offsetLeft;\n    const top = event.clientY - offsetTop;\n\n    if (element && !this.state.selectedElementIds[element.id]) {\n      this.setState({ selectedElementIds: { [element.id]: true } }, () => {\n        this._openContextMenu({ top, left }, type);\n      });\n    } else {\n      this._openContextMenu({ top, left }, type);\n    }\n  };\n\n  private maybeDragNewGenericElement = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): void => {\n    const draggingElement = this.state.draggingElement;\n    const pointerCoords = pointerDownState.lastCoords;\n    if (!draggingElement) {\n      return;\n    }\n    if (draggingElement.type === \"selection\") {\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        pointerCoords.x,\n        pointerCoords.y,\n        distance(pointerDownState.origin.x, pointerCoords.x),\n        distance(pointerDownState.origin.y, pointerCoords.y),\n        shouldMaintainAspectRatio(event),\n        shouldResizeFromCenter(event),\n      );\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      const image =\n        isInitializedImageElement(draggingElement) &&\n        this.imageCache.get(draggingElement.fileId)?.image;\n      const aspectRatio =\n        image && !(image instanceof Promise)\n          ? image.width / image.height\n          : null;\n\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.originInGrid.x,\n        pointerDownState.originInGrid.y,\n        gridX,\n        gridY,\n        distance(pointerDownState.originInGrid.x, gridX),\n        distance(pointerDownState.originInGrid.y, gridY),\n        isImageElement(draggingElement)\n          ? !shouldMaintainAspectRatio(event)\n          : shouldMaintainAspectRatio(event),\n        shouldResizeFromCenter(event),\n        aspectRatio,\n      );\n\n      this.maybeSuggestBindingForAll([draggingElement]);\n    }\n  };\n\n  private maybeHandleResize = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const transformHandleType = pointerDownState.resize.handleType;\n    this.setState({\n      // TODO: rename this state field to \"isScaling\" to distinguish\n      // it from the generic \"isResizing\" which includes scaling and\n      // rotating\n      isResizing: transformHandleType && transformHandleType !== \"rotation\",\n      isRotating: transformHandleType === \"rotation\",\n    });\n    const pointerCoords = pointerDownState.lastCoords;\n    const [resizeX, resizeY] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      this.state.gridSize,\n    );\n    if (\n      transformElements(\n        pointerDownState,\n        transformHandleType,\n        selectedElements,\n        pointerDownState.resize.arrowDirection,\n        shouldRotateWithDiscreteAngle(event),\n        shouldResizeFromCenter(event),\n        selectedElements.length === 1 && isImageElement(selectedElements[0])\n          ? !shouldMaintainAspectRatio(event)\n          : shouldMaintainAspectRatio(event),\n        resizeX,\n        resizeY,\n        pointerDownState.resize.center.x,\n        pointerDownState.resize.center.y,\n      )\n    ) {\n      this.maybeSuggestBindingForAll(selectedElements);\n      return true;\n    }\n    return false;\n  };\n\n  /** @private use this.handleCanvasContextMenu */\n  private _openContextMenu = (\n    {\n      left,\n      top,\n    }: {\n      left: number;\n      top: number;\n    },\n    type: \"canvas\" | \"element\",\n  ) => {\n    const maybeGroupAction = actionGroup.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const maybeUngroupAction = actionUngroup.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const maybeFlipHorizontal = actionFlipHorizontal.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const maybeFlipVertical = actionFlipVertical.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const separator = \"separator\";\n\n    const elements = this.scene.getElements();\n\n    const options: ContextMenuOption[] = [];\n    if (probablySupportsClipboardBlob && elements.length > 0) {\n      options.push(actionCopyAsPng);\n    }\n\n    if (probablySupportsClipboardWriteText && elements.length > 0) {\n      options.push(actionCopyAsSvg);\n    }\n    if (type === \"canvas\") {\n      const viewModeOptions = [\n        ...options,\n        typeof this.props.gridModeEnabled === \"undefined\" &&\n          actionToggleGridMode,\n        typeof this.props.zenModeEnabled === \"undefined\" && actionToggleZenMode,\n        typeof this.props.viewModeEnabled === \"undefined\" &&\n          actionToggleViewMode,\n        actionToggleStats,\n      ];\n\n      if (this.state.viewModeEnabled) {\n        ContextMenu.push({\n          options: viewModeOptions,\n          top,\n          left,\n          actionManager: this.actionManager,\n          appState: this.state,\n          container: this.excalidrawContainerRef.current!,\n        });\n      } else {\n        ContextMenu.push({\n          options: [\n            this.isMobile &&\n              navigator.clipboard && {\n                name: \"paste\",\n                perform: (elements, appStates) => {\n                  this.pasteFromClipboard(null);\n                  return {\n                    commitToHistory: false,\n                  };\n                },\n                contextItemLabel: \"labels.paste\",\n              },\n            this.isMobile && navigator.clipboard && separator,\n            probablySupportsClipboardBlob &&\n              elements.length > 0 &&\n              actionCopyAsPng,\n            probablySupportsClipboardWriteText &&\n              elements.length > 0 &&\n              actionCopyAsSvg,\n            ((probablySupportsClipboardBlob && elements.length > 0) ||\n              (probablySupportsClipboardWriteText && elements.length > 0)) &&\n              separator,\n            actionSelectAll,\n            separator,\n            typeof this.props.gridModeEnabled === \"undefined\" &&\n              actionToggleGridMode,\n            typeof this.props.zenModeEnabled === \"undefined\" &&\n              actionToggleZenMode,\n            typeof this.props.viewModeEnabled === \"undefined\" &&\n              actionToggleViewMode,\n            actionToggleStats,\n          ],\n          top,\n          left,\n          actionManager: this.actionManager,\n          appState: this.state,\n          container: this.excalidrawContainerRef.current!,\n        });\n      }\n    } else if (type === \"element\") {\n      if (this.state.viewModeEnabled) {\n        ContextMenu.push({\n          options: [navigator.clipboard && actionCopy, ...options],\n          top,\n          left,\n          actionManager: this.actionManager,\n          appState: this.state,\n          container: this.excalidrawContainerRef.current!,\n        });\n      } else {\n        ContextMenu.push({\n          options: [\n            this.isMobile && actionCut,\n            this.isMobile && navigator.clipboard && actionCopy,\n            this.isMobile &&\n              navigator.clipboard && {\n                name: \"paste\",\n                perform: (elements, appStates) => {\n                  this.pasteFromClipboard(null);\n                  return {\n                    commitToHistory: false,\n                  };\n                },\n                contextItemLabel: \"labels.paste\",\n              },\n            this.isMobile && separator,\n            ...options,\n            separator,\n            actionCopyStyles,\n            actionPasteStyles,\n            separator,\n            maybeGroupAction && actionGroup,\n            maybeUngroupAction && actionUngroup,\n            (maybeGroupAction || maybeUngroupAction) && separator,\n            actionAddToLibrary,\n            separator,\n            actionSendBackward,\n            actionBringForward,\n            actionSendToBack,\n            actionBringToFront,\n            separator,\n            maybeFlipHorizontal && actionFlipHorizontal,\n            maybeFlipVertical && actionFlipVertical,\n            (maybeFlipHorizontal || maybeFlipVertical) && separator,\n            actionDuplicateSelection,\n            actionDeleteSelected,\n          ],\n          top,\n          left,\n          actionManager: this.actionManager,\n          appState: this.state,\n          container: this.excalidrawContainerRef.current!,\n        });\n      }\n    }\n  };\n\n  private handleWheel = withBatchedUpdates((event: WheelEvent) => {\n    event.preventDefault();\n\n    if (isPanning) {\n      return;\n    }\n\n    const { deltaX, deltaY } = event;\n    const { selectedElementIds, previousSelectedElementIds } = this.state;\n    // note that event.ctrlKey is necessary to handle pinch zooming\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY);\n      const MAX_STEP = 10;\n      let delta = Math.abs(deltaY);\n      if (delta > MAX_STEP) {\n        delta = MAX_STEP;\n      }\n      delta *= sign;\n      if (Object.keys(previousSelectedElementIds).length !== 0) {\n        setTimeout(() => {\n          this.setState({\n            selectedElementIds: previousSelectedElementIds,\n            previousSelectedElementIds: {},\n          });\n        }, 1000);\n      }\n\n      let newZoom = this.state.zoom.value - delta / 100;\n      // increase zoom steps the more zoomed-in we are (applies to >100% only)\n      newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign;\n      // round to nearest step\n      newZoom = Math.round(newZoom * ZOOM_STEP * 100) / (ZOOM_STEP * 100);\n\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(newZoom),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          {\n            x: cursorX,\n            y: cursorY,\n          },\n        ),\n        selectedElementIds: {},\n        previousSelectedElementIds:\n          Object.keys(selectedElementIds).length !== 0\n            ? selectedElementIds\n            : previousSelectedElementIds,\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n      return;\n    }\n\n    // scroll horizontally when shift pressed\n    if (event.shiftKey) {\n      this.setState(({ zoom, scrollX }) => ({\n        // on Mac, shift+wheel tends to result in deltaX\n        scrollX: scrollX - (deltaY || deltaX) / zoom.value,\n      }));\n      return;\n    }\n\n    this.setState(({ zoom, scrollX, scrollY }) => ({\n      scrollX: scrollX - deltaX / zoom.value,\n      scrollY: scrollY - deltaY / zoom.value,\n    }));\n  });\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n    scale: number,\n  ) {\n    const elementClickedInside = getElementContainingPosition(\n      this.scene\n        .getElementsIncludingDeleted()\n        .filter((element) => !isTextElement(element)),\n      x,\n      y,\n    );\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          appState,\n        );\n        return { viewportX, viewportY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const pointer = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n    );\n\n    if (isNaN(pointer.x) || isNaN(pointer.y)) {\n      // sometimes the pointer goes off screen\n    }\n\n    this.props.onPointerUpdate?.({\n      pointer,\n      button,\n      pointersMap: gesture.pointers,\n    });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    if (!this.unmounted) {\n      this.setState({ shouldCacheIgnoreZoom: false });\n    }\n  }, 300);\n\n  private updateDOMRect = (cb?: () => void) => {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const {\n        width,\n        height,\n        left: offsetLeft,\n        top: offsetTop,\n      } = excalidrawContainer.getBoundingClientRect();\n      const {\n        width: currentWidth,\n        height: currentHeight,\n        offsetTop: currentOffsetTop,\n        offsetLeft: currentOffsetLeft,\n      } = this.state;\n\n      if (\n        width === currentWidth &&\n        height === currentHeight &&\n        offsetLeft === currentOffsetLeft &&\n        offsetTop === currentOffsetTop\n      ) {\n        if (cb) {\n          cb();\n        }\n        return;\n      }\n\n      this.setState(\n        {\n          width,\n          height,\n          offsetLeft,\n          offsetTop,\n        },\n        () => {\n          cb && cb();\n        },\n      );\n    }\n  };\n\n  public refresh = () => {\n    this.setState({ ...this.getCanvasOffsets() });\n  };\n\n  private getCanvasOffsets(): Pick<AppState, \"offsetTop\" | \"offsetLeft\"> {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const { left, top } = excalidrawContainer.getBoundingClientRect();\n      return {\n        offsetLeft: left,\n        offsetTop: top,\n      };\n    }\n    return {\n      offsetLeft: 0,\n      offsetTop: 0,\n    };\n  }\n\n  private async updateLanguage() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    h: {\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      app: InstanceType<typeof App>;\n      history: History;\n    };\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.h = window.h || ({} as Window[\"h\"]);\n\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n      get() {\n        return this.app.scene.getElementsIncludingDeleted();\n      },\n      set(elements: ExcalidrawElement[]) {\n        return this.app.scene.replaceAllElements(elements);\n      },\n    },\n  });\n}\nexport default App;\n","import \"./Modal.scss\";\n\nimport React, { useState, useLayoutEffect, useRef } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport clsx from \"clsx\";\nimport { KEYS } from \"../keys\";\nimport { useExcalidrawContainer, useIsMobile } from \"./App\";\nimport { AppState } from \"../types\";\nimport { THEME } from \"../constants\";\n\nexport const Modal = (props: {\n  className?: string;\n  children: React.ReactNode;\n  maxWidth?: number;\n  onCloseRequest(): void;\n  labelledBy: string;\n  theme?: AppState[\"theme\"];\n}) => {\n  const { theme = THEME.LIGHT } = props;\n  const modalRoot = useBodyRoot(theme);\n\n  if (!modalRoot) {\n    return null;\n  }\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    if (event.key === KEYS.ESCAPE) {\n      event.nativeEvent.stopImmediatePropagation();\n      event.stopPropagation();\n      props.onCloseRequest();\n    }\n  };\n\n  return createPortal(\n    <div\n      className={clsx(\"Modal\", props.className)}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      onKeyDown={handleKeydown}\n      aria-labelledby={props.labelledBy}\n    >\n      <div className=\"Modal__background\" onClick={props.onCloseRequest}></div>\n      <div\n        className=\"Modal__content\"\n        style={{ \"--max-width\": `${props.maxWidth}px` }}\n        tabIndex={0}\n      >\n        {props.children}\n      </div>\n    </div>,\n    modalRoot,\n  );\n};\n\nconst useBodyRoot = (theme: AppState[\"theme\"]) => {\n  const [div, setDiv] = useState<HTMLDivElement | null>(null);\n\n  const isMobile = useIsMobile();\n  const isMobileRef = useRef(isMobile);\n  isMobileRef.current = isMobile;\n\n  const { container: excalidrawContainer } = useExcalidrawContainer();\n\n  useLayoutEffect(() => {\n    if (div) {\n      div.classList.toggle(\"excalidraw--mobile\", isMobile);\n    }\n  }, [div, isMobile]);\n\n  useLayoutEffect(() => {\n    const isDarkTheme =\n      !!excalidrawContainer?.classList.contains(\"theme--dark\") ||\n      theme === \"dark\";\n    const div = document.createElement(\"div\");\n\n    div.classList.add(\"excalidraw\", \"excalidraw-modal-container\");\n    div.classList.toggle(\"excalidraw--mobile\", isMobileRef.current);\n\n    if (isDarkTheme) {\n      div.classList.add(\"theme--dark\");\n      div.classList.add(\"theme--dark-background-none\");\n    }\n    document.body.appendChild(div);\n\n    setDiv(div);\n\n    return () => {\n      document.body.removeChild(div);\n    };\n  }, [excalidrawContainer, theme]);\n\n  return div;\n};\n","import clsx from \"clsx\";\nimport React, { useEffect, useState } from \"react\";\nimport { useCallbackRefState } from \"../hooks/useCallbackRefState\";\nimport { t } from \"../i18n\";\nimport { useExcalidrawContainer, useIsMobile } from \"../components/App\";\nimport { KEYS } from \"../keys\";\nimport \"./Dialog.scss\";\nimport { back, close } from \"./icons\";\nimport { Island } from \"./Island\";\nimport { Modal } from \"./Modal\";\nimport { AppState } from \"../types\";\n\nexport const Dialog = (props: {\n  children: React.ReactNode;\n  className?: string;\n  small?: boolean;\n  onCloseRequest(): void;\n  title: React.ReactNode;\n  autofocus?: boolean;\n  theme?: AppState[\"theme\"];\n}) => {\n  const [islandNode, setIslandNode] = useCallbackRefState<HTMLDivElement>();\n  const [lastActiveElement] = useState(document.activeElement);\n  const { id } = useExcalidrawContainer();\n\n  useEffect(() => {\n    if (!islandNode) {\n      return;\n    }\n\n    const focusableElements = queryFocusableElements(islandNode);\n\n    if (focusableElements.length > 0 && props.autofocus !== false) {\n      // If there's an element other than close, focus it.\n      (focusableElements[1] || focusableElements[0]).focus();\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === KEYS.TAB) {\n        const focusableElements = queryFocusableElements(islandNode);\n        const { activeElement } = document;\n        const currentIndex = focusableElements.findIndex(\n          (element) => element === activeElement,\n        );\n\n        if (currentIndex === 0 && event.shiftKey) {\n          focusableElements[focusableElements.length - 1].focus();\n          event.preventDefault();\n        } else if (\n          currentIndex === focusableElements.length - 1 &&\n          !event.shiftKey\n        ) {\n          focusableElements[0].focus();\n          event.preventDefault();\n        }\n      }\n    };\n\n    islandNode.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => islandNode.removeEventListener(\"keydown\", handleKeyDown);\n  }, [islandNode, props.autofocus]);\n\n  const queryFocusableElements = (node: HTMLElement) => {\n    const focusableElements = node.querySelectorAll<HTMLElement>(\n      \"button, a, input, select, textarea, div[tabindex]\",\n    );\n\n    return focusableElements ? Array.from(focusableElements) : [];\n  };\n\n  const onClose = () => {\n    (lastActiveElement as HTMLElement).focus();\n    props.onCloseRequest();\n  };\n\n  return (\n    <Modal\n      className={clsx(\"Dialog\", props.className)}\n      labelledBy=\"dialog-title\"\n      maxWidth={props.small ? 550 : 800}\n      onCloseRequest={onClose}\n      theme={props.theme}\n    >\n      <Island ref={setIslandNode}>\n        <h2 id={`${id}-dialog-title`} className=\"Dialog__title\">\n          <span className=\"Dialog__titleContent\">{props.title}</span>\n          <button\n            className=\"Modal__close\"\n            onClick={onClose}\n            aria-label={t(\"buttons.close\")}\n          >\n            {useIsMobile() ? back : close}\n          </button>\n        </h2>\n        <div className=\"Dialog__content\">{props.children}</div>\n      </Island>\n    </Modal>\n  );\n};\n","import React, { useState } from \"react\";\nimport { t } from \"../i18n\";\n\nimport { Dialog } from \"./Dialog\";\nimport { useExcalidrawContainer } from \"./App\";\n\nexport const ErrorDialog = ({\n  message,\n  onClose,\n}: {\n  message: string;\n  onClose?: () => void;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(!!message);\n  const { container: excalidrawContainer } = useExcalidrawContainer();\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n\n    if (onClose) {\n      onClose();\n    }\n    // TODO: Fix the A11y issues so this is never needed since we should always focus on last active element\n    excalidrawContainer?.focus();\n  }, [onClose, excalidrawContainer]);\n\n  return (\n    <>\n      {modalIsShown && (\n        <Dialog\n          small\n          onCloseRequest={handleClose}\n          title={t(\"errorDialog.title\")}\n        >\n          <div style={{ whiteSpace: \"pre-wrap\" }}>{message}</div>\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import React from \"react\";\nimport * as Sentry from \"@sentry/browser\";\nimport { t } from \"../i18n\";\n\ninterface TopErrorBoundaryState {\n  hasError: boolean;\n  sentryEventId: string;\n  localStorage: string;\n}\n\nexport class TopErrorBoundary extends React.Component<\n  any,\n  TopErrorBoundaryState\n> {\n  state: TopErrorBoundaryState = {\n    hasError: false,\n    sentryEventId: \"\",\n    localStorage: \"\",\n  };\n\n  render() {\n    return this.state.hasError ? this.errorSplash() : this.props.children;\n  }\n\n  componentDidCatch(error: Error, errorInfo: any) {\n    const _localStorage: any = {};\n    for (const [key, value] of Object.entries({ ...localStorage })) {\n      try {\n        _localStorage[key] = JSON.parse(value);\n      } catch (error: any) {\n        _localStorage[key] = value;\n      }\n    }\n\n    Sentry.withScope((scope) => {\n      scope.setExtras(errorInfo);\n      const eventId = Sentry.captureException(error);\n\n      this.setState((state) => ({\n        hasError: true,\n        sentryEventId: eventId,\n        localStorage: JSON.stringify(_localStorage),\n      }));\n    });\n  }\n\n  private selectTextArea(event: React.MouseEvent<HTMLTextAreaElement>) {\n    if (event.target !== document.activeElement) {\n      event.preventDefault();\n      (event.target as HTMLTextAreaElement).select();\n    }\n  }\n\n  private async createGithubIssue() {\n    let body = \"\";\n    try {\n      const templateStrFn = (\n        await import(\n          /* webpackChunkName: \"bug-issue-template\" */ \"../bug-issue-template\"\n        )\n      ).default;\n      body = encodeURIComponent(templateStrFn(this.state.sentryEventId));\n    } catch (error: any) {\n      console.error(error);\n    }\n\n    window.open(\n      `https://github.com/excalidraw/excalidraw/issues/new?body=${body}`,\n    );\n  }\n\n  private errorSplash() {\n    return (\n      <div className=\"ErrorSplash excalidraw\">\n        <div className=\"ErrorSplash-messageContainer\">\n          <div className=\"ErrorSplash-paragraph bigger align-center\">\n            {t(\"errorSplash.headingMain_pre\")}\n            <button onClick={() => window.location.reload()}>\n              {t(\"errorSplash.headingMain_button\")}\n            </button>\n          </div>\n          <div className=\"ErrorSplash-paragraph align-center\">\n            {t(\"errorSplash.clearCanvasMessage\")}\n            <button\n              onClick={() => {\n                try {\n                  localStorage.clear();\n                  window.location.reload();\n                } catch (error: any) {\n                  console.error(error);\n                }\n              }}\n            >\n              {t(\"errorSplash.clearCanvasMessage_button\")}\n            </button>\n            <br />\n            <div className=\"smaller\">\n              <span role=\"img\" aria-label=\"warning\">\n                \n              </span>\n              {t(\"errorSplash.clearCanvasCaveat\")}\n              <span role=\"img\" aria-hidden=\"true\">\n                \n              </span>\n            </div>\n          </div>\n          <div>\n            <div className=\"ErrorSplash-paragraph\">\n              {t(\"errorSplash.trackedToSentry_pre\")}\n              {this.state.sentryEventId}\n              {t(\"errorSplash.trackedToSentry_post\")}\n            </div>\n            <div className=\"ErrorSplash-paragraph\">\n              {t(\"errorSplash.openIssueMessage_pre\")}\n              <button onClick={() => this.createGithubIssue()}>\n                {t(\"errorSplash.openIssueMessage_button\")}\n              </button>\n              {t(\"errorSplash.openIssueMessage_post\")}\n            </div>\n            <div className=\"ErrorSplash-paragraph\">\n              <div className=\"ErrorSplash-details\">\n                <label>{t(\"errorSplash.sceneContent\")}</label>\n                <textarea\n                  rows={5}\n                  onPointerDown={this.selectTextArea}\n                  readOnly={true}\n                  value={this.state.localStorage}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import { ENV } from \"../../constants\";\nimport pkg from \"./package.json\";\nif (process.env.NODE_ENV !== ENV.TEST) {\n  /* eslint-disable */\n  /* global __webpack_public_path__:writable */\n  __webpack_public_path__ =\n    window.EXCALIDRAW_ASSET_PATH ||\n    `https://unpkg.com/${pkg.name}@${pkg.version}/dist/`;\n}\n","import React, { useEffect, useState } from \"react\";\n\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport { defaultLang, Language, languages, setLanguage } from \"../i18n\";\n\ninterface Props {\n  langCode: Language[\"code\"];\n  children: React.ReactElement;\n}\n\nexport const InitializeApp = (props: Props) => {\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const updateLang = async () => {\n      await setLanguage(currentLang);\n    };\n    const currentLang =\n      languages.find((lang) => lang.code === props.langCode) || defaultLang;\n    updateLang();\n    setLoading(false);\n  }, [props.langCode]);\n\n  return loading ? <LoadingMessage /> : props.children;\n};\n","import {\n  exportToCanvas as _exportToCanvas,\n  exportToSvg as _exportToSvg,\n} from \"../scene/export\";\nimport { getDefaultAppState } from \"../appState\";\nimport { AppState, BinaryFiles } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getNonDeletedElements } from \"../element\";\nimport { restore } from \"../data/restore\";\nimport { MIME_TYPES } from \"../constants\";\n\ntype ExportOpts = {\n  elements: readonly ExcalidrawElement[];\n  appState?: Partial<Omit<AppState, \"offsetTop\" | \"offsetLeft\">>;\n  files: BinaryFiles | null;\n  getDimensions?: (\n    width: number,\n    height: number,\n  ) => { width: number; height: number; scale: number };\n};\n\nexport const exportToCanvas = ({\n  elements,\n  appState,\n  files,\n  getDimensions = (width, height) => ({ width, height, scale: 1 }),\n}: ExportOpts) => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n  const { exportBackground, viewBackgroundColor } = restoredAppState;\n  return _exportToCanvas(\n    getNonDeletedElements(restoredElements),\n    { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },\n    files || {},\n    { exportBackground, viewBackgroundColor },\n    (width: number, height: number) => {\n      const canvas = document.createElement(\"canvas\");\n      const ret = getDimensions(width, height);\n\n      canvas.width = ret.width;\n      canvas.height = ret.height;\n\n      return { canvas, scale: ret.scale };\n    },\n  );\n};\n\nexport const exportToBlob = async (\n  opts: ExportOpts & {\n    mimeType?: string;\n    quality?: number;\n  },\n): Promise<Blob | null> => {\n  const canvas = await exportToCanvas(opts);\n\n  let { mimeType = MIME_TYPES.png, quality } = opts;\n\n  if (mimeType === MIME_TYPES.png && typeof quality === \"number\") {\n    console.warn(`\"quality\" will be ignored for \"${MIME_TYPES.png}\" mimeType`);\n  }\n\n  // typo in MIME type (should be \"jpeg\")\n  if (mimeType === \"image/jpg\") {\n    mimeType = MIME_TYPES.jpg;\n  }\n\n  quality = quality ? quality : /image\\/jpe?g/.test(mimeType) ? 0.92 : 0.8;\n\n  return new Promise((resolve) => {\n    canvas.toBlob(\n      (blob: Blob | null) => {\n        resolve(blob);\n      },\n      mimeType,\n      quality,\n    );\n  });\n};\n\nexport const exportToSvg = async ({\n  elements,\n  appState = getDefaultAppState(),\n  files = {},\n  exportPadding,\n}: Omit<ExportOpts, \"getDimensions\"> & {\n  exportPadding?: number;\n}): Promise<SVGSVGElement> => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n  return _exportToSvg(\n    getNonDeletedElements(restoredElements),\n    {\n      ...restoredAppState,\n      exportPadding,\n    },\n    files,\n  );\n};\n\nexport { serializeAsJSON } from \"../data/json\";\nexport { loadFromBlob, loadLibraryFromBlob } from \"../data/blob\";\nexport { getFreeDrawSvgPath } from \"../renderer/renderElement\";\n","import React, { useEffect, forwardRef } from \"react\";\nimport \"./publicPath\";\n\nimport { InitializeApp } from \"../../components/InitializeApp\";\nimport App from \"../../components/App\";\n\nimport \"../../css/app.scss\";\nimport \"../../css/styles.scss\";\n\nimport { AppProps, ExcalidrawAPIRefValue, ExcalidrawProps } from \"../../types\";\nimport { defaultLang } from \"../../i18n\";\nimport { DEFAULT_UI_OPTIONS } from \"../../constants\";\n\nconst Excalidraw = (props: ExcalidrawProps) => {\n  const {\n    onChange,\n    initialData,\n    excalidrawRef,\n    onCollabButtonClick,\n    isCollaborating,\n    onPointerUpdate,\n    renderTopRightUI,\n    renderFooter,\n    langCode = defaultLang.code,\n    viewModeEnabled,\n    zenModeEnabled,\n    gridModeEnabled,\n    libraryReturnUrl,\n    theme,\n    name,\n    renderCustomStats,\n    onPaste,\n    detectScroll = true,\n    handleKeyboardGlobally = false,\n    onLibraryChange,\n    autoFocus = false,\n    generateIdForFile,\n  } = props;\n\n  const canvasActions = props.UIOptions?.canvasActions;\n\n  const UIOptions: AppProps[\"UIOptions\"] = {\n    canvasActions: {\n      ...DEFAULT_UI_OPTIONS.canvasActions,\n      ...canvasActions,\n    },\n  };\n\n  if (canvasActions?.export) {\n    UIOptions.canvasActions.export.saveFileToDisk =\n      canvasActions.export?.saveFileToDisk ??\n      DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;\n  }\n\n  useEffect(() => {\n    // Block pinch-zooming on iOS outside of the content area\n    const handleTouchMove = (event: TouchEvent) => {\n      // @ts-ignore\n      if (typeof event.scale === \"number\" && event.scale !== 1) {\n        event.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"touchmove\", handleTouchMove, {\n      passive: false,\n    });\n\n    return () => {\n      document.removeEventListener(\"touchmove\", handleTouchMove);\n    };\n  }, []);\n\n  return (\n    <InitializeApp langCode={langCode}>\n      <App\n        onChange={onChange}\n        initialData={initialData}\n        excalidrawRef={excalidrawRef}\n        onCollabButtonClick={onCollabButtonClick}\n        isCollaborating={isCollaborating}\n        onPointerUpdate={onPointerUpdate}\n        renderTopRightUI={renderTopRightUI}\n        renderFooter={renderFooter}\n        langCode={langCode}\n        viewModeEnabled={viewModeEnabled}\n        zenModeEnabled={zenModeEnabled}\n        gridModeEnabled={gridModeEnabled}\n        libraryReturnUrl={libraryReturnUrl}\n        theme={theme}\n        name={name}\n        renderCustomStats={renderCustomStats}\n        UIOptions={UIOptions}\n        onPaste={onPaste}\n        detectScroll={detectScroll}\n        handleKeyboardGlobally={handleKeyboardGlobally}\n        onLibraryChange={onLibraryChange}\n        autoFocus={autoFocus}\n        generateIdForFile={generateIdForFile}\n      />\n    </InitializeApp>\n  );\n};\n\ntype PublicExcalidrawProps = Omit<ExcalidrawProps, \"forwardedRef\">;\n\nconst areEqual = (\n  prevProps: PublicExcalidrawProps,\n  nextProps: PublicExcalidrawProps,\n) => {\n  const {\n    initialData: prevInitialData,\n    UIOptions: prevUIOptions = {},\n    ...prev\n  } = prevProps;\n  const {\n    initialData: nextInitialData,\n    UIOptions: nextUIOptions = {},\n    ...next\n  } = nextProps;\n\n  // comparing UIOptions\n  const prevUIOptionsKeys = Object.keys(prevUIOptions) as (keyof Partial<\n    typeof DEFAULT_UI_OPTIONS\n  >)[];\n  const nextUIOptionsKeys = Object.keys(nextUIOptions) as (keyof Partial<\n    typeof DEFAULT_UI_OPTIONS\n  >)[];\n\n  if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {\n    return false;\n  }\n\n  const isUIOptionsSame = prevUIOptionsKeys.every((key) => {\n    if (key === \"canvasActions\") {\n      const canvasOptionKeys = Object.keys(\n        prevUIOptions.canvasActions!,\n      ) as (keyof Partial<typeof DEFAULT_UI_OPTIONS.canvasActions>)[];\n      canvasOptionKeys.every((key) => {\n        if (\n          key === \"export\" &&\n          prevUIOptions?.canvasActions?.export &&\n          nextUIOptions?.canvasActions?.export\n        ) {\n          return (\n            prevUIOptions.canvasActions.export.saveFileToDisk ===\n            nextUIOptions.canvasActions.export.saveFileToDisk\n          );\n        }\n        return (\n          prevUIOptions?.canvasActions?.[key] ===\n          nextUIOptions?.canvasActions?.[key]\n        );\n      });\n    }\n    return true;\n  });\n\n  const prevKeys = Object.keys(prevProps) as (keyof typeof prev)[];\n  const nextKeys = Object.keys(nextProps) as (keyof typeof next)[];\n  return (\n    isUIOptionsSame &&\n    prevKeys.length === nextKeys.length &&\n    prevKeys.every((key) => prev[key] === next[key])\n  );\n};\n\nconst forwardedRefComp = forwardRef<\n  ExcalidrawAPIRefValue,\n  PublicExcalidrawProps\n>((props, ref) => <Excalidraw {...props} excalidrawRef={ref} />);\nexport default React.memo(forwardedRefComp, areEqual);\nexport {\n  getSceneVersion,\n  getElementMap,\n  isInvisiblySmallElement,\n  getNonDeletedElements,\n} from \"../../element\";\nexport { defaultLang, languages } from \"../../i18n\";\nexport { restore, restoreAppState, restoreElements } from \"../../data/restore\";\nexport {\n  exportToCanvas,\n  exportToBlob,\n  exportToSvg,\n  serializeAsJSON,\n  loadLibraryFromBlob,\n  loadFromBlob,\n  getFreeDrawSvgPath,\n} from \"../../packages/utils\";\nexport { isLinearElement } from \"../../element/typeChecks\";\n\nexport { FONT_FAMILY, THEME } from \"../../constants\";\n\nexport {\n  mutateElement,\n  newElementWith,\n  bumpVersion,\n} from \"../../element/mutateElement\";\n","// time constants (ms)\nexport const SAVE_TO_LOCAL_STORAGE_TIMEOUT = 300;\nexport const INITIAL_SCENE_UPDATE_TIMEOUT = 5000;\nexport const FILE_UPLOAD_TIMEOUT = 300;\nexport const LOAD_IMAGES_TIMEOUT = 500;\nexport const SYNC_FULL_SCENE_INTERVAL_MS = 20000;\n\nexport const FILE_UPLOAD_MAX_BYTES = 3 * 1024 * 1024; // 3 MiB\n// 1 year (https://stackoverflow.com/a/25201898/927631)\nexport const FILE_CACHE_MAX_AGE_SEC = 31536000;\n\nexport const BROADCAST = {\n  SERVER_VOLATILE: \"server-volatile-broadcast\",\n  SERVER: \"server-broadcast\",\n};\n\nexport enum SCENE {\n  INIT = \"SCENE_INIT\",\n  UPDATE = \"SCENE_UPDATE\",\n}\n\nexport const FIREBASE_STORAGE_PREFIXES = {\n  shareLinkFiles: `/files/shareLinks`,\n  collabFiles: `/files/rooms`,\n};\n","import { compressData } from \"../../data/encode\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport { isInitializedImageElement } from \"../../element/typeChecks\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  FileId,\n  InitializedExcalidrawImageElement,\n} from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport {\n  BinaryFileData,\n  BinaryFileMetadata,\n  ExcalidrawImperativeAPI,\n  BinaryFiles,\n} from \"../../types\";\n\nexport class FileManager {\n  /** files being fetched */\n  private fetchingFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n  /** files being saved */\n  private savingFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n  /* files already saved to persistent storage */\n  private savedFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n  private erroredFiles = new Map<ExcalidrawImageElement[\"fileId\"], true>();\n\n  private _getFiles;\n  private _saveFiles;\n\n  constructor({\n    getFiles,\n    saveFiles,\n  }: {\n    getFiles: (fileIds: FileId[]) => Promise<{\n      loadedFiles: BinaryFileData[];\n      erroredFiles: Map<FileId, true>;\n    }>;\n    saveFiles: (data: { addedFiles: Map<FileId, BinaryFileData> }) => Promise<{\n      savedFiles: Map<FileId, true>;\n      erroredFiles: Map<FileId, true>;\n    }>;\n  }) {\n    this._getFiles = getFiles;\n    this._saveFiles = saveFiles;\n  }\n\n  /**\n   * returns whether file is already saved or being processed\n   */\n  isFileHandled = (id: FileId) => {\n    return (\n      this.savedFiles.has(id) ||\n      this.fetchingFiles.has(id) ||\n      this.savingFiles.has(id) ||\n      this.erroredFiles.has(id)\n    );\n  };\n\n  isFileSaved = (id: FileId) => {\n    return this.savedFiles.has(id);\n  };\n\n  saveFiles = async ({\n    elements,\n    files,\n  }: {\n    elements: readonly ExcalidrawElement[];\n    files: BinaryFiles;\n  }) => {\n    const addedFiles: Map<FileId, BinaryFileData> = new Map();\n\n    for (const element of elements) {\n      if (\n        isInitializedImageElement(element) &&\n        files[element.fileId] &&\n        !this.isFileHandled(element.fileId)\n      ) {\n        addedFiles.set(element.fileId, files[element.fileId]);\n        this.savingFiles.set(element.fileId, true);\n      }\n    }\n\n    try {\n      const { savedFiles, erroredFiles } = await this._saveFiles({\n        addedFiles,\n      });\n\n      for (const [fileId] of savedFiles) {\n        this.savedFiles.set(fileId, true);\n      }\n\n      return {\n        savedFiles,\n        erroredFiles,\n      };\n    } finally {\n      for (const [fileId] of addedFiles) {\n        this.savingFiles.delete(fileId);\n      }\n    }\n  };\n\n  getFiles = async (\n    ids: FileId[],\n  ): Promise<{\n    loadedFiles: BinaryFileData[];\n    erroredFiles: Map<FileId, true>;\n  }> => {\n    if (!ids.length) {\n      return {\n        loadedFiles: [],\n        erroredFiles: new Map(),\n      };\n    }\n    for (const id of ids) {\n      this.fetchingFiles.set(id, true);\n    }\n\n    try {\n      const { loadedFiles, erroredFiles } = await this._getFiles(ids);\n\n      for (const file of loadedFiles) {\n        this.savedFiles.set(file.id, true);\n      }\n      for (const [fileId] of erroredFiles) {\n        this.erroredFiles.set(fileId, true);\n      }\n\n      return { loadedFiles, erroredFiles };\n    } finally {\n      for (const id of ids) {\n        this.fetchingFiles.delete(id);\n      }\n    }\n  };\n\n  /** a file element prevents unload only if it's being saved regardless of\n   *  its `status`. This ensures that elements who for any reason haven't\n   *  beed set to `saved` status don't prevent unload in future sessions.\n   *  Technically we should prevent unload when the origin client haven't\n   *  yet saved the `status` update to storage, but that should be taken care\n   *  of during regular beforeUnload unsaved files check.\n   */\n  shouldPreventUnload = (elements: readonly ExcalidrawElement[]) => {\n    return elements.some((element) => {\n      return (\n        isInitializedImageElement(element) &&\n        !element.isDeleted &&\n        this.savingFiles.has(element.fileId)\n      );\n    });\n  };\n\n  /**\n   * helper to determine if image element status needs updating\n   */\n  shouldUpdateImageElementStatus = (\n    element: ExcalidrawElement,\n  ): element is InitializedExcalidrawImageElement => {\n    return (\n      isInitializedImageElement(element) &&\n      this.isFileSaved(element.fileId) &&\n      element.status === \"pending\"\n    );\n  };\n\n  reset() {\n    this.fetchingFiles.clear();\n    this.savingFiles.clear();\n    this.savedFiles.clear();\n    this.erroredFiles.clear();\n  }\n}\n\nexport const encodeFilesForUpload = async ({\n  files,\n  maxBytes,\n  encryptionKey,\n}: {\n  files: Map<FileId, BinaryFileData>;\n  maxBytes: number;\n  encryptionKey: string;\n}) => {\n  const processedFiles: {\n    id: FileId;\n    buffer: Uint8Array;\n  }[] = [];\n\n  for (const [id, fileData] of files) {\n    const buffer = new TextEncoder().encode(fileData.dataURL);\n\n    const encodedFile = await compressData<BinaryFileMetadata>(buffer, {\n      encryptionKey,\n      metadata: {\n        id,\n        mimeType: fileData.mimeType,\n        created: Date.now(),\n      },\n    });\n\n    if (buffer.byteLength > maxBytes) {\n      throw new Error(\n        t(\"errors.fileTooBig\", {\n          maxSize: `${Math.trunc(maxBytes / 1024 / 1024)}MB`,\n        }),\n      );\n    }\n\n    processedFiles.push({\n      id,\n      buffer: encodedFile,\n    });\n  }\n\n  return processedFiles;\n};\n\nexport const updateStaleImageStatuses = (params: {\n  excalidrawAPI: ExcalidrawImperativeAPI;\n  erroredFiles: Map<FileId, true>;\n  elements: readonly ExcalidrawElement[];\n}) => {\n  if (!params.erroredFiles.size) {\n    return;\n  }\n  params.excalidrawAPI.updateScene({\n    elements: params.excalidrawAPI\n      .getSceneElementsIncludingDeleted()\n      .map((element) => {\n        if (\n          isInitializedImageElement(element) &&\n          params.erroredFiles.has(element.fileId)\n        ) {\n          return newElementWith(element, {\n            status: \"error\",\n          });\n        }\n        return element;\n      }),\n  });\n};\n","import { ExcalidrawElement, FileId } from \"../../element/types\";\nimport { getSceneVersion } from \"../../element\";\nimport Portal from \"../collab/Portal\";\nimport { restoreElements } from \"../../data/restore\";\nimport { BinaryFileData, BinaryFileMetadata, DataURL } from \"../../types\";\nimport { FILE_CACHE_MAX_AGE_SEC } from \"../app_constants\";\nimport { decompressData } from \"../../data/encode\";\nimport { getImportedKey, createIV } from \"../../data/encryption\";\nimport { MIME_TYPES } from \"../../constants\";\n\n// private\n// -----------------------------------------------------------------------------\n\nconst FIREBASE_CONFIG = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);\n\nlet firebasePromise: Promise<typeof import(\"firebase/app\").default> | null =\n  null;\nlet firestorePromise: Promise<any> | null | true = null;\nlet firebaseStoragePromise: Promise<any> | null | true = null;\n\nlet isFirebaseInitialized = false;\n\nconst _loadFirebase = async () => {\n  const firebase = (\n    await import(/* webpackChunkName: \"firebase\" */ \"firebase/app\")\n  ).default;\n\n  if (!isFirebaseInitialized) {\n    try {\n      firebase.initializeApp(FIREBASE_CONFIG);\n    } catch (error: any) {\n      // trying initialize again throws. Usually this is harmless, and happens\n      // mainly in dev (HMR)\n      if (error.code === \"app/duplicate-app\") {\n        console.warn(error.name, error.code);\n      } else {\n        throw error;\n      }\n    }\n    isFirebaseInitialized = true;\n  }\n\n  return firebase;\n};\n\nconst _getFirebase = async (): Promise<\n  typeof import(\"firebase/app\").default\n> => {\n  if (!firebasePromise) {\n    firebasePromise = _loadFirebase();\n  }\n  return firebasePromise;\n};\n\n// -----------------------------------------------------------------------------\n\nconst loadFirestore = async () => {\n  const firebase = await _getFirebase();\n  if (!firestorePromise) {\n    firestorePromise = import(\n      /* webpackChunkName: \"firestore\" */ \"firebase/firestore\"\n    );\n  }\n  if (firestorePromise !== true) {\n    await firestorePromise;\n    firestorePromise = true;\n  }\n  return firebase;\n};\n\nexport const loadFirebaseStorage = async () => {\n  const firebase = await _getFirebase();\n  if (!firebaseStoragePromise) {\n    firebaseStoragePromise = import(\n      /* webpackChunkName: \"storage\" */ \"firebase/storage\"\n    );\n  }\n  if (firebaseStoragePromise !== true) {\n    await firebaseStoragePromise;\n    firebaseStoragePromise = true;\n  }\n  return firebase;\n};\n\ninterface FirebaseStoredScene {\n  sceneVersion: number;\n  iv: firebase.default.firestore.Blob;\n  ciphertext: firebase.default.firestore.Blob;\n}\n\nconst encryptElements = async (\n  key: string,\n  elements: readonly ExcalidrawElement[],\n): Promise<{ ciphertext: ArrayBuffer; iv: Uint8Array }> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  const json = JSON.stringify(elements);\n  const encoded = new TextEncoder().encode(json);\n  const ciphertext = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    encoded,\n  );\n\n  return { ciphertext, iv };\n};\n\nconst decryptElements = async (\n  key: string,\n  iv: Uint8Array,\n  ciphertext: ArrayBuffer | Uint8Array,\n): Promise<readonly ExcalidrawElement[]> => {\n  const importedKey = await getImportedKey(key, \"decrypt\");\n  const decrypted = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    ciphertext,\n  );\n\n  const decodedData = new TextDecoder(\"utf-8\").decode(\n    new Uint8Array(decrypted),\n  );\n  return JSON.parse(decodedData);\n};\n\nconst firebaseSceneVersionCache = new WeakMap<SocketIOClient.Socket, number>();\n\nexport const isSavedToFirebase = (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n): boolean => {\n  if (portal.socket && portal.roomId && portal.roomKey) {\n    const sceneVersion = getSceneVersion(elements);\n\n    return firebaseSceneVersionCache.get(portal.socket) === sceneVersion;\n  }\n  // if no room exists, consider the room saved so that we don't unnecessarily\n  // prevent unload (there's nothing we could do at that point anyway)\n  return true;\n};\n\nexport const saveFilesToFirebase = async ({\n  prefix,\n  files,\n}: {\n  prefix: string;\n  files: { id: FileId; buffer: Uint8Array }[];\n}) => {\n  const firebase = await loadFirebaseStorage();\n\n  const erroredFiles = new Map<FileId, true>();\n  const savedFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    files.map(async ({ id, buffer }) => {\n      try {\n        await firebase\n          .storage()\n          .ref(`${prefix}/${id}`)\n          .put(\n            new Blob([buffer], {\n              type: MIME_TYPES.binary,\n            }),\n            {\n              cacheControl: `public, max-age=${FILE_CACHE_MAX_AGE_SEC}`,\n            },\n          );\n        savedFiles.set(id, true);\n      } catch (error: any) {\n        erroredFiles.set(id, true);\n      }\n    }),\n  );\n\n  return { savedFiles, erroredFiles };\n};\n\nexport const saveToFirebase = async (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n) => {\n  const { roomId, roomKey, socket } = portal;\n  if (\n    // if no room exists, consider the room saved because there's nothing we can\n    // do at this point\n    !roomId ||\n    !roomKey ||\n    !socket ||\n    isSavedToFirebase(portal, elements)\n  ) {\n    return true;\n  }\n\n  const firebase = await loadFirestore();\n  const sceneVersion = getSceneVersion(elements);\n  const { ciphertext, iv } = await encryptElements(roomKey, elements);\n\n  const nextDocData = {\n    sceneVersion,\n    ciphertext: firebase.firestore.Blob.fromUint8Array(\n      new Uint8Array(ciphertext),\n    ),\n    iv: firebase.firestore.Blob.fromUint8Array(iv),\n  } as FirebaseStoredScene;\n\n  const db = firebase.firestore();\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const didUpdate = await db.runTransaction(async (transaction) => {\n    const doc = await transaction.get(docRef);\n    if (!doc.exists) {\n      transaction.set(docRef, nextDocData);\n      return true;\n    }\n\n    const prevDocData = doc.data() as FirebaseStoredScene;\n    if (prevDocData.sceneVersion >= nextDocData.sceneVersion) {\n      return false;\n    }\n\n    transaction.update(docRef, nextDocData);\n    return true;\n  });\n\n  if (didUpdate) {\n    firebaseSceneVersionCache.set(socket, sceneVersion);\n  }\n\n  return didUpdate;\n};\n\nexport const loadFromFirebase = async (\n  roomId: string,\n  roomKey: string,\n  socket: SocketIOClient.Socket | null,\n): Promise<readonly ExcalidrawElement[] | null> => {\n  const firebase = await loadFirestore();\n  const db = firebase.firestore();\n\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const doc = await docRef.get();\n  if (!doc.exists) {\n    return null;\n  }\n  const storedScene = doc.data() as FirebaseStoredScene;\n  const ciphertext = storedScene.ciphertext.toUint8Array();\n  const iv = storedScene.iv.toUint8Array();\n\n  const elements = await decryptElements(roomKey, iv, ciphertext);\n\n  if (socket) {\n    firebaseSceneVersionCache.set(socket, getSceneVersion(elements));\n  }\n\n  return restoreElements(elements, null);\n};\n\nexport const loadFilesFromFirebase = async (\n  prefix: string,\n  decryptionKey: string,\n  filesIds: readonly FileId[],\n) => {\n  const loadedFiles: BinaryFileData[] = [];\n  const erroredFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    [...new Set(filesIds)].map(async (id) => {\n      try {\n        const url = `https://firebasestorage.googleapis.com/v0/b/${\n          FIREBASE_CONFIG.storageBucket\n        }/o/${encodeURIComponent(prefix.replace(/^\\//, \"\"))}%2F${id}`;\n        const response = await fetch(`${url}?alt=media`);\n        if (response.status < 400) {\n          const arrayBuffer = await response.arrayBuffer();\n\n          const { data, metadata } = await decompressData<BinaryFileMetadata>(\n            new Uint8Array(arrayBuffer),\n            {\n              decryptionKey,\n            },\n          );\n\n          const dataURL = new TextDecoder().decode(data) as DataURL;\n\n          loadedFiles.push({\n            mimeType: metadata.mimeType || MIME_TYPES.binary,\n            id,\n            dataURL,\n            created: metadata?.created || Date.now(),\n          });\n        } else {\n          erroredFiles.set(id, true);\n        }\n      } catch (error: any) {\n        erroredFiles.set(id, true);\n        console.error(error);\n      }\n    }),\n  );\n\n  return { loadedFiles, erroredFiles };\n};\n","import {\n  createIV,\n  generateEncryptionKey,\n  getImportedKey,\n  IV_LENGTH_BYTES,\n} from \"../../data/encryption\";\nimport { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { isInitializedImageElement } from \"../../element/typeChecks\";\nimport { ExcalidrawElement, FileId } from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport {\n  AppState,\n  BinaryFileData,\n  BinaryFiles,\n  UserIdleState,\n} from \"../../types\";\nimport { FILE_UPLOAD_MAX_BYTES } from \"../app_constants\";\nimport { encodeFilesForUpload } from \"./FileManager\";\nimport { saveFilesToFirebase } from \"./firebase\";\n\nconst byteToHex = (byte: number): string => `0${byte.toString(16)}`.slice(-2);\n\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketId: string;\n      pointer: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n  IDLE_STATUS: {\n    type: \"IDLE_STATUS\";\n    payload: {\n      socketId: string;\n      userState: UserIdleState;\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\nexport type SocketUpdateData =\n  SocketUpdateDataSource[keyof SocketUpdateDataSource] & {\n    _brand: \"socketUpdateData\";\n  };\n\nexport const encryptAESGEM = async (\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n};\n\nexport const decryptAESGEM = async (\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted),\n    );\n    return JSON.parse(decodedData);\n  } catch (error: any) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  const hash = new URL(link).hash;\n  const match = hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n  if (match && match[2].length !== 22) {\n    window.alert(t(\"alerts.invalidEncryptionKey\"));\n    return null;\n  }\n  return match ? { roomId: match[1], roomKey: match[2] } : null;\n};\n\nexport const generateCollaborationLinkData = async () => {\n  const roomId = await generateRandomID();\n  const roomKey = await generateEncryptionKey();\n\n  if (!roomKey) {\n    throw new Error(\"Couldn't generate room key\");\n  }\n\n  return { roomId, roomKey };\n};\n\nexport const getCollaborationLink = (data: {\n  roomId: string;\n  roomKey: string;\n}) => {\n  return `${window.location.origin}${window.location.pathname}#room=${data.roomId},${data.roomKey}`;\n};\n\nexport const decryptImported = async (\n  iv: ArrayBuffer | Uint8Array,\n  encrypted: ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getImportedKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n\nconst importFromBackend = async (\n  id: string,\n  privateKey: string,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(`${BACKEND_V2_GET}${id}`);\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    const buffer = await response.arrayBuffer();\n\n    let decrypted: ArrayBuffer;\n    try {\n      // Buffer should contain both the IV (fixed length) and encrypted data\n      const iv = buffer.slice(0, IV_LENGTH_BYTES);\n      const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n      decrypted = await decryptImported(iv, encrypted, privateKey);\n    } catch (error: any) {\n      // Fixed IV (old format, backward compatibility)\n      const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n      decrypted = await decryptImported(fixedIv, buffer, privateKey);\n    }\n\n    // We need to convert the decrypted array buffer to a string\n    const string = new window.TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted),\n    );\n    const data: ImportedDataState = JSON.parse(string);\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error: any) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply local state even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  localDataState: ImportedDataState | undefined | null,\n) => {\n  let data;\n  if (id != null && privateKey != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      localDataState?.appState,\n      localDataState?.elements,\n    );\n  } else {\n    data = restore(localDataState || null, null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    // note: this will always be empty because we're not storing files\n    // in the scene database/localStorage, and instead fetch them async\n    // from a different database\n    files: data.files,\n    commitToHistory: false,\n  };\n};\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n) => {\n  const json = serializeAsJSON(elements, appState, files, \"database\");\n  const encoded = new TextEncoder().encode(json);\n\n  const cryptoKey = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n\n  const iv = createIV();\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    cryptoKey,\n    encoded,\n  );\n\n  // Concatenate IV with encrypted data (IV does not have to be secret).\n  const payloadBlob = new Blob([iv.buffer, encrypted]);\n  const payload = await new Response(payloadBlob).arrayBuffer();\n\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", cryptoKey);\n\n  try {\n    const filesMap = new Map<FileId, BinaryFileData>();\n    for (const element of elements) {\n      if (isInitializedImageElement(element) && files[element.fileId]) {\n        filesMap.set(element.fileId, files[element.fileId]);\n      }\n    }\n\n    const encryptionKey = exportedKey.k!;\n\n    const filesToUpload = await encodeFilesForUpload({\n      files: filesMap,\n      encryptionKey,\n      maxBytes: FILE_UPLOAD_MAX_BYTES,\n    });\n\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: payload,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${encryptionKey}`;\n      const urlString = url.toString();\n\n      await saveFilesToFirebase({\n        prefix: `/files/shareLinks/${json.id}`,\n        files: filesToUpload,\n      });\n\n      window.prompt(`${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      window.alert(t(\"alerts.couldNotCreateShareableLinkTooBig\"));\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error: any) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};\n","import { ExcalidrawElement } from \"../../element/types\";\nimport { AppState } from \"../../types\";\nimport {\n  clearAppStateForLocalStorage,\n  getDefaultAppState,\n} from \"../../appState\";\nimport { clearElementsForLocalStorage } from \"../../element\";\nimport { STORAGE_KEYS as APP_STORAGE_KEYS } from \"../../constants\";\n\nexport const STORAGE_KEYS = {\n  LOCAL_STORAGE_ELEMENTS: \"excalidraw\",\n  LOCAL_STORAGE_APP_STATE: \"excalidraw-state\",\n  LOCAL_STORAGE_COLLAB: \"excalidraw-collab\",\n  LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG: \"collabLinkForceLoadFlag\",\n};\n\nexport const saveUsernameToLocalStorage = (username: string) => {\n  try {\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_COLLAB,\n      JSON.stringify({ username }),\n    );\n  } catch (error: any) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\n\nexport const importUsernameFromLocalStorage = (): string | null => {\n  try {\n    const data = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_COLLAB);\n    if (data) {\n      return JSON.parse(data).username;\n    }\n  } catch (error: any) {\n    // Unable to access localStorage\n    console.error(error);\n  }\n\n  return null;\n};\n\nexport const saveToLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  try {\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS,\n      JSON.stringify(clearElementsForLocalStorage(elements)),\n    );\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_APP_STATE,\n      JSON.stringify(clearAppStateForLocalStorage(appState)),\n    );\n  } catch (error: any) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\n\nexport const importFromLocalStorage = () => {\n  let savedElements = null;\n  let savedState = null;\n\n  try {\n    savedElements = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS);\n    savedState = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_APP_STATE);\n  } catch (error: any) {\n    // Unable to access localStorage\n    console.error(error);\n  }\n\n  let elements: ExcalidrawElement[] = [];\n  if (savedElements) {\n    try {\n      elements = clearElementsForLocalStorage(JSON.parse(savedElements));\n    } catch (error: any) {\n      console.error(error);\n      // Do nothing because elements array is already empty\n    }\n  }\n\n  let appState = null;\n  if (savedState) {\n    try {\n      appState = {\n        ...getDefaultAppState(),\n        ...clearAppStateForLocalStorage(\n          JSON.parse(savedState) as Partial<AppState>,\n        ),\n      };\n    } catch (error: any) {\n      console.error(error);\n      // Do nothing because appState is already null\n    }\n  }\n  return { elements, appState };\n};\n\nexport const getElementsStorageSize = () => {\n  try {\n    const elements = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS);\n    const elementsSize = elements?.length || 0;\n    return elementsSize;\n  } catch (error: any) {\n    console.error(error);\n    return 0;\n  }\n};\n\nexport const getTotalStorageSize = () => {\n  try {\n    const appState = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_APP_STATE);\n    const collab = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_COLLAB);\n    const library = localStorage.getItem(\n      APP_STORAGE_KEYS.LOCAL_STORAGE_LIBRARY,\n    );\n\n    const appStateSize = appState?.length || 0;\n    const collabSize = collab?.length || 0;\n    const librarySize = library?.length || 0;\n\n    return appStateSize + collabSize + librarySize + getElementsStorageSize();\n  } catch (error: any) {\n    console.error(error);\n    return 0;\n  }\n};\n","import {\n  encryptAESGEM,\n  SocketUpdateData,\n  SocketUpdateDataSource,\n} from \"../data\";\n\nimport CollabWrapper from \"./CollabWrapper\";\n\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { BROADCAST, FILE_UPLOAD_TIMEOUT, SCENE } from \"../app_constants\";\nimport { UserIdleState } from \"../../types\";\nimport { trackEvent } from \"../../analytics\";\nimport { throttle } from \"lodash\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport { BroadcastedExcalidrawElement } from \"./reconciliation\";\n\nclass Portal {\n  collab: CollabWrapper;\n  socket: SocketIOClient.Socket | null = null;\n  socketInitialized: boolean = false; // we don't want the socket to emit any updates until it is fully initialized\n  roomId: string | null = null;\n  roomKey: string | null = null;\n  broadcastedElementVersions: Map<string, number> = new Map();\n\n  constructor(collab: CollabWrapper) {\n    this.collab = collab;\n  }\n\n  open(socket: SocketIOClient.Socket, id: string, key: string) {\n    this.socket = socket;\n    this.roomId = id;\n    this.roomKey = key;\n\n    // Initialize socket listeners\n    this.socket.on(\"init-room\", () => {\n      if (this.socket) {\n        this.socket.emit(\"join-room\", this.roomId);\n        trackEvent(\"share\", \"room joined\");\n      }\n    });\n    this.socket.on(\"new-user\", async (_socketId: string) => {\n      this.broadcastScene(\n        SCENE.INIT,\n        this.collab.getSceneElementsIncludingDeleted(),\n        /* syncAll */ true,\n      );\n    });\n    this.socket.on(\"room-user-change\", (clients: string[]) => {\n      this.collab.setCollaborators(clients);\n    });\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n    this.queueFileUpload.flush();\n    this.socket.close();\n    this.socket = null;\n    this.roomId = null;\n    this.roomKey = null;\n    this.socketInitialized = false;\n    this.broadcastedElementVersions = new Map();\n  }\n\n  isOpen() {\n    return !!(\n      this.socketInitialized &&\n      this.socket &&\n      this.roomId &&\n      this.roomKey\n    );\n  }\n\n  async _broadcastSocketData(\n    data: SocketUpdateData,\n    volatile: boolean = false,\n  ) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey!);\n      this.socket?.emit(\n        volatile ? BROADCAST.SERVER_VOLATILE : BROADCAST.SERVER,\n        this.roomId,\n        encrypted.data,\n        encrypted.iv,\n      );\n    }\n  }\n\n  queueFileUpload = throttle(async () => {\n    try {\n      await this.collab.fileManager.saveFiles({\n        elements: this.collab.excalidrawAPI.getSceneElementsIncludingDeleted(),\n        files: this.collab.excalidrawAPI.getFiles(),\n      });\n    } catch (error: any) {\n      if (error.name !== \"AbortError\") {\n        this.collab.excalidrawAPI.updateScene({\n          appState: {\n            errorMessage: error.message,\n          },\n        });\n      }\n    }\n\n    this.collab.excalidrawAPI.updateScene({\n      elements: this.collab.excalidrawAPI\n        .getSceneElementsIncludingDeleted()\n        .map((element) => {\n          if (this.collab.fileManager.shouldUpdateImageElementStatus(element)) {\n            // this will signal collaborators to pull image data from server\n            // (using mutation instead of newElementWith otherwise it'd break\n            // in-progress dragging)\n            return newElementWith(element, { status: \"saved\" });\n          }\n          return element;\n        }),\n    });\n  }, FILE_UPLOAD_TIMEOUT);\n\n  broadcastScene = async (\n    sceneType: SCENE.INIT | SCENE.UPDATE,\n    allElements: readonly ExcalidrawElement[],\n    syncAll: boolean,\n  ) => {\n    if (sceneType === SCENE.INIT && !syncAll) {\n      throw new Error(\"syncAll must be true when sending SCENE.INIT\");\n    }\n\n    // sync out only the elements we think we need to to save bandwidth.\n    // periodically we'll resync the whole thing to make sure no one diverges\n    // due to a dropped message (server goes down etc).\n    const syncableElements = allElements.reduce(\n      (acc, element: BroadcastedExcalidrawElement, idx, elements) => {\n        if (\n          (syncAll ||\n            !this.broadcastedElementVersions.has(element.id) ||\n            element.version >\n              this.broadcastedElementVersions.get(element.id)!) &&\n          this.collab.isSyncableElement(element)\n        ) {\n          acc.push({\n            ...element,\n            // z-index info for the reconciler\n            parent: idx === 0 ? \"^\" : elements[idx - 1]?.id,\n          });\n        }\n        return acc;\n      },\n      [] as BroadcastedExcalidrawElement[],\n    );\n\n    const data: SocketUpdateDataSource[typeof sceneType] = {\n      type: sceneType,\n      payload: {\n        elements: syncableElements,\n      },\n    };\n\n    for (const syncableElement of syncableElements) {\n      this.broadcastedElementVersions.set(\n        syncableElement.id,\n        syncableElement.version,\n      );\n    }\n\n    const broadcastPromise = this._broadcastSocketData(\n      data as SocketUpdateData,\n    );\n\n    this.queueFileUpload();\n\n    if (syncAll && this.collab.isCollaborating) {\n      await Promise.all([\n        broadcastPromise,\n        this.collab.saveCollabRoomToFirebase(syncableElements),\n      ]);\n    } else {\n      await broadcastPromise;\n    }\n  };\n\n  broadcastIdleChange = (userState: UserIdleState) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"IDLE_STATUS\"] = {\n        type: \"IDLE_STATUS\",\n        payload: {\n          socketId: this.socket.id,\n          userState,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n\n  broadcastMouseLocation = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n  }) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"MOUSE_LOCATION\"] = {\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketId: this.socket.id,\n          pointer: payload.pointer,\n          button: payload.button || \"up\",\n          selectedElementIds:\n            this.collab.excalidrawAPI.getAppState().selectedElementIds,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n}\n\nexport default Portal;\n","import React, { useRef } from \"react\";\nimport { copyTextToSystemClipboard } from \"../../clipboard\";\nimport { Dialog } from \"../../components/Dialog\";\nimport {\n  clipboard,\n  start,\n  stop,\n  share,\n  shareIOS,\n  shareWindows,\n} from \"../../components/icons\";\nimport { ToolButton } from \"../../components/ToolButton\";\nimport { t } from \"../../i18n\";\nimport \"./RoomDialog.scss\";\nimport Stack from \"../../components/Stack\";\nimport { AppState } from \"../../types\";\n\nconst getShareIcon = () => {\n  const navigator = window.navigator as any;\n  const isAppleBrowser = /Apple/.test(navigator.vendor);\n  const isWindowsBrowser = navigator.appVersion.indexOf(\"Win\") !== -1;\n\n  if (isAppleBrowser) {\n    return shareIOS;\n  } else if (isWindowsBrowser) {\n    return shareWindows;\n  }\n\n  return share;\n};\n\nconst RoomDialog = ({\n  handleClose,\n  activeRoomLink,\n  username,\n  onUsernameChange,\n  onRoomCreate,\n  onRoomDestroy,\n  setErrorMessage,\n  theme,\n}: {\n  handleClose: () => void;\n  activeRoomLink: string;\n  username: string;\n  onUsernameChange: (username: string) => void;\n  onRoomCreate: () => void;\n  onRoomDestroy: () => void;\n  setErrorMessage: (message: string) => void;\n  theme: AppState[\"theme\"];\n}) => {\n  const roomLinkInput = useRef<HTMLInputElement>(null);\n\n  const copyRoomLink = async () => {\n    try {\n      await copyTextToSystemClipboard(activeRoomLink);\n    } catch (error: any) {\n      setErrorMessage(error.message);\n    }\n    if (roomLinkInput.current) {\n      roomLinkInput.current.select();\n    }\n  };\n\n  const shareRoomLink = async () => {\n    try {\n      await navigator.share({\n        title: t(\"roomDialog.shareTitle\"),\n        text: t(\"roomDialog.shareTitle\"),\n        url: activeRoomLink,\n      });\n    } catch (error: any) {\n      // Just ignore.\n    }\n  };\n\n  const selectInput = (event: React.MouseEvent<HTMLInputElement>) => {\n    if (event.target !== document.activeElement) {\n      event.preventDefault();\n      (event.target as HTMLInputElement).select();\n    }\n  };\n\n  const renderRoomDialog = () => {\n    return (\n      <div className=\"RoomDialog-modal\">\n        {!activeRoomLink && (\n          <>\n            <p>{t(\"roomDialog.desc_intro\")}</p>\n            <p>{` ${t(\"roomDialog.desc_privacy\")}`}</p>\n            <div className=\"RoomDialog-sessionStartButtonContainer\">\n              <ToolButton\n                className=\"RoomDialog-startSession\"\n                type=\"button\"\n                icon={start}\n                title={t(\"roomDialog.button_startSession\")}\n                aria-label={t(\"roomDialog.button_startSession\")}\n                showAriaLabel={true}\n                onClick={onRoomCreate}\n              />\n            </div>\n          </>\n        )}\n        {activeRoomLink && (\n          <>\n            <p>{t(\"roomDialog.desc_inProgressIntro\")}</p>\n            <p>{t(\"roomDialog.desc_shareLink\")}</p>\n            <div className=\"RoomDialog-linkContainer\">\n              <Stack.Row gap={2}>\n                {\"share\" in navigator ? (\n                  <ToolButton\n                    type=\"button\"\n                    icon={getShareIcon()}\n                    title={t(\"labels.share\")}\n                    aria-label={t(\"labels.share\")}\n                    onClick={shareRoomLink}\n                  />\n                ) : null}\n                <ToolButton\n                  type=\"button\"\n                  icon={clipboard}\n                  title={t(\"labels.copy\")}\n                  aria-label={t(\"labels.copy\")}\n                  onClick={copyRoomLink}\n                />\n              </Stack.Row>\n              <input\n                value={activeRoomLink}\n                readOnly={true}\n                className=\"RoomDialog-link\"\n                ref={roomLinkInput}\n                onPointerDown={selectInput}\n              />\n            </div>\n            <div className=\"RoomDialog-usernameContainer\">\n              <label className=\"RoomDialog-usernameLabel\" htmlFor=\"username\">\n                {t(\"labels.yourName\")}\n              </label>\n              <input\n                id=\"username\"\n                value={username || \"\"}\n                className=\"RoomDialog-username TextInput\"\n                onChange={(event) => onUsernameChange(event.target.value)}\n                onKeyPress={(event) => event.key === \"Enter\" && handleClose()}\n              />\n            </div>\n            <p>\n              <span role=\"img\" aria-hidden=\"true\" className=\"RoomDialog-emoji\">\n                {\"\"}\n              </span>{\" \"}\n              {t(\"roomDialog.desc_privacy\")}\n            </p>\n            <p>{t(\"roomDialog.desc_exitSession\")}</p>\n            <div className=\"RoomDialog-sessionStartButtonContainer\">\n              <ToolButton\n                className=\"RoomDialog-stopSession\"\n                type=\"button\"\n                icon={stop}\n                title={t(\"roomDialog.button_stopSession\")}\n                aria-label={t(\"roomDialog.button_stopSession\")}\n                showAriaLabel={true}\n                onClick={onRoomDestroy}\n              />\n            </div>\n          </>\n        )}\n      </div>\n    );\n  };\n  return (\n    <Dialog\n      small\n      onCloseRequest={handleClose}\n      title={t(\"labels.liveCollaboration\")}\n      theme={theme}\n    >\n      {renderRoomDialog()}\n    </Dialog>\n  );\n};\n\nexport default RoomDialog;\n","import React from \"react\";\n\nexport const createInverseContext = <T extends unknown = null>(\n  initialValue: T,\n) => {\n  const Context = React.createContext(initialValue) as React.Context<T> & {\n    _updateProviderValue?: (value: T) => void;\n  };\n\n  class InverseConsumer extends React.Component {\n    state = { value: initialValue };\n    constructor(props: any) {\n      super(props);\n      Context._updateProviderValue = (value: T) => this.setState({ value });\n    }\n    render() {\n      return (\n        <Context.Provider value={this.state.value}>\n          {this.props.children}\n        </Context.Provider>\n      );\n    }\n  }\n\n  class InverseProvider extends React.Component<{ value: T }> {\n    componentDidMount() {\n      Context._updateProviderValue?.(this.props.value);\n    }\n    componentDidUpdate() {\n      Context._updateProviderValue?.(this.props.value);\n    }\n    render() {\n      return <Context.Consumer>{() => this.props.children}</Context.Consumer>;\n    }\n  }\n\n  return {\n    Context,\n    Consumer: InverseConsumer,\n    Provider: InverseProvider,\n  };\n};\n","import { ExcalidrawElement } from \"../../element/types\";\nimport { AppState } from \"../../types\";\n\nexport type ReconciledElements = readonly ExcalidrawElement[] & {\n  _brand: \"reconciledElements\";\n};\n\nexport type BroadcastedExcalidrawElement = ExcalidrawElement & {\n  parent?: string;\n};\n\nconst shouldDiscardRemoteElement = (\n  localAppState: AppState,\n  local: ExcalidrawElement | undefined,\n  remote: BroadcastedExcalidrawElement,\n): boolean => {\n  if (\n    local &&\n    // local element is being edited\n    (local.id === localAppState.editingElement?.id ||\n      local.id === localAppState.resizingElement?.id ||\n      local.id === localAppState.draggingElement?.id ||\n      // local element is newer\n      local.version > remote.version ||\n      // resolve conflicting edits deterministically by taking the one with\n      // the lowest versionNonce\n      (local.version === remote.version &&\n        local.versionNonce < remote.versionNonce))\n  ) {\n    return true;\n  }\n  return false;\n};\n\nconst getElementsMapWithIndex = <T extends ExcalidrawElement>(\n  elements: readonly T[],\n) =>\n  elements.reduce(\n    (\n      acc: {\n        [key: string]: [element: T, index: number] | undefined;\n      },\n      element: T,\n      idx,\n    ) => {\n      acc[element.id] = [element, idx];\n      return acc;\n    },\n    {},\n  );\n\nexport const reconcileElements = (\n  localElements: readonly ExcalidrawElement[],\n  remoteElements: readonly BroadcastedExcalidrawElement[],\n  localAppState: AppState,\n): ReconciledElements => {\n  const localElementsData =\n    getElementsMapWithIndex<ExcalidrawElement>(localElements);\n\n  const reconciledElements: ExcalidrawElement[] = localElements.slice();\n\n  const duplicates = new WeakMap<ExcalidrawElement, true>();\n\n  let cursor = 0;\n  let offset = 0;\n\n  let remoteElementIdx = -1;\n  for (const remoteElement of remoteElements) {\n    remoteElementIdx++;\n\n    const local = localElementsData[remoteElement.id];\n\n    if (shouldDiscardRemoteElement(localAppState, local?.[0], remoteElement)) {\n      if (remoteElement.parent) {\n        delete remoteElement.parent;\n      }\n\n      continue;\n    }\n\n    if (local) {\n      // mark for removal since it'll be replaced with the remote element\n      duplicates.set(local[0], true);\n    }\n\n    // parent may not be defined in case the remote client is running an older\n    // excalidraw version\n    const parent =\n      remoteElement.parent || remoteElements[remoteElementIdx - 1]?.id || null;\n\n    if (parent != null) {\n      delete remoteElement.parent;\n\n      // ^ indicates the element is the first in elements array\n      if (parent === \"^\") {\n        offset++;\n        if (cursor === 0) {\n          reconciledElements.unshift(remoteElement);\n          localElementsData[remoteElement.id] = [\n            remoteElement,\n            cursor - offset,\n          ];\n        } else {\n          reconciledElements.splice(cursor + 1, 0, remoteElement);\n          localElementsData[remoteElement.id] = [\n            remoteElement,\n            cursor + 1 - offset,\n          ];\n          cursor++;\n        }\n      } else {\n        let idx = localElementsData[parent]\n          ? localElementsData[parent]![1]\n          : null;\n        if (idx != null) {\n          idx += offset;\n        }\n        if (idx != null && idx >= cursor) {\n          reconciledElements.splice(idx + 1, 0, remoteElement);\n          offset++;\n          localElementsData[remoteElement.id] = [\n            remoteElement,\n            idx + 1 - offset,\n          ];\n          cursor = idx + 1;\n        } else if (idx != null) {\n          reconciledElements.splice(cursor + 1, 0, remoteElement);\n          offset++;\n          localElementsData[remoteElement.id] = [\n            remoteElement,\n            cursor + 1 - offset,\n          ];\n          cursor++;\n        } else {\n          reconciledElements.push(remoteElement);\n          localElementsData[remoteElement.id] = [\n            remoteElement,\n            reconciledElements.length - 1 - offset,\n          ];\n        }\n      }\n      // no parent z-index information, local element exists  replace in place\n    } else if (local) {\n      reconciledElements[local[1]] = remoteElement;\n      localElementsData[remoteElement.id] = [remoteElement, local[1]];\n      // otherwise push to the end\n    } else {\n      reconciledElements.push(remoteElement);\n      localElementsData[remoteElement.id] = [\n        remoteElement,\n        reconciledElements.length - 1 - offset,\n      ];\n    }\n  }\n\n  const ret: readonly ExcalidrawElement[] = reconciledElements.filter(\n    (element) => !duplicates.has(element),\n  );\n\n  return ret as ReconciledElements;\n};\n","import throttle from \"lodash.throttle\";\nimport { PureComponent } from \"react\";\nimport { ExcalidrawImperativeAPI } from \"../../types\";\nimport { ErrorDialog } from \"../../components/ErrorDialog\";\nimport { APP_NAME, ENV, EVENT } from \"../../constants\";\nimport { ImportedDataState } from \"../../data/types\";\nimport {\n  ExcalidrawElement,\n  InitializedExcalidrawImageElement,\n} from \"../../element/types\";\nimport { getSceneVersion } from \"../../packages/excalidraw/index\";\nimport { Collaborator, Gesture } from \"../../types\";\nimport {\n  preventUnload,\n  resolvablePromise,\n  withBatchedUpdates,\n} from \"../../utils\";\nimport {\n  FILE_UPLOAD_MAX_BYTES,\n  FIREBASE_STORAGE_PREFIXES,\n  INITIAL_SCENE_UPDATE_TIMEOUT,\n  LOAD_IMAGES_TIMEOUT,\n  SCENE,\n  SYNC_FULL_SCENE_INTERVAL_MS,\n} from \"../app_constants\";\nimport {\n  decryptAESGEM,\n  generateCollaborationLinkData,\n  getCollaborationLink,\n  SocketUpdateDataSource,\n  SOCKET_SERVER,\n} from \"../data\";\nimport {\n  isSavedToFirebase,\n  loadFilesFromFirebase,\n  loadFromFirebase,\n  saveFilesToFirebase,\n  saveToFirebase,\n} from \"../data/firebase\";\nimport {\n  importUsernameFromLocalStorage,\n  saveUsernameToLocalStorage,\n  STORAGE_KEYS,\n} from \"../data/localStorage\";\nimport Portal from \"./Portal\";\nimport RoomDialog from \"./RoomDialog\";\nimport { createInverseContext } from \"../../createInverseContext\";\nimport { t } from \"../../i18n\";\nimport { UserIdleState } from \"../../types\";\nimport { IDLE_THRESHOLD, ACTIVE_THRESHOLD } from \"../../constants\";\nimport { trackEvent } from \"../../analytics\";\nimport { isInvisiblySmallElement } from \"../../element\";\nimport {\n  encodeFilesForUpload,\n  FileManager,\n  updateStaleImageStatuses,\n} from \"../data/FileManager\";\nimport { AbortError } from \"../../errors\";\nimport {\n  isImageElement,\n  isInitializedImageElement,\n} from \"../../element/typeChecks\";\nimport { newElementWith } from \"../../element/mutateElement\";\nimport {\n  ReconciledElements,\n  reconcileElements as _reconcileElements,\n} from \"./reconciliation\";\n\ninterface CollabState {\n  modalIsShown: boolean;\n  errorMessage: string;\n  username: string;\n  userState: UserIdleState;\n  activeRoomLink: string;\n}\n\ntype CollabInstance = InstanceType<typeof CollabWrapper>;\n\nexport interface CollabAPI {\n  /** function so that we can access the latest value from stale callbacks */\n  isCollaborating: () => boolean;\n  username: CollabState[\"username\"];\n  userState: CollabState[\"userState\"];\n  onPointerUpdate: CollabInstance[\"onPointerUpdate\"];\n  initializeSocketClient: CollabInstance[\"initializeSocketClient\"];\n  onCollabButtonClick: CollabInstance[\"onCollabButtonClick\"];\n  broadcastElements: CollabInstance[\"broadcastElements\"];\n  fetchImageFilesFromFirebase: CollabInstance[\"fetchImageFilesFromFirebase\"];\n}\n\ninterface Props {\n  excalidrawAPI: ExcalidrawImperativeAPI;\n  onRoomClose?: () => void;\n}\n\nconst {\n  Context: CollabContext,\n  Consumer: CollabContextConsumer,\n  Provider: CollabContextProvider,\n} = createInverseContext<{ api: CollabAPI | null }>({ api: null });\n\nexport { CollabContext, CollabContextConsumer };\n\nclass CollabWrapper extends PureComponent<Props, CollabState> {\n  portal: Portal;\n  fileManager: FileManager;\n  excalidrawAPI: Props[\"excalidrawAPI\"];\n  isCollaborating: boolean = false;\n  activeIntervalId: number | null;\n  idleTimeoutId: number | null;\n\n  private socketInitializationTimer?: number;\n  private lastBroadcastedOrReceivedSceneVersion: number = -1;\n  private collaborators = new Map<string, Collaborator>();\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      modalIsShown: false,\n      errorMessage: \"\",\n      username: importUsernameFromLocalStorage() || \"\",\n      userState: UserIdleState.ACTIVE,\n      activeRoomLink: \"\",\n    };\n    this.portal = new Portal(this);\n    this.fileManager = new FileManager({\n      getFiles: async (fileIds) => {\n        const { roomId, roomKey } = this.portal;\n        if (!roomId || !roomKey) {\n          throw new AbortError();\n        }\n\n        return loadFilesFromFirebase(`files/rooms/${roomId}`, roomKey, fileIds);\n      },\n      saveFiles: async ({ addedFiles }) => {\n        const { roomId, roomKey } = this.portal;\n        if (!roomId || !roomKey) {\n          throw new AbortError();\n        }\n\n        return saveFilesToFirebase({\n          prefix: `${FIREBASE_STORAGE_PREFIXES.collabFiles}/${roomId}`,\n          files: await encodeFilesForUpload({\n            files: addedFiles,\n            encryptionKey: roomKey,\n            maxBytes: FILE_UPLOAD_MAX_BYTES,\n          }),\n        });\n      },\n    });\n    this.excalidrawAPI = props.excalidrawAPI;\n    this.activeIntervalId = null;\n    this.idleTimeoutId = null;\n  }\n\n  componentDidMount() {\n    window.addEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload);\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      window.collab = window.collab || ({} as Window[\"collab\"]);\n      Object.defineProperties(window, {\n        collab: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload);\n    window.removeEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    window.removeEventListener(\n      EVENT.VISIBILITY_CHANGE,\n      this.onVisibilityChange,\n    );\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n  }\n\n  private onUnload = () => {\n    this.destroySocketClient({ isUnload: true });\n  };\n\n  private beforeUnload = withBatchedUpdates((event: BeforeUnloadEvent) => {\n    const syncableElements = this.getSyncableElements(\n      this.getSceneElementsIncludingDeleted(),\n    );\n\n    if (\n      this.isCollaborating &&\n      (this.fileManager.shouldPreventUnload(syncableElements) ||\n        !isSavedToFirebase(this.portal, syncableElements))\n    ) {\n      // this won't run in time if user decides to leave the site, but\n      //  the purpose is to run in immediately after user decides to stay\n      this.saveCollabRoomToFirebase(syncableElements);\n\n      preventUnload(event);\n    }\n\n    if (this.isCollaborating || this.portal.roomId) {\n      try {\n        localStorage?.setItem(\n          STORAGE_KEYS.LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG,\n          JSON.stringify({\n            timestamp: Date.now(),\n            room: this.portal.roomId,\n          }),\n        );\n      } catch {}\n    }\n  });\n\n  saveCollabRoomToFirebase = async (\n    syncableElements: readonly ExcalidrawElement[] = this.getSyncableElements(\n      this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n    ),\n  ) => {\n    try {\n      await saveToFirebase(this.portal, syncableElements);\n    } catch (error: any) {\n      console.error(error);\n    }\n  };\n\n  openPortal = async () => {\n    trackEvent(\"share\", \"room creation\");\n    return this.initializeSocketClient(null);\n  };\n\n  closePortal = () => {\n    this.queueBroadcastAllElements.cancel();\n    this.loadImageFiles.cancel();\n\n    this.saveCollabRoomToFirebase();\n    if (window.confirm(t(\"alerts.collabStopOverridePrompt\"))) {\n      window.history.pushState({}, APP_NAME, window.location.origin);\n      this.destroySocketClient();\n      trackEvent(\"share\", \"room closed\");\n\n      this.props.onRoomClose?.();\n\n      const elements = this.excalidrawAPI\n        .getSceneElementsIncludingDeleted()\n        .map((element) => {\n          if (isImageElement(element) && element.status === \"saved\") {\n            return newElementWith(element, { status: \"pending\" });\n          }\n          return element;\n        });\n\n      this.excalidrawAPI.updateScene({\n        elements,\n        commitToHistory: false,\n      });\n    }\n  };\n\n  private destroySocketClient = (opts?: { isUnload: boolean }) => {\n    if (!opts?.isUnload) {\n      this.collaborators = new Map();\n      this.excalidrawAPI.updateScene({\n        collaborators: this.collaborators,\n      });\n      this.setState({\n        activeRoomLink: \"\",\n      });\n      this.isCollaborating = false;\n    }\n    this.lastBroadcastedOrReceivedSceneVersion = -1;\n    this.portal.close();\n    this.fileManager.reset();\n  };\n\n  private fetchImageFilesFromFirebase = async (scene: {\n    elements: readonly ExcalidrawElement[];\n  }) => {\n    const unfetchedImages = scene.elements\n      .filter((element) => {\n        return (\n          isInitializedImageElement(element) &&\n          !this.fileManager.isFileHandled(element.fileId) &&\n          !element.isDeleted &&\n          element.status === \"saved\"\n        );\n      })\n      .map((element) => (element as InitializedExcalidrawImageElement).fileId);\n\n    return await this.fileManager.getFiles(unfetchedImages);\n  };\n\n  private initializeSocketClient = async (\n    existingRoomLinkData: null | { roomId: string; roomKey: string },\n  ): Promise<ImportedDataState | null> => {\n    if (this.portal.socket) {\n      return null;\n    }\n\n    let roomId;\n    let roomKey;\n\n    if (existingRoomLinkData) {\n      ({ roomId, roomKey } = existingRoomLinkData);\n    } else {\n      ({ roomId, roomKey } = await generateCollaborationLinkData());\n      window.history.pushState(\n        {},\n        APP_NAME,\n        getCollaborationLink({ roomId, roomKey }),\n      );\n    }\n\n    const scenePromise = resolvablePromise<ImportedDataState | null>();\n\n    this.isCollaborating = true;\n\n    const { default: socketIOClient }: any = await import(\n      /* webpackChunkName: \"socketIoClient\" */ \"socket.io-client\"\n    );\n\n    this.portal.open(socketIOClient(SOCKET_SERVER), roomId, roomKey);\n\n    if (existingRoomLinkData) {\n      this.excalidrawAPI.resetScene();\n\n      try {\n        const elements = await loadFromFirebase(\n          roomId,\n          roomKey,\n          this.portal.socket,\n        );\n        if (elements) {\n          scenePromise.resolve({\n            elements,\n            scrollToContent: true,\n          });\n        }\n      } catch (error: any) {\n        // log the error and move on. other peers will sync us the scene.\n        console.error(error);\n      }\n    } else {\n      const elements = this.excalidrawAPI.getSceneElements().map((element) => {\n        if (isImageElement(element) && element.status === \"saved\") {\n          return newElementWith(element, { status: \"pending\" });\n        }\n        return element;\n      });\n      // remove deleted elements from elements array & history to ensure we don't\n      // expose potentially sensitive user data in case user manually deletes\n      // existing elements (or clears scene), which would otherwise be persisted\n      // to database even if deleted before creating the room.\n      this.excalidrawAPI.history.clear();\n      this.excalidrawAPI.updateScene({\n        elements,\n        commitToHistory: true,\n      });\n\n      this.broadcastElements(elements);\n\n      const syncableElements = this.getSyncableElements(elements);\n      this.saveCollabRoomToFirebase(syncableElements);\n    }\n\n    // fallback in case you're not alone in the room but still don't receive\n    // initial SCENE_UPDATE message\n    this.socketInitializationTimer = window.setTimeout(() => {\n      this.initializeSocket();\n      scenePromise.resolve(null);\n    }, INITIAL_SCENE_UPDATE_TIMEOUT);\n\n    // All socket listeners are moving to Portal\n    this.portal.socket!.on(\n      \"client-broadcast\",\n      async (encryptedData: ArrayBuffer, iv: Uint8Array) => {\n        if (!this.portal.roomKey) {\n          return;\n        }\n        const decryptedData = await decryptAESGEM(\n          encryptedData,\n          this.portal.roomKey,\n          iv,\n        );\n\n        switch (decryptedData.type) {\n          case \"INVALID_RESPONSE\":\n            return;\n          case SCENE.INIT: {\n            if (!this.portal.socketInitialized) {\n              this.initializeSocket();\n              const remoteElements = decryptedData.payload.elements;\n              const reconciledElements = this.reconcileElements(remoteElements);\n              this.handleRemoteSceneUpdate(reconciledElements, {\n                init: true,\n              });\n              // noop if already resolved via init from firebase\n              scenePromise.resolve({\n                elements: reconciledElements,\n                scrollToContent: true,\n              });\n            }\n            break;\n          }\n          case SCENE.UPDATE:\n            this.handleRemoteSceneUpdate(\n              this.reconcileElements(decryptedData.payload.elements),\n            );\n            break;\n          case \"MOUSE_LOCATION\": {\n            const { pointer, button, username, selectedElementIds } =\n              decryptedData.payload;\n            const socketId: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"socketId\"] =\n              decryptedData.payload.socketId ||\n              // @ts-ignore legacy, see #2094 (#2097)\n              decryptedData.payload.socketID;\n\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.pointer = pointer;\n            user.button = button;\n            user.selectedElementIds = selectedElementIds;\n            user.username = username;\n            collaborators.set(socketId, user);\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n          case \"IDLE_STATUS\": {\n            const { userState, socketId, username } = decryptedData.payload;\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.userState = userState;\n            user.username = username;\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n        }\n      },\n    );\n\n    this.portal.socket!.on(\"first-in-room\", () => {\n      if (this.portal.socket) {\n        this.portal.socket.off(\"first-in-room\");\n      }\n      this.initializeSocket();\n      scenePromise.resolve(null);\n    });\n\n    this.initializeIdleDetector();\n\n    this.setState({\n      activeRoomLink: window.location.href,\n    });\n\n    return scenePromise;\n  };\n\n  private initializeSocket = () => {\n    this.portal.socketInitialized = true;\n    clearTimeout(this.socketInitializationTimer!);\n  };\n\n  private reconcileElements = (\n    remoteElements: readonly ExcalidrawElement[],\n  ): ReconciledElements => {\n    const localElements = this.getSceneElementsIncludingDeleted();\n    const appState = this.excalidrawAPI.getAppState();\n\n    const reconciledElements = _reconcileElements(\n      localElements,\n      remoteElements,\n      appState,\n    );\n\n    // Avoid broadcasting to the rest of the collaborators the scene\n    // we just received!\n    // Note: this needs to be set before updating the scene as it\n    // synchronously calls render.\n    this.setLastBroadcastedOrReceivedSceneVersion(\n      getSceneVersion(reconciledElements),\n    );\n\n    return reconciledElements;\n  };\n\n  private loadImageFiles = throttle(async () => {\n    const { loadedFiles, erroredFiles } =\n      await this.fetchImageFilesFromFirebase({\n        elements: this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n      });\n\n    this.excalidrawAPI.addFiles(loadedFiles);\n\n    updateStaleImageStatuses({\n      excalidrawAPI: this.excalidrawAPI,\n      erroredFiles,\n      elements: this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n    });\n  }, LOAD_IMAGES_TIMEOUT);\n\n  private handleRemoteSceneUpdate = (\n    elements: ReconciledElements,\n    { init = false }: { init?: boolean } = {},\n  ) => {\n    this.excalidrawAPI.updateScene({\n      elements,\n      commitToHistory: !!init,\n    });\n\n    // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n    // when we receive any messages from another peer. This UX can be pretty rough -- if you\n    // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n    // right now we think this is the right tradeoff.\n    this.excalidrawAPI.history.clear();\n\n    this.loadImageFiles();\n  };\n\n  private onPointerMove = () => {\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n    this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n    if (!this.activeIntervalId) {\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n    }\n  };\n\n  private onVisibilityChange = () => {\n    if (document.hidden) {\n      if (this.idleTimeoutId) {\n        window.clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = null;\n      }\n      if (this.activeIntervalId) {\n        window.clearInterval(this.activeIntervalId);\n        this.activeIntervalId = null;\n      }\n      this.onIdleStateChange(UserIdleState.AWAY);\n    } else {\n      this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n      this.onIdleStateChange(UserIdleState.ACTIVE);\n    }\n  };\n\n  private reportIdle = () => {\n    this.onIdleStateChange(UserIdleState.IDLE);\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n  };\n\n  private reportActive = () => {\n    this.onIdleStateChange(UserIdleState.ACTIVE);\n  };\n\n  private initializeIdleDetector = () => {\n    document.addEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    document.addEventListener(EVENT.VISIBILITY_CHANGE, this.onVisibilityChange);\n  };\n\n  setCollaborators(sockets: string[]) {\n    this.setState((state) => {\n      const collaborators: InstanceType<typeof CollabWrapper>[\"collaborators\"] =\n        new Map();\n      for (const socketId of sockets) {\n        if (this.collaborators.has(socketId)) {\n          collaborators.set(socketId, this.collaborators.get(socketId)!);\n        } else {\n          collaborators.set(socketId, {});\n        }\n      }\n      this.collaborators = collaborators;\n      this.excalidrawAPI.updateScene({ collaborators });\n    });\n  }\n\n  public setLastBroadcastedOrReceivedSceneVersion = (version: number) => {\n    this.lastBroadcastedOrReceivedSceneVersion = version;\n  };\n\n  public getLastBroadcastedOrReceivedSceneVersion = () => {\n    return this.lastBroadcastedOrReceivedSceneVersion;\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.excalidrawAPI.getSceneElementsIncludingDeleted();\n  };\n\n  onPointerUpdate = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n    pointersMap: Gesture[\"pointers\"];\n  }) => {\n    payload.pointersMap.size < 2 &&\n      this.portal.socket &&\n      this.portal.broadcastMouseLocation(payload);\n  };\n\n  onIdleStateChange = (userState: UserIdleState) => {\n    this.setState({ userState });\n    this.portal.broadcastIdleChange(userState);\n  };\n\n  broadcastElements = (elements: readonly ExcalidrawElement[]) => {\n    if (\n      getSceneVersion(elements) >\n      this.getLastBroadcastedOrReceivedSceneVersion()\n    ) {\n      this.portal.broadcastScene(SCENE.UPDATE, elements, false);\n      this.lastBroadcastedOrReceivedSceneVersion = getSceneVersion(elements);\n      this.queueBroadcastAllElements();\n    }\n  };\n\n  queueBroadcastAllElements = throttle(() => {\n    this.portal.broadcastScene(\n      SCENE.UPDATE,\n      this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n      true,\n    );\n    const currentVersion = this.getLastBroadcastedOrReceivedSceneVersion();\n    const newVersion = Math.max(\n      currentVersion,\n      getSceneVersion(this.getSceneElementsIncludingDeleted()),\n    );\n    this.setLastBroadcastedOrReceivedSceneVersion(newVersion);\n  }, SYNC_FULL_SCENE_INTERVAL_MS);\n\n  handleClose = () => {\n    this.setState({ modalIsShown: false });\n  };\n\n  onUsernameChange = (username: string) => {\n    this.setState({ username });\n    saveUsernameToLocalStorage(username);\n  };\n\n  onCollabButtonClick = () => {\n    this.setState({\n      modalIsShown: true,\n    });\n  };\n\n  isSyncableElement = (element: ExcalidrawElement) => {\n    return element.isDeleted || !isInvisiblySmallElement(element);\n  };\n\n  getSyncableElements = (elements: readonly ExcalidrawElement[]) =>\n    elements.filter((element) => this.isSyncableElement(element));\n\n  /** PRIVATE. Use `this.getContextValue()` instead. */\n  private contextValue: CollabAPI | null = null;\n\n  /** Getter of context value. Returned object is stable. */\n  getContextValue = (): CollabAPI => {\n    if (!this.contextValue) {\n      this.contextValue = {} as CollabAPI;\n    }\n\n    this.contextValue.isCollaborating = () => this.isCollaborating;\n    this.contextValue.username = this.state.username;\n    this.contextValue.onPointerUpdate = this.onPointerUpdate;\n    this.contextValue.initializeSocketClient = this.initializeSocketClient;\n    this.contextValue.onCollabButtonClick = this.onCollabButtonClick;\n    this.contextValue.broadcastElements = this.broadcastElements;\n    this.contextValue.fetchImageFilesFromFirebase =\n      this.fetchImageFilesFromFirebase;\n    return this.contextValue;\n  };\n\n  render() {\n    const { modalIsShown, username, errorMessage, activeRoomLink } = this.state;\n\n    return (\n      <>\n        {modalIsShown && (\n          <RoomDialog\n            handleClose={this.handleClose}\n            activeRoomLink={activeRoomLink}\n            username={username}\n            onUsernameChange={this.onUsernameChange}\n            onRoomCreate={this.openPortal}\n            onRoomDestroy={this.closePortal}\n            setErrorMessage={(errorMessage) => {\n              this.setState({ errorMessage });\n            }}\n            theme={this.excalidrawAPI.getAppState().theme}\n          />\n        )}\n        {errorMessage && (\n          <ErrorDialog\n            message={errorMessage}\n            onClose={() => this.setState({ errorMessage: \"\" })}\n          />\n        )}\n        <CollabContextProvider\n          value={{\n            api: this.getContextValue(),\n          }}\n        />\n      </>\n    );\n  }\n}\n\ndeclare global {\n  interface Window {\n    collab: InstanceType<typeof CollabWrapper>;\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.collab = window.collab || ({} as Window[\"collab\"]);\n}\n\nexport default CollabWrapper;\n","import React from \"react\";\nimport * as i18n from \"../../i18n\";\n\nexport const LanguageList = ({\n  onChange,\n  languages = i18n.languages,\n  currentLangCode = i18n.getLanguage().code,\n}: {\n  languages?: { code: string; label: string }[];\n  onChange: (langCode: i18n.Language[\"code\"]) => void;\n  currentLangCode?: i18n.Language[\"code\"];\n}) => (\n  <React.Fragment>\n    <select\n      className=\"dropdown-select dropdown-select__language\"\n      onChange={({ target }) => onChange(target.value)}\n      value={currentLangCode}\n      aria-label={i18n.t(\"buttons.selectLanguage\")}\n    >\n      <option key={i18n.defaultLang.code} value={i18n.defaultLang.code}>\n        {i18n.defaultLang.label}\n      </option>\n      {languages.map((lang) => (\n        <option key={lang.code} value={lang.code}>\n          {lang.label}\n        </option>\n      ))}\n    </select>\n  </React.Fragment>\n);\n","import { useEffect, useState } from \"react\";\nimport { debounce, getVersion, nFormatter } from \"../utils\";\nimport {\n  getElementsStorageSize,\n  getTotalStorageSize,\n} from \"./data/localStorage\";\nimport { DEFAULT_VERSION } from \"../constants\";\nimport { t } from \"../i18n\";\nimport { copyTextToSystemClipboard } from \"../clipboard\";\ntype StorageSizes = { scene: number; total: number };\n\nconst STORAGE_SIZE_TIMEOUT = 500;\n\nconst getStorageSizes = debounce((cb: (sizes: StorageSizes) => void) => {\n  cb({\n    scene: getElementsStorageSize(),\n    total: getTotalStorageSize(),\n  });\n}, STORAGE_SIZE_TIMEOUT);\n\ntype Props = {\n  setToastMessage: (message: string) => void;\n};\nconst CustomStats = (props: Props) => {\n  const [storageSizes, setStorageSizes] = useState<StorageSizes>({\n    scene: 0,\n    total: 0,\n  });\n\n  useEffect(() => {\n    getStorageSizes((sizes) => {\n      setStorageSizes(sizes);\n    });\n  });\n  useEffect(() => () => getStorageSizes.cancel(), []);\n\n  const version = getVersion();\n  let hash;\n  let timestamp;\n\n  if (version !== DEFAULT_VERSION) {\n    timestamp = version.slice(0, 16).replace(\"T\", \" \");\n    hash = version.slice(21);\n  } else {\n    timestamp = t(\"stats.versionNotAvailable\");\n  }\n\n  return (\n    <>\n      <tr>\n        <th colSpan={2}>{t(\"stats.storage\")}</th>\n      </tr>\n      <tr>\n        <td>{t(\"stats.scene\")}</td>\n        <td>{nFormatter(storageSizes.scene, 1)}</td>\n      </tr>\n      <tr>\n        <td>{t(\"stats.total\")}</td>\n        <td>{nFormatter(storageSizes.total, 1)}</td>\n      </tr>\n      <tr>\n        <th colSpan={2}>{t(\"stats.version\")}</th>\n      </tr>\n      <tr>\n        <td\n          colSpan={2}\n          style={{ textAlign: \"center\", cursor: \"pointer\" }}\n          onClick={async () => {\n            try {\n              await copyTextToSystemClipboard(getVersion());\n              props.setToastMessage(t(\"toast.copyToClipboard\"));\n            } catch {}\n          }}\n          title={t(\"stats.versionCopy\")}\n        >\n          {timestamp}\n          <br />\n          {hash}\n        </td>\n      </tr>\n    </>\n  );\n};\n\nexport default CustomStats;\n","import { createIcon } from \"../../components/icons\";\n\nexport const excalidrawPlusIcon = createIcon(\n  <>\n    <path\n      d=\"M72.652 63.598c-1.368.91-1.191 2.833-.953 4.572.702 5.104.47 5.323 1.073 7.016.649 1.826.433 2.553-.08 3.292-.406.588-1.207 1.371-1.906 1.516-.98.204-2.967.01-3.922-.246-.643-.174-1.292-.94-1.598-1.53-.389-.751-1.256-1.951-.694-3.593.56-1.64 1.325-5.374 1.363-6.108.098-1.904.02-3.934-1.085-5.014-1.104-1.082-3.941-1.055-5.739-1.038-1.723.017-3.583 1.207-5.045 1.141-1.343-.061-2.939-.686-3.728-1.536-.79-.852-1.082-2.469-1.007-3.57.074-1.1.726-2.398 1.454-3.033.727-.635 1.91-.867 2.909-.777 1.472.13 4.1 1.342 5.928 1.564 1.67.203 4.016.501 5.04-.227 1.021-.73 1.048-2.717 1.094-4.145.07-2.063-1.021-6.528-.683-8.23.22-1.098 1.709-1.696 2.717-1.979 1.007-.282 2.521-.125 3.328.285.788.398 1.499 1.29 1.516 2.173.031 1.68-1.209 5.66-1.322 7.905-.058 1.133-.61 3.124.482 3.764 1.264.74 2.95 1.778 7.1.673 1.765-.47 3.157-.689 4.62-.622 1.342.06 2.939.685 3.728 1.536.787.85 1.08 2.468 1.006 3.568-.074 1.101-.726 2.4-1.454 3.035-.727.634-1.908.866-2.908.777-1.473-.13-3.164-.68-4.88-1.248-2.526-.835-5.176-.708-6.354.079z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M51.396 25.807c0 .237-.285.474-.617.474-.284 0-1.09 1.328-1.708 2.941-1.897 4.934-20.873 42.46-20.92 41.273 0-.616-.285-1.043-.76-1.043-.664 0-.759.38-.474 2.23.284 2.134.095 2.609-6.642 15.702-3.795 7.448-7.875 15.228-9.06 17.316-1.234 2.182-2.183 4.554-2.278 5.55-.142 1.708.047 1.945 4.175 5.503 2.372 2.088 5.408 4.697 6.736 5.883 5.978 5.456 8.777 7.638 9.536 7.496 1.138-.19 18.739-18.644 18.786-19.688 0-.475-.854-7.685-1.898-16.035-1.802-14.232-3.51-30.884-3.32-32.497.142-.996-.57-6.024-1.092-8.207-.426-1.708-.237-2.42 3.179-10.2 1.992-4.601 4.602-10.247 5.74-12.524 1.091-2.277 2.04-4.27 2.04-4.412 0-.142-.332-.237-.711-.237-.38 0-.712.19-.712.475zM40.485 61.245c.522 3.32 1.565 11.29 2.324 17.695 1.47 11.765 3.179 24.811 3.653 28.132.285 1.66.095 1.992-2.989 5.408-5.36 6.025-11.053 11.955-12.998 13.473l-1.803 1.423-9.25-8.634c-8.54-7.875-9.252-8.681-8.73-9.63.285-.522 2.704-4.934 5.361-9.773 2.657-4.839 6.167-11.29 7.78-14.327 1.66-3.084 3.179-5.74 3.463-5.882.332-.19.427 4.601.332 14.8-.19 15.23-.142 15.277 1.376 14.945.19 0 .332-7.686.332-17.031V74.86l4.981-9.963c2.752-5.503 5.03-9.915 5.124-9.867.095.047.57 2.846 1.044 6.215zM20.228 3.842c-3.51 2.799-8.919 7.543-13.189 11.623l-3.368 3.178.617 4.175c.332 2.277.949 6.736 1.328 9.867.427 3.132.854 6.073.996 6.5.19.57 0 .854-.521.854-.902 0-.95-.237 1.518 7.59.901 2.989 1.755 5.74 1.85 6.025.095.332.474.474.901.332.427-.19.664-.57.522-.901-.142-.38.095-.76.474-.902.522-.19.475-.569-.332-1.945-1.28-2.134-4.554-20.352-4.744-26.234-.142-4.175-.142-4.222 1.613-6.594 1.708-2.325 5.646-5.835 11.718-10.295 1.708-1.28 3.416-2.704 3.89-3.178.712-.854 1.044-.617 7.021 5.74 3.463 3.653 7.306 7.4 8.54 8.35l2.277 1.707-1.756 3.7c-.948 1.993-4.791 9.678-8.586 16.984-7.923 15.37-6.31 13.9-15.513 14.043l-5.978.047-1.992 2.277c-2.088 2.42-2.372 3.32-1.376 4.839.38.522.664 1.376.664 1.898 0 .854.332.996 2.23 1.09 1.186.048 2.277.19 2.42.333.142.142.331 3.083.474 6.547l.19 6.262-3.179 6.831c-5.266 11.386-7.353 16.604-7.353 18.312 0 .901.19 1.66.38 1.66.474 0 .474-.047 19.782-40.324 8.966-18.691 17.458-36.292 18.881-39.185 1.423-2.894 2.704-5.55 2.799-5.93.095-.427-3.178-3.7-8.397-8.303-4.696-4.174-8.824-7.97-9.203-8.396-1.091-1.329-2.704-.902-5.598 1.423zm-2.372 62.147c-.38.996-1.376 3.083-2.183 4.649-1.328 2.656-1.47 2.751-1.802 1.66-.19-.664-.332-2.61-.38-4.364-.047-3.464-.142-3.416 3.843-3.653l1.28-.048-.758 1.756zm3.985-7.59c-2.183 4.221-2.277 4.269-8.255 4.553-5.266.285-5.36.238-5.36-.759 0-.569-.19-1.328-.428-1.708-.284-.426-.094-1.186.57-2.23l1.043-1.612h4.744c2.61-.048 5.598-.237 6.642-.427 1.044-.19 1.945-.285 2.04-.237.095.047-.38 1.138-.996 2.42zm-.19-43.266c-.854.616-1.091 1.233-1.091 2.799 0 1.85.142 2.134 1.423 2.656 1.28.522 1.613.475 3.084-.522 1.945-1.328 1.992-1.66.569-3.795-1.234-1.85-2.467-2.182-3.985-1.138z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M50.141 24.917c.352-.615 1.06-1.085 1.967-1.085.804 0 1.477.34 1.734.597.342.342.477.74.477 1.14 0 .089-.006.305-.119.612-.168.461-1.056 2.337-2.08 4.471-1.131 2.264-3.724 7.875-5.708 12.457-1.671 3.806-2.558 5.881-2.97 7.216-.301.975-.279 1.406-.123 2.032.558 2.33 1.27 7.704 1.122 8.73-.187 1.596 1.537 18.06 3.32 32.136 1.056 8.446 1.91 15.74 1.91 16.22l-.002.07c-.009.184-.087.607-.447 1.14-.506.747-1.932 2.414-3.805 4.476-4.242 4.672-10.806 11.46-13.673 14.059-.682.617-1.199 1.023-1.472 1.182a1.872 1.872 0 01-.612.236c-.41.077-1.225-.015-2.35-.737-1.495-.959-4.19-3.217-8.46-7.114-1.327-1.184-4.36-3.79-6.718-5.865-1.712-1.476-2.767-2.405-3.411-3.096-.677-.727-.994-1.291-1.16-1.839-.165-.544-.18-1.09-.117-1.847.104-1.1 1.103-3.737 2.466-6.15 1.182-2.08 5.247-9.833 9.031-17.26 3.34-6.491 5.06-9.853 5.906-11.859.677-1.603.696-2.113.587-2.93-.18-1.168-.195-1.884-.111-2.308.1-.511.321-.851.58-1.1.346-.331.813-.55 1.488-.55.199 0 .391.024.574.07 4.068-7.268 18.093-35.143 19.705-39.334.585-1.53 1.353-2.823 1.794-3.288.228-.24.462-.39.677-.482zM38.72 59.573a448.835 448.835 0 00-3.06 5.995l-4.823 9.646v16.63c0 8.501-.124 15.643-.287 16.987-.142 1.166-1.002 1.462-1.384 1.526l.16-.017c-.671.147-1.214.135-1.647-.047-.495-.209-1.058-.629-1.33-1.813-.332-1.439-.336-5.202-.22-14.563.04-4.272.047-7.59.016-9.984-.33.582-.666 1.188-.986 1.783-1.615 3.04-5.13 9.5-7.79 14.345-2.383 4.34-4.576 8.338-5.207 9.493.131.186.356.489.61.77 1.165 1.287 3.451 3.428 7.667 7.316l8.316 7.76.798-.63c1.917-1.495 7.517-7.35 12.808-13.295.898-.995 1.544-1.72 2-2.29.37-.464.594-.76.675-1.06.067-.247.004-.478-.051-.8l-.007-.041c-.475-3.324-2.184-16.382-3.657-28.168-.757-6.384-1.797-14.328-2.317-17.639l-.004-.023c-.089-.635-.185-1.272-.28-1.881zM19.289 2.67c1.673-1.343 3-2.096 4.04-2.364 1.537-.394 2.687.004 3.621 1.119.396.44 4.46 4.165 9.071 8.264 4.274 3.769 7.265 6.676 8.244 7.909.69.868.68 1.598.625 1.844-.002.013-.006.026-.009.038-.1.398-1.416 3.195-2.908 6.228-1.423 2.893-9.912 20.488-18.875 39.173C7.581 97.252 4.465 103.75 3.6 105.058c-.497.751-.885.854-1.111.924a1.729 1.729 0 01-.526.076c-.42 0-.964-.148-1.368-.767-.223-.342-.511-1.288-.511-2.394 0-.606.19-1.592.67-3.03.955-2.866 3.1-7.864 6.821-15.911l3.03-6.513-.178-5.89a153.908 153.908 0 00-.33-5.346c-.352-.041-.773-.081-1.14-.096-.98-.049-1.616-.131-2.03-.261-.645-.204-1.016-.535-1.267-.928-.221-.348-.358-.79-.358-1.4 0-.282-.173-.735-.377-1.016l-.04-.059c-.621-.945-.859-1.757-.79-2.608.085-1.023.72-2.222 2.283-4.034l1.607-1.836c-.218-.687-.996-3.199-1.807-5.89-1.558-4.942-2.122-6.841-2.152-7.56-.034-.83.282-1.245.57-1.51a1.53 1.53 0 01.406-.265c-.217-1.235-.55-3.498-.875-5.878a488.89 488.89 0 00-1.323-9.829l-.617-4.175a1.5 1.5 0 01.455-1.31l3.361-3.172c4.301-4.11 9.749-8.888 13.287-11.709zm-3.879 71.31c-.31.283-.612.394-.858.441a1.547 1.547 0 01-1.04-.132l.103 3.418v.018l1.795-3.746zm12.426 1.473a23.55 23.55 0 01-.225.553 43.912 43.912 0 01-.763 1.686c.328-.11.65-.094.966.015l.022.008v-2.262zm1.524-3.996l-.032.037a1.575 1.575 0 01-.862.5c.042.411.057.798 0 1.25l.894-1.787zM16.286 65.87c-.566.056-1.034.117-1.267.149-.014.118-.03.275-.035.408-.012.4-.001.889.007 1.466.006.237.014.477.024.716.49-.997.97-2.02 1.271-2.739zm4.486-3.076a4.31 4.31 0 01-.88.654c.136.22.21.469.22.721l.281-.585.38-.79zm-.299-5.017c-1.381.168-3.98.324-6.29.365h-3.956l-.594.92c-.19.298-.36.7-.429.874.215.444.399 1.073.478 1.666h.014c.771.012 1.964-.048 3.819-.148 2.63-.125 3.979-.11 4.898-.616.326-.18.561-.453.817-.83.374-.551.75-1.276 1.243-2.23zm4.52-3.77a6.345 6.345 0 01-1.098.892c.156.141.3.333.383.595l.714-1.487zm15.241-3.122c-.47.934-.941 1.866-1.41 2.789.6-.264 1.192-.034 1.288.014.079.04.308.15.517.425a27.335 27.335 0 00-.224-1.044c-.185-.74-.289-1.336-.17-2.184zM24.148 5.38c-.758.673-2.198 1.856-3.649 2.944-5.896 4.33-9.738 7.717-11.4 9.978-.594.803-.97 1.279-1.177 1.801-.316.802-.217 1.685-.143 3.852.132 4.065 1.762 14.092 3.157 20.466.555 2.535 1.023 4.46 1.383 5.059.528.9.771 1.5.842 1.889.088.484.016.86-.118 1.167a1.86 1.86 0 01-.27.446l2.687-.021c1.825-.028 3.22.008 4.349-.038.897-.038 1.587-.111 2.187-.396.71-.336 1.26-.968 1.948-2.018 1.313-2.003 2.904-5.314 5.721-10.782 3.785-7.286 7.618-14.95 8.563-16.935l1.23-2.593-1.311-.984c-1.258-.967-5.182-4.782-8.717-8.51-2.604-2.769-4.52-4.608-5.282-5.325zm-11.86 47.181l-.001-.003-.026-.064.027.067zm-1.503-1.764l.059-.024a1.07 1.07 0 00-.059.024zm42.106-24.884l-.002.022.001-.009.001-.013zm.003-.035l.002-.071-.002.071zM20.773 13.917c-1.241.896-1.713 1.74-1.713 4.015 0 1.663.252 2.444.727 3.002.334.391.822.714 1.63 1.043.743.303 1.275.437 1.771.44.735.005 1.457-.254 2.72-1.109 1.495-1.02 2.072-1.825 2.19-2.615.111-.744-.188-1.715-1.214-3.254-.872-1.307-1.805-2.006-2.727-2.266-1.036-.292-2.15-.105-3.356.723l-.028.02zm4.263 4.285c-.128-.242-.375-.69-.648-1.099-.4-.598-.691-1.03-1.123-1.056-.24-.015-.473.123-.744.308-.461.337-.461.721-.461 1.577 0 .417.04.883.058 1.064.1.052.282.142.431.203.283.115.47.216.66.218.084 0 .152-.057.255-.113.215-.115.46-.275.757-.476.311-.213.632-.472.815-.626zM19.293 2.669l-.005.003.005-.003z\"\n      fill=\"currentColor\"\n    />\n  </>,\n  { width: 89, height: 131, style: { transform: \"translateX(4px)\" } },\n);\n","import React from \"react\";\nimport { Card } from \"../../components/Card\";\nimport { ToolButton } from \"../../components/ToolButton\";\nimport { serializeAsJSON } from \"../../data/json\";\nimport { loadFirebaseStorage, saveFilesToFirebase } from \"../data/firebase\";\nimport { FileId, NonDeletedExcalidrawElement } from \"../../element/types\";\nimport { AppState, BinaryFileData, BinaryFiles } from \"../../types\";\nimport { nanoid } from \"nanoid\";\nimport { t } from \"../../i18n\";\nimport { excalidrawPlusIcon } from \"./icons\";\nimport { encryptData, generateEncryptionKey } from \"../../data/encryption\";\nimport { isInitializedImageElement } from \"../../element/typeChecks\";\nimport { FILE_UPLOAD_MAX_BYTES } from \"../app_constants\";\nimport { encodeFilesForUpload } from \"../data/FileManager\";\nimport { MIME_TYPES } from \"../../constants\";\n\nconst exportToExcalidrawPlus = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n) => {\n  const firebase = await loadFirebaseStorage();\n\n  const id = `${nanoid(12)}`;\n\n  const encryptionKey = (await generateEncryptionKey())!;\n  const encryptedData = await encryptData(\n    encryptionKey,\n    serializeAsJSON(elements, appState, files, \"database\"),\n  );\n\n  const blob = new Blob(\n    [encryptedData.iv, new Uint8Array(encryptedData.encryptedBuffer)],\n    {\n      type: MIME_TYPES.binary,\n    },\n  );\n\n  await firebase\n    .storage()\n    .ref(`/migrations/scenes/${id}`)\n    .put(blob, {\n      customMetadata: {\n        data: JSON.stringify({ version: 2, name: appState.name }),\n        created: Date.now().toString(),\n      },\n    });\n\n  const filesMap = new Map<FileId, BinaryFileData>();\n  for (const element of elements) {\n    if (isInitializedImageElement(element) && files[element.fileId]) {\n      filesMap.set(element.fileId, files[element.fileId]);\n    }\n  }\n\n  if (filesMap.size) {\n    const filesToUpload = await encodeFilesForUpload({\n      files: filesMap,\n      encryptionKey,\n      maxBytes: FILE_UPLOAD_MAX_BYTES,\n    });\n\n    await saveFilesToFirebase({\n      prefix: `/migrations/files/scenes/${id}`,\n      files: filesToUpload,\n    });\n  }\n\n  window.open(\n    `https://plus.excalidraw.com/import?excalidraw=${id},${encryptionKey}`,\n  );\n};\n\nexport const ExportToExcalidrawPlus: React.FC<{\n  elements: readonly NonDeletedExcalidrawElement[];\n  appState: AppState;\n  files: BinaryFiles;\n  onError: (error: Error) => void;\n}> = ({ elements, appState, files, onError }) => {\n  return (\n    <Card color=\"indigo\">\n      <div className=\"Card-icon\">{excalidrawPlusIcon}</div>\n      <h2>Excalidraw+</h2>\n      <div className=\"Card-details\">\n        {t(\"exportDialog.excalidrawplus_description\")}\n      </div>\n      <ToolButton\n        className=\"Card-button\"\n        type=\"button\"\n        title={t(\"exportDialog.excalidrawplus_button\")}\n        aria-label={t(\"exportDialog.excalidrawplus_button\")}\n        showAriaLabel={true}\n        onClick={async () => {\n          try {\n            await exportToExcalidrawPlus(elements, appState, files);\n          } catch (error: any) {\n            console.error(error);\n            if (error.name !== \"AbortError\") {\n              onError(new Error(t(\"exportDialog.excalidrawplus_exportError\")));\n            }\n          }\n        }}\n      />\n    </Card>\n  );\n};\n","import LanguageDetector from \"i18next-browser-languagedetector\";\nimport { useCallback, useContext, useEffect, useRef, useState } from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport { ErrorDialog } from \"../components/ErrorDialog\";\nimport { TopErrorBoundary } from \"../components/TopErrorBoundary\";\nimport {\n  APP_NAME,\n  EVENT,\n  STORAGE_KEYS,\n  TITLE_TIMEOUT,\n  URL_HASH_KEYS,\n  VERSION_TIMEOUT,\n} from \"../constants\";\nimport { loadFromBlob } from \"../data/blob\";\nimport { ImportedDataState } from \"../data/types\";\nimport {\n  ExcalidrawElement,\n  FileId,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { useCallbackRefState } from \"../hooks/useCallbackRefState\";\nimport { Language, t } from \"../i18n\";\nimport Excalidraw, {\n  defaultLang,\n  languages,\n} from \"../packages/excalidraw/index\";\nimport {\n  AppState,\n  LibraryItems,\n  ExcalidrawImperativeAPI,\n  BinaryFileData,\n  BinaryFiles,\n} from \"../types\";\nimport {\n  debounce,\n  getVersion,\n  preventUnload,\n  ResolvablePromise,\n  resolvablePromise,\n} from \"../utils\";\nimport {\n  FIREBASE_STORAGE_PREFIXES,\n  SAVE_TO_LOCAL_STORAGE_TIMEOUT,\n} from \"./app_constants\";\nimport CollabWrapper, {\n  CollabAPI,\n  CollabContext,\n  CollabContextConsumer,\n} from \"./collab/CollabWrapper\";\nimport { LanguageList } from \"./components/LanguageList\";\nimport { exportToBackend, getCollaborationLinkData, loadScene } from \"./data\";\nimport {\n  importFromLocalStorage,\n  saveToLocalStorage,\n} from \"./data/localStorage\";\nimport CustomStats from \"./CustomStats\";\nimport { restoreAppState, RestoredDataState } from \"../data/restore\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport { shield } from \"../components/icons\";\n\nimport \"./index.scss\";\nimport { ExportToExcalidrawPlus } from \"./components/ExportToExcalidrawPlus\";\n\nimport { getMany, set, del, keys, createStore } from \"idb-keyval\";\nimport { FileManager, updateStaleImageStatuses } from \"./data/FileManager\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { isInitializedImageElement } from \"../element/typeChecks\";\nimport { loadFilesFromFirebase } from \"./data/firebase\";\n\nconst filesStore = createStore(\"files-db\", \"files-store\");\n\nconst clearObsoleteFilesFromIndexedDB = async (opts: {\n  currentFileIds: FileId[];\n}) => {\n  const allIds = await keys(filesStore);\n  for (const id of allIds) {\n    if (!opts.currentFileIds.includes(id as FileId)) {\n      del(id, filesStore);\n    }\n  }\n};\n\nconst localFileStorage = new FileManager({\n  getFiles(ids) {\n    return getMany(ids, filesStore).then(\n      (filesData: (BinaryFileData | undefined)[]) => {\n        const loadedFiles: BinaryFileData[] = [];\n        const erroredFiles = new Map<FileId, true>();\n        filesData.forEach((data, index) => {\n          const id = ids[index];\n          if (data) {\n            loadedFiles.push(data);\n          } else {\n            erroredFiles.set(id, true);\n          }\n        });\n\n        return { loadedFiles, erroredFiles };\n      },\n    );\n  },\n  async saveFiles({ addedFiles }) {\n    const savedFiles = new Map<FileId, true>();\n    const erroredFiles = new Map<FileId, true>();\n\n    await Promise.all(\n      [...addedFiles].map(async ([id, fileData]) => {\n        try {\n          await set(id, fileData, filesStore);\n          savedFiles.set(id, true);\n        } catch (error: any) {\n          console.error(error);\n          erroredFiles.set(id, true);\n        }\n      }),\n    );\n\n    return { savedFiles, erroredFiles };\n  },\n});\n\nconst languageDetector = new LanguageDetector();\nlanguageDetector.init({\n  languageUtils: {\n    formatLanguageCode: (langCode: Language[\"code\"]) => langCode,\n    isWhitelisted: () => true,\n  },\n  checkWhitelist: false,\n});\n\nconst saveDebounced = debounce(\n  async (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n    onFilesSaved: () => void,\n  ) => {\n    saveToLocalStorage(elements, appState);\n\n    await localFileStorage.saveFiles({\n      elements,\n      files,\n    });\n\n    onFilesSaved();\n  },\n  SAVE_TO_LOCAL_STORAGE_TIMEOUT,\n);\n\nconst onBlur = () => {\n  saveDebounced.flush();\n};\n\nconst initializeScene = async (opts: {\n  collabAPI: CollabAPI;\n}): Promise<\n  { scene: ImportedDataState | null } & (\n    | { isExternalScene: true; id: string; key: string }\n    | { isExternalScene: false; id?: null; key?: null }\n  )\n> => {\n  const searchParams = new URLSearchParams(window.location.search);\n  const id = searchParams.get(\"id\");\n  const jsonBackendMatch = window.location.hash.match(\n    /^#json=([0-9]+),([a-zA-Z0-9_-]+)$/,\n  );\n  const externalUrlMatch = window.location.hash.match(/^#url=(.*)$/);\n\n  const localDataState = importFromLocalStorage();\n\n  let scene: RestoredDataState & {\n    scrollToContent?: boolean;\n  } = await loadScene(null, null, localDataState);\n\n  let roomLinkData = getCollaborationLinkData(window.location.href);\n  const isExternalScene = !!(id || jsonBackendMatch || roomLinkData);\n  if (isExternalScene) {\n    if (\n      // don't prompt if scene is empty\n      !scene.elements.length ||\n      // don't prompt for collab scenes because we don't override local storage\n      roomLinkData ||\n      // otherwise, prompt whether user wants to override current scene\n      window.confirm(t(\"alerts.loadSceneOverridePrompt\"))\n    ) {\n      if (jsonBackendMatch) {\n        scene = await loadScene(\n          jsonBackendMatch[1],\n          jsonBackendMatch[2],\n          localDataState,\n        );\n      }\n      scene.scrollToContent = true;\n      if (!roomLinkData) {\n        window.history.replaceState({}, APP_NAME, window.location.origin);\n      }\n    } else {\n      // https://github.com/excalidraw/excalidraw/issues/1919\n      if (document.hidden) {\n        return new Promise((resolve, reject) => {\n          window.addEventListener(\n            \"focus\",\n            () => initializeScene(opts).then(resolve).catch(reject),\n            {\n              once: true,\n            },\n          );\n        });\n      }\n\n      roomLinkData = null;\n      window.history.replaceState({}, APP_NAME, window.location.origin);\n    }\n  } else if (externalUrlMatch) {\n    window.history.replaceState({}, APP_NAME, window.location.origin);\n\n    const url = externalUrlMatch[1];\n    try {\n      const request = await fetch(window.decodeURIComponent(url));\n      const data = await loadFromBlob(await request.blob(), null, null);\n      if (\n        !scene.elements.length ||\n        window.confirm(t(\"alerts.loadSceneOverridePrompt\"))\n      ) {\n        return { scene: data, isExternalScene };\n      }\n    } catch (error: any) {\n      return {\n        scene: {\n          appState: {\n            errorMessage: t(\"alerts.invalidSceneUrl\"),\n          },\n        },\n        isExternalScene,\n      };\n    }\n  }\n\n  if (roomLinkData) {\n    return {\n      scene: await opts.collabAPI.initializeSocketClient(roomLinkData),\n      isExternalScene: true,\n      id: roomLinkData.roomId,\n      key: roomLinkData.roomKey,\n    };\n  } else if (scene) {\n    return isExternalScene && jsonBackendMatch\n      ? {\n          scene,\n          isExternalScene,\n          id: jsonBackendMatch[1],\n          key: jsonBackendMatch[2],\n        }\n      : { scene, isExternalScene: false };\n  }\n  return { scene: null, isExternalScene: false };\n};\n\nconst PlusLinkJSX = (\n  <p style={{ direction: \"ltr\", unicodeBidi: \"embed\" }}>\n    Introducing Excalidraw+\n    <br />\n    <a\n      href=\"https://plus.excalidraw.com/?utm_source=excalidraw&utm_medium=banner&utm_campaign=launch\"\n      target=\"_blank\"\n      rel=\"noreferrer\"\n    >\n      Try out now!\n    </a>\n  </p>\n);\n\nconst ExcalidrawWrapper = () => {\n  const [errorMessage, setErrorMessage] = useState(\"\");\n  let currentLangCode = languageDetector.detect() || defaultLang.code;\n  if (Array.isArray(currentLangCode)) {\n    currentLangCode = currentLangCode[0];\n  }\n  const [langCode, setLangCode] = useState(currentLangCode);\n\n  // initial state\n  // ---------------------------------------------------------------------------\n\n  const initialStatePromiseRef = useRef<{\n    promise: ResolvablePromise<ImportedDataState | null>;\n  }>({ promise: null! });\n  if (!initialStatePromiseRef.current.promise) {\n    initialStatePromiseRef.current.promise =\n      resolvablePromise<ImportedDataState | null>();\n  }\n\n  useEffect(() => {\n    // Delayed so that the app has a time to load the latest SW\n    setTimeout(() => {\n      trackEvent(\"load\", \"version\", getVersion());\n    }, VERSION_TIMEOUT);\n  }, []);\n\n  const [excalidrawAPI, excalidrawRefCallback] =\n    useCallbackRefState<ExcalidrawImperativeAPI>();\n\n  const collabAPI = useContext(CollabContext)?.api;\n\n  useEffect(() => {\n    if (!collabAPI || !excalidrawAPI) {\n      return;\n    }\n\n    const loadImages = (\n      data: ResolutionType<typeof initializeScene>,\n      isInitialLoad = false,\n    ) => {\n      if (!data.scene) {\n        return;\n      }\n      if (collabAPI.isCollaborating()) {\n        if (data.scene.elements) {\n          collabAPI\n            .fetchImageFilesFromFirebase({\n              elements: data.scene.elements,\n            })\n            .then(({ loadedFiles, erroredFiles }) => {\n              excalidrawAPI.addFiles(loadedFiles);\n              updateStaleImageStatuses({\n                excalidrawAPI,\n                erroredFiles,\n                elements: excalidrawAPI.getSceneElementsIncludingDeleted(),\n              });\n            });\n        }\n      } else {\n        const fileIds =\n          data.scene.elements?.reduce((acc, element) => {\n            if (isInitializedImageElement(element)) {\n              return acc.concat(element.fileId);\n            }\n            return acc;\n          }, [] as FileId[]) || [];\n\n        if (data.isExternalScene) {\n          loadFilesFromFirebase(\n            `${FIREBASE_STORAGE_PREFIXES.shareLinkFiles}/${data.id}`,\n            data.key,\n            fileIds,\n          ).then(({ loadedFiles, erroredFiles }) => {\n            excalidrawAPI.addFiles(loadedFiles);\n            updateStaleImageStatuses({\n              excalidrawAPI,\n              erroredFiles,\n              elements: excalidrawAPI.getSceneElementsIncludingDeleted(),\n            });\n          });\n        } else if (isInitialLoad) {\n          if (fileIds.length) {\n            localFileStorage\n              .getFiles(fileIds)\n              .then(({ loadedFiles, erroredFiles }) => {\n                if (loadedFiles.length) {\n                  excalidrawAPI.addFiles(loadedFiles);\n                }\n                updateStaleImageStatuses({\n                  excalidrawAPI,\n                  erroredFiles,\n                  elements: excalidrawAPI.getSceneElementsIncludingDeleted(),\n                });\n              });\n          }\n          // on fresh load, clear unused files from IDB (from previous\n          // session)\n          clearObsoleteFilesFromIndexedDB({ currentFileIds: fileIds });\n        }\n      }\n\n      try {\n        data.scene.libraryItems =\n          JSON.parse(\n            localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY) as string,\n          ) || [];\n      } catch (error: any) {\n        console.error(error);\n      }\n    };\n\n    initializeScene({ collabAPI }).then((data) => {\n      loadImages(data, /* isInitialLoad */ true);\n      initialStatePromiseRef.current.promise.resolve(data.scene);\n    });\n\n    const onHashChange = (event: HashChangeEvent) => {\n      event.preventDefault();\n      const hash = new URLSearchParams(window.location.hash.slice(1));\n      const libraryUrl = hash.get(URL_HASH_KEYS.addLibrary);\n      if (libraryUrl) {\n        // If hash changed and it contains library url, import it and replace\n        // the url to its previous state (important in case of collaboration\n        // and similar).\n        // Using history API won't trigger another hashchange.\n        window.history.replaceState({}, \"\", event.oldURL);\n        excalidrawAPI.importLibrary(libraryUrl, hash.get(\"token\"));\n      } else {\n        initializeScene({ collabAPI }).then((data) => {\n          loadImages(data);\n          if (data.scene) {\n            excalidrawAPI.updateScene({\n              ...data.scene,\n              appState: restoreAppState(data.scene.appState, null),\n            });\n          }\n        });\n      }\n    };\n\n    const titleTimeout = setTimeout(\n      () => (document.title = APP_NAME),\n      TITLE_TIMEOUT,\n    );\n    window.addEventListener(EVENT.HASHCHANGE, onHashChange, false);\n    window.addEventListener(EVENT.UNLOAD, onBlur, false);\n    window.addEventListener(EVENT.BLUR, onBlur, false);\n    return () => {\n      window.removeEventListener(EVENT.HASHCHANGE, onHashChange, false);\n      window.removeEventListener(EVENT.UNLOAD, onBlur, false);\n      window.removeEventListener(EVENT.BLUR, onBlur, false);\n      clearTimeout(titleTimeout);\n    };\n  }, [collabAPI, excalidrawAPI]);\n\n  useEffect(() => {\n    const unloadHandler = (event: BeforeUnloadEvent) => {\n      saveDebounced.flush();\n\n      if (\n        excalidrawAPI &&\n        localFileStorage.shouldPreventUnload(excalidrawAPI.getSceneElements())\n      ) {\n        preventUnload(event);\n      }\n    };\n    window.addEventListener(EVENT.BEFORE_UNLOAD, unloadHandler);\n    return () => {\n      window.removeEventListener(EVENT.BEFORE_UNLOAD, unloadHandler);\n    };\n  }, [excalidrawAPI]);\n\n  useEffect(() => {\n    languageDetector.cacheUserLanguage(langCode);\n  }, [langCode]);\n\n  const onChange = (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n  ) => {\n    if (collabAPI?.isCollaborating()) {\n      collabAPI.broadcastElements(elements);\n    } else {\n      saveDebounced(elements, appState, files, () => {\n        if (excalidrawAPI) {\n          let didChange = false;\n\n          let pendingImageElement = appState.pendingImageElement;\n          const elements = excalidrawAPI\n            .getSceneElementsIncludingDeleted()\n            .map((element) => {\n              if (localFileStorage.shouldUpdateImageElementStatus(element)) {\n                didChange = true;\n                const newEl = newElementWith(element, { status: \"saved\" });\n                if (pendingImageElement === element) {\n                  pendingImageElement = newEl;\n                }\n                return newEl;\n              }\n              return element;\n            });\n\n          if (didChange) {\n            excalidrawAPI.updateScene({\n              elements,\n              appState: {\n                pendingImageElement,\n              },\n            });\n          }\n        }\n      });\n    }\n  };\n\n  const onExportToBackend = async (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    files: BinaryFiles,\n    canvas: HTMLCanvasElement | null,\n  ) => {\n    if (exportedElements.length === 0) {\n      return window.alert(t(\"alerts.cannotExportEmptyCanvas\"));\n    }\n    if (canvas) {\n      try {\n        await exportToBackend(\n          exportedElements,\n          {\n            ...appState,\n            viewBackgroundColor: appState.exportBackground\n              ? appState.viewBackgroundColor\n              : getDefaultAppState().viewBackgroundColor,\n          },\n          files,\n        );\n      } catch (error: any) {\n        if (error.name !== \"AbortError\") {\n          const { width, height } = canvas;\n          console.error(error, { width, height });\n          setErrorMessage(error.message);\n        }\n      }\n    }\n  };\n\n  const renderTopRightUI = useCallback(\n    (isMobile: boolean, appState: AppState) => {\n      if (isMobile) {\n        return null;\n      }\n      return (\n        <div\n          style={{\n            width: \"24ch\",\n            fontSize: \"0.7em\",\n            textAlign: \"center\",\n          }}\n        >\n          {/* <GitHubCorner theme={appState.theme} dir={document.dir} /> */}\n          {/* FIXME remove after 2021-05-20 */}\n          {PlusLinkJSX}\n        </div>\n      );\n    },\n    [],\n  );\n\n  const renderFooter = useCallback(\n    (isMobile: boolean) => {\n      const renderEncryptedIcon = () => (\n        <a\n          className=\"encrypted-icon tooltip\"\n          href=\"https://blog.excalidraw.com/end-to-end-encryption/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          aria-label={t(\"encrypted.link\")}\n        >\n          <Tooltip label={t(\"encrypted.tooltip\")} long={true}>\n            {shield}\n          </Tooltip>\n        </a>\n      );\n\n      const renderLanguageList = () => (\n        <LanguageList\n          onChange={(langCode) => setLangCode(langCode)}\n          languages={languages}\n          currentLangCode={langCode}\n        />\n      );\n      if (isMobile) {\n        const isTinyDevice = window.innerWidth < 362;\n        return (\n          <div\n            style={{\n              display: \"flex\",\n              flexDirection: isTinyDevice ? \"column\" : \"row\",\n            }}\n          >\n            <fieldset>\n              <legend>{t(\"labels.language\")}</legend>\n              {renderLanguageList()}\n            </fieldset>\n            {/* FIXME remove after 2021-05-20 */}\n            <div\n              style={{\n                width: \"24ch\",\n                fontSize: \"0.7em\",\n                textAlign: \"center\",\n                marginTop: isTinyDevice ? 16 : undefined,\n                marginLeft: \"auto\",\n                marginRight: isTinyDevice ? \"auto\" : undefined,\n                padding: \"4px 2px\",\n                border: \"1px dashed #aaa\",\n                borderRadius: 12,\n              }}\n            >\n              {PlusLinkJSX}\n            </div>\n          </div>\n        );\n      }\n      return (\n        <>\n          {renderEncryptedIcon()}\n          {renderLanguageList()}\n        </>\n      );\n    },\n    [langCode],\n  );\n\n  const renderCustomStats = () => {\n    return (\n      <CustomStats\n        setToastMessage={(message) => excalidrawAPI!.setToastMessage(message)}\n      />\n    );\n  };\n\n  const onLibraryChange = async (items: LibraryItems) => {\n    if (!items.length) {\n      localStorage.removeItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n      return;\n    }\n    const serializedItems = JSON.stringify(items);\n    localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY, serializedItems);\n  };\n\n  const onRoomClose = useCallback(() => {\n    localFileStorage.reset();\n  }, []);\n\n  return (\n    <>\n      <Excalidraw\n        ref={excalidrawRefCallback}\n        onChange={onChange}\n        initialData={initialStatePromiseRef.current.promise}\n        onCollabButtonClick={collabAPI?.onCollabButtonClick}\n        isCollaborating={collabAPI?.isCollaborating()}\n        onPointerUpdate={collabAPI?.onPointerUpdate}\n        UIOptions={{\n          canvasActions: {\n            export: {\n              onExportToBackend,\n              renderCustomUI: (elements, appState, files) => {\n                return (\n                  <ExportToExcalidrawPlus\n                    elements={elements}\n                    appState={appState}\n                    files={files}\n                    onError={(error) => {\n                      excalidrawAPI?.updateScene({\n                        appState: {\n                          errorMessage: error.message,\n                        },\n                      });\n                    }}\n                  />\n                );\n              },\n            },\n          },\n        }}\n        renderTopRightUI={renderTopRightUI}\n        renderFooter={renderFooter}\n        langCode={langCode}\n        renderCustomStats={renderCustomStats}\n        detectScroll={false}\n        handleKeyboardGlobally={true}\n        onLibraryChange={onLibraryChange}\n        autoFocus={true}\n      />\n      {excalidrawAPI && (\n        <CollabWrapper\n          excalidrawAPI={excalidrawAPI}\n          onRoomClose={onRoomClose}\n        />\n      )}\n      {errorMessage && (\n        <ErrorDialog\n          message={errorMessage}\n          onClose={() => setErrorMessage(\"\")}\n        />\n      )}\n    </>\n  );\n};\n\nconst ExcalidrawApp = () => {\n  return (\n    <TopErrorBoundary>\n      <CollabContextConsumer>\n        <ExcalidrawWrapper />\n      </CollabContextConsumer>\n    </TopErrorBoundary>\n  );\n};\n\nexport default ExcalidrawApp;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport const register = (config?: Config) => {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const isWebexLP = window.location.pathname.startsWith(\"/webex\");\n      if (isWebexLP) {\n        unregister(() => {\n          window.location.reload();\n        });\n        return false;\n      }\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.info(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\",\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n};\n\nconst registerValidSW = (swUrl: string, config?: Config) => {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n\n              console.info(\n                \"New content is available and will be used when all tabs for this page are closed.\",\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n\n              console.info(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n};\n\nconst checkValidServiceWorker = (swUrl: string, config?: Config) => {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch((error) => {\n      console.info(\n        \"No internet connection found. App is running in offline mode.\",\n        error.message,\n      );\n    });\n};\n\nexport const unregister = (callback?: () => void) => {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        return registration.unregister();\n      })\n      .then(() => {\n        callback?.();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n};\n","import { register as registerServiceWorker } from \"../serviceWorker\";\nimport { EVENT } from \"../constants\";\n\n// On Apple mobile devices add the proprietary app icon and splashscreen markup.\n// No one should have to do this manually, and eventually this annoyance will\n// go away once https://bugs.webkit.org/show_bug.cgi?id=183937 is fixed.\nif (\n  /\\b(iPad|iPhone|iPod|Safari)\\b/.test(navigator.userAgent) &&\n  !matchMedia(\"(display-mode: standalone)\").matches\n) {\n  import(/* webpackChunkName: \"pwacompat\" */ \"pwacompat\");\n}\n\nregisterServiceWorker({\n  onUpdate: (registration) => {\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\n        EVENT.STATE_CHANGE,\n        (event: Event) => {\n          const target = event.target as ServiceWorker;\n          const state = target.state as ServiceWorkerState;\n          if (state === \"activated\") {\n            window.location.reload();\n          }\n        },\n      );\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  },\n});\n","import * as Sentry from \"@sentry/browser\";\nimport * as SentryIntegrations from \"@sentry/integrations\";\n\nconst SentryEnvHostnameMap: { [key: string]: string } = {\n  \"excalidraw.com\": \"production\",\n  \"vercel.app\": \"staging\",\n};\n\nconst REACT_APP_DISABLE_SENTRY =\n  process.env.REACT_APP_DISABLE_SENTRY === \"true\";\n\n// Disable Sentry locally or inside the Docker to avoid noise/respect privacy\nconst onlineEnv =\n  !REACT_APP_DISABLE_SENTRY &&\n  Object.keys(SentryEnvHostnameMap).find(\n    (item) => window.location.hostname.indexOf(item) >= 0,\n  );\n\nSentry.init({\n  dsn: onlineEnv\n    ? \"https://7bfc596a5bf945eda6b660d3015a5460@sentry.io/5179260\"\n    : undefined,\n  environment: onlineEnv ? SentryEnvHostnameMap[onlineEnv] : undefined,\n  release: process.env.REACT_APP_GIT_SHA,\n  ignoreErrors: [\n    \"undefined is not an object (evaluating 'window.__pad.performLoop')\", // Only happens on Safari, but spams our servers. Doesn't break anything\n  ],\n  integrations: [\n    new SentryIntegrations.CaptureConsole({\n      levels: [\"error\"],\n    }),\n  ],\n  beforeSend(event) {\n    if (event.request?.url) {\n      event.request.url = event.request.url.replace(/#.*$/, \"\");\n    }\n    return event;\n  },\n});\n","import ReactDOM from \"react-dom\";\nimport ExcalidrawApp from \"./excalidraw-app\";\n\nimport \"./excalidraw-app/pwa\";\nimport \"./excalidraw-app/sentry\";\nwindow.__EXCALIDRAW_SHA__ = process.env.REACT_APP_GIT_SHA;\n\nReactDOM.render(<ExcalidrawApp />, document.getElementById(\"root\"));\n"],"sourceRoot":""}